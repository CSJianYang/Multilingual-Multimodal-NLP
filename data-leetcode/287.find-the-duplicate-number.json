[
    {
        "title": "Find the Duplicate Number",
        "question_content": "Given an array of integers nums containing&nbsp;n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this&nbsp;repeated&nbsp;number.\nYou must solve the problem without modifying the array nums&nbsp;and uses only constant extra space.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\tnums.length == n + 1\n\t1 <= nums[i] <= n\n\tAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n\n&nbsp;\nFollow up:\n\n\tHow can we prove that at least one duplicate number must exist in nums?\n\tCan you solve the problem in linear runtime complexity?",
        "solutions": [
            {
                "id": 1892921,
                "title": "9-approaches-count-hash-in-place-marked-sort-binary-search-bit-mask-fast-slow-pointers",
                "content": "[Leetcode](https://leetcode.com/) [287. Find the Duplicate Number](https://leetcode.com/problems/coin-change/).\\n\\nHere are **9** approaches to solve this problem in Java, which is Brute Force, Count, Hash, In-place Marked, Sorting, Index Sort, Binary Search, Bit Manipulation, Fast Slow Pointers.\\n\\nInspired by @[user2670f](/u/user2670f) and his solution [[C++] 7 Different solutions to this problem (with relaxed constraints)](https://leetcode.com/problems/find-the-duplicate-number/discuss/1894339/C%2B%2B-8-Different-solutions-to-this-problem-or-Do-you-have-another-one) , I added **3** more approaches.\\n\\n\\n# Brute Force (2 Loops)\\n\\nSince `solve the problem without modifying the array nums and uses only constant extra space`, we can use Brute Force to solve it.\\n\\nIt\\'s easy to use **2 loops** to do it, but the time complexity is $O(n^2)$, so it wouldn\\'t accepted as timeout.\\n\\n```java\\n    // 2 Loops\\n    public static int findDuplicate_2loops(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Count\\n\\nCount the frequency of the num in the array.\\n\\nWith extra $O(n)$ space, without modifying the input.\\n\\n```java\\n    public static int findDuplicate(int[] nums) {\\n        int len = nums.length;\\n        int[] cnt = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# Hash\\n\\nUsing a $\\\\texttt{HashSet}$ to record the occurrence of each number.\\n\\nWith extra $O(n)$ space, without modifying the input.\\n\\n```java\\n    public static int findDuplicate_set(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (!set.add(nums[i])) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# Marking visited value within the array\\n\\nSince all values of the array are between $[1 \\\\dots n]$ and the array size is $n+1$, while scanning the array from left to right, we set the $\\\\textit{nums}[n]$ to its negative value.\\n\\nWith extra $O(1)$ space, with modifying the input.\\n\\n```java\\n    // Visited\\n    public static int findDuplicate_mark(int[] nums) {\\n        int len = nums.length;\\n        for (int num : nums) {\\n            int idx = Math.abs(num);\\n            if (nums[idx] < 0) {\\n                return idx;\\n            }\\n            nums[idx] = -nums[idx];\\n        }\\n\\n        return len;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Sort\\n\\nSorting the array first, then use a loop from $1$ to $n$.\\n\\nWith extra $O(nlogn)$ space, modifying the input.\\n\\n```java\\n    public static int findDuplicate_sort(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 1; i < len; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$\\n- **Space Complexity**: $O(logn)$\\n\\n# Index Sort\\n\\nIf the array is sorted, the value of each array element is its index value $index + 1$, then we can do this:\\n\\n1. If $\\\\textit{nums}[i] == i + 1$, it means that the order has been sorted, then skip, $i++$;\\n2. If $\\\\textit{nums}[i] == \\\\textit{nums}[\\\\textit{nums}[i] - 1]$, it means that there is already a value at the correct index, then this value is a duplicated element;\\n3. If none of the above is satisfied, exchange the values of $\\\\textit{nums}[i]$ and $\\\\textit{nums}[\\\\textit{nums}[i] - 1]$.\\n\\nWith extra $O(logn)$ space, with modifying the input.\\n\\n```java\\n    // Index Sort\\n    // n + 1 numbers in n.\\n    public static int findDuplicate_index_sort(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; ) {\\n            int n = nums[i];\\n            if (n == i + 1) {\\n                i++;\\n            } else if (n == nums[n - 1]) {\\n                return n;\\n            } else {\\n                nums[i] = nums[n - 1];\\n                nums[n - 1] = n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Binary Search\\n\\nNote that the key is to find an integer in the array $[1, 2, \\\\dots, n]$ instead of finding an integer in the **input array**.\\n\\nWe can use the binary search algorithm, each round we guess one number, then scan the input array, narrow the search range, and finally get the answer.\\n\\nAccording to the **Pigeonhole Principle**, $n + 1$ integers, placed in an array of length $n$, at least $1$ integer will be repeated.\\n\\nSo guess a number first(the number $mid$ in the valid range $[left, right]$), count the elements of the array which is less than or equal to $mid$ in the array.\\n\\n1. If $cnt$ is strictly greater than $mid$. According to the Pigeonhole Principle, repeated elements are in the interval $[left, mid]$;\\n2. Otherwise, the repeated element is in the interval $[mid + 1, right]$.\\n\\nWith extra $O(1)$ space, without modifying the input.\\n\\n```java\\n    public static int findDuplicate_bs(int[] nums) {\\n        int len = nums.length;\\n        int low = 1;\\n        int high = len - 1;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            int cnt = 0;\\n            for (int i = 0; i < len; i++) {\\n                if (nums[i] <= mid) {\\n                    cnt++;\\n                }\\n            }\\n\\n            if (cnt <= mid) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Bit \\n\\nThis method is convert all the numbers to **binary** numbers. If we can get **each digit** of the repeated number in binary, we can rebuild the repeated number.\\n\\nCount all the bits of $[1, n]$ and array numbers as $1$ respectively, and then restore them bit by bit to get this repeated number.\\n\\nFor example, the $i$th digit, note that in the $\\\\textit{nums}$ array, the sum of all the elements whose ith digit is $1$ is $x$ as convert the number to binary. \\n\\nAs the range $[1, n]$, we can also count the sum of the number whose $i$th digit is $1$, we denoted it $y$.\\n\\nWe can easily get that $x > y$.\\n\\nThe following table lists whether each bit in the binary of each number is $1$ or $0$ and what the $x$ and $y$ of the corresponding bit are:\\n\\n\\n|\\t \\t|    1   |    3   |    4   |    2   |    2   |    x   |    y   |\\n|:-----\\t| :----: | :----: | :----: | :----: | :----: | :----: | :----: |\\n| Bit 0 |    1   |    1   |    0   |    0   |    0   |    2   |    2   |\\n| Bit 1 |    1   |    0   |    1   |    1   |    1   |    3   |    2   |\\n| Bit 2 |    0   |    0   |    1   |    0   |    0   |    1   |    1   |\\n\\nFrom the table, we found that only the $1$th bit $x > y$, so after bitwise restoration $\\\\textit{target}=(010)_2=(2)_{10}$, which is the answer.\\n\\nThe proof of correctness is actually similar to method $1$. We can consider the change of the number $x$ of the $i$-th in different example arrays.\\n\\n- If $\\\\textit{target}$ appears twice in the test case array, the rest of the numbers appear once, and the $i$th bit of $\\\\textit{target}$ is $1$, then the $\\\\textit{nums}$ array x, is exactly one greater than y. If bit $i$ of \\\\textit{target} is $0$, then both are equal.\\n\\n- If $\\\\textit{target}$ appears three or more times in the array of test cases, then there must be some numbers that are not in the $\\\\textit{nums}$ array. At this time, it is equivalent to replacing these with $\\\\textit{target}$, we consider the impact on $x$ when replacing:\\n\\n\\t- If the $i$-th bit of the number to be replaced is $1$, and the $i$-th bit of $\\\\textit{target}$ is $1$: $x$ remains unchanged, $x > y$.\\n\\n\\t- If the $i$-th bit of the number being replaced is $0$, and the $i$-th bit of $\\\\textit{target}$ is $1$: x plus one, $x > y$.\\n\\n\\t- If the i-th bit of the number to be replaced is $1$, and the $i$-th bit of $\\\\textit{target}$ is $0$: $x$ minus one, $x \\\\le y$.\\n\\n\\t- If the $i$-th bit of the number to be replaced is $0$, and the $i$-th bit of $\\\\textit{target}$ is $0$: x remains unchanged, satisfying $x \\\\le y$.\\n\\nTherefore, if the ith bit of $\\\\textit{target}$ is $1$, then after each replacement, only $x$ will be unchanged or increased. If it is $0$, only $x$ will be unchanged or decreased.\\n\\nWhen $x > y$, the ith bit of $\\\\textit{target}$ is $1$, otherwise it is $0$. We only need to restore this repeated number bitwise.\\n\\nWith extra $O(nlogn)$ space, without modifying the input.\\n\\n```java\\n    public static int findDuplicate_bit(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n        int bit_max = 31;\\n        while (((n - 1) >> bit_max) == 0) {\\n            bit_max -= 1;\\n        }\\n\\n        for (int bit = 0; bit <= bit_max; ++bit) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if ((nums[i] & (1 << bit)) != 0) {\\n                    x += 1;\\n                }\\n                if (i >= 1 && ((i & (1 << bit)) != 0)) {\\n                    y += 1;\\n                }\\n            }\\n            if (x > y) {\\n                ans |= 1 << bit;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Fast Slow Pointers\\n\\nThis problem is as same as [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/),  you can refer to this [solution](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701055/JavaC%2B%2BPython-best-explanation-ever-happen\\'s-for-this-problem) for the explanation of the slow fast pointer approach to solve this problem.\\n\\nThe key is to understand how to treat **the input array as a linked list**.\\n\\nTake the array $[1,3,4,2]$ as an example, the index of this array is $[0, 1, 2, 3]$, we can map the index to the $nums[n]$.\\n\\n$$\\n0 \\\\to 1 \\\\to 3 \\\\to 2 \\\\to 4 \\\\to 3 \\\\to 2\\n$$\\n\\nStart from $\\\\textit{nums}[n]$ as a new index, and so on, until the index exceeds the bounds. This produces a sequence similar to a linked list.\\n\\n$$\\n0 \\\\to 1 \\\\to 3 \\\\to 2 \\\\to 4 \\\\to null\\n$$\\n\\nIf there are a repeated numbers in the array, take the array $[1,3,4,2,2]$ as an example, \\n\\n$$\\n0 \\\\to 1 \\\\to 3 \\\\to 2 \\\\to 4 \\\\to 3 \\\\to 2 \\\\to 4 \\\\to 2\\n$$\\n\\nSimilarly, a linked list is like that:\\n\\n$$\\n0 \\\\to 1 \\\\to 3 \\\\to 2 \\\\to 4 \\\\to 2 \\\\to 4 \\\\to 2 \\\\to \\\\dots \\n$$\\n\\nHere $2 \\\\to 4$ is a cycle, then this linked list can be abstracted as the following figure:\\n\\n![Link List](https://assets.leetcode.com/users/images/aeb3e536-9615-466c-a2de-88a9a59ef255_1648626512.666411.png)\\n\\nWith extra $O(n)$ space, without modifying the input.\\n\\n```java\\n    public int findDuplicate_fastSlow(int[] nums) {\\n        int slow = 0;\\n        int fast = 0;\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        slow = 0;\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```java\\n    // 2 Loops\\n    public static int findDuplicate_2loops(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\n```java\\n    public static int findDuplicate(int[] nums) {\\n        int len = nums.length;\\n        int[] cnt = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\n```java\\n    public static int findDuplicate_set(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (!set.add(nums[i])) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\n```java\\n    // Visited\\n    public static int findDuplicate_mark(int[] nums) {\\n        int len = nums.length;\\n        for (int num : nums) {\\n            int idx = Math.abs(num);\\n            if (nums[idx] < 0) {\\n                return idx;\\n            }\\n            nums[idx] = -nums[idx];\\n        }\\n\\n        return len;\\n    }\\n```\n```java\\n    public static int findDuplicate_sort(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 1; i < len; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i];\\n            }\\n        }\\n\\n        return len;\\n    }\\n```\n```java\\n    // Index Sort\\n    // n + 1 numbers in n.\\n    public static int findDuplicate_index_sort(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; ) {\\n            int n = nums[i];\\n            if (n == i + 1) {\\n                i++;\\n            } else if (n == nums[n - 1]) {\\n                return n;\\n            } else {\\n                nums[i] = nums[n - 1];\\n                nums[n - 1] = n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```\n```java\\n    public static int findDuplicate_bs(int[] nums) {\\n        int len = nums.length;\\n        int low = 1;\\n        int high = len - 1;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            int cnt = 0;\\n            for (int i = 0; i < len; i++) {\\n                if (nums[i] <= mid) {\\n                    cnt++;\\n                }\\n            }\\n\\n            if (cnt <= mid) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n```\n```java\\n    public static int findDuplicate_bit(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n        int bit_max = 31;\\n        while (((n - 1) >> bit_max) == 0) {\\n            bit_max -= 1;\\n        }\\n\\n        for (int bit = 0; bit <= bit_max; ++bit) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if ((nums[i] & (1 << bit)) != 0) {\\n                    x += 1;\\n                }\\n                if (i >= 1 && ((i & (1 << bit)) != 0)) {\\n                    y += 1;\\n                }\\n            }\\n            if (x > y) {\\n                ans |= 1 << bit;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public int findDuplicate_fastSlow(int[] nums) {\\n        int slow = 0;\\n        int fast = 0;\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        slow = 0;\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1892872,
                "title": "c-6-approaches-interview-question",
                "content": "# 287. Find the Duplicate Number\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Tortoise Algorithm is the most appropriate one, brute, map, count vector and binary Search, Making Visted Values within an Array are other possible approaches.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n\\n**APPROACH 1 BRUTE FORCE**\\n``` ```\\n**ALGORITHM**\\n``` ```\\n* **initaialise a  variable (ind)**\\n* **Sort the given vector.**\\n* **Traverse a for loop** to nums.size();\\n* if you **find two consecutive elements equal**, you **find a duplicate, break the loop.**\\n* **Return ind.**\\n``` ```\\n\\nTime Complexity -> O(N Log N)\\nSpace Complexit -> O(1)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ind = 0;\\n\\t\\t\\n\\t\\t// sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n\\t\\t\\t// if two consecutive elements are equal\\n\\t\\t\\t// you have find a duplicate\\n\\t\\t\\t// break the loop\\n            if(nums[i] == nums[i+1])\\n            {\\n                ind = nums[i];\\n                break;\\n            }\\n        }\\n        // return duplicate value\\n        return ind;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\\n* **APPROACH 2 USING CNT VECTOR**\\n\\n**ALGORITHM**\\n* **take a cnt vector of size num.size()** & **initilise all it value to 0.**\\n* **Iterate the nums and store the cnt of every element in cnt array.**\\n* Now **traverse the cnt vector if any value in cnt vector is greater than 1** , **return i**.\\n* That\\'s the **duplicate value;**\\n``` ```\\n\\nTime Complexity -> O(N)\\nSpace Complexit -> O(N)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n\\t\\t// initialise cnt vector of size nums with 0\\n        vector<int> cnt(nums.size(),0);\\n        int ind =  0;\\n\\t\\t\\n\\t\\t// store the cnt of each value in the cnt vector\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            cnt[nums[i]]++;\\n        }\\n        \\n        for(int i = 0; i<cnt.size(); i++)\\n        {\\n\\t\\t\\t// if cnt[i] > 1\\n\\t\\t\\t// this means that element occur more than once in nums\\n\\t\\t\\t// we have to return i\\n            if(cnt[i] > 1)\\n            {\\n                ind  = i;\\n                break;\\n            }\\n        }\\n        \\n        return ind;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\nTime Complexity -> O(N)\\nSpace Complexit -> O(N)\\n\\n```\\n**APPROCH 2 USING MAP**\\n// Same Approach as above just used map  for storing counts.\\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        map<int, int> m;\\n        int duplicate = 0;\\n        for(auto i= 0; i<nums.size(); ++i)\\n        ++m[nums[i]];\\n        \\n        for(auto i : m)\\n        {\\n            if(i.second > 1)\\n            {\\n                duplicate = i.first;\\n                break;\\n            }\\n        }\\n        return duplicate;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\\n**APPROACH 4 USING BINARY SEARCH**\\n\\nTime Complexity -> O(N Log N)\\nSpace Complexit -> O(1)\\n\\n\\n**ALGORITHM**\\n* Perform **Binary Search on range 1 to n;**\\n* **low = 1, high =  nums.size() - 1;**\\n* While the **value of high is greater than or equal to low.**\\n\\t* **calculate mid**.\\n\\t* **count elements <= to mid.**\\n\\t* if **count is less than equal to mid**.\\n\\t\\t* **low = mid + 1** (binary search on **right half**)\\n\\t\\t* else **high = mid + 1** (binary search on **left half**)\\n* Return **low which will point to duplicate.**\\n\\n``` ```\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\\n\\n**Approach 5 Making Visted Values within an Array**\\n\\nThe idea behind this approach is that as we iterate over the array **we treat every element as idx** and **we make the element at that idx as negative**\\ni.e **for 4 i will go to arr[4] and make it -arr[4]**\\nand now if at some point the element at that **idx is already negative which means i had already visit that element and than that will be the duplicate element.**\\n\\nwe are doing abs of nums[i] because we might mark that element at negative and array do not have negative idx and hence we make it positive for checking that indexed element.\\n\\n**Time Complexity ->  O(N)\\nSpace Complexit -> O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            int idx = abs(nums[i]);\\n            \\n            if(nums[idx] < 0)\\n                return idx;\\n            \\n            nums[idx] = -nums[idx];\\n        }\\n        \\n        return n;\\n    }\\n};\\n```\\n\\n**Approach 6 (Tortoise Method)**\\n\\nwe will **assume this given array as a linkedlist** and then we can **solve it using the idea of cycle in a linked list.**\\n\\nsince we know there is a **repeated element therefore there will always be a cycle** and **starting element of the cycle is always the repeated element** let understand this in detail.\\n\\nSince there is a duplicate number that means there will be definetely a cycle that mean fast and slow meet  each other or **we can also say since fast and slow meet therefore there is a cycle.**\\n\\nwhen we move **fast by 2steps** and **slow by 1step**\\n\\nthis can be simply done using the **find cycle in the linkedlist approach**, please refer to the idea of that\\nfrom here [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1829489/C%2B%2B-oror-Easy-To-Understand-oror-2-Pointer-oror-Fast-and-Slow)\\n\\nhere **updating slow pointer** will be done as\\n\\n**slow = nums[slow]**; // by 1 steps\\n\\n**fast pointer will be updated** as \\n\\n**fast = nums[nums[fast]]**; // by 2 steps\\n\\nso now we are at a **point where they both meet** and hence the **first collision point.**\\n\\nNow to **find the starting of cycle , i.e\\nThe second collision** is when we **move both the pointer by 1** (For Finding the Starting point)\\n\\nbut before that when are fast and slow pointer meets then the **slow pointer have covered a dist of let say x**, and the **fast pointer have covered the dist of 2x**. So the **difference of distance travel by both fast and slow is x**, and we can say this **x is the multiple of the length of the cycle** because fast and slow are meeting at  any point in the cycle and **they will only meet if differece of distance between them is a multiple of length of cycle.**\\n\\nso for **finding the second collision we keep the fast pointer at start and the slow remains at the first collison point** and now **both will move by 1 steps till both slow and fast becomes equal**, and now  slow will be the start of the cycle and is the repeated element.\\n\\n**so now the question is when both fast and slow meet again how it be the starting element of linkedlist ?**\\n\\nas i proved earlier that the difference of distance of fast and slow is x (multilple of length of cycle), so when they meet the fast pointer has already moved an extra x(dist) than slow and we can easily say x  is the multiple of length of cycle.\\n\\n**x = n C (x is a multiple of length of Cycle C)**\\n\\n\\nnow **assume the distance from start to duplicate** is **\\'a\\'** so the **distance from duplicate  to first collision is \\'x - a\\';**\\n\\nnow to **find the second collison we are keeping the fast pointer at  start and  moving fast and slow by 1**, so now **if the duplicate is at dist a** so the **fast pointer will move a dist of a** and the **slow pointer is at x - a it will also move a dist of a**\\ni.e *x - a  + a* **that is x** and **this x is the multiple of lenght of cycle** so we can say that when we start fast pointer from starting point and slow pointer from first collison point **they are bound to meet at the duplicate element i.e the start of the cycle**.\\n\\n\\n**Time Complexity -> O(N)\\nSpace Complextiy -> O(1)**\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int fast = nums[0];\\n        int slow = nums[0];\\n        \\n        do{\\n            fast = nums[nums[fast]];\\n            slow = nums[slow];\\n        }while(fast != slow);\\n        \\n        fast = nums[0];\\n        \\n        while(fast != slow)\\n        {\\n            fast = nums[fast];\\n            slow = nums[slow];\\n        }\\n        \\n        return slow;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Tortoise Algorithm is the most appropriate one, brute, map, count vector and binary Search, Making Visted Values within an Array are other possible approaches.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ind = 0;\\n\\t\\t\\n\\t\\t// sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n\\t\\t\\t// if two consecutive elements are equal\\n\\t\\t\\t// you have find a duplicate\\n\\t\\t\\t// break the loop\\n            if(nums[i] == nums[i+1])\\n            {\\n                ind = nums[i];\\n                break;\\n            }\\n        }\\n        // return duplicate value\\n        return ind;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```\n``` ```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n\\t\\t// initialise cnt vector of size nums with 0\\n        vector<int> cnt(nums.size(),0);\\n        int ind =  0;\\n\\t\\t\\n\\t\\t// store the cnt of each value in the cnt vector\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            cnt[nums[i]]++;\\n        }\\n        \\n        for(int i = 0; i<cnt.size(); i++)\\n        {\\n\\t\\t\\t// if cnt[i] > 1\\n\\t\\t\\t// this means that element occur more than once in nums\\n\\t\\t\\t// we have to return i\\n            if(cnt[i] > 1)\\n            {\\n                ind  = i;\\n                break;\\n            }\\n        }\\n        \\n        return ind;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\nTime Complexity -> O(N)\\nSpace Complexit -> O(N)\\n\\n```\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        map<int, int> m;\\n        int duplicate = 0;\\n        for(auto i= 0; i<nums.size(); ++i)\\n        ++m[nums[i]];\\n        \\n        for(auto i : m)\\n        {\\n            if(i.second > 1)\\n            {\\n                duplicate = i.first;\\n                break;\\n            }\\n        }\\n        return duplicate;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\n``` ```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            int idx = abs(nums[i]);\\n            \\n            if(nums[idx] < 0)\\n                return idx;\\n            \\n            nums[idx] = -nums[idx];\\n        }\\n        \\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int fast = nums[0];\\n        int slow = nums[0];\\n        \\n        do{\\n            fast = nums[nums[fast]];\\n            slow = nums[slow];\\n        }while(fast != slow);\\n        \\n        fast = nums[0];\\n        \\n        while(fast != slow)\\n        {\\n            fast = nums[fast];\\n            slow = nums[slow];\\n        }\\n        \\n        return slow;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72846,
                "title": "my-easy-understood-solution-with-o-n-time-and-o-1-space-without-modifying-the-array-with-clear-explanation",
                "content": "The main idea is the same with problem ***Linked List Cycle II***,*https://leetcode.com/problems/linked-list-cycle-ii/*. Use two pointers the fast and the slow. The fast one goes forward two steps each time, while the slow one goes only step each time. They must meet the same item when slow==fast. In fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0]. Next we just need to find the entry point. We use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle. The easy understood code is as follows.\\n\\n    int findDuplicate3(vector<int>& nums)\\n    {\\n    \\tif (nums.size() > 1)\\n    \\t{\\n    \\t\\tint slow = nums[0];\\n    \\t\\tint fast = nums[nums[0]];\\n    \\t\\twhile (slow != fast)\\n    \\t\\t{\\n    \\t\\t\\tslow = nums[slow];\\n    \\t\\t\\tfast = nums[nums[fast]];\\n    \\t\\t}\\n    \\n    \\t\\tfast = 0;\\n    \\t\\twhile (fast != slow)\\n    \\t\\t{\\n    \\t\\t\\tfast = nums[fast];\\n    \\t\\t\\tslow = nums[slow];\\n    \\t\\t}\\n    \\t\\treturn slow;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "The main idea is the same with problem ***Linked List Cycle II***,*https://leetcode.com/problems/linked-list-cycle-ii/*. Use two pointers the fast and the slow. The fast one goes forward two steps each time, while the slow one goes only step each time. They must meet the same item when slow==fast. In fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0]. Next we just need to find the entry point. We use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle. The easy understood code is as follows.\\n\\n    int findDuplicate3(vector<int>& nums)\\n    {\\n    \\tif (nums.size() > 1)\\n    \\t{\\n    \\t\\tint slow = nums[0];\\n    \\t\\tint fast = nums[nums[0]];\\n    \\t\\twhile (slow != fast)\\n    \\t\\t{\\n    \\t\\t\\tslow = nums[slow];\\n    \\t\\t\\tfast = nums[nums[fast]];\\n    \\t\\t}\\n    \\n    \\t\\tfast = 0;\\n    \\t\\twhile (fast != slow)\\n    \\t\\t{\\n    \\t\\t\\tfast = nums[fast];\\n    \\t\\t\\tslow = nums[slow];\\n    \\t\\t}\\n    \\t\\treturn slow;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72844,
                "title": "two-solutions-with-explanation-o-nlog-n-and-o-n-time-o-1-space-without-changing-the-input-array",
                "content": "This solution is based on binary search.\\n\\nAt first the search space is numbers between 1 to n. Each time I select a number `mid` (which is the one in the middle) and count all the numbers equal to or less than `mid`. Then if the `count` is more than `mid`, the search space will be `[1 mid]` otherwise `[mid+1 n]`. I do this until search space is only one number.\\n \\nLet's say `n=10` and I select `mid=5`. Then I count all the numbers in the array which are less than equal `mid`. If the there are more than `5` numbers that are less than `5`, then by Pigeonhole Principle (https://en.wikipedia.org/wiki/Pigeonhole_principle) one of them has occurred more than once. So I shrink the search space from `[1 10]` to `[1 5]`. Otherwise the duplicate number is in the second half so for the next step the search space would be `[6 10]`. \\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            low = 1\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = low+(high-low)/2\\n                count = 0\\n                for i in nums:\\n                    if i <= mid:\\n                        count+=1\\n                if count <= mid:\\n                    low = mid+1\\n                else:\\n                    high = mid\\n            return low\\n\\n\\nThere's also a better algorithm with `O(n)` time. Please read this very interesting solution here:\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate](http://keithschwarz.com/interesting/code/?dir=find-duplicate)",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "This solution is based on binary search.\\n\\nAt first the search space is numbers between 1 to n. Each time I select a number `mid` (which is the one in the middle) and count all the numbers equal to or less than `mid`. Then if the `count` is more than `mid`, the search space will be `[1 mid]` otherwise `[mid+1 n]`. I do this until search space is only one number.\\n \\nLet's say `n=10` and I select `mid=5`. Then I count all the numbers in the array which are less than equal `mid`. If the there are more than `5` numbers that are less than `5`, then by Pigeonhole Principle (https://en.wikipedia.org/wiki/Pigeonhole_principle) one of them has occurred more than once. So I shrink the search space from `[1 10]` to `[1 5]`. Otherwise the duplicate number is in the second half so for the next step the search space would be `[6 10]`. \\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            low = 1\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = low+(high-low)/2\\n                count = 0\\n                for i in nums:\\n                    if i <= mid:\\n                        count+=1\\n                if count <= mid:\\n                    low = mid+1\\n                else:\\n                    high = mid\\n            return low\\n\\n\\nThere's also a better algorithm with `O(n)` time. Please read this very interesting solution here:\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate](http://keithschwarz.com/interesting/code/?dir=find-duplicate)",
                "codeTag": "Java"
            },
            {
                "id": 73045,
                "title": "simple-c-code-with-o-1-space-and-o-nlogn-time-complexity",
                "content": "class Solution {\\n\\npublic:\\n\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int low=1;\\n        int high=n;\\n        int mid;\\n        while(low<high){\\n            mid=(low+high)/2;\\n            int count=0;\\n            for(int num:nums){\\n                if(num<=mid) count++;\\n            }\\n            if(count>mid) high=mid;\\n            else low=mid+1; \\n        }\\n        return low;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int low=1;\\n        int high=n;\\n        int mid;\\n        while(low<high){\\n            mid=(low+high)/2;\\n            int count=0;\\n            for(int num:nums){\\n                if(num<=mid) count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 560089,
                "title": "c-4-different-solutions-beats-100-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/find-the-duplicate-number/\\n*/\\nclass Solution {\\npublic:\\n    // TC: O(N), SC: O(1)\\n    /*\\n        Since the numbers are [1:N], so we use the array indices for storing the\\n        visited state of each number, only the duplicate will be visited twice.\\n        For each number we goto its index position and multiply by -1. In case\\n        of duplicate it will be multiplied twice and the number will be +ve.\\n    */\\n    int indexSolution(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            int index = abs(nums[i]) - 1;\\n            \\n            // mark as visited\\n            nums[index] *= -1;\\n            // incase of duplicate, this will become +ve \\n            if(nums[index] > 0)\\n                return abs(nums[i]);\\n        }    \\n        return -1;\\n    }\\n    \\n    // Using Floyd Cycle detection\\n    // TC: O(N), SC: O(1)\\n    \\n    /*\\n        Assume each nums value as an address just like in linked list node addr.\\n        Then since there is one number whith duplicates, that means there are multiple instances\\n        of the same address, so it is a cycle just like in linked list. Do the same thing\\n        as in linked list.\\n    */\\n    int floydSolution(vector<int>& nums) {\\n        // Each index is taken 1 based, as if it is zero based, then\\n        // for nums[2] = 3, if we goto nums[nums[2] - 1], it is again nums[2]\\n        // infinite loop\\n        int hare = nums[0], tortoise = nums[0];\\n        \\n        do {\\n            hare = nums[nums[hare]];\\n            tortoise = nums[tortoise];\\n        } while(hare != tortoise);\\n        \\n        // to find the starting of cycle, make tortoise to start from begining\\n        tortoise = nums[0];\\n        while(hare != tortoise) {\\n            hare = nums[hare];\\n            tortoise = nums[tortoise];\\n        }\\n        \\n        return hare;\\n    }\\n    \\n    // Using Binary search\\n    // TC: O(nlogn), SC: O(1)\\n    int binarySearchSolution(vector<int>& nums) {\\n        // The idea is that it is known that there is a duplicate, so \\n        // we can use pigeon hole concept here. We do binary search on the search\\n        // space of [1:N], then count the number of elements <= middle. If the \\n        // duplicate is on the left side, then count should be more than mid,\\n        // else it is on the right side. Initially search space is [1: N], then\\n        // each time narrow down the search space\\n        int left = 1, right = nums.size() - 1;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            // count the number of elements smaller/ equal than middle element\\n            int c = 0;\\n            for(const int& el: nums)\\n                if(el <= mid)\\n                    ++c;\\n            \\n            if(c > mid)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    // Using Sorting\\n    // TC: O(nlogn)\\n    int sortingSolution(vector<int>& nums) {\\n        // sort the numbers and find the number which has duplicate\\n        // by checking the one which has the same at next position\\n        sort(nums.begin(), nums.end());\\n        \\n        int duplicate = 0;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            if(nums[i] == nums[i+1]) {\\n                duplicate = nums[i];\\n                break;\\n            }\\n        return duplicate;\\n    }\\n    \\n    \\n    \\n    int findDuplicate(vector<int>& nums) {\\n        // return sortingSolution(nums);\\n        // return binarySearchSolution(nums);\\n        //return floydSolution(nums);\\n        return indexSolution(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/find-the-duplicate-number/\\n*/\\nclass Solution {\\npublic:\\n    // TC: O(N), SC: O(1)\\n    /*\\n        Since the numbers are [1:N], so we use the array indices for storing the\\n        visited state of each number, only the duplicate will be visited twice.\\n        For each number we goto its index position and multiply by -1. In case\\n        of duplicate it will be multiplied twice and the number will be +ve.\\n    */\\n    int indexSolution(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            int index = abs(nums[i]) - 1;\\n            \\n            // mark as visited\\n            nums[index] *= -1;\\n            // incase of duplicate, this will become +ve \\n            if(nums[index] > 0)\\n                return abs(nums[i]);\\n        }    \\n        return -1;\\n    }\\n    \\n    // Using Floyd Cycle detection\\n    // TC: O(N), SC: O(1)\\n    \\n    /*\\n        Assume each nums value as an address just like in linked list node addr.\\n        Then since there is one number whith duplicates, that means there are multiple instances\\n        of the same address, so it is a cycle just like in linked list. Do the same thing\\n        as in linked list.\\n    */\\n    int floydSolution(vector<int>& nums) {\\n        // Each index is taken 1 based, as if it is zero based, then\\n        // for nums[2] = 3, if we goto nums[nums[2] - 1], it is again nums[2]\\n        // infinite loop\\n        int hare = nums[0], tortoise = nums[0];\\n        \\n        do {\\n            hare = nums[nums[hare]];\\n            tortoise = nums[tortoise];\\n        } while(hare != tortoise);\\n        \\n        // to find the starting of cycle, make tortoise to start from begining\\n        tortoise = nums[0];\\n        while(hare != tortoise) {\\n            hare = nums[hare];\\n            tortoise = nums[tortoise];\\n        }\\n        \\n        return hare;\\n    }\\n    \\n    // Using Binary search\\n    // TC: O(nlogn), SC: O(1)\\n    int binarySearchSolution(vector<int>& nums) {\\n        // The idea is that it is known that there is a duplicate, so \\n        // we can use pigeon hole concept here. We do binary search on the search\\n        // space of [1:N], then count the number of elements <= middle. If the \\n        // duplicate is on the left side, then count should be more than mid,\\n        // else it is on the right side. Initially search space is [1: N], then\\n        // each time narrow down the search space\\n        int left = 1, right = nums.size() - 1;\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            // count the number of elements smaller/ equal than middle element\\n            int c = 0;\\n            for(const int& el: nums)\\n                if(el <= mid)\\n                    ++c;\\n            \\n            if(c > mid)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    // Using Sorting\\n    // TC: O(nlogn)\\n    int sortingSolution(vector<int>& nums) {\\n        // sort the numbers and find the number which has duplicate\\n        // by checking the one which has the same at next position\\n        sort(nums.begin(), nums.end());\\n        \\n        int duplicate = 0;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            if(nums[i] == nums[i+1]) {\\n                duplicate = nums[i];\\n                break;\\n            }\\n        return duplicate;\\n    }\\n    \\n    \\n    \\n    int findDuplicate(vector<int>& nums) {\\n        // return sortingSolution(nums);\\n        // return binarySearchSolution(nums);\\n        //return floydSolution(nums);\\n        return indexSolution(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72845,
                "title": "java-o-n-time-and-o-1-space-solution-similar-to-find-loop-in-linkedlist",
                "content": "suppose the array is \\n\\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 2 5 1 1 4 3\\n\\nfirst subtract 1 from each element in the array, so it is much easy to understand.\\n    use the value as pointer. the array becomes:\\n\\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 1 4 0 0 3 2\\n\\n![enter image description here][1]\\n\\n\\n  [1]: http://cyukang.com/images/cycle3.png\\n\\nSecond if the array is \\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 0 1 2 4 2 3\\n\\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\\n\\nNow the problem is the same as find the cycle in linkedlist!\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<nums.length;i++) nums[i]--;\\n        int slow = n-1;\\n        int fast = n-1;\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        slow = n-1;\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow+1;\\n    }\\n\\nOne condition is we cannot modify the array. So the solution is\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int slow = n;\\n        int fast = n;\\n        do{\\n            slow = nums[slow-1];\\n            fast = nums[nums[fast-1]-1];\\n        }while(slow != fast);\\n        slow = n;\\n        while(slow != fast){\\n            slow = nums[slow-1];\\n            fast = nums[fast-1];\\n        }\\n        return slow;\\n    }",
                "solutionTags": [],
                "code": "suppose the array is \\n\\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 2 5 1 1 4 3\\n\\nfirst subtract 1 from each element in the array, so it is much easy to understand.\\n    use the value as pointer. the array becomes:\\n\\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 1 4 0 0 3 2\\n\\n![enter image description here][1]\\n\\n\\n  [1]: http://cyukang.com/images/cycle3.png\\n\\nSecond if the array is \\n\\n> index: 0 1 2 3 4 5\\n> \\n> value: 0 1 2 4 2 3\\n\\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\\n\\nNow the problem is the same as find the cycle in linkedlist!\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<nums.length;i++) nums[i]--;\\n        int slow = n-1;\\n        int fast = n-1;\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        slow = n-1;\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow+1;\\n    }\\n\\nOne condition is we cannot modify the array. So the solution is\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int slow = n;\\n        int fast = n;\\n        do{\\n            slow = nums[slow-1];\\n            fast = nums[nums[fast-1]-1];\\n        }while(slow != fast);\\n        slow = n;\\n        while(slow != fast){\\n            slow = nums[slow-1];\\n            fast = nums[fast-1];\\n        }\\n        return slow;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 72841,
                "title": "java-o-1-space-using-binary-search",
                "content": "    public int findDuplicate(int[] nums) {\\n\\t\\tint low = 1, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = (int) (low + (high - low) * 0.5);\\n            int cnt = 0;\\n            for (int a : nums) {\\n                if (a <= mid) ++cnt;\\n            }\\n            if (cnt <= mid) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return low;\\n    }",
                "solutionTags": [],
                "code": "    public int findDuplicate(int[] nums) {\\n\\t\\tint low = 1, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = (int) (low + (high - low) * 0.5);\\n            int cnt = 0;\\n            for (int a : nums) {\\n                if (a <= mid) ++cnt;\\n            }\\n            if (cnt <= mid) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return low;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 704693,
                "title": "python-2-solutions-linked-list-cycle-o-n-and-bs-o-n-log-n-explained",
                "content": "For me the main difficulty was that given tests are not clear at all: both of them have only one duplicate, however there can be examples like `2,2,2,2,3`. \\nWhy there always will be duplicate? Because of Pigeonhole principle! Actually, it can be proven very easily: let us assume that it not correct: it means, that each number between `1` and `n` can have frequency only `0` of `1`. It means, that there will be `<= n` numbers, but we need to have `n+1`. Contradiction: so, our assumption is correct: there will be at least one duplicate number.\\n\\nOne way to handle this problem is to sort data with `O(n log n)` time and `O(n)` memory or use hash table. Howerer it violates the conditions of problem: we can not use extra memory. There is smarter way and we need to use the fact that each integer is **between 1 and n**, which we did not use in sort.\\n\\nLet us deal our list as linked list, where `i` is connected with `nums[i]`.\\nConsider example `6, 2, 4, 1, 3, 2, 5, 2`. Then we have the following singly-linked list:\\n`0 -> 6 -> 5 ->` **2** `-> 4 -> 3 -> 1 ->` **2** `-> ...` \\nWe start with index **0**, look what is inside? it is number `6`, so we look at index number **6**, what is inside? Number **5** and so on. Look at the image below for better understanding.\\nSo the goal is to find loop in this linkes list. Why there will be always loop? Because `nums[1] = nums[5]` in our case, and similarly there will be always duplicate, and it is given that it is only one.\\n\\n![image](https://assets.leetcode.com/users/images/7abc4538-ec0e-4713-a525-343584c6b3f3_1593079845.8204632.png)\\n\\n\\n\\n\\n\\nSo now, the problem is to find the starting point of loop in singly-linked list (**problem 142**), which has a classical solution with two pointers: slow which moves one step at a time and fast, which moves two times at a time. To find this place we need to do it in two iterations: first we wait until fast pointer gains slow pointer and then we move slow pointer to the start and run them with the same speed and wait until they concide.\\n\\n**Complexity**: Time complexity is `O(n)`, because we potentially can traverse all list. Space complexity is `O(1)`, because we actually do not use any extra space: our linked list is **virtual**.\\n\\n```\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        slow, fast = nums[0], nums[0]\\n        while True:\\n            slow, fast = nums[slow], nums[nums[fast]]\\n            if slow == fast: break\\n           \\n        slow = nums[0];\\n        while slow != fast:\\n            slow, fast = nums[slow], nums[fast]\\n        return slow\\n```\\n\\n### Binary search solution\\n\\nThere is **Binary Search** solution with time complexity `O(n log n)` and space complexity `O(1)`. We have numbers from `1` to `n`. Let us choose middle element `m = n//2` and count number of elements in list, which are less or equal than `m`. If we have `m+1` of them it means we need to search for duplicate in `[1,m]` range, else in `[m+1,n]` range. Each time we reduce searching range twice, but each time we go over **all** data. So overall complexity is `O(n log n)`. \\n\\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        beg, end = 1, len(nums)-1\\n        \\n        while beg + 1 <= end:\\n            mid, count = (beg + end)//2, 0\\n            for num in nums:\\n                if num <= mid: count += 1        \\n            if count <= mid:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        return end\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        slow, fast = nums[0], nums[0]\\n        while True:\\n            slow, fast = nums[slow], nums[nums[fast]]\\n            if slow == fast: break\\n           \\n        slow = nums[0];\\n        while slow != fast:\\n            slow, fast = nums[slow], nums[fast]\\n        return slow\\n```\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        beg, end = 1, len(nums)-1\\n        \\n        while beg + 1 <= end:\\n            mid, count = (beg + end)//2, 0\\n            for num in nums:\\n                if num <= mid: count += 1        \\n            if count <= mid:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        return end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72872,
                "title": "o-32-n-solution-using-bit-manipulation-in-10-lines",
                "content": "We can count the sum of each 32 bits separately for the given array (stored in \"b\" variable) and for the array [1, 2, 3, ..., n] (stored in \"a\" variable). If \"b\" is greater than \"a\", it means that duplicated number has 1 at the current bit position (otherwise, \"b\" couldn't be greater than \"a\"). This way we retrieve the answer bit by bit:\\n\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length-1, res = 0;\\n        for (int p = 0; p < 32; ++ p) {\\n            int bit = (1 << p), a = 0, b = 0;\\n            for (int i = 0; i <= n; ++ i) {\\n                if (i > 0 && (i & bit) > 0) ++a;\\n                if ((nums[i] & bit) > 0) ++b;\\n            }\\n            if (b > a) res += bit;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "We can count the sum of each 32 bits separately for the given array (stored in \"b\" variable) and for the array [1, 2, 3, ..., n] (stored in \"a\" variable). If \"b\" is greater than \"a\", it means that duplicated number has 1 at the current bit position (otherwise, \"b\" couldn't be greater than \"a\"). This way we retrieve the answer bit by bit:\\n\\n\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length-1, res = 0;\\n        for (int p = 0; p < 32; ++ p) {\\n            int bit = (1 << p), a = 0, b = 0;\\n            for (int i = 0; i <= n; ++ i) {\\n                if (i > 0 && (i & bit) > 0) ++a;\\n                if ((nums[i] & bit) > 0) ++b;\\n            }\\n            if (b > a) res += bit;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4062141,
                "title": "97-77-6-approaches-set-count-binary-search-fast-slow-mark-sort",
                "content": "# Comprehensive Guide to Solving \"Find the Duplicate Number\"\\n\\n## Introduction & Problem Statement\\n\\nGiven an array of integers, $$ \\\\text{nums} $$, containing $$ n + 1 $$ integers where each integer is in the range $$[1, n]$$ inclusive, find the one repeated number in the array. The challenge lies in solving the problem without modifying the array $$ \\\\text{nums} $$ and using only constant extra space. This problem is a classic example of array manipulation and number theory combined, making it an interesting problem to tackle.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes This Problem Unique?\\n\\n1. **Array Representation**:  \\n   The array contains $$ n + 1 $$ integers, each falling within the range $$[1, n]$$.\\n\\n2. **Single Duplication**:  \\n   Only one integer is repeated in the array, and it can be repeated more than once.\\n\\n3. **Constraints**:  \\n   - Array length: $$ n + 1 $$, where $$ 1 \\\\leq n \\\\leq 10^5 $$\\n   - $$ 1 \\\\leq \\\\text{nums}[i] \\\\leq n $$\\n\\n## Six Primary Strategies to Solve the Problem:\\n\\n1. **Set/Hash Table**: Use a hash table to track the numbers that have appeared so far.\\n2. **Count Array**: Use an auxiliary array to count the frequency of each number.\\n3. **Marking in Array**: Negate the value at the index corresponding to each number in the array.\\n4. **Floyd\\'s Cycle Detection (Fast-Slow Pointers)**: Treat the array as a linked list to find a cycle.\\n5. **Binary Search**: Count the numbers less than or equal to the middle element to find the duplicate.\\n6. **Sort**: Sort the array and check adjacent elements for duplicates.\\n\\n---\\n\\n# In-Depth Strategies for Finding the Duplicate Number in an Array\\n\\n## Live Coding & comparing 6 Approaches\\nhttps://youtu.be/J3qIbJA7t9Q?si=1H3cjdkBb7QQ8D7x\\n\\n## 1. Set/Hash Table Approach\\n\\n#### Detailed Logic:\\n1. Initialize an empty set `seen`.\\n2. Traverse through the array `nums`.\\n3. For each element `num` in `nums`, check if it exists in `seen`.\\n    - If it does, return `num` as the duplicate.\\n    - Otherwise, add `num` to `seen`.\\n\\n#### Pros:\\n- Extremely straightforward to implement.\\n- No need to sort or modify the original array.\\n\\n#### Cons:\\n- This approach requires extra space for the set, which violates the problem\\'s constraint of constant extra space.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$O(n)$$ because we iterate through the array once.\\n- **Space Complexity**: $$O(n)$$ for storing the set.\\n\\n## Code Set\\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return num\\n            seen.add(num)\\n\\n```\\n``` Go []\\nfunc findDuplicate(nums []int) int {\\n    seen := make(map[int]bool)\\n    for _, num := range nums {\\n        if seen[num] {\\n            return num\\n        }\\n        seen[num] = true\\n    }\\n    return -1  // Just to satisfy the compiler, this should never be reached\\n}\\n```\\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\\n    let mut seen = HashSet::new();\\n    for &num in nums.iter() {\\n        if seen.contains(&num) {\\n            return num;\\n        }\\n        seen.insert(num);\\n    }\\n    -1  // Just to satisfy the compiler, this should never be reached\\n}\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(std::vector<int>& nums) {\\n        std::unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.find(num) != seen.end()) {\\n                return num;\\n            }\\n            seen.insert(num);\\n        }\\n        return -1;  // Just to satisfy the compiler, this should never be reached\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n    HashSet<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  // Just to satisfy the compiler, this should never be reached\\n}\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  // Just to satisfy the compiler, this should never be reached\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        HashSet<int> seen = new HashSet<int>();\\n        foreach (int num in nums) {\\n            if (seen.Contains(num)) {\\n                return num;\\n            }\\n            seen.Add(num);\\n        }\\n        return -1;  // Just to satisfy the compiler, this should never be reached\\n    }\\n}\\n```\\n\\n---\\n\\n## 2. Count Array Approach\\n\\n#### Detailed Logic:\\n1. Initialize an auxiliary count array `cnt` with zeros. Its size will be $$ n+1 $$ to accommodate all possible numbers.\\n2. Traverse through the array `nums`.\\n3. For each element `num` in `nums`, increment `cnt[num]` by 1.\\n4. Check if `cnt[num]` exceeds 1; if yes, return `num` as the duplicate.\\n\\n#### Pros:\\n- Implementation is simple and direct.\\n  \\n#### Cons:\\n- Extra space is used for the count array, which contradicts the constraint of constant extra space.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$O(n)$$ due to a single pass through the array.\\n- **Space Complexity**: $$O(n)$$ for the count array.\\n\\n\\n## Code Count\\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        cnt = [0] * (len(nums) + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n            if cnt[num] > 1:\\n                return num\\n        return len(nums)\\n```\\n\\n---\\n\\n## 3. Marking in Array Approach\\n\\n#### Detailed Logic:\\n1. Traverse the array `nums`.\\n2. For each element `num`, take its absolute value as an index (`idx = abs(num)`).\\n3. If `nums[idx]` is negative, then `idx` is the duplicate number.\\n4. Otherwise, negate `nums[idx]`.\\n\\n#### Pros:\\n- Doesn\\'t use any extra space other than the input array.\\n  \\n#### Cons:\\n- Modifies the original array, which is disallowed by the problem constraints.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$O(n)$$ for a single pass through the array.\\n- **Space Complexity**: $$O(1)$$ as no extra space is used.\\n\\n## Code Mark\\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            idx = abs(num)\\n            if nums[idx] < 0:\\n                return idx\\n            nums[idx] = -nums[idx]\\n        return len(nums)\\n```\\n\\n---\\n\\n## 4. Fast-Slow Pointers Approach (Floyd\\'s Cycle Detection)\\n\\n### Detailed Logic Behind the Fast-Slow Pointers Approach\\n\\n**Step 1: Initialize Pointers**\\nFirst, we initialize two pointers, `slow` and `fast`, both set to `nums[0]`. This is the starting point for both pointers, and it\\'s done to set up the conditions for Floyd\\'s cycle detection algorithm.\\n\\n**Step 2: Detect a Cycle**\\nIn this step, we enter a `while` loop where the `slow` pointer moves one step at a time (`slow = nums[slow]`), while the `fast` pointer moves two steps (`fast = nums[nums[fast]]`). The loop continues until both pointers meet at some point within the cycle. Note that this meeting point is not necessarily the duplicate number; it\\'s just a point inside the cycle.\\n\\nWhy does this happen? Because there is a duplicate number, there must be a cycle in the \\'linked list\\' created by following `nums[i]` as next elements. Once a cycle is detected, the algorithm breaks out of this loop.\\n\\n**Step 3: Find the Start of the Cycle (Duplicate Number)**\\nAfter identifying a meeting point inside the cycle, we reinitialize the `slow` pointer back to `nums[0]`. The `fast` pointer stays at the last meeting point. Now, we enter another `while` loop where both pointers move one step at a time. The reason behind this is mathematical: according to Floyd\\'s cycle detection algorithm, when both pointers move at the same speed, they will eventually meet at the starting point of the cycle. This is the duplicate number we are looking for.\\n\\n**Step 4: Return the Duplicate Number**\\nFinally, when the `slow` and `fast` pointers meet again, the meeting point will be the duplicate number, and we return it as the output.\\n\\n#### Pros:\\n- Adheres to the constant space constraint.\\n- Doesn\\'t modify the original array.\\n\\n#### Cons:\\n- The logic can be slightly tricky to grasp initially.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$O(n)$$, where $$ n $$ is the length of the array.\\n- **Space Complexity**: $$O(1)$$ as no extra space is required.\\n\\n## Code Fast Slow Pointers\\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n\\n        slow = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n            \\n        return slow\\n```\\n``` Go []\\nfunc findDuplicate(nums []int) int {\\n    slow := nums[0]\\n    fast := nums[0]\\n    \\n    for {\\n        slow = nums[slow]\\n        fast = nums[nums[fast]]\\n        \\n        if slow == fast {\\n            break\\n        }\\n    }\\n    \\n    slow = nums[0]\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[fast]\\n    }\\n    \\n    return slow\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\\n        let mut slow = nums[0];\\n        let mut fast = nums[0];\\n        \\n        loop {\\n            slow = nums[slow as usize];\\n            fast = nums[nums[fast as usize] as usize];\\n            \\n            if slow == fast {\\n                break;\\n            }\\n        }\\n        \\n        slow = nums[0];\\n        while slow != fast {\\n            slow = nums[slow as usize];\\n            fast = nums[fast as usize];\\n        }\\n        \\n        slow\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n    \\n    do {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    } while (slow !== fast);\\n    \\n    slow = nums[0];\\n    while (slow !== fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    \\n    return slow;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function findDuplicate($nums) {\\n        $slow = $nums[0];\\n        $fast = $nums[0];\\n        \\n        do {\\n            $slow = $nums[$slow];\\n            $fast = $nums[$nums[$fast]];\\n        } while ($slow != $fast);\\n        \\n        $slow = $nums[0];\\n        while ($slow != $fast) {\\n            $slow = $nums[$slow];\\n            $fast = $nums[$fast];\\n        }\\n        \\n        return $slow;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```\\n\\n---\\n\\n### 5. Binary Search Approach\\n\\n#### Detailed Logic:\\n1. Initialize `low` to 1 and `high` to $$ n $$.\\n2. Run a binary search loop until `low < high`:\\n    - Calculate `mid` as the midpoint between `low` and `high`.\\n    - Count elements in the array that are less than or equal to `mid`.\\n    - If the count is greater than `mid`, set `high = mid`. Otherwise, set `low = mid + 1`.\\n\\n#### Pros:\\n- No modification to the original array.\\n  \\n#### Cons:\\n- Somewhat more complex to understand due to binary search mechanics.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$O(n \\\\log n)$$ due to binary search combined with array scanning.\\n- **Space Complexity**: $$O(1)$$ as no extra space is needed.\\n\\n\\n## Code Binary Search\\n``` Python \\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        low, high = 1, len(nums) - 1\\n        \\n        while low < high:\\n            mid = (low + high) // 2\\n            count = 0\\n            for num in nums:\\n                if num <= mid:\\n                    count += 1\\n            if count > mid:\\n                high = mid\\n            else:\\n                low = mid + 1\\n                \\n        return low\\n\\n```\\n\\n## 6. Sort Approach\\n\\n#### Detailed Logic:\\n1. Sort the `nums` array in ascending order.\\n2. Traverse the sorted array and compare adjacent elements.\\n    - If two adjacent elements are equal, return one of them as the duplicate.\\n3. If no duplicate is found, return the length of the array (this should not happen under the problem constraints).\\n\\n#### Pros:\\n- Simple to understand and implement.\\n- Utilizes Python\\'s efficient built-in sorting algorithm.\\n\\n#### Cons:\\n- Modifies the original array by sorting it.\\n- Not the most time-efficient solution for this problem.\\n\\n#### Time and Space Complexity:\\n- **Time Complexity**: $$ O(n \\\\log n) $$ due to sorting.\\n- **Space Complexity**: $$ O(1) $$ if sorting is done in-place, otherwise $$ O(n) $$.\\n\\n---\\n\\n\\n## Code Sort\\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return nums[i]\\n        return len(nums)\\n```\\n\\n## Performance\\n\\n| Language  | Time (ms) | Space (MB) | Approach         | \\n|-----------|-----------|------------|------------------|\\n| Java      | 4         | 56.8       | Fast Slow Pointers|                  |\\n| Rust      | 10        | 3.1        | Fast Slow Pointers|                  |\\n| JavaScript| 75        | 49.6       | Fast Slow Pointers|                  |\\n| C++       | 73        | 61.5       | Fast Slow Pointers\\n| Go        | 98        | 9.2        | Fast Slow Pointers|                  |\\n| C#        | 167       | 54.6       | Fast Slow Pointers|                  |\\n| PHP       | 179       | 31.7       | Fast Slow Pointers|                  |\\n| Java      | 20        | 61.2       | Set               |                  |\\n| Rust      | 26        | 4.1        | Set               |                  |\\n| C#        | 193       | 50.7       | Set               |                  |\\n| Go        | 100       | 9.2        | Set               |                  |\\n| JavaScript| 92        | 61.3       | Set               |                  |\\n| C++       | 135       | 84.2       | Set               |                  |\\n| Python3   | 495       | 32.3       | Set               |                  |\\n| Python3   | 518       | 31.1       | Fast Slow Pointers|                  |\\n| Python3   | 518       | 30.9       | Count             |                  |\\n| Python3   | 522       | 31.0       | Mark              |                  |\\n| Python3   | 564       | 31.1       | Sort              |                  |\\n| Python3   | 724       | 31.0       | Binary Search     |                  |\\n\\n![pl44.png](https://assets.leetcode.com/users/images/1f172996-462a-4849-b8b3-0ef697817fd1_1695085986.8572996.png)\\n\\n\\n## Conclusion\\n\\nEach strategy has its merits and demerits, and the choice of approach depends on the specific constraints of the problem. Understanding these methods not only helps in solving this problem but also broadens one\\'s array manipulation and algorithmic skills. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return num\\n            seen.add(num)\\n\\n```\n``` Go []\\nfunc findDuplicate(nums []int) int {\\n    seen := make(map[int]bool)\\n    for _, num := range nums {\\n        if seen[num] {\\n            return num\\n        }\\n        seen[num] = true\\n    }\\n    return -1  // Just to satisfy the compiler, this should never be reached\\n}\\n```\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\\n    let mut seen = HashSet::new();\\n    for &num in nums.iter() {\\n        if seen.contains(&num) {\\n            return num;\\n        }\\n        seen.insert(num);\\n    }\\n    -1  // Just to satisfy the compiler, this should never be reached\\n}\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(std::vector<int>& nums) {\\n        std::unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.find(num) != seen.end()) {\\n                return num;\\n            }\\n            seen.insert(num);\\n        }\\n        return -1;  // Just to satisfy the compiler, this should never be reached\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n    HashSet<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  // Just to satisfy the compiler, this should never be reached\\n}\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    const seen = new Set();\\n    for (const num of nums) {\\n        if (seen.has(num)) {\\n            return num;\\n        }\\n        seen.add(num);\\n    }\\n    return -1;  // Just to satisfy the compiler, this should never be reached\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        HashSet<int> seen = new HashSet<int>();\\n        foreach (int num in nums) {\\n            if (seen.Contains(num)) {\\n                return num;\\n            }\\n            seen.Add(num);\\n        }\\n        return -1;  // Just to satisfy the compiler, this should never be reached\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        cnt = [0] * (len(nums) + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n            if cnt[num] > 1:\\n                return num\\n        return len(nums)\\n```\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            idx = abs(num)\\n            if nums[idx] < 0:\\n                return idx\\n            nums[idx] = -nums[idx]\\n        return len(nums)\\n```\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n\\n        slow = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n            \\n        return slow\\n```\n``` Go []\\nfunc findDuplicate(nums []int) int {\\n    slow := nums[0]\\n    fast := nums[0]\\n    \\n    for {\\n        slow = nums[slow]\\n        fast = nums[nums[fast]]\\n        \\n        if slow == fast {\\n            break\\n        }\\n    }\\n    \\n    slow = nums[0]\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[fast]\\n    }\\n    \\n    return slow\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\\n        let mut slow = nums[0];\\n        let mut fast = nums[0];\\n        \\n        loop {\\n            slow = nums[slow as usize];\\n            fast = nums[nums[fast as usize] as usize];\\n            \\n            if slow == fast {\\n                break;\\n            }\\n        }\\n        \\n        slow = nums[0];\\n        while slow != fast {\\n            slow = nums[slow as usize];\\n            fast = nums[fast as usize];\\n        }\\n        \\n        slow\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n    \\n    do {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    } while (slow !== fast);\\n    \\n    slow = nums[0];\\n    while (slow !== fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    \\n    return slow;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function findDuplicate($nums) {\\n        $slow = $nums[0];\\n        $fast = $nums[0];\\n        \\n        do {\\n            $slow = $nums[$slow];\\n            $fast = $nums[$nums[$fast]];\\n        } while ($slow != $fast);\\n        \\n        $slow = $nums[0];\\n        while ($slow != $fast) {\\n            $slow = $nums[$slow];\\n            $fast = $nums[$fast];\\n        }\\n        \\n        return $slow;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n}\\n```\n``` Python \\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        low, high = 1, len(nums) - 1\\n        \\n        while low < high:\\n            mid = (low + high) // 2\\n            count = 0\\n            for num in nums:\\n                if num <= mid:\\n                    count += 1\\n            if count > mid:\\n                high = mid\\n            else:\\n                low = mid + 1\\n                \\n        return low\\n\\n```\n``` Python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return nums[i]\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73022,
                "title": "python-solution-with-o-1-space-and-o-nlogn-time",
                "content": "    class Solution(object):\\n        def findDuplicate(self, nums):\\n            low = 0\\n            high = len(nums) - 1\\n            mid = (high + low) / 2\\n            while high - low > 1:\\n                count = 0\\n                for k in nums:\\n                    if mid < k <= high:\\n                        count += 1\\n                if count > high - mid:\\n                    low = mid\\n                else:\\n                    high = mid\\n                mid = (high + low) / 2\\n            return high\\n\\nThe difficulty in this problem lies in O(1) space, and many solution using O(n) space can also be accepted by OJ.\\nThe solution is applying bi-search in the range[1, n] by counting the element which falls in sub range(n/2, n].\\nIf the number is bigger than capacity of that sub range, it means the duplicated integer falls in the sub-range.\\nOtherwise the duplicated integer falls in the other half sub range.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def findDuplicate(self, nums):\\n            low = 0\\n            high = len(nums) - 1\\n            mid = (high + low) / 2\\n            while high - low > 1:\\n                count = 0\\n                for k in nums:\\n                    if mid < k <= high:\\n                        count += 1\\n                if count > high - mid:\\n                    low = mid\\n                else:\\n                    high = mid\\n                mid = (high + low) / 2\\n            return high\\n\\nThe difficulty in this problem lies in O(1) space, and many solution using O(n) space can also be accepted by OJ.\\nThe solution is applying bi-search in the range[1, n] by counting the element which falls in sub range(n/2, n].\\nIf the number is bigger than capacity of that sub range, it means the duplicated integer falls in the sub-range.\\nOtherwise the duplicated integer falls in the other half sub range.",
                "codeTag": "Java"
            },
            {
                "id": 705111,
                "title": "summary-7-solutions-consice-explanation-and-complexity-analysis",
                "content": "## solution 1\\uFF1AO(N) time, O(N) space\\uFF1Aset\\nThis is the same as the [set solution](https://leetcode.com/articles/find-the-duplicate-number/), but since we already know the items are integers in the range [1, N], we can simply use an array to mark whether we have already seen the item.\\n\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        seen = [0] * (N+1)\\n        for num in nums:\\n            if seen[num]:\\n                return num\\n            seen[num] = 1\\n```\\n\\n### solution 1.2: bit manipulation\\nA so-called O(1) space but essencially O(N) space algorithm using bit manipulation: use each bit of number `seen` as the `seen` array in solution 1.\\n\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        seen = 0\\n        for num in nums:\\n            if seen & (1 << num):\\n                return num\\n            seen |= 1 << num\\n```\\n\\n## solution2\\uFF1AO(N) time/O(1) space: `nums` needs to be writable\\nuse positive/negative signal of each item in `nums` to act as the `seen` array in solution 1.\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums[ abs(num) ] < 0:\\n                ans = abs(num)\\n                break\\n            nums[ abs(num) ] = -nums[ abs(num) ]\\n        # restore nums\\n        for i in range(len(nums)):\\n            nums[i] = abs(nums[i])\\n        return ans\\n```\\n\\n\\n## solution 3\\uFF1AO(N^2) time/O(1) space\\uFF1Abrute-force\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        for i, num in enumerate(nums):\\n            for j in range(i+1, N):\\n                if nums[j] == num:\\n                    return num\\n```\\n\\n\\n## solution 4\\uFF1AO(NlogN) time/O(1) space\\uFF1Abinary search\\ntrick\\uFF1Anot binary search the index of the array, but the value of the array !\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        lo, hi = 1, N\\n        while lo < hi:\\n            mi = ( lo + hi ) >> 1\\n            less, equal = 0, 0\\n            for num in nums:\\n                if num < mi:\\n                    less += 1\\n                elif num == mi:\\n                    equal += 1\\n            if equal > 1:\\n                return mi\\n            if less >= mi:\\n                hi = mi - 1\\n            else:\\n                lo = mi + 1\\n        return lo\\n```\\n\\n## solution 5\\uFF1AO(NlogN) time/O(1) space\\uFF1Abit operation\\n\\nquestion\\uFF1Awhich bits of the answer are set as 1 ?\\n\\nFor each bit i, we calculate 2 values:\\n- `a`: In array `nums`, how many items has its i-th bit set as 1?\\n- `b`: For integers from 1 to N, how many items has its i-th bit set as 1?\\n- `a>b` is the necessary and sufficient condition that the i-th bit of the answer is set as 1.\\n\\n\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        nbits = N.bit_length()\\n        ans = 0\\n        for p in range(nbits):   # log2(N)\\n            mask = 1 << p\\n            a = sum( 1 if num & mask else 0 for num in nums )\\n            b = sum( 1 if num & mask else 0 for num in range(1, N+1) )\\n            if a > b:\\n                ans |= mask\\n        return ans\\n```\\n\\n\\n## solution 6\\uFF1AO(N) time/O(1) space\\uFF1AFloyd\\'s Tortoise and Hare\\n\\nreduce the problem to [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/): \\nGiven a linked list, return the node where the cycle begins.\\n\\nhow to construct the linked list\\uFF1A\\n- x -> nums[x] -> nums[nums[x]] -> ...\\n- there is a duplicate item \\u2194 there is cycle in the list\\n- the entrance of the cycle \\u2194 the duplicate item we want\\n\\n![image](https://assets.leetcode.com/users/images/a456c9f4-b49f-4728-90f6-b866b8e79f53_1593096719.1034768.png)\\n\\nPlease refer to the solution article if you find it hard to understand: [solution](https://leetcode.com/articles/find-the-duplicate-number/)\\n\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[nums[0]]\\n        fast = nums[slow]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[ nums[fast] ]\\n        slow = nums[0]\\n        while slow != fast:\\n            slow, fast = nums[slow], nums[fast]\\n        return slow\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        seen = [0] * (N+1)\\n        for num in nums:\\n            if seen[num]:\\n                return num\\n            seen[num] = 1\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        seen = 0\\n        for num in nums:\\n            if seen & (1 << num):\\n                return num\\n            seen |= 1 << num\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums[ abs(num) ] < 0:\\n                ans = abs(num)\\n                break\\n            nums[ abs(num) ] = -nums[ abs(num) ]\\n        # restore nums\\n        for i in range(len(nums)):\\n            nums[i] = abs(nums[i])\\n        return ans\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        for i, num in enumerate(nums):\\n            for j in range(i+1, N):\\n                if nums[j] == num:\\n                    return num\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        lo, hi = 1, N\\n        while lo < hi:\\n            mi = ( lo + hi ) >> 1\\n            less, equal = 0, 0\\n            for num in nums:\\n                if num < mi:\\n                    less += 1\\n                elif num == mi:\\n                    equal += 1\\n            if equal > 1:\\n                return mi\\n            if less >= mi:\\n                hi = mi - 1\\n            else:\\n                lo = mi + 1\\n        return lo\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        N = len(nums) - 1\\n        nbits = N.bit_length()\\n        ans = 0\\n        for p in range(nbits):   # log2(N)\\n            mask = 1 << p\\n            a = sum( 1 if num & mask else 0 for num in nums )\\n            b = sum( 1 if num & mask else 0 for num in range(1, N+1) )\\n            if a > b:\\n                ans |= mask\\n        return ans\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[nums[0]]\\n        fast = nums[slow]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[ nums[fast] ]\\n        slow = nums[0]\\n        while slow != fast:\\n            slow, fast = nums[slow], nums[fast]\\n        return slow\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1202994,
                "title": "c-o-n-solution-with-o-1-space-using-tortois-and-hare-method-with-clear-and-easiest-explanation",
                "content": "**Tortoise and Hare Algo:**\\n1. Take two pointers (basically integers) namely, ```slow``` and ```fast```. Initially both will point to first element\\n2. Increase ```slow``` by 1 and ```fast``` by two.\\n3. Step 2 will be done as follows: ```slow = nums[slow]; fast = nums[nums[fast]]```.\\n4. There will be one time when ```slow``` and ```fast``` will meet. They will meet in a cycle.\\n5. At step 4 we have to stop.\\n6. Now move ```fast``` to initial position i.e. ```fast = nums[0]```.\\n7. Now move both ```slow``` and ```fast``` by one position till both of them meet.\\n8. Step 7 increment will be done as follows: ```slow = nums[slow]; fast = nums[fast]```.\\n9. The node at which both ```slow``` and ```fast``` will meet will be the duplicate number.\\n10. Return ```slow``` or ```fast``` :). \\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        \\n        fast = nums[0];\\n        while(slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```\\n\\nI have tried my best to explain the algorithm. sorry for any mistakes.\\nPlz upvote and support my work.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```slow```\n```fast```\n```slow```\n```fast```\n```slow = nums[slow]; fast = nums[nums[fast]]```\n```slow```\n```fast```\n```fast```\n```fast = nums[0]```\n```slow```\n```fast```\n```slow = nums[slow]; fast = nums[fast]```\n```slow```\n```fast```\n```slow```\n```fast```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        \\n        fast = nums[0];\\n        while(slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72934,
                "title": "share-my-solution-o-n-time-o-1-space-12-ms",
                "content": "    class Solution {\\n    public:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0;\\n\\t\\tint fast = 0;\\n\\t\\tint finder = 0;\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\n\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfinder = nums[finder];\\n\\t\\t\\tif (slow == finder)\\n\\t\\t\\t\\treturn slow;\\n\\t\\t}\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0;\\n\\t\\tint fast = 0;\\n\\t\\tint finder = 0;\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\n\\t\\t\\tif (slow == fast)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 515872,
                "title": "python-js-java-go-c-o-1-aux-space-by-hopping-w-hint",
                "content": "Python O(1) aux space, O(n) time sol. by hopping.\\n\\n---\\n\\n**Hint**:\\n\\n#1. \\nThink of model of **linked list**, and **algorithm of cycle detection**.\\nA common and practical one is [Tortoise and Hare algorithm](https://www.techiedelight.com/detect-cycle-linked-list-floyds-cycle-detection-algorithm/), also known as [Floyd\\'s algorithm](https://en.wikipedia.org/wiki/Cycle_detection).\\n\\n---\\n\\n#2.\\nConvert  this challenge into **cycle detection in linked list**, and locating of **start node of cycle**.\\n\\nEach **array cell** denotes a **node** in linked list.\\nAnd the **value of each array cell** points to the **next node** in linked list.\\n\\n\\nFinally, what we want to know is the **duplicate number**, which also is the **start node of cycle**, and vice versa.\\n\\nWe take the demo input as example, please refer to the diagram as following.\\n\\n---\\n\\n#3.\\n\\nRemeber that [description](https://leetcode.com/problems/find-the-duplicate-number/) asks us **not** to modify the array.\\n(assume the array is read only).\\n\\n---\\n\\n**Illustration**:\\n\\nInput: \\nnums = [1,3,4,2,2]\\n\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582288339.png)\\n\\nDuplicate number is 2.\\nAlso, Node_2 is the start node of cycle in linked list.\\n\\n---\\n\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        \\n        # start hopping from Node_#0\\n        slow, fast = 0, 0\\n\\t\\t\\n\\t\\t# for locating start node of cycle\\n        check = 0\\n        \\n\\t\\t# Step_#1\\n\\t\\t# Cycle detection\\n        # Let slow jumper and fast jumper meet somewhere in the cycle \\n\\t\\t\\n        while True:\\n            \\n\\t\\t\\t# slow jumper hops 1 step, while fast jumper hops two steps forward.\\n            slow = nums[ slow ]\\n            fast = nums[ nums[fast] ]\\n            \\n            if slow == fast:\\n                break\\n        \\n\\t\\t\\n\\t\\t# Step_#2\\n        # Locate the start node of cycle (i.e., the duplicate number)\\n        while True:\\n            \\n            slow = nums[ slow ]\\n            check = nums[ check ]\\n            \\n            if slow == check:\\n                break\\n        \\n        return check\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar findDuplicate = function(nums) {\\n    \\n    // start hopping from Node_#0\\n    let [slow, fast] = [0,0];\\n    \\n    // for locating start node of cycle\\n    let check = 0;\\n    \\n    // Step_#1\\n    // Cycle detection\\n    // Let slow jumper and fast jumper meet somewhere in the cycle\\n    \\n    while( true ){\\n        \\n        // slow jumpper hops 1 step, while fast jumpper hops two steps forward\\n        slow = nums[ slow ];\\n        fast = nums[ nums[ fast ] ];\\n        \\n        if( slow == fast ){\\n            break;\\n        }\\n    }\\n    \\n    // Step_#2\\n    // Locate the start node of cycle (i.e., the duplicate number)\\n    while( true ){\\n        \\n        slow = nums[ slow ];\\n        check = nums[ check ];\\n        \\n        if( slow == check ){\\n            break;\\n        }\\n    }\\n    \\n    return check;\\n    \\n};\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n\\n        \\n        // start hopping from Node_#0\\n        int slow=0, fast=0;\\n            \\n        int check = 0;\\n            \\n        // Step_#1\\n        // Cycle detection\\n        // Implement Tortoise and Hare algorithm\\n        while( true ){\\n            slow = nums[slow];\\n            fast = nums[ nums[fast] ];\\n            \\n            if( slow == fast ){\\n                break;\\n            }\\n        }\\n        \\n        \\n        // Step_#2\\n        // Locate the start node of cycle (i.e., the duplicate number)\\n        while( true ){\\n            slow = nums[slow];\\n            check = nums[check];\\n            \\n            if( slow == check ){\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n            \\n        \\n    }\\n}\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc findDuplicate(nums []int) int {\\n    \\n    // start hoppoing from Node_0\\n    slow, fast := 0, 0\\n    \\n    // for locating start node of cycle\\n    check := 0\\n    \\n    // Step_#1\\n    // Cycle detection\\n    // Implement Tortoise and Hare algorithm\\n    for true {\\n        \\n        slow = nums[ slow ]\\n        fast = nums[ nums[fast] ]\\n        \\n        if slow == fast {\\n            break\\n        }\\n    }\\n    \\n    // Step_#2\\n    // Locate the start node of cycle (i.e., the duplicate number)\\n    for true {\\n        \\n        slow = nums[slow]\\n        check = nums[check]\\n        \\n        if slow == check{\\n            break\\n        }\\n    }\\n    \\n    return check\\n    \\n}\\n```\\n\\n---\\n\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        // start hopping from Node_#0\\n        int slow=0, fast=0;\\n            \\n        int check = 0;\\n            \\n        // Step_#1\\n        // Cycle detection\\n        // Implement Tortoise and Hare algorithm\\n        while( true ){\\n            slow = nums[slow];\\n            fast = nums[ nums[fast] ];\\n            \\n            if( slow == fast ){\\n                break;\\n            }\\n        }\\n        \\n        \\n        // Step_#2\\n        // Locate the start node of cycle (i.e., the duplicate number)\\n        while( true ){\\n            slow = nums[slow];\\n            check = nums[check];\\n            \\n            if( slow == check ){\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\nAbout cycle detection:\\n[Leetcode #141 Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)\\n\\n[Leetcode #142 Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)\\n\\n\\n---\\n\\nReference:\\n\\n[1] [Techie Delight: Cycle detection implementation](https://www.techiedelight.com/detect-cycle-linked-list-floyds-cycle-detection-algorithm/)\\n\\n[2] [Wiki: Cycle detection and Floyd\\'s algorithm](https://en.wikipedia.org/wiki/Cycle_detection)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        \\n        # start hopping from Node_#0\\n        slow, fast = 0, 0\\n\\t\\t\\n\\t\\t# for locating start node of cycle\\n        check = 0\\n        \\n\\t\\t# Step_#1\\n\\t\\t# Cycle detection\\n        # Let slow jumper and fast jumper meet somewhere in the cycle \\n\\t\\t\\n        while True:\\n            \\n\\t\\t\\t# slow jumper hops 1 step, while fast jumper hops two steps forward.\\n            slow = nums[ slow ]\\n            fast = nums[ nums[fast] ]\\n            \\n            if slow == fast:\\n                break\\n        \\n\\t\\t\\n\\t\\t# Step_#2\\n        # Locate the start node of cycle (i.e., the duplicate number)\\n        while True:\\n            \\n            slow = nums[ slow ]\\n            check = nums[ check ]\\n            \\n            if slow == check:\\n                break\\n        \\n        return check\\n```\n```\\nvar findDuplicate = function(nums) {\\n    \\n    // start hopping from Node_#0\\n    let [slow, fast] = [0,0];\\n    \\n    // for locating start node of cycle\\n    let check = 0;\\n    \\n    // Step_#1\\n    // Cycle detection\\n    // Let slow jumper and fast jumper meet somewhere in the cycle\\n    \\n    while( true ){\\n        \\n        // slow jumpper hops 1 step, while fast jumpper hops two steps forward\\n        slow = nums[ slow ];\\n        fast = nums[ nums[ fast ] ];\\n        \\n        if( slow == fast ){\\n            break;\\n        }\\n    }\\n    \\n    // Step_#2\\n    // Locate the start node of cycle (i.e., the duplicate number)\\n    while( true ){\\n        \\n        slow = nums[ slow ];\\n        check = nums[ check ];\\n        \\n        if( slow == check ){\\n            break;\\n        }\\n    }\\n    \\n    return check;\\n    \\n};\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n\\n        \\n        // start hopping from Node_#0\\n        int slow=0, fast=0;\\n            \\n        int check = 0;\\n            \\n        // Step_#1\\n        // Cycle detection\\n        // Implement Tortoise and Hare algorithm\\n        while( true ){\\n            slow = nums[slow];\\n            fast = nums[ nums[fast] ];\\n            \\n            if( slow == fast ){\\n                break;\\n            }\\n        }\\n        \\n        \\n        // Step_#2\\n        // Locate the start node of cycle (i.e., the duplicate number)\\n        while( true ){\\n            slow = nums[slow];\\n            check = nums[check];\\n            \\n            if( slow == check ){\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n            \\n        \\n    }\\n}\\n```\n```\\nfunc findDuplicate(nums []int) int {\\n    \\n    // start hoppoing from Node_0\\n    slow, fast := 0, 0\\n    \\n    // for locating start node of cycle\\n    check := 0\\n    \\n    // Step_#1\\n    // Cycle detection\\n    // Implement Tortoise and Hare algorithm\\n    for true {\\n        \\n        slow = nums[ slow ]\\n        fast = nums[ nums[fast] ]\\n        \\n        if slow == fast {\\n            break\\n        }\\n    }\\n    \\n    // Step_#2\\n    // Locate the start node of cycle (i.e., the duplicate number)\\n    for true {\\n        \\n        slow = nums[slow]\\n        check = nums[check]\\n        \\n        if slow == check{\\n            break\\n        }\\n    }\\n    \\n    return check\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        // start hopping from Node_#0\\n        int slow=0, fast=0;\\n            \\n        int check = 0;\\n            \\n        // Step_#1\\n        // Cycle detection\\n        // Implement Tortoise and Hare algorithm\\n        while( true ){\\n            slow = nums[slow];\\n            fast = nums[ nums[fast] ];\\n            \\n            if( slow == fast ){\\n                break;\\n            }\\n        }\\n        \\n        \\n        // Step_#2\\n        // Locate the start node of cycle (i.e., the duplicate number)\\n        while( true ){\\n            slow = nums[slow];\\n            check = nums[check];\\n            \\n            if( slow == check ){\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062178,
                "title": "two-pointer-solution-with-floyd-s-tortoise-and-hare-algorithm-python-javascript-java-and-c",
                "content": "Before starting my article, why do I have to get multiple downvotes in a minute? Please show your respect to others. Thanks. \\n\\n# Intuition\\nslow pointer moves once and fast pointer move twice.\\n\\n---\\n\\n# Solution Video\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/UUqfQTYmmLs\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,367\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\nAlgorithm Overview:\\n1. Initialize two pointers, `slow` and `fast`, to the first element of the input list `nums`.\\n2. Iterate through the list using the Floyd\\'s Tortoise and Hare algorithm(See below) to find a cycle.\\n3. Once a cycle is found, reset one of the pointers to the beginning of the list and continue iterating until both pointers meet again.\\n\\nDetailed Explanation:\\n1. Initialize `slow` and `fast` pointers to the first element of the input list `nums`.\\n2. Enter a loop to detect a cycle:\\n   a. Update `slow` to the next element using `nums[slow]`.\\n   b. Update `fast` to the next element after `nums[fast]`, effectively moving two steps.\\n   c. Check if `slow` is equal to `fast`. If they are equal, a cycle has been found, and exit the loop.\\n3. After finding the cycle, reset one of the pointers (`slow2`) to the beginning of the list.\\n4. Enter a loop to find the duplicate element:\\n   a. Update `slow` using `nums[slow]`.\\n   b. Update `slow2` using `nums[slow2]`.\\n   c. Continue this process until `slow` is equal to `slow2`, which represents the duplicate element.\\n5. Return the duplicate element found (`slow`).\\n\\n\\n---\\n\\n# Floyd\\'s Tortoise and Hare algorithm\\n\\nFloyd\\'s Tortoise and Hare algorithm, also known as Floyd\\'s Cycle Detection algorithm, is an algorithm used to detect loops (cycles) in data structures like linked lists or arrays. It has been proven to reliably detect cycles under specific circumstances and can be applied to finding duplicate elements.\\n\\nThis algorithm employs two pointers, referred to as the \"tortoise\" and the \"hare,\" to traverse the list.\\n\\n- **Tortoise**: A pointer that advances one step at a time through the list.\\n- **Hare**: A pointer that advances two steps at a time through the list.\\n\\nUsing these pointers, you progress until the hare catches up with the tortoise or a cycle is detected.\\n\\nHere\\'s an overview of the algorithm:\\n\\n1. **Phase 1 (Cycle Detection)**:\\n   Move the tortoise and hare, advancing the hare twice as fast as the tortoise, until the hare catches up with the tortoise or a cycle is detected. If a cycle is detected, reset the tortoise and move the hare back to its position before the reset.\\n\\n2. **Phase 2 (Cycle Start Detection)**:\\n   Move the tortoise and hare one step at a time until they match again. The position where they match again is the starting point of the cycle, corresponding to the duplicate element.\\n\\nLet\\'s explain why this works for the problem at hand:\\n\\n- **Properties of Floyd\\'s Tortoise and Hare Algorithm**:\\n   The algorithm ensures that the tortoise and hare will match again at some position in the list. Exploiting this property, if a cycle exists, the tortoise and hare will certainly match at some position within the cycle.\\n\\n- **Relation between Duplicate Element and Cycle**:\\n   In the presence of a duplicate element, the duplicate corresponds to the starting point of the cycle. Starting from the first element as the tortoise, and moving through the duplicates until reaching a duplicate (cycle start), the hare will join, and the tortoise and hare will match again inside the cycle.\\n\\nTherefore, the Floyd\\'s Tortoise and Hare Algorithm provides an efficient and reliable way to find duplicate elements.\\n\\nWe can apply the same algorithm to `Linked List cycle \\u2161`. I calculate movement distance of the two pointers with easy mathematics knowledge. I hope you can understand it easily and deeply.\\n\\nhttps://youtu.be/eW5pVXX2dow\\n\\n---\\n\\n# How it works\\n\\n```\\nInput: nums = [1,3,4,2,2]\\n```\\n\\nInitialze `slow` and `fast` pointers with `nums[0]` \\n\\n```\\nslow = 1 (nums[0])\\nfast = 1 (nums[0])\\n```\\nStart iteration until the both pointers are the same value.\\n```\\nIteration 1:\\nslow: 3 (nums[1])\\nfast: 2 (nums[nums[1]] = nums[3])\\n\\nIteration 2:\\nslow: 2 (nums[3])\\nfast: 2 (nums[nums[2]] = nums[4])\\n\\nNow the both pointers are equal, so break the loop.\\n```\\n\\nSet `nums[0]` to `slow2` pointer. Start Itetation again until `slow` and `slow2` are equal.\\n\\n```\\nIteration 1:\\nslow: 4 (nums[2])\\nslow2: 3 (nums[1])\\n\\nIteration 2:\\nslow: 2 (nums[4])\\nslow2: 2 (nums[3])\\n\\nNow the both pointers are equal, so break the loop.\\n```\\n```\\nInput: 2\\n```\\n\\n\\n---\\n\\n\\n\\n# Visualization of Floyd\\'s Tortoise and Hare algorithm \\n\\n![IMG_6561.JPG](https://assets.leetcode.com/users/images/e1745f79-6e7e-41f9-9b0e-4e832a67fe41_1695094681.3119178.jpeg)\\n\\n\\nAt first, Let\\'s think with Linked List and try to find starting node of cycle which is `y`.\\n\\nNow, slow and fast pointers are at `node x`\\n\\n`slow` pointer moves once which is at `node y`\\n`fast` pointer moves twice which is at `node z`\\n\\nthey don\\'t meet each other, so let\\'s continue\\n\\n`slow` pointer moves once which is at `node z`\\n`fast` pointer moves twice which is at `node z`\\n\\nnow they meet each other, so let\\'s initialize fast pointer with `node x`\\n\\n`slow` pointer moves once which is at `node y`\\n`fast` pointer moves `once` which is at `node y`\\n\\nThat\\'s why we can find starting node of cycle `node y`.\\n\\nLet\\'s calculate movement distance of slow and fast pointers\\n\\n`slow` pointer moves `A + B`\\n`fast` pointer moves `A + B + C + B`\\n\\nSince slow pointer moves once and fast pointer moves twice, the below formula is vaild.\\n\\n`2(A + B) = A + B + C + B`\\n\\nLet\\'s simplify the formula\\n\\n`2A + 2B = 2B + A + C`\\n\\nDelete `2B` at both sides\\n`2A = A + C`\\n\\nDelete `A` at both sides\\n`A = C`\\n\\nso, it turns out `distance A` and `distance C` is actually the same. When two pointers meet at `node z` then `fast pointer` is initialized with `node x` again and each pointer moves through path `A` or `C` one by one, so that we can find starting node of cycle which is `node y`.\\n\\n#### \\u2B50\\uFE0FLet\\'s apply this idea to this question. Look at the below list in the picture.\\n\\nnow slow and fast pointers are at `1`\\n\\n`slow` pointer moves once which is at `3`\\n`fast` pointer moves twice which is at `2`\\n\\nthey are not the same. Let\\'s continue.\\n\\n`slow` pointer moves once which is at `2`\\n`fast` pointer moves twice which is at `2`\\n\\nthey meet each other at value `2`.\\n\\nLet\\'s initialize `slow2` with `1`. And distance between `2` and `4` cycle is similar to `C` distance of the above list.\\n\\n`slow` pointer moves once which is at `4`\\n`slow2` pointer moves once which is at `3`\\n\\nthey are not the same. Let\\'s continue.\\n\\n`slow` pointer moves once which is at `2`\\n`slow2` pointer moves once which is at `2`\\n\\n\\nFinally, they are the same value.\\n```\\nOutput: 2\\n```\\nWait! For just in case, is there anyone who think why we need the second loop with slow and slow2? Because we found `2` in the first loop.\\n\\nThe second loop with `slow` and `slow2` is necessary to find the starting point of the cycle, which corresponds to the duplicate element in the array. Let me explain why this is needed:\\n\\nIn the first loop (cycle detection phase) using the Floyd\\'s Tortoise and Hare algorithm, we detect that there is a cycle in the array by finding a position where the slow and fast pointers meet. However, this position is not necessarily the starting point of the cycle or the duplicate element. It\\'s just a position within the cycle.\\n\\nThe second loop (cycle start detection phase) helps us find the actual starting point of the cycle, which is the duplicate element we are looking for. The starting point of the cycle is the position where the slow and slow2 pointers meet. This second loop is crucial to pinpoint the exact duplicate element in the array.\\n\\nWithout this second loop, we would have detected the presence of a cycle but would not have determined the duplicate element. The second loop is essential for identifying the duplicate element within the cycle.\\n\\nTry to run the code below with input `[2,5,9,6,9,3,8,9,7,1]`. We should return `9` and the first loop should stop at `7`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n```python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        \\n        slow2 = nums[0]\\n        while slow != slow2:\\n            slow = nums[slow]\\n            slow2 = nums[slow2]\\n\\n        return slow\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n\\n        if (slow === fast) {\\n            break;\\n        }\\n    }\\n\\n    let slow2 = nums[0];\\n\\n    while (slow !== slow2) {\\n        slow = nums[slow];\\n        slow2 = nums[slow2];\\n    }\\n\\n    return slow;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        int slow2 = nums[0];\\n\\n        while (slow != slow2) {\\n            slow = nums[slow];\\n            slow2 = nums[slow2];\\n        }\\n\\n        return slow;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        int slow2 = nums[0];\\n\\n        while (slow != slow2) {\\n            slow = nums[slow];\\n            slow2 = nums[slow2];\\n        }\\n\\n        return slow;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\nThank you for reading. \\u2B50\\uFE0FIf you like the article, don\\'t forget to upvote it and subscribe to my youtube channel!\\n\\nMy next post for daily coding challenge on Sep 20, 2023\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066549/how-we-think-about-a-solution-on-time-o1-space-python-javascript-java-c/\\n\\nHave a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: nums = [1,3,4,2,2]\\n```\n```\\nslow = 1 (nums[0])\\nfast = 1 (nums[0])\\n```\n```\\nIteration 1:\\nslow: 3 (nums[1])\\nfast: 2 (nums[nums[1]] = nums[3])\\n\\nIteration 2:\\nslow: 2 (nums[3])\\nfast: 2 (nums[nums[2]] = nums[4])\\n\\nNow the both pointers are equal, so break the loop.\\n```\n```\\nIteration 1:\\nslow: 4 (nums[2])\\nslow2: 3 (nums[1])\\n\\nIteration 2:\\nslow: 2 (nums[4])\\nslow2: 2 (nums[3])\\n\\nNow the both pointers are equal, so break the loop.\\n```\n```\\nInput: 2\\n```\n```\\nOutput: 2\\n```\n```python []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        \\n        slow2 = nums[0]\\n        while slow != slow2:\\n            slow = nums[slow]\\n            slow2 = nums[slow2]\\n\\n        return slow\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n\\n    while (true) {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n\\n        if (slow === fast) {\\n            break;\\n        }\\n    }\\n\\n    let slow2 = nums[0];\\n\\n    while (slow !== slow2) {\\n        slow = nums[slow];\\n        slow2 = nums[slow2];\\n    }\\n\\n    return slow;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        int slow2 = nums[0];\\n\\n        while (slow != slow2) {\\n            slow = nums[slow];\\n            slow2 = nums[slow2];\\n        }\\n\\n        return slow;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        int slow2 = nums[0];\\n\\n        while (slow != slow2) {\\n            slow = nums[slow];\\n            slow2 = nums[slow2];\\n        }\\n\\n        return slow;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72852,
                "title": "python-same-solution-as-142-linked-list-cycle-ii",
                "content": "In this problem, nums[a] = b can be seen as a.next = b, the the problem is exactly the same as Linked List Cycle II which finds the node that cycle begins.\\n\\n    def findDuplicate(self, nums):\\n        slow = fast = finder = 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                while finder != slow:\\n                    finder = nums[finder]\\n                    slow = nums[slow]\\n                return finder",
                "solutionTags": [
                    "Python"
                ],
                "code": "In this problem, nums[a] = b can be seen as a.next = b, the the problem is exactly the same as Linked List Cycle II which finds the node that cycle begins.\\n\\n    def findDuplicate(self, nums):\\n        slow = fast = finder = 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                while finder != slow:\\n                    finder = nums[finder]\\n                    slow = nums[slow]\\n                return finder",
                "codeTag": "Python3"
            },
            {
                "id": 72906,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static int findDuplicate(int[] nums) {\\n\\t\\tif (nums.length == 0 || nums == null)\\n\\t\\t\\treturn 0;\\n\\t\\tint low = 1, high = nums.length - 1, mid;\\n\\t\\twhile (low < high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tif (nums[i] <= mid)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (count > mid)\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static int findDuplicate(int[] nums) {\\n\\t\\tif (nums.length == 0 || nums == null)\\n\\t\\t\\treturn 0;\\n\\t\\tint low = 1, high = nums.length - 1, mid;\\n\\t\\twhile (low < high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tif (nums[i] <= mid)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (count > mid)\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 4062235,
                "title": "3-approach-transitioning-from-a-brute-force-to-optimized-ones",
                "content": "# Problem Understanding\\nGiven an array of N + 1 integers where each element is between 1 and N, the task is to find the duplicate number efficiently.\\n\\n# Approach\\n\\n---\\n\\n**I have explored three different approaches to solve this problem, and I am gradually transitioning from a brute-force approach to more optimized ones.**\\n\\n---\\n# Solution 1: Using Sorting\\n**Approach:**\\n\\n1. **Sort** the given array in ascending order.\\n2. **Iterate** through the sorted array.\\n3. **Check if arr[i] is equal to arr[i+1].** If true, arr[i] is the duplicate number.\\n\\n**Intuition:**\\nThe **idea** behind this approach is that **if there is a duplicate number in the array, it will be adjacent to another identical number** after sorting. Sorting the array allows us to find duplicates efficiently by comparing adjacent elements.\\n\\n# Solution 2: Using Frequency Array\\n\\n**Approach:**\\n\\n1. **Create a frequency array** of size N+1 and initialize it to all zeros.\\n2. **Traverse** through the given array.\\n3. **For each element arr[i], increment** the corresponding index in the frequency array by 1.\\n4. **If you encounter an element with a frequency greater than 1, that element is the duplicate number.**\\n\\n**Intuition:**\\n**This approach maintains a count of how many times each element appears in the array using a separate data structure** (the frequency array). When we encounter an element with a frequency greater than 1, we have found the duplicate element.\\n\\n\\n# Solution 3: Linked List Cycle method\\n**Step 1 (Phase 1 - Detect the Cycle):**\\n<!-- Describe your approach to solving the problem. -->\\n- **Initialize two pointers, slow and fast**, both initially pointing to the first element in the array.\\n- **Use a loop to move slow one step at a time and fast two steps at a time.**\\n- **Continue** this loop until slow and fast meet inside the cycle (i.e., slow == fast).\\n\\n**Step 2 (Phase 2 - Find the Entrance to the Cycle):**\\n- **After detecting the cycle,** reset one of the pointers (in this case, we reset fast) to the beginning of the array (i.e., fast = nums[0]).\\n- **Now, move both slow and fast one step at a time until they meet again.**\\n- The point **where slow and fast meet** for the second time is the entrance to the cycle.\\n\\n**Step 3 (Return the Duplicate Number):**\\n\\n- Return either slow or fast because they both point to the entrance of the cycle, which corresponds to the duplicate number in the array.\\n\\n\\n# Let\\'s Dry run-\\n**Step 1**: Consider the following array where each element\\'s value indicates the next index to jump to.\\n\\n```\\n[3,1,3,4,2]\\n```\\n\\n**Step 2:** Initialize two pointers, slow and fast, both initially at the first element (index 0).\\n```\\nslow\\n\\u2193\\n[3, 1, 3, 4, 2]\\n\\u2191\\nfast\\n```\\n**Step 3:** Move the pointers. slow moves one step at a time, and fast moves two steps at a time.\\n```\\n   slow\\n    \\u2193\\n[3, 1, 3, 4, 2]\\n       \\u2191\\n      fast\\n```\\n**Step 4**: Continue moving the pointers.\\n```\\n      slow\\n       \\u2193\\n[3, 1, 3, 4, 2]\\n             \\u2191\\n            fast\\n```\\n\\n**Step 5:** Continue moving the pointers one step at a time until they meet again. This meeting point will be the entrance to the cycle.\\n```\\n      slow\\n       \\u2193\\n[3, 1, 3, 4, 2]\\n       \\u2191\\n      fast\\n```\\n**Step 6:** Now Point out to slow at Start, then iterate it one step again. Until it does not meet up with fast. When they meet that\\'s our duplicate Number.\\n\\n---\\n# Time Complexity\\n- Sorting-O(nlogn)\\n- Map-O(n)\\n- Linked List cycle-O(n)\\n# Space Complexity\\n- Sorting-O(1)\\n- Map-O(n)\\n- Linked List cycle-O(1)\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n# Code Using Sorting Method\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        // Iterate through the sorted array\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check if adjacent elements are equal\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i]; // Found the duplicate number\\n            }\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        Arrays.sort(nums); // Sort the array in ascending order\\n\\n        // Iterate through the sorted array\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check if adjacent elements are equal\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i]; // Found the duplicate number\\n            }\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        nums.sort()  # Sort the array in ascending order\\n\\n        # Iterate through the sorted array\\n        for i in range(1, len(nums)):\\n            # Check if adjacent elements are equal\\n            if nums[i] == nums[i - 1]:\\n                return nums[i]  # Found the duplicate number\\n\\n        return -1  # No duplicate found (shouldn\\'t happen for this problem)\\n\\n```\\n\\n# Code Using Map Method\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> numCount; // Map to store the count of each number\\n\\n    // Iterate through the array and count the occurrences of each number\\n        for (int num : nums) {\\n            if (numCount.find(num) != numCount.end()) {\\n                return num; // Found the duplicate number\\n            }\\n            numCount[num] = 1;\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)  \\n    }\\n};\\n```\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        Map<Integer, Integer> numCount = new HashMap<>(); // Map to store the count of each number\\n\\n        // Iterate through the array and count the occurrences of each number\\n        for (int num : nums) {\\n            if (numCount.containsKey(num)) {\\n                return num; // Found the duplicate number\\n            }\\n            numCount.put(num, 1);\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        numCount = {}  # Dictionary to store the count of each number\\n\\n        # Iterate through the array and count the occurrences of each number\\n        for num in nums:\\n            if num in numCount:\\n                return num  # Found the duplicate number\\n            numCount[num] = 1\\n\\n        return -1  # No duplicate found (shouldn\\'t happen for this problem)\\n\\n```\\n\\n# Code Using Linked-List cycle Method\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        // Phase 1: Detect the cycle\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        // Phase 2: Find the entrance to the cycle\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow; // or fast, as they both point to the entrance of the cycle\\n    }\\n};\\n\\n```\\n```Java []\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        // Phase 1: Detect the cycle\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        // Phase 2: Find the entrance to the cycle\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow; // or fast, as they both point to the entrance of the cycle\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        slow = nums[0]\\n        fast = nums[0]\\n\\n        # Phase 1: Detect the cycle\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n\\n        # Phase 2: Find the entrance to the cycle\\n        slow = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n\\n        return slow  # or fast, as they both point to the entrance of the cycle\\n\\n```\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n![upvotememe.png](https://assets.leetcode.com/users/images/b982d6fb-b6ec-4a05-bbce-d40fc844341a_1695088177.9465516.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\n[3,1,3,4,2]\\n```\n```\\nslow\\n\\u2193\\n[3, 1, 3, 4, 2]\\n\\u2191\\nfast\\n```\n```\\n   slow\\n    \\u2193\\n[3, 1, 3, 4, 2]\\n       \\u2191\\n      fast\\n```\n```\\n      slow\\n       \\u2193\\n[3, 1, 3, 4, 2]\\n             \\u2191\\n            fast\\n```\n```\\n      slow\\n       \\u2193\\n[3, 1, 3, 4, 2]\\n       \\u2191\\n      fast\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        // Iterate through the sorted array\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check if adjacent elements are equal\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i]; // Found the duplicate number\\n            }\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        Arrays.sort(nums); // Sort the array in ascending order\\n\\n        // Iterate through the sorted array\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check if adjacent elements are equal\\n            if (nums[i] == nums[i - 1]) {\\n                return nums[i]; // Found the duplicate number\\n            }\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        nums.sort()  # Sort the array in ascending order\\n\\n        # Iterate through the sorted array\\n        for i in range(1, len(nums)):\\n            # Check if adjacent elements are equal\\n            if nums[i] == nums[i - 1]:\\n                return nums[i]  # Found the duplicate number\\n\\n        return -1  # No duplicate found (shouldn\\'t happen for this problem)\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> numCount; // Map to store the count of each number\\n\\n    // Iterate through the array and count the occurrences of each number\\n        for (int num : nums) {\\n            if (numCount.find(num) != numCount.end()) {\\n                return num; // Found the duplicate number\\n            }\\n            numCount[num] = 1;\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)  \\n    }\\n};\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        Map<Integer, Integer> numCount = new HashMap<>(); // Map to store the count of each number\\n\\n        // Iterate through the array and count the occurrences of each number\\n        for (int num : nums) {\\n            if (numCount.containsKey(num)) {\\n                return num; // Found the duplicate number\\n            }\\n            numCount.put(num, 1);\\n        }\\n\\n        return -1; // No duplicate found (shouldn\\'t happen for this problem)\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        numCount = {}  # Dictionary to store the count of each number\\n\\n        # Iterate through the array and count the occurrences of each number\\n        for num in nums:\\n            if num in numCount:\\n                return num  # Found the duplicate number\\n            numCount[num] = 1\\n\\n        return -1  # No duplicate found (shouldn\\'t happen for this problem)\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        // Phase 1: Detect the cycle\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        // Phase 2: Find the entrance to the cycle\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow; // or fast, as they both point to the entrance of the cycle\\n    }\\n};\\n\\n```\n```Java []\\npublic class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        // Phase 1: Detect the cycle\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n\\n        // Phase 2: Find the entrance to the cycle\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow; // or fast, as they both point to the entrance of the cycle\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        slow = nums[0]\\n        fast = nums[0]\\n\\n        # Phase 1: Detect the cycle\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n\\n        # Phase 2: Find the entrance to the cycle\\n        slow = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n\\n        return slow  # or fast, as they both point to the entrance of the cycle\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315924,
                "title": "c-o-nlog-n-no-array-modification-o-1-space-detailed-explanation",
                "content": "# steps:-\\n![Screenshot (888).png](https://assets.leetcode.com/users/images/56fa88d4-9bf5-487c-b15a-1103712d1d52_1679224944.9459226.png)\\n![Screenshot (889).png](https://assets.leetcode.com/users/images/2cdaf20f-6921-4719-a9ac-535f9a5a6288_1679224958.6253443.png)\\n\\n# UPVOTE  please upvote if you like my post . it motivates me lot .\\nLets Connect On Linkedin https://www.linkedin.com/in/sonal-prasad-sahu-78973a229/\\n# Code\\n```\\nclass Solution {\\npublic:  \\n     int ok(vector<int>& nums,int mid){ /*function that checks how many number in given array \\n      nums is less or equal to the mid .*/\\n         int  count=0;\\n            for(auto value:nums){\\n               if(value<=mid){\\n                   count++;\\n             }\\n            }\\n            return count ;\\n      }\\n   int findDuplicate(vector<int>& nums) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        int mid=0;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n    \\n            if(ok(nums,mid)>mid){ /* checking duplicates if it is gretaer for passed mid that means duplicates\\n        is on left side so reduce search space for left subarray only */\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n\\n    }\\n};\\n```\\n\\n![begging.jpg](https://assets.leetcode.com/users/images/7de8f5f2-aa0d-48ab-af1d-a2573f552013_1679225176.4093425.jpeg)\\n# Time Complexity :- O(N log(N))\\n# Space Complexity :- O(1).\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n     int ok(vector<int>& nums,int mid){ /*function that checks how many number in given array \\n      nums is less or equal to the mid .*/\\n         int  count=0;\\n            for(auto value:nums){\\n               if(value<=mid){\\n                   count++;\\n             }\\n            }\\n            return count ;\\n      }\\n   int findDuplicate(vector<int>& nums) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        int mid=0;\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n    \\n            if(ok(nums,mid)>mid){ /* checking duplicates if it is gretaer for passed mid that means duplicates\\n        is on left side so reduce search space for left subarray only */\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134813,
                "title": "javascript-soution-beats-99-35-runtime-56ms-using-linked-list",
                "content": "I was inspired by other programmers\\' idea. So after I figured it out, I want to mark down my understanding.\\n\\nHere is my code with some examples to help you understand linked list and loop.\\nOur goal is to find out the entry of the loop, as showed in the examples.\\n```\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0], fast = nums[nums[0]];\\n\\t\\t\\n    //here fast moves two steps at a time\\n    while(slow!==fast){\\n    \\tslow = nums[slow];\\n    \\tfast = nums[nums[fast]];\\n    }\\n    fast=0;\\n\\t\\t\\n    //here fast move one step at a time\\n    while(slow!==fast){\\n    \\tslow = nums[slow];\\n    \\tfast = nums[fast];\\n    }\\n    return slow;\\n};\\n\\n// Examples:\\n// [1,4,3,5,2,2]\\n// 0->1->4->2->3->5->2->3->5->...\\n//          ^\\n\\n// [1,3,2,1]\\n// 0->1->3->1->3->...\\n//    ^\\n\\n// [3,4,6,5,1,1,2]\\n// 0->3->5->1->4->1->4->...\\n//          ^\\n```\\nHere is my understanding about finding the entry using linked list:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lmiaoj/image_1527687950.png)\\n\\nAs we can see from the examples above, the linked list will eventually run into a loop.\\nWhen slow and fast first meet at m1, let\\'s assume that the fast had passed **fLen**, and the slow had passed **sLen**, and the length of the loop is **LoopLen**,  then \\n* **fLen - sLen = LoopLen * n** (n can be any integer >= 1)\\n* **fLen = sLen * 2**\\n\\nso\\n* **sLen = LoopLen * n**\\n\\nand because \\n* **sLen = len + curve1 + LoopLen * n1** (n1 can be any integer, including 0)\\n\\nso\\n* **len + curve1 = LoopLen * n2** (n2 can be any integer >= 1)\\n\\nand because\\n* **curve1 + curve2 = LoopLen**\\n\\nso, in the second loop, fast will re-begin at the begin point and moves one step at a time.\\nafter\\n* fast moves **len**, and\\n* slow moves **curve2 + LoopLen * n3** (n3 can be any integer, including 0)\\n\\nfast and slow will both reach the **entry point**.",
                "solutionTags": [],
                "code": "```\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0], fast = nums[nums[0]];\\n\\t\\t\\n    //here fast moves two steps at a time\\n    while(slow!==fast){\\n    \\tslow = nums[slow];\\n    \\tfast = nums[nums[fast]];\\n    }\\n    fast=0;\\n\\t\\t\\n    //here fast move one step at a time\\n    while(slow!==fast){\\n    \\tslow = nums[slow];\\n    \\tfast = nums[fast];\\n    }\\n    return slow;\\n};\\n\\n// Examples:\\n// [1,4,3,5,2,2]\\n// 0->1->4->2->3->5->2->3->5->...\\n//          ^\\n\\n// [1,3,2,1]\\n// 0->1->3->1->3->...\\n//    ^\\n\\n// [3,4,6,5,1,1,2]\\n// 0->3->5->1->4->1->4->...\\n//          ^\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650942,
                "title": "proof-of-floyd-s-cycle-detection-algorithm-find-the-duplicate-number",
                "content": "At meet point, suppose `slow` has run `a` cyles and `fast` has run `b` cycles, then the following equation holds:\\n```\\n2(x + a(y+z) + y) = x + b(y+z) + y\\n````\\nThis equation can be transformed to\\n```\\nx = (b-2a-1)(y+z) + z\\n```\\nThis means `ans` and `slow` will meet at the start of the cycle when `ans` first gets there. Because at that time, `slow` would have run `b-2a-1` cycles plus `z`, which means it must be at the start of the cycle.\\n\\n![image](https://assets.leetcode.com/users/r0bertz/image_1590388484.png)\\n\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = fast = ans = 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        while ans != slow:\\n            ans = nums[ans]\\n            slow = nums[slow]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n2(x + a(y+z) + y) = x + b(y+z) + y\\n```\n```\\nx = (b-2a-1)(y+z) + z\\n```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = fast = ans = 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        while ans != slow:\\n            ans = nums[ans]\\n            slow = nums[slow]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676192,
                "title": "5-approach-s-to-find-the-duplicate-number-using-java",
                "content": "#### 1. Brute Force\\n```\\nclass Solution {\\n    for(int i = 0; i< nums.length; i++){\\n        for(int j = i + 1; j < nums.length; j++){\\n            if(nums[i] == nums[j]){\\n                return nums[i];\\n            }\\n        }\\n    }\\n    return nums.length;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n#### 2. HashSet\\n```\\nclass Solution {\\n    Set<Integer> set = new HashSet<>();\\n        for(int num:nums){\\n            if(!set.add(num)){\\n                return num;\\n            }\\n        }\\n    return nums.length;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n#### 3. Sorting\\n```\\nclass Solution {\\n    Arrays.sort(nums);\\n    for(int i = 0; i < nums.length - 1; i++){\\n        if(nums[i] == nums[i + 1]){\\n            return nums[i];\\n        }\\n    }\\n    return nums.length;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n$$O(nlog n)$$\\n\\n- Space complexity:\\n$$O(log n)$$\\n\\n#### 4. Binary Search\\n```\\nclass Solution {\\n   int low = 0,high = nums.length - 1,cnt;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            cnt = 0;\\n            for(int num:nums){\\n                if(num <= mid){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt <= mid){\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n    return low; \\n}\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n#### 5. Counting\\n```\\nclass Solution {\\n    int count[] = new int [nums.length];\\n    for(int i = 0; i<nums.length; i++){\\n        count[nums[i]]++;\\n        if(count[nums[i]] > 1){\\n            return nums[i];\\n        } \\n    }\\n    return nums.length;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sort",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    for(int i = 0; i< nums.length; i++){\\n        for(int j = i + 1; j < nums.length; j++){\\n            if(nums[i] == nums[j]){\\n                return nums[i];\\n            }\\n        }\\n    }\\n    return nums.length;\\n}\\n```\n```\\nclass Solution {\\n    Set<Integer> set = new HashSet<>();\\n        for(int num:nums){\\n            if(!set.add(num)){\\n                return num;\\n            }\\n        }\\n    return nums.length;\\n}\\n```\n```\\nclass Solution {\\n    Arrays.sort(nums);\\n    for(int i = 0; i < nums.length - 1; i++){\\n        if(nums[i] == nums[i + 1]){\\n            return nums[i];\\n        }\\n    }\\n    return nums.length;\\n}\\n```\n```\\nclass Solution {\\n   int low = 0,high = nums.length - 1,cnt;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            cnt = 0;\\n            for(int num:nums){\\n                if(num <= mid){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt <= mid){\\n                low = mid + 1;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n    return low; \\n}\\n```\n```\\nclass Solution {\\n    int count[] = new int [nums.length];\\n    for(int i = 0; i<nums.length; i++){\\n        count[nums[i]]++;\\n        if(count[nums[i]] > 1){\\n            return nums[i];\\n        } \\n    }\\n    return nums.length;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893407,
                "title": "time-o-n-space-o-1-c",
                "content": "***Upvote to keep me motivated*** \\u270C\\n\\n**Intution :-** \\nThe element has already been marked as negative which is a repeating number.\\n\\n![image](https://assets.leetcode.com/users/images/47d0f242-3e39-417d-9cb8-4d24bf0e034c_1648531112.285137.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            int index = abs(nums[i]) - 1;\\n            \\n            if(nums[index] < 0){\\n                return abs(nums[i]);\\n            }\\n            nums[index] = - nums[index];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            int index = abs(nums[i]) - 1;\\n            \\n            if(nums[index] < 0){\\n                return abs(nums[i]);\\n            }\\n            nums[index] = - nums[index];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73015,
                "title": "ac-c-code-with-o-n-time-and-o-1-space",
                "content": "Please read the link to understand it:http://keithschwarz.com/interesting/code/?dir=find-duplicate\\n\\n    class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int l=nums.size();\\n            int slow =l-1;int fast = l-1;\\n            while(1){\\n                slow=nums[slow]-1;\\n                fast=nums[nums[fast]-1]-1;\\n                if(slow == fast){\\n                    break;\\n                }\\n            }\\n            fast = l-1;\\n            while(1){\\n                slow=nums[slow]-1;\\n                fast=nums[fast]-1;\\n                if(slow==fast)return slow+1;\\n            }\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int l=nums.size();\\n            int slow =l-1;int fast = l-1;\\n            while(1){\\n                slow=nums[slow]-1;\\n                fast=nums[nums[fast]-1]-1;\\n                if(slow == fast){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1894339,
                "title": "c-7-different-solutions-to-this-problem-with-relaxed-constraints",
                "content": "I ask this problem in interviews as it has so many approaches (but with the repeated number appearing exacctly twice). I usually give 5 to 15 minutes to the candidate to solve this problem, trying to get the candidate to a O(n) time O(1) space not modifying the input solution. \\n\\nNOTE: I removed the sum based solution as it works when duplicate number appears only twice, which is not exactly the constraints of this problem.\\n\\n**Summary solutions that I found:**\\n- With extra space - O(n) time, O(n) space\\n\\t- using an additional vector \\n\\t- using an unordered_set \\n- Without extra space, modifying the input - O(1) space\\n\\t- marking visted value - O(n) time\\n\\t- sorting input array - O(n log(n)) time\\n\\t- index sort - O(n) time\\n- Without extra space, non modifying the input - O(1) space\\n    - brute force - O(n^2)\\n\\t- cycle detection - O(n) time\\n\\n\\n**Solution 1 : Using an additional vector - O(n) time, O(n) space**\\n\\nThat is generally the approach that comes to mind immediately, it does not fully take advantage of the problem.\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tvector<int> seen(nums.size()+1);\\n\\tfor(auto n: nums){\\n\\t\\tif(seen[n]) \\n\\t\\t\\treturn n;\\n\\t\\tseen[n] = true;\\n\\t}\\n\\treturn 0; // return whatever here\\n}\\n```\\n\\n**Note 1:** Some could suggest to use `vector<bool>` to consume less memory. True, but to do that, `vector<bool>` is a specialized implementation of `vector` that comes with weird issues (returned element is a proxy, not a reference to a bool) and is quite slow.\\n\\n**Note 2:** Some extra effort could be made on this solution to have a single return statement. \\n\\n\\n**Solution 2 : Using an unordered_set - O(n) time, O(n) space**\\n\\nMore or less the same as solution 1.\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tunordered_set<int> seen(nums.size()+1);\\n\\tfor(auto n: nums){\\n\\t\\tif(seen.count(n)) \\n\\t\\t\\treturn n;\\n\\t\\tseen.insert(n);\\n\\t}\\n\\treturn 0; // return whatever here\\n}\\n```\\n\\n\\n**Solution 3: Marking visited value within the array - O(n) time, O(1) space**\\n\\nThis approach is similar to solution 1, but a bit more clever: the idea here is to encode the fact that a value has been seen within the input array. \\nIt relies on the observation that the values within the array fit the indexing space, all values are in between `[1..n]` and the array size is `n+1`. \\nA simple way to encode this information is to flip the sign of `nums[n]` to indicate that value `n` has been observed. It works beccause it\\'s guaranteed that there is no negative value in the input.\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tfor(auto n: nums) {\\n\\t\\tint idx = abs(n);\\n\\t\\tif(nums[idx] < 0)\\n\\t\\t\\treturn idx;\\n\\t\\tnums[idx] = -nums[idx];\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\\n**Solution 4: Sorting the array then finding adjacent duplicate - O(n log(n)) time, O(1) space**\\n\\nThis is very natural approach to solve the problem, however it has some complexity penalty and it does not take advantage of the constraints of the problem. It\\'s implementation in C++  is quite elegant in just 2 lines (when using STL):\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n\\treturn *adjacent_find(nums.cbegin(), nums.cend());\\n}\\n```\\n\\n\\n**Solution 5: Index sort - O(n) time, O(1) space**\\n\\nGenerally after 5 minutes looking at the problem, we notice that once sorted, each value `v` is stored at index `v-1` (i.e. 1 is at index 0, 5 at index 4, etc..). Therefore we can sort the input array in linear time:\\n- The algorithm starts at index `0` and finishes at index `n`\\n- if the value is already sorted (`nums[i] == i+1`), then skip to the next value\\n- else, check if there is alreay the same value at the correct index (`nums[i] == nums[nums[i]-1]`):\\n\\t- if there is one, that\\'s our duplicate\\n\\t- else exchange the value with the one at it\\'s place\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tfor(int i = 0; i < nums.size();) {\\n\\t\\tif(nums[i] == i+1)\\n\\t\\t\\t++i;\\n\\t\\telse if(int &n = nums[i]; nums[n-1] == n)\\n\\t\\t\\treturn n;\\n\\t\\telse\\n\\t\\t\\tswap(n, nums[n-1]);\\n\\t}\\n\\treturn 0;\\n}\\n```\\n\\n\\n**Solutions not modifying the input and without extra space**\\n\\n\\n**Solution 6: Brute force - O(n^2) time, O(1) space - TLE**\\n\\nSurprisingly (or not), this is not the approach that comes first to the mind to candidates (they suggest it when I ask to solve the problem in O(1) space and without modifying the input array). However I consider it fine as a starter solution during an interview.\\n\\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tfor(int i=0; i < nums.size()-1; ++i)\\n\\t\\tfor(int j=i+1; j < nums.size(); ++j)\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t\\treturn nums[i];\\n\\treturn 0;\\n}\\n```\\n\\n**Solution 7: Cycle detection using slow fast pointers - O(n) time, O(1) space**\\n\\nThe idea here is to apply the slow fast pointer approach to find a cycle in a linked list.\\nSince the values space `[1..n]` fits the index space `[0..n]`, the input array can represent an underlying linked list where the next element of `nums[i]` is `nums[nums[i]]`.\\nThe existence of a duplicate in the array will therefore create a cycle in the underlying linked list as 2 nodes of the linked list will point to the same next element.\\nSo now, the problem is the same as [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/), please refer to [this solution](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701055/JavaC%2B%2BPython-best-explanation-ever-happen\\'s-for-this-problem) for the explanation of the slow fast pointer approach to solve this problem.\\n\\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tint slow = nums[0], fast = nums[slow];\\n\\twhile(slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[nums[fast]];\\n\\t}\\n\\tslow = 0;\\n\\twhile(slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[fast];\\n\\t}\\n\\treturn fast;\\n}\\n```\\n\\nThis can be code golfed in 4 unreadable lines:\\n\\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tint n1, n2;\\n\\tfor(n1=nums[0], n2=nums[n1]; n1!=n2; n1=nums[n1], n2=nums[nums[n2]]);\\n\\tfor(n1=0; n1 != n2; n1=nums[n1], n2=nums[n2]);\\n\\treturn n2;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tvector<int> seen(nums.size()+1);\\n\\tfor(auto n: nums){\\n\\t\\tif(seen[n]) \\n\\t\\t\\treturn n;\\n\\t\\tseen[n] = true;\\n\\t}\\n\\treturn 0; // return whatever here\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tunordered_set<int> seen(nums.size()+1);\\n\\tfor(auto n: nums){\\n\\t\\tif(seen.count(n)) \\n\\t\\t\\treturn n;\\n\\t\\tseen.insert(n);\\n\\t}\\n\\treturn 0; // return whatever here\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tfor(auto n: nums) {\\n\\t\\tint idx = abs(n);\\n\\t\\tif(nums[idx] < 0)\\n\\t\\t\\treturn idx;\\n\\t\\tnums[idx] = -nums[idx];\\n\\t}\\n\\treturn 0;\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n\\treturn *adjacent_find(nums.cbegin(), nums.cend());\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tfor(int i = 0; i < nums.size();) {\\n\\t\\tif(nums[i] == i+1)\\n\\t\\t\\t++i;\\n\\t\\telse if(int &n = nums[i]; nums[n-1] == n)\\n\\t\\t\\treturn n;\\n\\t\\telse\\n\\t\\t\\tswap(n, nums[n-1]);\\n\\t}\\n\\treturn 0;\\n}\\n```\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tfor(int i=0; i < nums.size()-1; ++i)\\n\\t\\tfor(int j=i+1; j < nums.size(); ++j)\\n\\t\\t\\tif(nums[i] == nums[j])\\n\\t\\t\\t\\treturn nums[i];\\n\\treturn 0;\\n}\\n```\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tint slow = nums[0], fast = nums[slow];\\n\\twhile(slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[nums[fast]];\\n\\t}\\n\\tslow = 0;\\n\\twhile(slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[fast];\\n\\t}\\n\\treturn fast;\\n}\\n```\n```cpp\\nint findDuplicate(const vector<int>& nums) {\\n\\tint n1, n2;\\n\\tfor(n1=nums[0], n2=nums[n1]; n1!=n2; n1=nums[n1], n2=nums[nums[n2]]);\\n\\tfor(n1=0; n1 != n2; n1=nums[n1], n2=nums[n2]);\\n\\treturn n2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73012,
                "title": "share-my-c-solutions-easy-to-understand",
                "content": "(1)Binary Search \\n\\n    class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int n = nums.size(), i = 0, counter = 0;\\n            int left = 1, right = n - 1, mid = 0;\\n            \\n            while (left < right)\\n            {\\n                mid = left + (right - left) / 2;\\n                \\n                counter = 0;\\n                for (i = 0; i < n; ++i)\\n                {\\n                    if (nums[i] <= mid)\\n                        ++counter;\\n                }\\n                \\n                if (counter > mid)\\n                    right = mid;\\n                else \\n                    left = mid + 1;\\n            }\\n            \\n            return left;\\n        }\\n    };\\n\\n(2)http://keithschwarz.com/interesting/code/find-duplicate/FindDuplicate.python.html\\n\\n    class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int slow = 0, fast = 0, finder = 0;\\n            \\n            while (1)\\n            {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n                \\n                if (slow == fast)\\n                    break;\\n            }\\n            \\n            \\n            while (1)\\n            {\\n                finder = nums[finder];\\n                slow = nums[slow];\\n                \\n                if (finder == slow)\\n                    return finder;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int n = nums.size(), i = 0, counter = 0;\\n            int left = 1, right = n - 1, mid = 0;\\n            \\n            while (left < right)\\n            {\\n                mid = left + (right - left) / 2;\\n                \\n                counter = 0;\\n                for (i = 0; i < n; ++i)\\n                {\\n                    if (nums[i] <= mid)\\n                        ++counter;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 73026,
                "title": "o-n-without-extra-space-without-modifying-the-array",
                "content": "    //Basically transfer the problem to finding the beginning of cycle in linked list.     \\n    public int findDuplicate(int[] nums) {\\n                if(nums.length ==0 )\\n                    return 0;\\n                int slow=0, fast=0;\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n                while(slow != fast){\\n                    if(slow == nums[slow])\\n                        return slow;\\n                    slow = nums[slow];\\n                    fast = nums[nums[fast]];\\n                }\\n                fast = 0;\\n                while(slow != fast){\\n                    if(slow == nums[slow])\\n                        return slow;\\n                    slow = nums[slow];\\n                    fast = nums[fast];\\n                }\\n                return slow;\\n            }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "    //Basically transfer the problem to finding the beginning of cycle in linked list.     \\n    public int findDuplicate(int[] nums) {\\n                if(nums.length ==0 )\\n                    return 0;\\n                int slow=0, fast=0;\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n                while(slow != fast){\\n                    if(slow == nums[slow])\\n                        return slow;\\n                    slow = nums[slow];\\n                    fast = nums[nums[fast]];\\n                }\\n                fast = 0;\\n                while(slow != fast){\\n                    if(slow == nums[slow])\\n                        return slow;\\n                    slow = nums[slow];\\n                    fast = nums[fast];\\n                }\\n                return slow;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 3236488,
                "title": "287-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem can be treated as a linked list cycle detection problem.\\nSince there is only one duplicate number, the array can be treated as a linked list,\\nwhere each number points to the index indicated by the value.\\nFor example, if nums[0] = 2, it means that there is a pointer from index 0 to index 2.\\nWe can use Floyd\\'s Tortoise and Hare algorithm to detect the cycle in the linked list,\\nwhich is guaranteed to exist since there is at least one duplicate number in the list.\\nOnce we have detected the cycle, we can reset the tortoise to the start of the list,\\nand move both the tortoise and hare at the same speed until they meet again.\\nThe point where they meet will be the duplicate number.\\n\\n# Complexity\\n- Time complexity:\\nO(n) 83.46%\\n\\n- Space complexity:\\nO(1) 88.35%\\n\\n# Code\\n```\\nclass Solution:\\n  def findDuplicate(self, nums: List[int]) -> int:\\n    # Using Floyd\\'s Tortoise and Hare algorithm\\n    # to detect the cycle in the linked list\\n    tortoise = nums[0]\\n    hare = nums[0]\\n    \\n    # Move tortoise and hare until they meet\\n    while True:\\n        tortoise = nums[tortoise]\\n        hare = nums[nums[hare]]\\n        if tortoise == hare:\\n            break\\n    \\n    # Reset tortoise to the start of the list\\n    tortoise = nums[0]\\n    \\n    # Move tortoise and hare at the same speed until they meet again\\n    while tortoise != hare:\\n        tortoise = nums[tortoise]\\n        hare = nums[hare]\\n    \\n    # Return the duplicate number\\n    return tortoise\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n  def findDuplicate(self, nums: List[int]) -> int:\\n    # Using Floyd\\'s Tortoise and Hare algorithm\\n    # to detect the cycle in the linked list\\n    tortoise = nums[0]\\n    hare = nums[0]\\n    \\n    # Move tortoise and hare until they meet\\n    while True:\\n        tortoise = nums[tortoise]\\n        hare = nums[nums[hare]]\\n        if tortoise == hare:\\n            break\\n    \\n    # Reset tortoise to the start of the list\\n    tortoise = nums[0]\\n    \\n    # Move tortoise and hare at the same speed until they meet again\\n    while tortoise != hare:\\n        tortoise = nums[tortoise]\\n        hare = nums[hare]\\n    \\n    # Return the duplicate number\\n    return tortoise\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138618,
                "title": "java-o-n-time-1ms-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for (int n : nums) {\\n            if (nums[Math.abs(n)] < 0) {\\n                return Math.abs(n);\\n            } else {\\n                nums[Math.abs(n)] *= -1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nSince array length is n+1, the values in nums are essentially valid indices of itself.\\nfor each value n of nums, go to nums[n] to make that value negative.\\nif the value at nums[n] is already negative, it means that `n` has already existed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for (int n : nums) {\\n            if (nums[Math.abs(n)] < 0) {\\n                return Math.abs(n);\\n            } else {\\n                nums[Math.abs(n)] *= -1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510442,
                "title": "javascript-solution-floyd-s-cycle-finding-algorithm-tortoise-and-hare",
                "content": "```\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[nums[0]];\\n    \\n    while (slow != fast) { // we are guaranteed to have a cycle\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    }\\n    \\n    slow = 0;\\n    \\n    while (slow != fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    \\n    return slow;\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[nums[0]];\\n    \\n    while (slow != fast) { // we are guaranteed to have a cycle\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    }\\n    \\n    slow = 0;\\n    \\n    while (slow != fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    \\n    return slow;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73009,
                "title": "o-n-time-o-1-space-using-floyd-s-loop-detection",
                "content": "Let's try to follow a chain starting from element at index 0, and interpret a value of the element as an index, let's take element at that index and interpret it as a next index, and so on. Since there is a duplicate there must be a loop in this chain. It's trivial to show that the beginning of the loop is our duplicate.\\nFollowing implementation uses classic two-pointers Floyd's loop detection algorithm to find the beginning of the loop.\\n\\n    int findDuplicate(const vector<int>& nums) {\\n        int a = 0, b = 0;\\n        do a = nums[nums[a]], b = nums[b]; while (a!=b);\\n        b = 0;\\n        while (a!=b) a = nums[a], b = nums[b];\\n        return a;\\n    }",
                "solutionTags": [
                    "Two Pointers",
                    "Graph"
                ],
                "code": "Let's try to follow a chain starting from element at index 0, and interpret a value of the element as an index, let's take element at that index and interpret it as a next index, and so on. Since there is a duplicate there must be a loop in this chain. It's trivial to show that the beginning of the loop is our duplicate.\\nFollowing implementation uses classic two-pointers Floyd's loop detection algorithm to find the beginning of the loop.\\n\\n    int findDuplicate(const vector<int>& nums) {\\n        int a = 0, b = 0;\\n        do a = nums[nums[a]], b = nums[b]; while (a!=b);\\n        b = 0;\\n        while (a!=b) a = nums[a], b = nums[b];\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 358670,
                "title": "bs-binarysearch-with-very-detailed-explanation",
                "content": "There is a better solution in O(N) time with cycle detection, but it is very hard to come up with unless you know it IMO.\\n\\nFirst of all, why binary search? We know that the complexity should be less than O(N^2), which leaves us O(N) and O(N * logN). We can discard O(logN) since we need to check all elements at least once.\\nSince we cannot modify the input array and we cannot use extra space, we can discard:\\n1. Sorting. It\\'s O(N * logN), but requires either extra space or modifying the array.\\n2. Any kind of recursion. In languages with no tail recursion, recursion takes additional non-constant space.\\n3. Dynamic Programming (most likely). Usually DP takes extra space for storing intermediate results.\\n4. Any kind of additional data structures, like HashTables, Queues, Stacks, Trees, Graphs etc.\\n\\nIf you look at what\\'s left from the basic concepts (even in LeetCode explore section), Binary Search is the only thing that\\'s left. Frankly speaking, following that logic, LinkedList would also be discarded, which would make you miss the cycle detection solution. But the trick here is to figure out that array in this case can be used as a LinkedList, that\\'s why I think it\\'s not reasonable to expect somebody to come up with this solution during an interview.\\n\\nOK, so we will try to come up with binary search solution. How can we do that?\\n\\nWe know that the answer lies between 1 and N. If we can come up with an idea of how to discard half of the interval at each step, we will get log N part of the target complexity of O(N * logN). Keep in mind that here we do not apply binary search to the array itself as it is usually done, we apply BS to the interval of possible solutions. So in each iteration we do not \"shrink\" the array in any way, we \"shrink\" the possible answer space.\\nUsually when you search element in the array, the array is your \"answer space\". You go either to the left of \\'mid\\' element or to the right when searching for target. Here the array serves only as a data structure for the \\'check\\' condition in binary search.\\n\\nIt\\'s worth noting that this observation leaves us O(N) time complexity for each step of the binary search (each check of the \"mid\" element), which allows us to fully traverse the array.\\n\\nHow can we shrink the interval of answer space between 1..N in half?\\n\\nIn each iteration of binary search, we need to answer two questions:\\n1. Is mid the duplicate element we look for?\\n2. Is answer in the interval [l, mid)? l here stands for the left bound of our current answer space.\\n\\nIf we know answers to these questions, we can either immediately return the mid if the answer to question #1 is yes, or to go either to the left if the answer to question 2 is yes, or to go right if the answer is no.\\n\\nHow can we answer question #2? We can iterate through the entire array and count number of elements that lie in interval [l, mid]. If the count is greater than mid - l +1, than the answer is yes, otherwise no. Why is that? Let\\'s look at some examples.\\nLet\\'s say our interval is [3,4], where 3 is l (left) and 4 is mid, and the interval is between[3,5]. Let\\'s look at various possible values of \\'count\\', where \\'count\\' is number of elements between 3 and 4 inclusive (i.e., elements is either 3 or 4).\\ncount = 1:\\nwe encountered only one element, which was either 3 or 4.\\ncount = 2:\\nwe encountered two elements, which were either 3,3 or 3,4 or 4,4. If it was 4,4, we would return it since it is mid element. If it is 3,4, then obviously we don\\'t have our answer between 3 and 4, since count(3) == 1 and count(4) == 1 in the entire array.\\nWhat about 3,3? Is it a valid input? No, since we\\'re looking at the left side of the array where numbers could be only from 1..n.\\nIn other words, if the following input *would have been* correct, then our algorithm wouldn\\'t work:\\n[1,2,3,3,5,6,7,8] \\nNotice that 4 is missing, but 8 is here which contradicts the requirements. The only possible \"slot\" left for the number instead of 8 is either another 3 or 4, because if it is let\\'s say 5, we would have 2 duplicates.\\nExamples of correct inputs:\\n[1,2,3,3,5,6,7,4]\\n[1,2,3,3,5,6,7,3]\\n[1,2,3,3,5,6,3,3]\\nWhich leads us to the next case.\\ncount > 2:\\n3,3,4\\n3,3,3\\n3,3,3,3 \\netc., so we need to look between [3,4] in the next step of our binary search.\\n\\nThe code:\\n\\n```\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        int l = 1, r = nums.Length - 1; // 1..n, initial answer space\\n        \\n        while (l <= r) // binary search, template 1 from leetcode explore\\n        {\\n            int eq = 0, inRange = 0;\\n            int mid = l + (r - l) / 2;\\n            \\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (nums[i] == mid)\\n                {\\n                    eq++; // need to check if mid is the answer\\n                    inRange++; // anyways, cound mid elements as in range to answer question #2\\n                }\\n                else if (nums[i] < mid && nums[i] >= l)\\n                {\\n                    inRange++;\\n                }\\n            }\\n            if (eq > 1)\\n                return mid;\\n            else if (inRange > mid - l+1)\\n                r = mid - 1; // go left\\n            else\\n                l = mid + 1; // go right\\n        }\\n        \\n        return -1; // not reachable according to problem statement\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindDuplicate(int[] nums) {\\n        int l = 1, r = nums.Length - 1; // 1..n, initial answer space\\n        \\n        while (l <= r) // binary search, template 1 from leetcode explore\\n        {\\n            int eq = 0, inRange = 0;\\n            int mid = l + (r - l) / 2;\\n            \\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (nums[i] == mid)\\n                {\\n                    eq++; // need to check if mid is the answer\\n                    inRange++; // anyways, cound mid elements as in range to answer question #2\\n                }\\n                else if (nums[i] < mid && nums[i] >= l)\\n                {\\n                    inRange++;\\n                }\\n            }\\n            if (eq > 1)\\n                return mid;\\n            else if (inRange > mid - l+1)\\n                r = mid - 1; // go left\\n            else\\n                l = mid + 1; // go right\\n        }\\n        \\n        return -1; // not reachable according to problem statement\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892999,
                "title": "simple-easy-solution-c",
                "content": "***When duplicate numbers are present , it form the cycle and using floyd cycle algorithm we can find the starting point of cycle***\\n ![image](https://assets.leetcode.com/users/images/8d434509-651f-4d6e-b466-ce1186363a35_1648519542.6683981.jpeg)\\n\\n**Time complexcity O(N)** \\n```\\n int findDuplicate(vector<int>& nums) \\n    {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n        slow=nums[slow];\\n        fast=nums[nums[fast]];\\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }\\n        slow=nums[0];\\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }\\n        return slow;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int findDuplicate(vector<int>& nums) \\n    {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n        slow=nums[slow];\\n        fast=nums[nums[fast]];\\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }\\n        slow=nums[0];\\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }\\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 704916,
                "title": "o-n-solution-using-o-1-space-complexity-c-neatly-explained-floyd-cycle-detection",
                "content": "# Using Floyd\\'s Cycle Detection\\n1. **Detecting the cycle**\\n This question is same as finding loop in linked lists..here the array values can be taken as **Address values of Linked list Nodes**. Considering the constraints we do it using **Floyd\\'s Cycle Detection Algorithm**. In this we consider two pointers slow and fast(both are initialised to starting of list),where slow moves by one step at a time,fast moves by 2 steps at a time. i.e (in terms of Linked lists) slow=slow->next and fast=fast->next->next .As i have mentioned earlier the address values can be considered as array values here i.e slow=nums[slow]; and fast=nums[nums[fast]]; And in question its mentioned that n+1 array having 1 to n values that means atleast one number will be repeating for sure(*Pigeon Hole Principle*) .i.e in our terms *there is an address that repeats for sure* and our task is to find it.  so by moving slow,fast values in above way they both will become equal for sure after some steps(since there\\'s a cycle).\\n2.  **Finding the Start of the loop**\\n    Now lets consider the loop starts at **s** distance from the starting of array. and x be the point where slow,fast met(**meeting position**). let rs,rf represent no.of rotations made by slow,fast pointers before meeting and let *l*  be the length of the loop.\\n\\t*Then Distance Travelled by slow pointer* = s+rs\\\\**l*+x and by Fast Pointer = s+rf \\\\**l*+x\\n\\tand we know that **since slow moves by one step and fast moves by 2 steps..the Distance travelled by fast =2(Distance travelled by slow)**.\\n\\t->s+rf \\\\**l*+x=2\\\\*(s+rs\\\\**l*+x)\\n\\t->(rf-2\\\\*rs)\\\\**l*=s+x\\n\\ti.e **s+x is the multiple of the length of the loop**.\\n\\t*Now as our pointers have already moved by x from the start of loop,moving by s will make the pointer move to the start of the loop. and we do that by making one pointer start from the starting point of array and the other at meeting position both moving one step at the time..there by making them meet at the start of the loop and that value is our required answer.. cheers!!* \\n\\t \\n\\t\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/8320fa90-f7c4-429d-ab44-bd623c28546c_1593083741.1838455.png)\\n\\n\\nHere\\'s the Code for above Explanation\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n       int slow = nums[0];\\n       int fast = nums[0];\\n\\t  //Detecting the loop.\\n       do{\\n           slow = nums[slow];\\n           fast = nums[nums[fast]];\\n       }while(slow != fast);\\n\\t\\t// Finding Start positon of the loop.\\n        slow = nums[0];\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return fast;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n       int slow = nums[0];\\n       int fast = nums[0];\\n\\t  //Detecting the loop.\\n       do{\\n           slow = nums[slow];\\n           fast = nums[nums[fast]];\\n       }while(slow != fast);\\n\\t\\t// Finding Start positon of the loop.\\n        slow = nums[0];\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return fast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72989,
                "title": "simple-5-line-python-solution-using-binary-search",
                "content": "The idea is that if you have a number (e.g. 5) and there are 5 numbers in the array that are less than or equal to 5 then the duplicate has to be a number greater than 5.  Otherwise, by the pigeonhole principle the duplicate has to be one of the numbers between 1 and 5 inclusive.\\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            left, right = 1, len(nums)-1\\n            while left < right:\\n               mid = (right + left)/2\\n               left, right = [left, mid] if sum(i <= mid for i in nums) > mid else [mid+1, right]\\n            return right",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "The idea is that if you have a number (e.g. 5) and there are 5 numbers in the array that are less than or equal to 5 then the duplicate has to be a number greater than 5.  Otherwise, by the pigeonhole principle the duplicate has to be one of the numbers between 1 and 5 inclusive.\\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            left, right = 1, len(nums)-1\\n            while left < right:\\n               mid = (right + left)/2\\n               left, right = [left, mid] if sum(i <= mid for i in nums) > mid else [mid+1, right]\\n            return right",
                "codeTag": "Java"
            },
            {
                "id": 1459792,
                "title": "c-easy-to-understand-3-efficient-solutions",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Using in-builtsort function\\nTime complexity O(NlogN+N)\\nSpace complexity O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            return nums[i];    \\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Using frequency array\\nTime complexity O(N)\\nSpace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(v[nums[i]]!=0)\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                v[nums[i]]++;\\n            }    \\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Slow and fast pointer approach\\nTime complexity O(N)\\nspace complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n     int slow=nums[0],fast=nums[0];\\n     do\\n     {\\n         fast=nums[nums[fast]];\\n         slow=nums[slow];\\n     }while(slow!=fast);\\n     fast=nums[0];\\n        while(slow!=fast)\\n        {\\n            fast=nums[fast];\\n            slow=nums[slow];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            return nums[i];    \\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(v[nums[i]]!=0)\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                v[nums[i]]++;\\n            }    \\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n     int slow=nums[0],fast=nums[0];\\n     do\\n     {\\n         fast=nums[nums[fast]];\\n         slow=nums[slow];\\n     }while(slow!=fast);\\n     fast=nums[0];\\n        while(slow!=fast)\\n        {\\n            fast=nums[fast];\\n            slow=nums[slow];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064373,
                "title": "98-89-easy-solution-1-line-code",
                "content": "\\n# Solution\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        seen = set()\\n        return next(num for num in nums if num in seen or seen.add(num))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        seen = set()\\n        return next(num for num in nums if num in seen or seen.add(num))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73053,
                "title": "tortoise-haire-cycle-detection-algorithm",
                "content": "O(n) time O(1) space solution - \\n\\n\\n    public class Solution {\\n        public static int findDuplicate(int[] nums) {\\n            //using Tortoise & Hair algorithm by Donald Knuth to find cycle in a sequence.\\n            //This algorithm also called Floyd's cycele detection algorithm\\n            int n = nums.length;\\n            int tortoise = n;\\n            int hair = n;\\n            \\n           do{\\n                tortoise = nums[tortoise-1];\\n                hair = nums[nums[hair-1]-1];\\n            } while(hair != tortoise);\\n            \\n            //find the starting point of the cycle\\n            //int mu = 0;\\n            tortoise = n;\\n            while(hair != tortoise){\\n                tortoise = nums[tortoise-1];\\n                hair = nums[hair-1];\\n                //mu++;\\n            }\\n            \\n            return tortoise;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public static int findDuplicate(int[] nums) {\\n            //using Tortoise & Hair algorithm by Donald Knuth to find cycle in a sequence.\\n            //This algorithm also called Floyd's cycele detection algorithm\\n            int n = nums.length;\\n            int tortoise = n;\\n            int hair = n;\\n            \\n           do{\\n                tortoise = nums[tortoise-1];\\n                hair = nums[nums[hair-1]-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2548490,
                "title": "you-learn-something-new-every-day",
                "content": "I\\'ll be honest here. I was not able to solve this problem in O(1) space and solving it in O(1) space complexity, O(n) time and without modifying original array makes it a really hard problem.\\n\\nI did find this interesting  article - https://keithschwarz.com/interesting/code/?dir=find-duplicate\\n\\nIt explains the way using which we can solve this problem in O(1) space, O(n) time and without modifying the array. We have to think of the array like a linked list and then think - How can we find repeated nodes in a linked list? or in other words - How to detect a cycle in a linked list?\\n\\nWell, we know that we can do that using two pointers - slow and fast. \\n\\nLets take an example : nums  = [1,3,4,2,2]\\n\\nLets create a linked list from it (We won\\'t do that in code, obviously).\\n\\n\\t\\t1 -> 3 -> 4 -> 2 -> 2\\n\\t   slow\\n\\t   fast\\n\\t\\t\\nSo, initially, we have slow and fast pointers both pointing to the first node. \\n\\nAnd now, we will increment fast by two nodes and slow by one node. But, in case of linked lists, we have next pointers that point to the next nodes. Here in the array, we do not have any such info so we cannot simply increment slow and fast. \\n\\nWe have to increment them by taking the values as the pointer/indexes to the next node. \\n\\ne.g. at slow pointer, currently value is 1\\nSo to increment it by one node, we will use this value as the index of new slow pointer node. i.e., \\n\\t\\t\\t\\n\\t\\t\\t\\tslow = nums[slow]\\n\\t\\t\\t\\nAnd similarly, to increment fast by two, we will do somethind similar to fast.next.next:\\n\\n\\t\\t\\t  fast = nums[nums[fast]]\\n\\t\\t\\t  \\nWe will do this until slow and fast are pointing to same node.\\n\\nSo, in first iteration. slow = 1 so new slow = nums[1] => 3\\n Similarly, fast = 1 so new fast = nums[nums[1]] => nums[3] => 2\\n\\n\\n\\t\\t1 -> 3 -> 4 -> 2 -> 2\\n\\t        slow\\n\\t                  fast\\n\\t\\nAgain, new slow = nums[3] = 2\\n\\t\\t  new fast = nums[nums[2]] = nums[4] = 2\\n\\t\\t \\n\\t\\t1 -> 3 -> 4 -> 2 -> 2\\n\\t\\t\\t\\t\\t  slow\\n\\t\\t\\t\\t\\t\\t   fast\\n\\t\\t\\t\\t\\t\\t   \\nHere, we see that slow = fast as both are 2. So we break.\\n\\nAnd now, we have to do the second step which is to find the beginning of cycle in linked list. So, we reset slow pointer to again point to first element.\\n\\t\\n\\t\\tslow = nums[0] = 1\\n\\t\\t\\nAnd now, we will increment slow and fast, both by one until they become same.\\n\\t\\nnew slow = nums[slow] = nums[1] = 3\\nnew fast = nums[nums[fast]] = nums[nums[2]] = nums[4] = 2\\n\\n\\t\\t1 -> 3 -> 4 -> 2 -> 2\\n\\t        slow\\n\\t\\t\\t\\t\\t\\t   fast\\n\\nnew slow = nums[slow] = nums[3] = 2\\nnew fast = nums[nums[fast]] = nums[nums[2]] = nums[4] = 2\\n\\nAnd here, slow = fast.\\n\\nSo finally, we will return any one of these two values and that is our required repeated number in the array.\\n\\n\\nHere is the code in Python - \\n\\n```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        \\n        #Use the same approach here as in detecting the beginning of cycle in a linked list\\n        \\n        #Initially, both slow and fast point to the first element of the array\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        #Now, we will increment slow by one and fast by two steps\\n        # DO Note that in case of a linked list, we do slow.next and slow.next.next as we use the next pointer ofa node\\n        # But here, since all we have at each position is a number, we will increment by using that number as the next pointer/index\\n        while(True):\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if(slow == fast): break\\n        \\n        \\n        #Now, once we detect the cycle, now its time to find the starting point of it. \\n        #Just like in a linked list, we will reset our slow pointer to again point to first element\\n        \\n        slow  = nums[0]\\n        \\n        #And now, we increment both pointers one step at a time until they point to the same element. \\n        # The element they will eventually point to is the repeated element\\n        while(slow != fast):\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        \\n        \\n        return slow\\n```\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\n\\t\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        \\n        #Use the same approach here as in detecting the beginning of cycle in a linked list\\n        \\n        #Initially, both slow and fast point to the first element of the array\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        #Now, we will increment slow by one and fast by two steps\\n        # DO Note that in case of a linked list, we do slow.next and slow.next.next as we use the next pointer ofa node\\n        # But here, since all we have at each position is a number, we will increment by using that number as the next pointer/index\\n        while(True):\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if(slow == fast): break\\n        \\n        \\n        #Now, once we detect the cycle, now its time to find the starting point of it. \\n        #Just like in a linked list, we will reset our slow pointer to again point to first element\\n        \\n        slow  = nums[0]\\n        \\n        #And now, we increment both pointers one step at a time until they point to the same element. \\n        # The element they will eventually point to is the repeated element\\n        while(slow != fast):\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        \\n        \\n        return slow\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1893550,
                "title": "find-the-duplicate-number-python-code",
                "content": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        occurence={}\\n        for i in nums:\\n            if i in occurence:\\n                occurence[i]+=1\\n            else:\\n                occurence[i]=1\\n        for dublicateVal in occurence:\\n            if occurence[dublicateVal]>1:\\n                return dublicateVal\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        occurence={}\\n        for i in nums:\\n            if i in occurence:\\n                occurence[i]+=1\\n            else:\\n                occurence[i]=1\\n        for dublicateVal in occurence:\\n            if occurence[dublicateVal]>1:\\n                return dublicateVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650999,
                "title": "3-solutions-using-set-floyd-s-loop-detection-algorithm-brute-force",
                "content": "Here we are gonna discuss 3 different approches by which we can solve this problem-\\n\\n**APPROACH-1: NAIVE APPROACH (Brute Force)**\\nAs we are guranteed that- there\\'s exactly one duplicate value, so if we compare each element with all the other values and if we see they are equal at any point then we can simply return that. \\n\\n**TC:** O(N^2), as we have nested loop here that are running close to N times in both the loops\\n**SC:** O(1), as we aren\\'t using any scaling DS here\\n\\n**CODE:**\\n   ```\\n //NOTE: This one may give you \\'Time Limit Exceeded\\' error, as it is not an optimized approach\\n int findDuplicate(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size() && j!=i; j++){\\n                if(nums[i]==nums[j]){\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;  //this one will be executed only when there will be no solution\\n    } \\n```\\n   \\n**APPROACH-2: USING SET**\\nAs we can check the duplicity of any value in set using O(1) TC only, we\\'ll use that advantage here. What we\\'ll do is- we\\'ll store all the values one by one if it hasn\\'t been inserted before in the set, and if we see the value already exist there, we can return that value.\\n\\n**TC:** O(N), as we are traversing the elements only once\\n**SC:** O(N), as in the worst case we may have to store (N-1) values in the set\\n\\n**CODE:**\\n   ```\\n int findDuplicate(vector<int>& nums){\\n        unordered_set<int> s;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(s.find(nums[i])!=s.end()){\\n                return nums[i];\\n            }\\n            s.insert(nums[i]);\\n        }\\n        return -1;\\n    } \\n```\\n    \\n    \\n**APPROACH-3: USING FLOYD\\'S LOOP DETECTION TECHNIQUE**\\nThe idea is pretty simple. As we are assured that there will be only one duplicate value, so if we create a virtual Linked List here (see, how we did that->Dry run if you don\\'t get the idea), and apply the Floyd\\'s Loop Detection technique here, then we gonna surely face a collision somewhere, and that tells us- yes, we have a duplicate value here. But, in order to find out which value is the duplicate one- we have to set a pointer to the 0-th element and we\\'ll move both the pointers at a same speed (one step at a time). Whenever we\\'ll see the \\'slow\\' and \\'fast\\' are having equal values that will be the duplicate value.\\n\\n**NOTE:** *If you didn\\'t get the idea make sure you know **Floyd\\'s Loop Detection Algorithm** (in Linked List), and also **dry run** the below code.*\\n\\n**TC:** almost O(N), because it may require us to have more than N opertaions to find out the collision\\n**SC:** O(1), as there\\'s no scaling DS used\\n\\n**CODE:**\\n```\\n    int findDuplicate(vector<int>& nums){\\n        int slow=nums[0], fast=nums[0];\\n        \\n        //NOTE: We are using do-while loop here, because at the very first step \\'fast==slow\\'. you can use normal while loop also, but for that you have to add additional conditions also.\\n        do{\\n            slow=nums[slow];  //one step at a time\\n            fast=nums[nums[fast]];  //two steps at a time\\n        }while(slow!=fast);\\n        \\n        //We have met our first collision, now we have to find out the value for which the collision happened\\n        slow=nums[0];   //re-initializing the slow pointer with the 0-th value \\n        while(slow!=fast){\\n            slow=nums[slow];  //one step at a time\\n            fast=nums[fast];  //one step at a time\\n        }\\n        return fast;  //return slow will also work\\n    }\\n```\\n\\n\\n*Hope it helps!\\nThank You:)*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n //NOTE: This one may give you \\'Time Limit Exceeded\\' error, as it is not an optimized approach\\n int findDuplicate(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums.size() && j!=i; j++){\\n                if(nums[i]==nums[j]){\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;  //this one will be executed only when there will be no solution\\n    } \\n```\n```\\n int findDuplicate(vector<int>& nums){\\n        unordered_set<int> s;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(s.find(nums[i])!=s.end()){\\n                return nums[i];\\n            }\\n            s.insert(nums[i]);\\n        }\\n        return -1;\\n    } \\n```\n```\\n    int findDuplicate(vector<int>& nums){\\n        int slow=nums[0], fast=nums[0];\\n        \\n        //NOTE: We are using do-while loop here, because at the very first step \\'fast==slow\\'. you can use normal while loop also, but for that you have to add additional conditions also.\\n        do{\\n            slow=nums[slow];  //one step at a time\\n            fast=nums[nums[fast]];  //two steps at a time\\n        }while(slow!=fast);\\n        \\n        //We have met our first collision, now we have to find out the value for which the collision happened\\n        slow=nums[0];   //re-initializing the slow pointer with the 0-th value \\n        while(slow!=fast){\\n            slow=nums[slow];  //one step at a time\\n            fast=nums[fast];  //one step at a time\\n        }\\n        return fast;  //return slow will also work\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316137,
                "title": "c-binary-search-explained",
                "content": "##### **Binary Search**\\n\\nIf an array of size n+1 contains numbers in the range from 1 to n, it contains a duplicate number.\\nWe can use this for designing binary search algorithm.\\n\\n**Algorithm**\\n*(Perform binary search on range 1 2 ... n)*\\n\\nlow <-- 1\\nhigh <-- n *(size of the array is n+1)*\\n\\nWhile the value of high is greater than equal to low\\n1. mid <-- (high + low) / 2\\n2. count <-- number of elements less than equal to **mid**\\n3. if count is less than equal to mid, **low <-- mid + 1** *( do binary seach on right part of the range)*\\n\\telse **high <-- mid - 1**  *( do binary seach on left part of the range)*\\n\\t\\nThe low will point to the duplicate number.\\n\\n**Example**\\n```\\nnums: 3 1 3 4 2\\n```\\n\\n```\\nrange: 1 2 3 4 \\n\\n// Binary Search 1... 4 \\n------------------------\\nlow | mid | high | count\\n------------------------\\n  1    2     4      2\\n  3    3     4      4\\n  3    3     2      -      //return low \\n  \\nlow = 3  //duplicate number\\n```\\n\\nThe above algorithm runs with the time complexity of **O(nlogn)**\\n\\n\\n**C++ Code**\\n```\\nint findDuplicate(vector<int>& nums){\\n\\tint high, mid, low, count;\\n\\t\\n    high = nums.size() - 1;\\n    low = 1;\\n\\n    while(high >= low){\\n        mid = (high + low)/2;\\n        count = 0;\\n\\n        for(int n: nums) if(n <= mid) count++; //count numbers less then equal to mid\\n      \\n        if(count <= mid) low = mid + 1; //binary search right \\n        else high = mid - 1;            //binary search left\\n    }\\n\\t\\n    return low;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nnums: 3 1 3 4 2\\n```\n```\\nrange: 1 2 3 4 \\n\\n// Binary Search 1... 4 \\n------------------------\\nlow | mid | high | count\\n------------------------\\n  1    2     4      2\\n  3    3     4      4\\n  3    3     2      -      //return low \\n  \\nlow = 3  //duplicate number\\n```\n```\\nint findDuplicate(vector<int>& nums){\\n\\tint high, mid, low, count;\\n\\t\\n    high = nums.size() - 1;\\n    low = 1;\\n\\n    while(high >= low){\\n        mid = (high + low)/2;\\n        count = 0;\\n\\n        for(int n: nums) if(n <= mid) count++; //count numbers less then equal to mid\\n      \\n        if(count <= mid) low = mid + 1; //binary search right \\n        else high = mid - 1;            //binary search left\\n    }\\n\\t\\n    return low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875492,
                "title": "wrong-testcase-do-it-using-sum-nums-n-n-1-2-if-there-s-only-one-duplicate",
                "content": "Under constraints it\\'s mentioned,\\n\\n> All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\n> There is only one duplicate number in nums, return this duplicate number.\\n\\nBut there\\'s a testcase ```[2, 2, 2, 2, 2]```, which isn\\'t valid input according to the constraints mentioned.\\n\\nIf we have valid inputs can\\'t we use ```sum(nums)``` - ```n*n+1/2``` here?\\nAs it\\'s guarenteed that `i` always lies in range `[1, n]` when there are `n+1` elements with only one duplicate, so the `sum(nums)` would be duplicate number greater than `n*n-1/2` right? `O(N)` time, `O(1)` space solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int sum = 0;\\n        int n = nums.size() - 1;\\n        int ts = n*(n+1)/2;\\n        for(auto i:nums){\\n            sum+=i;\\n        }\\n        return sum - ts;\\n    }\\n};\\n```\\n\\n--- \\n\\n### **UPDATE: Adding more clarification to the post.**\\n\\nIn the question, they mentioned that there would only one duplicate. So going by question\\'s constraints, which states *All the integers in nums appear only once except for precisely one integer which appears two or more times.* This says that for all `i` there would be only 1 such number which occurs twice.\\n\\nNow, it\\'s given that `i` is always in the range `[1, n]` for `n+1` elements. Let\\'s say given a vector of length `5`, all valid values would be 1 to 4 but anyone number in 1-4 can repeat once.\\n\\nWe know that some of `n` numbers are `n*n+1/2`. Now, consider the below example taken from the question itself:\\n```\\nInput: nums = [1,3,4,2,2]\\nOutput: 2\\n```\\n\\n`nums_sum = sum(nums)  # ->12 in  this case`\\nwe know that given `n+1` elements values would be between `[1, n]`, so `n = nums.length() - 1`, now use find sum of `n` elements. `n_sum = n*n+1/2 # -> 10`.\\n\\nnow, `nums_sum = 12`, `n_sum = 10`. In every case `nums_sum` would be duplicated number more. To get duplicate number `nums_sum - n_sum` would give `2` which is correct.\\n\\nVisualization:  \\n```\\nnums = [1, 3, 4, 2, 2]\\nn = [1, 2, 3, 4]  # 1 + 2 + 3 + ... n = n*n+1/2\\n```\\nCancel all common terms, you will be left with the duplicated number.",
                "solutionTags": [
                    "C"
                ],
                "code": "```[2, 2, 2, 2, 2]```\n```sum(nums)```\n```n*n+1/2```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int sum = 0;\\n        int n = nums.size() - 1;\\n        int ts = n*(n+1)/2;\\n        for(auto i:nums){\\n            sum+=i;\\n        }\\n        return sum - ts;\\n    }\\n};\\n```\n```\\nInput: nums = [1,3,4,2,2]\\nOutput: 2\\n```\n```\\nnums = [1, 3, 4, 2, 2]\\nn = [1, 2, 3, 4]  # 1 + 2 + 3 + ... n = n*n+1/2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164019,
                "title": "using-hashmap-in-java-well-explained",
                "content": "\\n\\n# Approach\\nThis solution is trying to find a duplicate element in an array of integers. It does this by using a HashMap data structure to store the frequency of each element in the array.\\n\\nThe solution iterates over the array and for each element, it increases the frequency count in the HashMap by 1. If the frequency count for a particular element becomes 2, it means that this element has already been encountered once and is therefore a duplicate. The function returns this duplicate element as the answer.\\n\\nIf there are no duplicates in the array, the function will return -1, which is a default value indicating that no duplicate was found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the number of elements in the input array. This is because the solution only needs to go through the array once, and each operation of updating the frequency count in the HashMap takes O(1) time on average.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is also O(n), as the HashMap needs to store the frequency count of all elements in the array. In the worst case, where all elements are different, the HashMap will need to store n key-value pairs, which takes O(n) space.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            if(map.get(nums[i])==2){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/194ca6ec-0c74-45e7-abf1-7acfa6005dbb_1675942668.3920887.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            if(map.get(nums[i])==2){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680358,
                "title": "c-solution-0-n-0-1-space-complexity-explained",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- In first method we\\u2019re using an extra space of 0(n).\\n- We have taken an array of size n+1 & initialized with 0.\\n- Traverse the given array and increase the index in temp array.\\n- At any point if the value is greater than 1 then return the value present in the index.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using ***Hare and tortoise method.***\\n- Here we\\u2019ll be using 2 pointers fast and slow. Initially slow will initialize with the first element and fast will initialize with the element present in ***nums[0]*** index.\\n- In the first loop, we\\u2019ll move both pointers with 1 index & break after slow=fast.\\n- Then we\\u2019ll make fast 0 & in the next loop we\\u2019ll move the slow pointer with 1 position and fast with 2 positions.\\n- One point the both will equal and return fast/slow.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp(n+1, 0);\\n        \\n        for(auto x:nums){\\n            temp[x]++;\\n            if(temp[x] >1)\\n                return x;\\n        }\\n        return -1;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums)\\n    {    \\n        if (nums.size() > 1)\\n        {\\n            int slow = nums[0];\\n            int fast = nums[nums[0]];\\n            while (slow != fast)\\n            {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n            }\\n\\n            fast = 0;\\n            while (fast != slow)\\n            {\\n                fast = nums[fast];\\n                slow = nums[slow];\\n            }\\n            return slow;\\n        }\\n        return -1;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp(n+1, 0);\\n        \\n        for(auto x:nums){\\n            temp[x]++;\\n            if(temp[x] >1)\\n                return x;\\n        }\\n        return -1;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums)\\n    {    \\n        if (nums.size() > 1)\\n        {\\n            int slow = nums[0];\\n            int fast = nums[nums[0]];\\n            while (slow != fast)\\n            {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n            }\\n\\n            fast = 0;\\n            while (fast != slow)\\n            {\\n                fast = nums[fast];\\n                slow = nums[slow];\\n            }\\n            return slow;\\n        }\\n        return -1;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427294,
                "title": "most-people-s-code-violates-the-problem-description-which-won-t-work-in-an-interview",
                "content": "Leetcode doesn\\'t seem to police the answers, but many people here are practicing for an interview.  People who ignore requirements in an inteview will not look good to the interviewer.\\n\\nHere\\'s the first two rules from the problem description:\\n```\\nYou must not modify the array (assume the array is read only).\\nYou must use only constant, O(1) extra space.\\n```\\n\\nMany posts claim the problem is easy to solve with a fast solution - often ignoring the O(1) restriction.  Code that performs one insert per input is using O(n) space.  Doesn\\'t even matter if it puts all or most of them into a set or dictionary, it\\'s using O(n) space.\\n\\nBut modifying the array, by assinging things to ```nums``` or calling ```nums.sort()``` also violates the problem description.  Here\\'s some sample solutions that violate these two requirements:\\n\\n32 ms: ```distinct = set()``` followed later by ```distinct.add(num)```\\n44 ms: ```nums.sort()```\\n56 ms: ```nums[abs(nums[i])] = - nums[abs(nums[i])]```\\n60 ms: ```nums.sort()```\\n\\nAs you browse the topics for this problem, just keep in mind most of them violate the problem description.  That works only because leetcode isn\\'t enforcing the stated restrictions - it won\\'t work in a live interview.",
                "solutionTags": [],
                "code": "```\\nYou must not modify the array (assume the array is read only).\\nYou must use only constant, O(1) extra space.\\n```\n```nums```\n```nums.sort()```\n```distinct = set()```\n```distinct.add(num)```\n```nums.sort()```\n```nums[abs(nums[i])] = - nums[abs(nums[i])]```\n```nums.sort()```",
                "codeTag": "Unknown"
            },
            {
                "id": 72979,
                "title": "java-o-1-space-o-nlgn-time-solution",
                "content": "Every time, we scan all the array to find how many numbers are in range of [low, mid), [mid, mid] and (mid, high)\\n\\n    public static int findDuplicate(int[] nums) {\\n      \\n        int low = 1; //[low, high)\\n        int high = nums.length;\\n        while(low < high){\\n          int mid = low + (high - low) / 2;\\n          int leftCount = 0;\\n          int rightCount = 0;\\n          int midCount = 0;\\n          for(int i : nums){\\n            if(i == mid){\\n              ++midCount;\\n            }else if(i >= low && i < mid){ //[low, mid]\\n              ++leftCount;\\n            }else if(i > mid && i < high){ //(mid, high)\\n              ++rightCount;\\n            }\\n          }\\n          if(midCount > 1){\\n            return mid;\\n          }else if(leftCount > (mid - low)){//[1, 4) 3\\n            high = mid;\\n          }else if(rightCount > (high - mid - 1)){//(4, 8) 3\\n            low = mid + 1;\\n          }\\n          \\n        }\\n        return low;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Every time, we scan all the array to find how many numbers are in range of [low, mid), [mid, mid] and (mid, high)\\n\\n    public static int findDuplicate(int[] nums) {\\n      \\n        int low = 1; //[low, high)\\n        int high = nums.length;\\n        while(low < high){\\n          int mid = low + (high - low) / 2;\\n          int leftCount = 0;\\n          int rightCount = 0;\\n          int midCount = 0;\\n          for(int i : nums){\\n            if(i == mid){\\n              ++midCount;\\n            }else if(i >= low && i < mid){ //[low, mid]\\n              ++leftCount;\\n            }else if(i > mid && i < high){ //(mid, high)\\n              ++rightCount;\\n            }\\n          }\\n          if(midCount > 1){\\n            return mid;\\n          }else if(leftCount > (mid - low)){//[1, 4) 3\\n            high = mid;\\n          }else if(rightCount > (high - mid - 1)){//(4, 8) 3\\n            low = mid + 1;\\n          }\\n          \\n        }\\n        return low;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73105,
                "title": "a-java-solution-o-n-time-and-o-1-space",
                "content": "    public int findDuplicate(int[] nums) {\\n        int fast, slow;\\n\\t\\t\\n\\t\\tfast = slow = nums[0];\\n\\t\\t\\n\\t\\tdo {\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t} while (fast != slow);\\n\\t\\t\\n\\t\\tslow = nums[0];\\n\\t\\twhile (fast != slow) {\\n\\t\\t\\tfast = nums[fast];\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn fast;\\n    }\\n\\nThese numbers constitute a linked list and the value of the node (a array cell) is the index of the next node, and there must be a cycle. Therefore, we use the classical \"fast and slow pointers\". And you can read the detail which is given at [findArrayDuplicate][1].\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate",
                "solutionTags": [],
                "code": "    public int findDuplicate(int[] nums) {\\n        int fast, slow;\\n\\t\\t\\n\\t\\tfast = slow = nums[0];\\n\\t\\t\\n\\t\\tdo {\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t} while (fast != slow);\\n\\t\\t\\n\\t\\tslow = nums[0];\\n\\t\\twhile (fast != slow) {\\n\\t\\t\\tfast = nums[fast];\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn fast;\\n    }\\n\\nThese numbers constitute a linked list and the value of the node (a array cell) is the index of the next node, and there must be a cycle. Therefore, we use the classical \"fast and slow pointers\". And you can read the detail which is given at [findArrayDuplicate][1].\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate",
                "codeTag": "Java"
            },
            {
                "id": 1280737,
                "title": "short-simple-o-n-linear-time-o-1-space-single-pass-dry-run-c",
                "content": "### ***WE WILL BE DISCUSSING TWO SOLUTIONS FOR THIS PROBLEM***\\n\\n### 1. BUT THIS SOLUTION MODIFIES THE GIVEN ARRAY :\\n* **DRY RUN FOR THE FIRST SOLUTION IS GIVEN BELOW  [ALSO FINDS THE MISSING ELEMENT ] :)**\\n```\\n/* Traverse the array from start to end.\\nFor every element,take its absolute value and if the abs(array[i])\\u2018th element is positive, the element has not encountered before, \\nelse if negative the element has been encountered before print the absolute value of the current element. */\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[abs(nums[i])] >= 0) nums[abs(nums[i])] = -nums[abs(nums[i])];\\n            else{\\n                ans = abs(nums[i]); break;\\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(N)`, where N: total number of elements** \\n**SPACE COMPLEXITY :` O(1)`, (constant Aux. space)**\\n\\nif you find any mistakes pls, drop a comment\\n**if it makes any sense don\\'t forget to** **Upvote**\\n\\n```\\n/*The idea is to traverse the array and mark the visited elements.\\n\\nWhile traversing the array, we will use the absolute value of every element as an index and make the value at this index as negative to mark it visited. \\nFor example, for element 3, we will make the value at index 2 as negative ( since the array is 0-indexed ). For any element in the array, \\nif the element at the index {element - 1} is already marked negative, then this is the repeating element. \\n\\nTo find the missing number, we will traverse the array again and look for a positive value. The index at which we find the positive value\\nis our missing number because that index is not present in the array as an element.  \\n\\n \\n\\nFor Example: Consider the array Arr = { 1, 5, 2, 2, 3 }. \\n\\nNow we will traverse the array and mark the visited numbers as follows: \\n\\nAt index 0, we encounter 1. To mark this element as visited, Arr[1 - 1] = - Arr[1 - 1].\\nCurrent array Arr: {-1, 5, 2, 2, 3}. \\n\\nAt index 1, we encounter 5. To mark this element as visited, Arr[5 - 1] = - Arr[5 - 1].\\nCurrent array Arr: {-1, 5, 2, 2, -3}. \\n\\nAt index 2, we encounter 2. To mark this element as visited, Arr[2 - 1] = - Arr[2 - 1].\\nCurrent array Arr: {-1, -5, 2, 2, -3}. \\n\\nAt index 3, again we encounter 2.\\nHere, the element at index 1 (2 - 1), is already negative. It means we have already visited it. Thus, we have found our repeating number \\u2018R\\u2019 which is 2. \\n\\nCurrent array Arr: {-1, -5, 2, 2, -3}. \\n\\nAt index 4, we encounter 3. To mark this element as visited, Arr[3 - 1] = - Arr[3 - 1].\\nCurrent array Arr: {-1, -5, -2, 2, -3}. \\n\\nTo find the missing number \\u2018M\\u2019, we will again traverse the array.\\nWe will find that the element at index 3 is the only positive element. It means that the missing number is 3 + 1 = 4.\\nSo, our missing number \\u2018M\\u2019 is 4 and the repeating number \\u2018R\\u2019 is 2. \\n*/\\n```\\n```\\n```\\n### 2. SOLUTION WITH CONSTANT ARRAY (WITHOUT MODIFICATIONS):\\n```\\n/*We maintain two pointers fast and slow\\nFor each step fast will move to the index that is equal to arr[arr[fast]](two jumps at a time) \\nand slow will move to the index arr[slow](one step at a time)\\nWhen fast==slow that means now we are in a cycle.\\nFast and slow will meet in a circle and the entry point of that circle will be the duplicate element.\\nNow we need to find entry point so we will start with fast=0 and visit one step at a time for both fast and slow.\\nWhen fast==slow that will be entry point.\\nReturn the entry point.\\n*/\\n```\\n```\\nclass Solution {\\npublic:\\nint findDuplicate(vector<int> &arr) {\\n        int n = arr.size();\\n        if (n <= 1) return -1;\\n \\n        // initialize fast and slow\\n        int slow = arr[0], fast = arr[arr[0]];\\n\\n        // loop to enter in the cycle\\n        while (fast != slow) {\\n            slow = arr[slow];         // move one step for slow\\n            fast = arr[arr[fast]];     // move two step for fast\\n        }\\n\\n        // loop to find entry point of the cycle\\n        fast = 0;\\n        while (slow != fast) {\\n            slow = arr[slow];\\n            fast = arr[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY : `O(N)`, where N: total number of elements** \\n**SPACE COMPLEXITY :` O(1)`, (constant Aux. space)**\\n\\n**HOPE THIS ARTICLE WILL ABLE TO HELP YOU**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Traverse the array from start to end.\\nFor every element,take its absolute value and if the abs(array[i])\\u2018th element is positive, the element has not encountered before, \\nelse if negative the element has been encountered before print the absolute value of the current element. */\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[abs(nums[i])] >= 0) nums[abs(nums[i])] = -nums[abs(nums[i])];\\n            else{\\n                ans = abs(nums[i]); break;\\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```\n```\\n/*The idea is to traverse the array and mark the visited elements.\\n\\nWhile traversing the array, we will use the absolute value of every element as an index and make the value at this index as negative to mark it visited. \\nFor example, for element 3, we will make the value at index 2 as negative ( since the array is 0-indexed ). For any element in the array, \\nif the element at the index {element - 1} is already marked negative, then this is the repeating element. \\n\\nTo find the missing number, we will traverse the array again and look for a positive value. The index at which we find the positive value\\nis our missing number because that index is not present in the array as an element.  \\n\\n \\n\\nFor Example: Consider the array Arr = { 1, 5, 2, 2, 3 }. \\n\\nNow we will traverse the array and mark the visited numbers as follows: \\n\\nAt index 0, we encounter 1. To mark this element as visited, Arr[1 - 1] = - Arr[1 - 1].\\nCurrent array Arr: {-1, 5, 2, 2, 3}. \\n\\nAt index 1, we encounter 5. To mark this element as visited, Arr[5 - 1] = - Arr[5 - 1].\\nCurrent array Arr: {-1, 5, 2, 2, -3}. \\n\\nAt index 2, we encounter 2. To mark this element as visited, Arr[2 - 1] = - Arr[2 - 1].\\nCurrent array Arr: {-1, -5, 2, 2, -3}. \\n\\nAt index 3, again we encounter 2.\\nHere, the element at index 1 (2 - 1), is already negative. It means we have already visited it. Thus, we have found our repeating number \\u2018R\\u2019 which is 2. \\n\\nCurrent array Arr: {-1, -5, 2, 2, -3}. \\n\\nAt index 4, we encounter 3. To mark this element as visited, Arr[3 - 1] = - Arr[3 - 1].\\nCurrent array Arr: {-1, -5, -2, 2, -3}. \\n\\nTo find the missing number \\u2018M\\u2019, we will again traverse the array.\\nWe will find that the element at index 3 is the only positive element. It means that the missing number is 3 + 1 = 4.\\nSo, our missing number \\u2018M\\u2019 is 4 and the repeating number \\u2018R\\u2019 is 2. \\n*/\\n```\n```\\n```\n```\\n/*We maintain two pointers fast and slow\\nFor each step fast will move to the index that is equal to arr[arr[fast]](two jumps at a time) \\nand slow will move to the index arr[slow](one step at a time)\\nWhen fast==slow that means now we are in a cycle.\\nFast and slow will meet in a circle and the entry point of that circle will be the duplicate element.\\nNow we need to find entry point so we will start with fast=0 and visit one step at a time for both fast and slow.\\nWhen fast==slow that will be entry point.\\nReturn the entry point.\\n*/\\n```\n```\\nclass Solution {\\npublic:\\nint findDuplicate(vector<int> &arr) {\\n        int n = arr.size();\\n        if (n <= 1) return -1;\\n \\n        // initialize fast and slow\\n        int slow = arr[0], fast = arr[arr[0]];\\n\\n        // loop to enter in the cycle\\n        while (fast != slow) {\\n            slow = arr[slow];         // move one step for slow\\n            fast = arr[arr[fast]];     // move two step for fast\\n        }\\n\\n        // loop to find entry point of the cycle\\n        fast = 0;\\n        while (slow != fast) {\\n            slow = arr[slow];\\n            fast = arr[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705670,
                "title": "off-topic-joma-has-solved-this-problem-before",
                "content": "Good thing is I don\\'t need senpai to help me on this now!\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew&t=18s\\n",
                "solutionTags": [],
                "code": "Good thing is I don\\'t need senpai to help me on this now!\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew&t=18s\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 543300,
                "title": "swift-solution-with-explanation",
                "content": "According to the [solution article](https://leetcode.com/problems/find-the-duplicate-number/solution/), we are already knowing that we can use Floyd\\'s cycle detection algorithm.\\n\\n# Why Using Cycle Detection\\n\\nAccording to the description of this problem, we knowing that the value of the elements might between `1` to `count`.\\n\\nSo the hint tells as we might be ok to see this array as a kind of flow. Base on this, we also can say the value of an elements is represent the next index we can go.\\n\\nFor example, if we have a given array `[1, 3, 4, 2, 3]`\\n\\n``` text\\n+-----+-----+-----+-----+-----+\\n| [0] | [1] | [2] | [3] | [4] |\\n+-----+-----+-----+-----+-----+\\n|  1  |  3  |  4  |  2  |  3  |\\n+-----+-----+-----+-----+-----+\\n```\\n\\nWe started from `[0]`, we found that we start from `1`, then we got `3` at `[1]`, `2` at `[3]` and so on.\\n\\nAnd let\\'s trying to redraw this array into a simple flow. (I am not sure we can call it a state machine or not lol)\\n\\n``` text\\n\\n+---+    +---+    +---+    +---+\\n| 1 | -> | 3 | -> | 2 | -> | 4 |\\n+---+    +---+    +---+    +---+\\n           ^                 |\\n           |                 |\\n           +-----------------+\\n```\\n\\nThen we got a flow has a cycle. And that\\'s the reason why we can use Floyd to solve this problem.\\n\\n## Steps\\n\\nWe can devide this problem into 2 main parts base on Floyd\\'s algorithm.\\n\\n1. Prove the array (or flow) has a cycle, and get the intersection index of slow and fast from it.\\n2. Get the entrance of this cycle by using the intersection index then return the target index.\\n\\nPlease check [wiki](https://en.wikipedia.org/wiki/Cycle_detection#Floyd\\'s_Tortoise_and_Hare) for the detail of Floyd\\'s algorithm.\\n\\n### Traversal (\"1 Step\")\\n\\nSince we have already treat the value of an element as the destination index, our way of traversal will become like this\\n\\n``` swift\\nvar slow = nums[slow]\\n```\\n\\n### Slow-Fast Pointer at Part 1.\\n\\n``` swift\\nslow = nums[slow]           // Take 1 step\\nfast = nums[nums[fast]]     // Take 2 steps\\n```\\n\\nBase on Floyd\\'s algorithm\\'s theory, if there is a loop inside a list, slow and fast pointers will meet on the loop. And that\\'s the reason why we took the `meet` as the way of determine whether a list has a loop or not.\\n\\n## Code\\n\\nBase on the explanation above, we can have a piece of code liked below.\\n\\n``` swift\\nclass Solution {\\n    // Main method\\n    func findDuplicate(_ nums: [Int]) -> Int {\\n        let intersectionIndex = findIntersectionIndex(nums)\\n        return findStartIndex(nums, intersectionIndex)\\n    }\\n    \\n    private func findIntersectionIndex(_ nums: [Int]) -> Int {\\n        var slow = nums[0]\\n        var fast = nums[0]\\n        \\n        repeat {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        } while slow != fast\\n        \\n        return slow\\n    }\\n    \\n    private func findStartIndex(_ nums: [Int], _ intersection: Int) -> Int {\\n        var slow = nums[0]\\n        var fast = intersection\\n        \\n        while slow != fast {\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        }\\n        \\n        return slow\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "``` text\\n+-----+-----+-----+-----+-----+\\n| [0] | [1] | [2] | [3] | [4] |\\n+-----+-----+-----+-----+-----+\\n|  1  |  3  |  4  |  2  |  3  |\\n+-----+-----+-----+-----+-----+\\n```\n``` text\\n\\n+---+    +---+    +---+    +---+\\n| 1 | -> | 3 | -> | 2 | -> | 4 |\\n+---+    +---+    +---+    +---+\\n           ^                 |\\n           |                 |\\n           +-----------------+\\n```\n``` swift\\nvar slow = nums[slow]\\n```\n``` swift\\nslow = nums[slow]           // Take 1 step\\nfast = nums[nums[fast]]     // Take 2 steps\\n```\n``` swift\\nclass Solution {\\n    // Main method\\n    func findDuplicate(_ nums: [Int]) -> Int {\\n        let intersectionIndex = findIntersectionIndex(nums)\\n        return findStartIndex(nums, intersectionIndex)\\n    }\\n    \\n    private func findIntersectionIndex(_ nums: [Int]) -> Int {\\n        var slow = nums[0]\\n        var fast = nums[0]\\n        \\n        repeat {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        } while slow != fast\\n        \\n        return slow\\n    }\\n    \\n    private func findStartIndex(_ nums: [Int], _ intersection: Int) -> Int {\\n        var slow = nums[0]\\n        var fast = intersection\\n        \\n        while slow != fast {\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        }\\n        \\n        return slow\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151461,
                "title": "c-c-java-python-can-it-get-any-shorter-2-solutions-using-o-1-space-without-modifying",
                "content": "# **Find the cycle solution. O(n) time O(1) space**\\nThe problem is simple once you know the trick. Check out [finding cycle in linked list](https://leetcode.com/problems/linked-list-cycle-ii/discuss/151434/2-c++-solutions.-Beat-100.-With-comments-proof-and-description.) for background as to how this finds the start of a cycle.\\n\\nBasically we treat the array elements as an index to another element, this produces a kind of linked list starting at the first element. As each element is in the range [1, n] and there are n + 1 elements, each element will point to a valid index. A cycle will be created when two (or more) duplicates point to the same element. All that remains is to find the start of the cycle.\\n\\n## **C++ Solution**\\n```\\nint findDuplicate(vector<int>& nums) {\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]]))\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast]))\\n    ;\\n  return slow;\\n}\\n```\\nI mean, I know it could get stupid a really ugly compact.\\n```\\n  int fast = nums[nums[0]];\\n  for (int slow = nums[0]; slow != fast; slow = nums[slow], fast = nums[nums[fast]]) ;\\n  for (int slow = 0; slow != fast; slow = nums[slow], fast = nums[fast]) ;\\n  return fast;\\n}\\n```\\t\\t\\nBut that\\'s just dumb.\\n## **C Solution**\\nPretty much exactly the same as c++\\n```c\\nint findDuplicate(int* nums, int numsSize){\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]])) /* Move slow one step, fast two */\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast])) /* Move both one step until they meet now */\\n    ;\\n  return slow;\\n}\\n```\\n## **Java Solution**\\nPretty much exactly the same as c++\\n```java\\npublic int findDuplicate(int[] nums) {\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]]))\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast]))\\n    ;\\n  return slow;\\n}\\n```\\n## **Python Solution**\\nYou can\\'t update the indexes as part of the while loop, so the python solution is slightly longer (though you could update slow and fast on the same line with python.\\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n  slow = nums[0];\\n  fast = nums[nums[0]]\\n  while slow != fast:\\n    slow = nums[slow]\\n    fast = nums[nums[fast]]\\n  slow = 0\\n  while slow != fast:\\n    slow = nums[slow]\\n    fast = nums[fast]\\n  return slow\\n  ```\\n\\n# **Partition search. O(nlogn) time O(1) space**\\nAn alternative solution is to brute force it, guessing possible values and checking if it is the duplicate. How to check though? One way is to use a simple flag, setting it on the first occurance of the target number and returning if the target is seen again. That only gives a true or false indication, can we do better?\\n\\nIf you consider the case of no duplicates, if we are targeting a number `n`, then we would expect there to be `n` numbers equal or below `n`. What about if there is a duplicate? Well if the duplicate is `n` or below, then our count would be over. If the count is equal or less, then the duplicate must be _above_ `n`. That sounds like something we can search on.\\n\\n```\\nint findDuplicate(vector<int>& nums) {\\n  int lo = 0;\\n  int hi = nums.size() - 1;\\n  int mid;\\n  while (lo < hi) {\\n    mid = lo + (hi - lo) / 2;\\n    // Count how many numbers are equal or below the mid, if it is lower than expected then the\\n    // duplicate must be in the upper partition, other wise it\\'s in the lower partition.\\n    if (mid >= std::count_if(nums.begin(), nums.end(), [&mid] (int n) { return n <= mid; })) {\\n      lo = mid + 1;\\n    } else {\\n      hi = mid;\\n    }\\n  }\\n  return hi;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nint findDuplicate(vector<int>& nums) {\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]]))\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast]))\\n    ;\\n  return slow;\\n}\\n```\n```\\n  int fast = nums[nums[0]];\\n  for (int slow = nums[0]; slow != fast; slow = nums[slow], fast = nums[nums[fast]]) ;\\n  for (int slow = 0; slow != fast; slow = nums[slow], fast = nums[fast]) ;\\n  return fast;\\n}\\n```\n```c\\nint findDuplicate(int* nums, int numsSize){\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]])) /* Move slow one step, fast two */\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast])) /* Move both one step until they meet now */\\n    ;\\n  return slow;\\n}\\n```\n```java\\npublic int findDuplicate(int[] nums) {\\n  int slow = 0;\\n  int fast = 0;\\n  while ((slow = nums[slow]) != (fast = nums[nums[fast]]))\\n    ;\\n  slow = 0;\\n  while ((slow = nums[slow]) != (fast = nums[fast]))\\n    ;\\n  return slow;\\n}\\n```\n```python\\ndef findDuplicate(self, nums: List[int]) -> int:\\n  slow = nums[0];\\n  fast = nums[nums[0]]\\n  while slow != fast:\\n    slow = nums[slow]\\n    fast = nums[nums[fast]]\\n  slow = 0\\n  while slow != fast:\\n    slow = nums[slow]\\n    fast = nums[fast]\\n  return slow\\n  ```\n```\\nint findDuplicate(vector<int>& nums) {\\n  int lo = 0;\\n  int hi = nums.size() - 1;\\n  int mid;\\n  while (lo < hi) {\\n    mid = lo + (hi - lo) / 2;\\n    // Count how many numbers are equal or below the mid, if it is lower than expected then the\\n    // duplicate must be in the upper partition, other wise it\\'s in the lower partition.\\n    if (mid >= std::count_if(nums.begin(), nums.end(), [&mid] (int n) { return n <= mid; })) {\\n      lo = mid + 1;\\n    } else {\\n      hi = mid;\\n    }\\n  }\\n  return hi;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72912,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion**https://discuss.leetcode.com/topic/79603/python-solution-with-detailed-explanation\\n\\n**Find the Duplicate Number** https://leetcode.com/problems/find-the-duplicate-number/\\n\\n**Algorithm 1: Change the array:**\\n1. Make every element negative: A[A[i]] = A[A[i]] * -1\\n2. Whenever you see a negative number, it means a dupe.\\n\\n**Find the starting point of the cycle in a linked list with a cycle**\\n1. Model the problem that way. Make sure you remember the solution for that problem.\\n2. nums[a] = b means a.next = b\\n3. Example: [2,5,1,1,4,3]. Model a graph using the indices of this array. If there is a duplicate b, then we will have a1.next = b and a2.next = b and a3.next = b .....Sketch a graph for the above.\\n4. Apply the linked list cycle detection algorithm here.\\n5. https://leetcode.com/discuss/61086/java-time-and-space-solution-similar-find-loop-in-linkedlist\\n\\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        \"\"\"\\n        **Find the starting point of the cycle in a linked list with a cycle**\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        slow = 0\\n        fast = 0\\n        while True:\\n            fast = nums[nums[fast]]\\n            slow = nums[slow]\\n            if slow == fast:\\n                break\\n        slow = 0\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```\\n\\n**Use a binary search variant**\\n1. The array is not sorted - but the indices of the array are sorted - #Insight\\n2. Find the mid index. Call it M.\\n3. Traverse the main array and count all numbers <= M. Say the count is K.\\n4. Say N = 200. Num elements = 201. M = 100. Low=1. High = 200.\\n5. Say K = 101. Then we know original list of 201 elements has 101 elements <= 100. There must be a duplicate from 1 to 100. **So we should check in left half of index space - remember we are searching index space not element space**. high = mid.\\n6. Say K = 100. Then we know original list of 201 elements has 100 elements <= 100. It has 101 elements > 100 or from 101 to 200. So we should search right half of the index space:  **remember we are searching index space not element space** low =mid+1.\\n\\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        if len(nums) == 0:\\n            return 0\\n        low = 1\\n        high = len(nums)\\n        while low < high:\\n            mid = low + int((high-low)>>1)\\n            count = 0\\n            for x in nums:\\n                if x <= mid:\\n                    count = count + 1\\n            if count > mid:\\n                high = mid\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        \"\"\"\\n        **Find the starting point of the cycle in a linked list with a cycle**\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        slow = 0\\n        fast = 0\\n        while True:\\n            fast = nums[nums[fast]]\\n            slow = nums[slow]\\n            if slow == fast:\\n                break\\n        slow = 0\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        if len(nums) == 0:\\n            return 0\\n        low = 1\\n        high = len(nums)\\n        while low < high:\\n            mid = low + int((high-low)>>1)\\n            count = 0\\n            for x in nums:\\n                if x <= mid:\\n                    count = count + 1\\n            if count > mid:\\n                high = mid\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72986,
                "title": "o-n-log2-n-time-and-o-1-space",
                "content": "The value space `S` is `{1,2,3..n}`. Our array `nums` has cardinality `n+1`, so by the pigeonhole principle we must have at least one duplicate.\\n\\nThis solution is inspired on binary search. We're going to look at log2(n) order statistics of `S`, starting with the expected median and then recursing left or right.\\n\\nIn `S`, given median `m`, we have `m` values smaller than or equal to `m` and `m - 1` values bigger than `m`. In `nums` we have a single value `v` that is repeated twice or more. By definition, either `v <= m` or `v > m`. So in `nums` we'll either have more than `m` values smaller than or equal to `m`, or more than `m - 1` values greater than `m`. We can apply this recursively.\\n\\nFor example, for `S = {1,2,3,4,5}` and `nums = [3, 2, 4, 4, 1, 5]`:\\n\\n    median = 3\\n    3 items are smaller than or equal to 3 (as in S)\\n    3 items are greater than 3 (one more than in S)\\n\\nin `S` we have 2 values `> 3`, in `m` we have 3. The repeated value will be on the right. Now we recurse:\\n\\n    Next order statistic = (3 + 5) / 2 = 4\\n    5 items are smaller than or equal to 4 (one more than in S)\\n    1 item is greater than 4 (as in S)\\n\\nWe can't recurse any further, because there is no more value between 3 and 4 in `S`. Therefor, the current value of `m` must be the repeated value `v`.\\n\\nIn code:\\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            l, h, m = 0, len(nums) - 1, len(nums) >> 1\\n            while h - l > 1:\\n                if sum(1 for i in nums if i <= m) > m:\\n                    h = m\\n                else:\\n                    l = m\\n                m = (h + l + 1) >> 1\\n            return m\\n\\nThis ran in 64ms, has time complexity O(n*log2(n)) and space complexity O(1) (I'm not nitpicking about Python versions; I assume the comprehension in `sum` to be a generator). I saw the cycle detection solution as [posted earlier][1], which is faster and really very elegant. But if it took Knuth 24 hours to come up with a O(n) solution, I'm not feeling bad about coming up with this O(nlogn) cutie :-)\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "The value space `S` is `{1,2,3..n}`. Our array `nums` has cardinality `n+1`, so by the pigeonhole principle we must have at least one duplicate.\\n\\nThis solution is inspired on binary search. We're going to look at log2(n) order statistics of `S`, starting with the expected median and then recursing left or right.\\n\\nIn `S`, given median `m`, we have `m` values smaller than or equal to `m` and `m - 1` values bigger than `m`. In `nums` we have a single value `v` that is repeated twice or more. By definition, either `v <= m` or `v > m`. So in `nums` we'll either have more than `m` values smaller than or equal to `m`, or more than `m - 1` values greater than `m`. We can apply this recursively.\\n\\nFor example, for `S = {1,2,3,4,5}` and `nums = [3, 2, 4, 4, 1, 5]`:\\n\\n    median = 3\\n    3 items are smaller than or equal to 3 (as in S)\\n    3 items are greater than 3 (one more than in S)\\n\\nin `S` we have 2 values `> 3`, in `m` we have 3. The repeated value will be on the right. Now we recurse:\\n\\n    Next order statistic = (3 + 5) / 2 = 4\\n    5 items are smaller than or equal to 4 (one more than in S)\\n    1 item is greater than 4 (as in S)\\n\\nWe can't recurse any further, because there is no more value between 3 and 4 in `S`. Therefor, the current value of `m` must be the repeated value `v`.\\n\\nIn code:\\n\\n    class Solution(object):\\n        def findDuplicate(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            l, h, m = 0, len(nums) - 1, len(nums) >> 1\\n            while h - l > 1:\\n                if sum(1 for i in nums if i <= m) > m:\\n                    h = m\\n                else:\\n                    l = m\\n                m = (h + l + 1) >> 1\\n            return m\\n\\nThis ran in 64ms, has time complexity O(n*log2(n)) and space complexity O(1) (I'm not nitpicking about Python versions; I assume the comprehension in `sum` to be a generator). I saw the cycle detection solution as [posted earlier][1], which is faster and really very elegant. But if it took Knuth 24 hours to come up with a O(n) solution, I'm not feeling bad about coming up with this O(nlogn) cutie :-)\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate",
                "codeTag": "Java"
            },
            {
                "id": 4069481,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nDynamic Programming dp O()\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nDynamic Programming dp O()\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2932199,
                "title": "5-different-approach-solution-binary-search-map-sorting",
                "content": "# Binary Search Approach-1\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int n=v.size();\\n       int low=0;\\n       int high=n-1;\\n       int mid;\\n       \\n        while(low <= high){\\n        mid = (low+high)/2;\\n         \\n        if(v[mid] <= mid){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid + 1;\\n        }\\n    }\\n       return low;\\n    }\\n};\\n```\\n# Binary Search Approach-2\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int n=v.size();\\n       int low=0;\\n       int high=n-1;\\n       int mid;\\n       \\n       while(low<high){\\n         mid=(high+low)/2;\\n         if(mid==0){\\n           if(v[mid]==v[mid+1]){\\n               return v[mid];\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n         }\\n         else if(mid==n-1){\\n            if(v[mid]==v[mid-1]){\\n               return v[mid];\\n           }\\n           else{\\n               high=mid-1;\\n           }\\n         }\\n         else{\\n             if(v[mid]==v[mid+1] || v[mid]==v[mid-1]){\\n                 return v[mid];\\n               }\\n            else{\\n             if(v[mid]<=mid){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         } \\n       }\\n    return 0;\\n    }\\n};\\n```\\n# Normal Approach without extra space\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int a=0;\\n       for(int i=0;i<v.size()-1;i++){\\n           if(v[i]==v[i+1]){\\n               a= v[i];\\n           }\\n       }\\n       return a;\\n    }\\n};\\n```\\n# Using HashMap in O(n) time complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<n;i++){\\n            cnt[v[i]]++;\\n        }\\n        for(int i=0;i<n+5;i++){\\n            if(cnt[i]>1){\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Additional approach in O(1) space\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<n && v[i]==com){\\n                freq++;\\n                i++;\\n            }\\n            i--;\\n            if(freq>1){\\n                ans=com;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int n=v.size();\\n       int low=0;\\n       int high=n-1;\\n       int mid;\\n       \\n        while(low <= high){\\n        mid = (low+high)/2;\\n         \\n        if(v[mid] <= mid){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid + 1;\\n        }\\n    }\\n       return low;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int n=v.size();\\n       int low=0;\\n       int high=n-1;\\n       int mid;\\n       \\n       while(low<high){\\n         mid=(high+low)/2;\\n         if(mid==0){\\n           if(v[mid]==v[mid+1]){\\n               return v[mid];\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n         }\\n         else if(mid==n-1){\\n            if(v[mid]==v[mid-1]){\\n               return v[mid];\\n           }\\n           else{\\n               high=mid-1;\\n           }\\n         }\\n         else{\\n             if(v[mid]==v[mid+1] || v[mid]==v[mid-1]){\\n                 return v[mid];\\n               }\\n            else{\\n             if(v[mid]<=mid){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         } \\n       }\\n    return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n       sort(v.begin(),v.end());\\n       int a=0;\\n       for(int i=0;i<v.size()-1;i++){\\n           if(v[i]==v[i+1]){\\n               a= v[i];\\n           }\\n       }\\n       return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<n;i++){\\n            cnt[v[i]]++;\\n        }\\n        for(int i=0;i<n+5;i++){\\n            if(cnt[i]>1){\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<n && v[i]==com){\\n                freq++;\\n                i++;\\n            }\\n            i--;\\n            if(freq>1){\\n                ans=com;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013321,
                "title": "python-o-n-time-and-o-1-space-optimal-easy-to-understand-solution",
                "content": "Intuition: \\nUse the 2 pointers approach of LinkedList Cycle problem. \\nSince there is a duplicate number, we can always say that cycle will be formed.\\n\\nThe slow pointer moves by one step and the fast pointer moves by 2 steps and there exists a cycle so the first collision is bound to happen.\\n\\nThen start a pointer from 0 and another pointer from current slow\\'s position.\\nThe point where both collide will be the duplicate element.\\n\\n![image](https://assets.leetcode.com/users/images/921ee645-59a8-4fde-a744-ad7b6b5fc56e_1651830407.5786445.png)\\n\\nLet\\u2019s assume the distance between the first element and the first collision is a. So slow pointer has traveled a distance while fast(since moving 2 steps at a time) has traveled 2a distance. For slow and a fast pointer to collide 2a-a=a should be multiple of the length of cycle, Now we place a fast pointer to start. Assume the distance between the start and duplicate to be x. So now the distance between slow and duplicate shows also be x, as seen from the diagram, and so now fast and slow pointer both should move by one step.\\n\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        # Use concept of 142. Linked List Cycle II (find the node where linked list has cycle)\\n        \\n        # start hopping from Node\\n        slow, fast = 0, 0\\n        # Cycle detection\\n        # Let slow jumper and fast jumper meet somewhere in the cycle \\n        while True:\\n            # slow jumper hops 1 step, while fast jumper hops two steps forward.\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            \\n            if slow == fast:\\n                break\\n        \\n        # for locating start node of cycle\\n        check = 0\\n        while True:\\n            # Locate the start node of cycle (i.e., the duplicate number)\\n            slow = nums[slow]\\n            check = nums[check]\\n            \\n            if check == slow:\\n                break\\n        \\n        return check\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        # Use concept of 142. Linked List Cycle II (find the node where linked list has cycle)\\n        \\n        # start hopping from Node\\n        slow, fast = 0, 0\\n        # Cycle detection\\n        # Let slow jumper and fast jumper meet somewhere in the cycle \\n        while True:\\n            # slow jumper hops 1 step, while fast jumper hops two steps forward.\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            \\n            if slow == fast:\\n                break\\n        \\n        # for locating start node of cycle\\n        check = 0\\n        while True:\\n            # Locate the start node of cycle (i.e., the duplicate number)\\n            slow = nums[slow]\\n            check = nums[check]\\n            \\n            if check == slow:\\n                break\\n        \\n        return check\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893283,
                "title": "94-faster-c-3-liner-solution",
                "content": "\\n**//94% Faster using swap**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint findDuplicate(vector<int>& nums) {\\n\\t\\t\\twhile(nums[0]!=nums[nums[0]])\\n\\t\\t\\tswap(nums[0],nums[nums[0]]);\\n\\t\\t\\treturn nums[0];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**//hashmap solution**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint findDuplicate(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int,int>m;\\n\\t\\t\\tfor(auto i:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\t}\\n\\t\\t\\tint ans;\\n\\t\\t\\tfor(auto j:m)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(j.second>=2)ans=j.first;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\n**//bruteforce solution**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint findDuplicate(vector<int>& nums) {\\n\\t\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\t\\tint ans;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.size() - 1; i++) \\n\\t\\t\\t\\t\\tif (nums[i] == nums[i + 1])\\n\\t\\t\\t\\t\\t\\t return ans=nums[i];\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint findDuplicate(vector<int>& nums) {\\n\\t\\t\\twhile(nums[0]!=nums[nums[0]])\\n\\t\\t\\tswap(nums[0],nums[nums[0]]);\\n\\t\\t\\treturn nums[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 342853,
                "title": "solution-in-python-3-o-n-speed-and-o-1-memory",
                "content": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n    \\tt, h = nums[0], nums[nums[0]]\\n    \\twhile t != h: t, h = nums[t], nums[nums[h]]\\n    \\tt = 0\\n    \\twhile t != h: t, h = nums[t], nums[h]\\n    \\treturn t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n    \\tt, h = nums[0], nums[nums[0]]\\n    \\twhile t != h: t, h = nums[t], nums[nums[h]]\\n    \\tt = 0\\n    \\twhile t != h: t, h = nums[t], nums[h]\\n    \\treturn t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 4062535,
                "title": "floyd-s-tortoise-and-hare-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n#### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n. The approach used here is known as Floyd\\'s Tortoise and Hare (Cycle Detection) algorithm. It efficiently finds the duplicate element in an array with a time complexity of O(n) and a space complexity of O(1).\\n\\nHere\\'s a step-by-step explanation of the approach implemented in the code:\\n\\n- Initialize two integer variables, slow and fast, to 0. These two pointers will be used to traverse the vector nums.\\n\\n- Use a do-while loop to perform the following steps until slow and fast pointers meet:\\n\\n- Update the slow pointer by moving it to the element at the index nums[slow] in the nums vector.\\n- Update the fast pointer by moving it to the element at the index nums[nums[fast]] in the nums vector. The fast pointer moves twice as fast as the slow pointer.\\n- This loop continues until the slow and fast pointers meet at the same element within the array. This meeting point is within the cycle of duplicates in the array.\\n\\n- After the slow and fast pointers have met, reset the slow pointer to the beginning (0 index) of the array while keeping the fast pointer at the meeting point.\\n\\n- Use a while loop to traverse the array again with both slow and fast pointers. Increment both pointers one step at a time in each iteration.\\n\\n- The while loop continues until slow and fast meet again. The point where they meet is the duplicate element in the nums vector.\\n\\n- Return the value pointed to by slow as the duplicate element.\\n\\nThe idea behind this algorithm is to detect a cycle in the array. The slow and fast pointers move within the array, and since there is a duplicate element, they will eventually meet at some point within the cycle. The second traversal ensures that the duplicate element is found.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![upvote.png](https://assets.leetcode.com/users/images/082ac6f6-d9db-406f-921e-8af2e085d1ec_1695096028.791172.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0;\\n        int fast = 0;\\n        do\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        // in this place they have met so now slow will point oward oth index and traverse along long ,and where tehy meet that is duplicate\\n        slow =0;\\n        while(slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0;\\n        int fast = 0;\\n        do\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        // in this place they have met so now slow will point oward oth index and traverse along long ,and where tehy meet that is duplicate\\n        slow =0;\\n        while(slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219126,
                "title": "c-explained-diff-approach-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution 1:**\\n***Brute Force with sorting => Time Complexity:O(Nlogn + N)***\\n```\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int answer;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i] == nums[i+1])\\n            {\\n                answer =  nums[i]; \\n                break;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n**Solution 2:**\\n***Optimized Approach => Time Complexity:O(N)***\\n```\\n// Optimized Approach => Time Complexity:O(N)\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int answer;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.second > 1)\\n            {\\n                answer = i.first;\\n                break;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n**Solution 3:**\\n**More Optimized Approach (Floyd Warshall) => Time Complexity:O(N), Space Complexity => O(1)**\\n```\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        while (true)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n            if(slow==fast)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        fast = nums[0];\\n        while(slow!=fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int answer;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i] == nums[i+1])\\n            {\\n                answer =  nums[i]; \\n                break;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```\\n// Optimized Approach => Time Complexity:O(N)\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int answer;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.second > 1)\\n            {\\n                answer = i.first;\\n                break;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        while (true)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n            if(slow==fast)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        fast = nums[0];\\n        while(slow!=fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937700,
                "title": "binary-search-with-dry-run-explanation-javascript",
                "content": "```\\n\\n/*\\n* Focus on the indexes, not the values\\n  1. Find the mid point\\n  2. For each mid point, count how many elements are before. By count I don\\'t mean the sum.\\n  3. If count > mid then search left side because count should not exeeded mid\\n  4. Else left = mid +1;\\n*/\\n\\n/*\\n    Example:\\n    \\n    \\n     L     M     R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n\\n    Midpoint is 2\\n    \\n    - Count the number of elements in the array less than or equal to 2\\n    - There are 3 elements less than or equal to 2. This means count is > midpoint of 2\\n    - Because count is 3 and the midpoint is 2, it shows there may be a duplicate on the left side between L and M pointer\\n    - This is because, if there was no duplicate, then count would equal the midpoint\\n    - Mid = right;\\n\\n     L  M  R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n\\n    Midpoint is now 1\\n    \\n    - Count the number of elements in the array less than or equal to 1\\n    - There\\'s only 1 element less than or equal to 1. Count is equal to the midpoint. \\n    - This means there\\'s no duplicates of 1\\n    - Mid = left+1;\\n    \\n           L\\n           M\\n           R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n    \\n    - Count the number of elements in the array less than or equal to 2\\n    - There\\'s 3 elements less than or equal to 2. \\n    - Return left - answer is 2\\n\\n*/\\n\\n\\nvar findDuplicate = function(nums) {\\n    \\n    if(nums.length === 0 || nums === null) return 0;\\n    \\n    let left = 1;\\n    let right = nums.length -1;\\n    \\n    while(left < right){\\n        \\n        const mid = Math.floor(left + (right-left)/2);\\n        \\n        let count = 0;\\n        \\n        for(let i=0; i < nums.length; i++){\\n            if(nums[i] <= mid) count++\\n        }\\n        \\n        \\n        if(count > mid){\\n            right = mid;\\n        }else{\\n            left = mid +1;\\n        }\\n        \\n        count = 0;\\n    }\\n    \\n    return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n/*\\n* Focus on the indexes, not the values\\n  1. Find the mid point\\n  2. For each mid point, count how many elements are before. By count I don\\'t mean the sum.\\n  3. If count > mid then search left side because count should not exeeded mid\\n  4. Else left = mid +1;\\n*/\\n\\n/*\\n    Example:\\n    \\n    \\n     L     M     R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n\\n    Midpoint is 2\\n    \\n    - Count the number of elements in the array less than or equal to 2\\n    - There are 3 elements less than or equal to 2. This means count is > midpoint of 2\\n    - Because count is 3 and the midpoint is 2, it shows there may be a duplicate on the left side between L and M pointer\\n    - This is because, if there was no duplicate, then count would equal the midpoint\\n    - Mid = right;\\n\\n     L  M  R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n\\n    Midpoint is now 1\\n    \\n    - Count the number of elements in the array less than or equal to 1\\n    - There\\'s only 1 element less than or equal to 1. Count is equal to the midpoint. \\n    - This means there\\'s no duplicates of 1\\n    - Mid = left+1;\\n    \\n           L\\n           M\\n           R\\n     0  1  2  3  4\\n    [1, 3, 4, 2, 2]\\n    \\n    - Count the number of elements in the array less than or equal to 2\\n    - There\\'s 3 elements less than or equal to 2. \\n    - Return left - answer is 2\\n\\n*/\\n\\n\\nvar findDuplicate = function(nums) {\\n    \\n    if(nums.length === 0 || nums === null) return 0;\\n    \\n    let left = 1;\\n    let right = nums.length -1;\\n    \\n    while(left < right){\\n        \\n        const mid = Math.floor(left + (right-left)/2);\\n        \\n        let count = 0;\\n        \\n        for(let i=0; i < nums.length; i++){\\n            if(nums[i] <= mid) count++\\n        }\\n        \\n        \\n        if(count > mid){\\n            right = mid;\\n        }else{\\n            left = mid +1;\\n        }\\n        \\n        count = 0;\\n    }\\n    \\n    return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893724,
                "title": "python-o-1-space-o-n-time-with-bitwise-ops",
                "content": "```\\nclass Solution:\\n    \"\"\"Treat each number in the list as the target bit to set\"\"\"\\n    \"\"\"If the target bit is already 1, we have a dup\"\"\"\\n    \"\"\"\\n    Tbh this is the first approach i had in mind with the space restriction, \\n    plus the no manipulation to the original array thing, \\n    I thought I cant modify the original array at all, (no sorting, swapping), well. \\n    \"\"\"\\n\\n    \"\"\"\\n    The lc bit manipulation solution def performs better both space and time wise, \\n    since I might be dealing with some crazy large bits here,\\n    but I felt like it overcomplicated stuff too much, \\n    like during a 40 min interview with 2 questions, no way I coulda come up with that I aint no jeff dean\\n    \"\"\"\\n\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        temp = 0\\n        for num in nums:\\n            if self.check_bit(temp, num): return num\\n            temp = self.set_bit(temp, num)\\n    \\n    def set_bit(self, value, bit):\\n        return value | (1<<bit)\\n    \\n    def check_bit(self, value, bit):\\n        return (1 << bit) & value\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"Treat each number in the list as the target bit to set\"\"\"\\n    \"\"\"If the target bit is already 1, we have a dup\"\"\"\\n    \"\"\"\\n    Tbh this is the first approach i had in mind with the space restriction, \\n    plus the no manipulation to the original array thing, \\n    I thought I cant modify the original array at all, (no sorting, swapping), well. \\n    \"\"\"\\n\\n    \"\"\"\\n    The lc bit manipulation solution def performs better both space and time wise, \\n    since I might be dealing with some crazy large bits here,\\n    but I felt like it overcomplicated stuff too much, \\n    like during a 40 min interview with 2 questions, no way I coulda come up with that I aint no jeff dean\\n    \"\"\"\\n\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        temp = 0\\n        for num in nums:\\n            if self.check_bit(temp, num): return num\\n            temp = self.set_bit(temp, num)\\n    \\n    def set_bit(self, value, bit):\\n        return value | (1<<bit)\\n    \\n    def check_bit(self, value, bit):\\n        return (1 << bit) & value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893013,
                "title": "c-2-simplest-solutions-binary-search-two-pointers-w-explanation",
                "content": "We need to return the duplicate element from ```nums``` (size = n +1), where ```nums[i]``` is in the range of ```[1, n]``` **without altering the given array** & in **constant extra space**\\n\\n**APPROACH 1 :**\\n\\n* We can perform binary search on the intergers in the range ```[1, n]```.\\n\\n* First, we start with ```l = 1``` & ```r = n``` (or ```r = nums.size() - 1```).\\n\\n* While ```l <= r```, we do the following :\\n\\n           1. mid = l + (r-l)/2;\\n           \\n           2. We traverse nums & count the numbers that are <= mid.\\n           \\n           3. If the count is less than equal to mid => No number in the range ```[1, mid]``` is repeated. So we decrement the range of search to [mid + 1, r]\\n           \\n           4. But if it\\'s more => Some number in that range is repeated. So we only have to search the range [l, mid-1].\\n           \\n           5. Finally, we return l.\\n           \\n\\n**Time Complexity :** O(nlogn)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size(), l = 1, r = n-1;\\n        \\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            int cnt = 0;\\n            \\n            for(auto num : nums) if(num <= mid) cnt++;\\n            \\n            if(cnt <= mid) l = mid+1;\\n            \\n            else r = mid-1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```\\n\\n**APPROACH 2 :**\\n\\n* We use 2 pointers ```fast``` & ```slow``` both start at ```nums[0]```.\\n\\n* While ```fast != slow```, each time we do : ```fast = nums[nums[fast]]``` & ```slow = nums[slow]```.\\n\\n* Then, we set back ```slow``` to ```nums[0]```.\\n\\n* Now, we do ```slow = nums[slow] & fast = nums[fast]``` until ```slow != fast```. Then we return \\n```slow``` --> The repeated element.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n\\tint findDuplicate(vector& nums) {\\n\\t\\tint n = nums.size(), slow = nums[0], fast = nums[0];\\n\\t\\tdo {\\n\\t\\t\\t\\n\\t\\t\\tslow=nums[slow];\\n\\t\\t\\tfast=nums[nums[fast]];\\n\\t\\t\\t\\n\\t\\t}while(slow!=fast);\\n\\n\\t\\tslow=nums[0];\\n\\t\\twhile(slow != fast) {\\n\\t\\t\\n\\t\\t\\tslow=nums[slow];\\n\\t\\t\\tfast=nums[fast];\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn slow;\\n}\\n};\\n```\\n\\n\\n**Do upvote if you\\'ve found my solutions helpful :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```nums```\n```nums[i]```\n```[1, n]```\n```[1, n]```\n```l = 1```\n```r = n```\n```r = nums.size() - 1```\n```l <= r```\n```[1, mid]```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size(), l = 1, r = n-1;\\n        \\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            int cnt = 0;\\n            \\n            for(auto num : nums) if(num <= mid) cnt++;\\n            \\n            if(cnt <= mid) l = mid+1;\\n            \\n            else r = mid-1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```\n```fast```\n```slow```\n```nums[0]```\n```fast != slow```\n```fast = nums[nums[fast]]```\n```slow = nums[slow]```\n```slow```\n```nums[0]```\n```slow = nums[slow] & fast = nums[fast]```\n```slow != fast```\n```slow```\n```\\nclass Solution {\\npublic:\\n\\tint findDuplicate(vector& nums) {\\n\\t\\tint n = nums.size(), slow = nums[0], fast = nums[0];\\n\\t\\tdo {\\n\\t\\t\\t\\n\\t\\t\\tslow=nums[slow];\\n\\t\\t\\tfast=nums[nums[fast]];\\n\\t\\t\\t\\n\\t\\t}while(slow!=fast);\\n\\n\\t\\tslow=nums[0];\\n\\t\\twhile(slow != fast) {\\n\\t\\t\\n\\t\\t\\tslow=nums[slow];\\n\\t\\t\\tfast=nums[fast];\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn slow;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478286,
                "title": "python-binary-search-with-search-space-based-on-range-o-nlogn",
                "content": "Problem is basically the same as - https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\n\\nSearch space is from 1..N, therefore run a binary search and count the number of elements in array where count <= mid\\n\\nif `count <= mid`, this means that the number `mid` doesn\\'t contain any duplicates. E.g) if `mid=3` and the array is `3,5,4,2,1,4`, count will be 3 since `1,2,3` <= 3 for each element in that list\\nif `count > mid` this means that mid must be a duplicate, therefore `right = mid`\\n\\n\\tdef findDuplicate(self, nums: List[int]) -> int:\\n        # contains n+1 integers but search space of range 1..N\\n        \\n        # only one repeated number therefore find the num that is repeated (count)\\n        \\n        left,right = 1, len(nums)-1\\n        \\n\\t\\t# Loop is O(logn), excluding the inner-loop, total is O(nlogn)\\n        while left < right:\\n            mid = left + (right - left)//2\\n            \\n            count = 0\\n            \\n\\t\\t\\t# O(n)\\n            for i in nums:\\n                if i <= mid:\\n                    count+=1\\n            \\n            if count <= mid:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Problem is basically the same as - https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\n\\nSearch space is from 1..N, therefore run a binary search and count the number of elements in array where count <= mid\\n\\nif `count <= mid`, this means that the number `mid` doesn\\'t contain any duplicates. E.g) if `mid=3` and the array is `3,5,4,2,1,4`, count will be 3 since `1,2,3` <= 3 for each element in that list\\nif `count > mid` this means that mid must be a duplicate, therefore `right = mid`\\n\\n\\tdef findDuplicate(self, nums: List[int]) -> int:\\n        # contains n+1 integers but search space of range 1..N\\n        \\n        # only one repeated number therefore find the num that is repeated (count)\\n        \\n        left,right = 1, len(nums)-1\\n        \\n\\t\\t# Loop is O(logn), excluding the inner-loop, total is O(nlogn)\\n        while left < right:\\n            mid = left + (right - left)//2\\n            \\n            count = 0\\n            \\n\\t\\t\\t# O(n)\\n            for i in nums:\\n                if i <= mid:\\n                    count+=1\\n            \\n            if count <= mid:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return left",
                "codeTag": "Python3"
            },
            {
                "id": 1267942,
                "title": "3-method-brute-better-optimal-easiest-explaination-c-beginner-friendly",
                "content": "```\\nMethod 1 \\nTC -O(Nlogn)   *Nlogn for sorting (Merge Sort Internally*+N in worse case for searching if \"i==i+1 break;\" i.e *Nlogn +N=~Nlogn*\\nSC- Constant O(1)  *No External DS used here* \\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n              if(nums[i]==nums[i+1])\\n                {\\n                    a=nums[i];\\n                    break;\\n                }\\n            \\n        }\\n        \\n        return a;\\n    }\\n};\\n\\nMethod 2\\nTC -O(N )  *N i.e for iterating in nums vector + 0(logN) in just checking in set (Contains)function and as we Consider the Higher order while considering the asymptotic calculation so O( N+logN)=0(N) we ignore the lower i.e logN*\\nSC- Constant O(n) *As we took set another Data Structure i.e  SET*\\nCheck every time that if set contains that particular element whichever we are iterating right now in the nums vector ..If YES then return that particular element else add it int the set.\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        set<int>s;\\n        for(auto it:nums)\\n        {\\n            if(s.count(it)!=0)\\n            {\\n                return it;\\n            }\\n            s.insert(it);\\n        }\\n        return 0;\\n    }\\n};\\nMethod 3\\n\\nTC -O(N )  *N i.e just for iterating in nums vector *\\n\\nSC- Constant O(1) *As we took Nothing extra here\\n(NOTE:-Variable are not considered while Calculating  Space Complexity and TC*\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n     While islie nhi use kre rhe kyunki turant match hojaega aur *instant fuck hojaega*\\n        do\\n        {\\n            slow=nums[slow];//1 step\\n            fast=nums[nums[fast]]; //2 step\\n        }while(slow!=fast);\\n        \\n        \\n        *Ab akhir mein jab match kr gya hoga to tum ek ko shuru mei lejao aur ek ek krke badhao*\\n        slow=nums[0];\\n        while(slow!=fast)\\n        {\\n         slow=nums[slow];\\n        fast=nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\nThanks for giving it a read!!Good Luck\\n```**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nMethod 1 \\nTC -O(Nlogn)   *Nlogn for sorting (Merge Sort Internally*+N in worse case for searching if \"i==i+1 break;\" i.e *Nlogn +N=~Nlogn*\\nSC- Constant O(1)  *No External DS used here* \\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n              if(nums[i]==nums[i+1])\\n                {\\n                    a=nums[i];\\n                    break;\\n                }\\n            \\n        }\\n        \\n        return a;\\n    }\\n};\\n\\nMethod 2\\nTC -O(N )  *N i.e for iterating in nums vector + 0(logN) in just checking in set (Contains)function and as we Consider the Higher order while considering the asymptotic calculation so O( N+logN)=0(N) we ignore the lower i.e logN*\\nSC- Constant O(n) *As we took set another Data Structure i.e  SET*\\nCheck every time that if set contains that particular element whichever we are iterating right now in the nums vector ..If YES then return that particular element else add it int the set.\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        set<int>s;\\n        for(auto it:nums)\\n        {\\n            if(s.count(it)!=0)\\n            {\\n                return it;\\n            }\\n            s.insert(it);\\n        }\\n        return 0;\\n    }\\n};\\nMethod 3\\n\\nTC -O(N )  *N i.e just for iterating in nums vector *\\n\\nSC- Constant O(1) *As we took Nothing extra here\\n(NOTE:-Variable are not considered while Calculating  Space Complexity and TC*\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n     While islie nhi use kre rhe kyunki turant match hojaega aur *instant fuck hojaega*\\n        do\\n        {\\n            slow=nums[slow];//1 step\\n            fast=nums[nums[fast]]; //2 step\\n        }while(slow!=fast);\\n        \\n        \\n        *Ab akhir mein jab match kr gya hoga to tum ek ko shuru mei lejao aur ek ek krke badhao*\\n        slow=nums[0];\\n        while(slow!=fast)\\n        {\\n         slow=nums[slow];\\n        fast=nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\nThanks for giving it a read!!Good Luck\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961032,
                "title": "python-bitmap-idea-o-1-space",
                "content": "```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        x = 0\\n        for num in nums:\\n            if x & 1 << num:\\n                return num\\n            else:\\n                x |= 1 << num\\n```",
                "solutionTags": [],
                "code": "```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        x = 0\\n        for num in nums:\\n            if x & 1 << num:\\n                return num\\n            else:\\n                x |= 1 << num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 785600,
                "title": "best-method-using-slow-and-fast-pointer-c-fast-and-efficient-video-explanation",
                "content": "Link to Video :- https://youtu.be/HZ7Ly5EVTcs\\n\\nDo check this out :- I have explained all the Naive-Better-Best approach to this question!!\\n// O(N) Time and O(1) Space\\n\\n\\n```\\nint findDuplicate(vector<int>& nums) {        \\n        int slow = nums[0],fast = nums[0];\\n//         In this loop we will find the collision point\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n                    }\\n        while(slow != fast);\\n        \\n//         fast will be intizialized to the starting point \\n        fast = nums[0];\\n        \\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow ;\\n    }\\n\\n\\n```\\n\\n**Please do upvote if you liked the solution and video!!**\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findDuplicate(vector<int>& nums) {        \\n        int slow = nums[0],fast = nums[0];\\n//         In this loop we will find the collision point\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n                    }\\n        while(slow != fast);\\n        \\n//         fast will be intizialized to the starting point \\n        fast = nums[0];\\n        \\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow ;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72842,
                "title": "c-easiest-solution-5-lines",
                "content": "The following code is done in max O(n) time and without any extra space.\\n\\nIt uses a simple idea based on the constraint given that for an array with n+1 elements, each element can have a value between 1 to n. So we can store the occurrence of a number in that array itself.\\n\\nConsider the example,\\nIf you find 1 in somewhere in the array. You can simply make the value of a[1] negative. This will give you a count that you have seen a \"1\" in the array. Now whenever you get \"1\" again in the array and when you try to check a[1] ..... it will already be negative confirming that it is the element which is the duplicate\\n\\nSometime you will come at element which is already made negative by someone before(meaning that its index is the number which is already observed). Hence you have to take abs to handle that.\\n\\n```\\nint findDuplicate(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(nums[abs(nums[i])] < 0)\\n                return abs(nums[i]);\\n            \\n                nums[abs(nums[i])]*= -1;\\n        }\\n        return 0;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\nint findDuplicate(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(nums[abs(nums[i])] < 0)\\n                return abs(nums[i]);\\n            \\n                nums[abs(nums[i])]*= -1;\\n        }\\n        return 0;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062644,
                "title": "easy-solution-2-approach-c-explain",
                "content": "\\n# Code\\n### Approach 1\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ind = 0;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if(nums[i] == nums[i+1])\\n            {\\n                ind = nums[i];\\n                break;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n\\n```\\n\\n### Approach 2\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0, fast = 0;\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n\\n        slow = 0;\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```\\n\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/b5a57665-f683-4246-b5ff-dbeb4851108c_1695098099.8289697.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ind = 0;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < nums.size() - 1; i++)\\n        {\\n            if(nums[i] == nums[i+1])\\n            {\\n                ind = nums[i];\\n                break;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0, fast = 0;\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n\\n        slow = 0;\\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147482,
                "title": "cpp-solution-using-floyd-tortoise-method-with-added-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0,fast = 0,inters = 0;\\n\\t\\t//we make sure that the pointers have entered the loop, a loop is created when we encounter duplicate\\n        while(true){\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n            if (fast ==slow){\\n                break;\\n            }\\n        }\\n\\t\\t//now we start an iterating from beginning as well as the slow pointr\\'s current value, and they\\'ll meet exactly at the repeated value\\n        while(true){\\n            slow = nums[slow];\\n            inters = nums[inters];\\n            if (inters == slow){\\n                return slow;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = 0,fast = 0,inters = 0;\\n\\t\\t//we make sure that the pointers have entered the loop, a loop is created when we encounter duplicate\\n        while(true){\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n            if (fast ==slow){\\n                break;\\n            }\\n        }\\n\\t\\t//now we start an iterating from beginning as well as the slow pointr\\'s current value, and they\\'ll meet exactly at the repeated value\\n        while(true){\\n            slow = nums[slow];\\n            inters = nums[inters];\\n            if (inters == slow){\\n                return slow;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893362,
                "title": "javascript-o-n-time-and-o-1-space-faster-than-90-19-of-javascript-submissions",
                "content": "``` \\n// Same as detecting cycle in linked list using Floyd\\'s Cycle Detection.\\nvar findDuplicate = function (nums) {\\n  let slow = 0,\\n    fast = 0;\\n  while (true) {\\n    slow = nums[slow];\\n    fast = nums[nums[fast]];\\n\\n    if (slow === fast) break;\\n  }\\n  let newSlow = 0;\\n  while (slow !== newSlow) {\\n    slow = nums[slow];\\n    newSlow = nums[newSlow];\\n  }\\n  return newSlow;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\n// Same as detecting cycle in linked list using Floyd\\'s Cycle Detection.\\nvar findDuplicate = function (nums) {\\n  let slow = 0,\\n    fast = 0;\\n  while (true) {\\n    slow = nums[slow];\\n    fast = nums[nums[fast]];\\n\\n    if (slow === fast) break;\\n  }\\n  let newSlow = 0;\\n  while (slow !== newSlow) {\\n    slow = nums[slow];\\n    newSlow = nums[newSlow];\\n  }\\n  return newSlow;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893098,
                "title": "bit-manipulation-explained",
                "content": "# The idea \\nWe will compare the bit count of all the numbers in *[1,n]* with the numbers in the array. The duplicated number will leave a trail of bits. We\\'ll use that trail of bits to construct our answer, bit by bit.\\n\\n# Examples\\nFor simplicity we\\'ll follow an example with `nums` in order, but that is not necessary.\\n```\\nnums = [1,2,3,4,5,6,6,7,8]\\n\\nnums          [1,8]\\nin            in\\nbinary:       binary:\\n0001          0000\\n0010          0001\\n0011          0010\\n0100          0011\\n0101          0100\\n0110          0101\\n0110          0110\\n0111          0111\\n1000          1000\\n____          ____\\n1554          1444   ->  difference:   0110 = 6\\n```\\nWe can see that when we count the bits in each position for all the numbers in `nums` and the bits for all the numbers in `[1,8]` the extra bits are precisely those of the number `6`, the repeated number.\\n\\nNote this still works fine **even if the duplicate appears more than two times**:\\n```\\nnums = [1,2,6,6,6,6,6,7,8]\\n\\nnums          [1,8]\\nin            in\\nbinary:       binary:\\n0001          0000\\n0010          0001\\n0110          0010\\n0110          0011\\n0110          0100\\n0110          0101\\n0110          0110\\n0111          0111\\n1000          1000\\n____          ____\\n1672          1444   ->  difference:   023(-2) ~~> 6\\n```\\n\\nWe can see that the positions where the counts are over `0` are precisely the positions where the duplicate, `6`, has `1`s in its binary expansion. A positive difference means we had extra bits in that position, thus giving us a clue of what the repeated number was.\\n\\n# The algorithm\\nFor each possible bit used in the numbers in *[1,n]* we will count how many of the numbers in `nums` use that bit, and compare that with the count we would get looking only at the numbers from in *[1,n]* **only once**. If the difference of the counts is positive, we add that bit to our answer.\\n\\n# The code\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        \\n        n = len(nums) - 1\\n\\t\\t# gives the maximum binary length of a number in [1,n]\\n        max_length = n.bit_length()\\n        ans = 0\\n        \\n        for j in range(max_length):\\n\\t\\t\\t# moves the bits in 1 j positons to the left\\n\\t\\t\\t# thus mask has a 1 in the j-th position and 0s everywhere else\\n            mask = 1 << j\\n            count = 0\\n            for i in range(n + 1):\\n\\t\\t\\t\\t# if nums[i] has a 1 in the j-th position\\n                if nums[i] & mask > 0:\\n                    count += 1\\n\\t\\t\\t\\t# if i has a 1 in the j-th position\\n                if i & mask > 0:\\n                    count -= 1\\n\\t\\t\\t#if we found extra 1s in the j-th position add that bit to ans\\n            if count > 0:\\n                ans |= mask\\n                    \\n        return ans\\n```\\n# Comments\\n`max_length` is about *log<sub>2</sub>(n)*, so **this solution runs in O(n log(n)) time**.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nnums = [1,2,3,4,5,6,6,7,8]\\n\\nnums          [1,8]\\nin            in\\nbinary:       binary:\\n0001          0000\\n0010          0001\\n0011          0010\\n0100          0011\\n0101          0100\\n0110          0101\\n0110          0110\\n0111          0111\\n1000          1000\\n____          ____\\n1554          1444   ->  difference:   0110 = 6\\n```\n```\\nnums = [1,2,6,6,6,6,6,7,8]\\n\\nnums          [1,8]\\nin            in\\nbinary:       binary:\\n0001          0000\\n0010          0001\\n0110          0010\\n0110          0011\\n0110          0100\\n0110          0101\\n0110          0110\\n0111          0111\\n1000          1000\\n____          ____\\n1672          1444   ->  difference:   023(-2) ~~> 6\\n```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        \\n        n = len(nums) - 1\\n\\t\\t# gives the maximum binary length of a number in [1,n]\\n        max_length = n.bit_length()\\n        ans = 0\\n        \\n        for j in range(max_length):\\n\\t\\t\\t# moves the bits in 1 j positons to the left\\n\\t\\t\\t# thus mask has a 1 in the j-th position and 0s everywhere else\\n            mask = 1 << j\\n            count = 0\\n            for i in range(n + 1):\\n\\t\\t\\t\\t# if nums[i] has a 1 in the j-th position\\n                if nums[i] & mask > 0:\\n                    count += 1\\n\\t\\t\\t\\t# if i has a 1 in the j-th position\\n                if i & mask > 0:\\n                    count -= 1\\n\\t\\t\\t#if we found extra 1s in the j-th position add that bit to ans\\n            if count > 0:\\n                ans |= mask\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874359,
                "title": "python-solutions",
                "content": "\\u274C **Bruteforce Approach** (Not Recommended)\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]: return nums[i]\\n```\\n***\\n```Time Complexity: O(N*N)```\\n```Space Complexity: O(1)```\\n***\\n\\u2714 **Solution 2:** (Using Set)\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        s = set()\\n        for i in nums:\\n            if i in s: return i\\n            s.add(i)\\n```\\n***\\n```Time Complexity: O(N)```\\n```Space Complexity: O(N)```\\n***\\n\\u2714 **Solution 3:** (Pigeonhole principle)\\n\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums[abs(i)] < 0: return abs(i)\\n            nums[abs(i)] *= -1\\n```\\n***\\n```Time Complexity: O(N)```\\n```Space Complexity: O(1) But array is modified``` \\n***\\n\\u2714**Solution 4:** (Slow and Fast pointer)\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow, fast = nums[nums[0]], nums[nums[nums[0]]]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        start = nums[0]\\n        while start != slow:\\n            start = nums[start]\\n            slow = nums[slow]\\n        return start\\n```\\n***\\n```Time Complexity: O(N)```\\n```Space Complexity: O(1)``` \\n***\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]: return nums[i]\\n```\n```Time Complexity: O(N*N)```\n```Space Complexity: O(1)```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        s = set()\\n        for i in nums:\\n            if i in s: return i\\n            s.add(i)\\n```\n```Time Complexity: O(N)```\n```Space Complexity: O(N)```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums[abs(i)] < 0: return abs(i)\\n            nums[abs(i)] *= -1\\n```\n```Time Complexity: O(N)```\n```Space Complexity: O(1) But array is modified```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow, fast = nums[nums[0]], nums[nums[nums[0]]]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        start = nums[0]\\n        while start != slow:\\n            start = nums[start]\\n            slow = nums[slow]\\n        return start\\n```\n```Time Complexity: O(N)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1340913,
                "title": "without-floyds-algorithm-sorting-in-o-n-time-and-o-1-space-with-explanation-c",
                "content": "If we can sort the given array in O(n) time then we can just find a duplicate in O(1) by checking adjacents.\\nBut we do not need to find the adjacents separately we can figure out the duplicate while sorting the array.\\n\\n# Intuition\\nSo it\\'s given that elements of the array are in the range from 1 to n, then it gives me intuition that while traversing the array, any element that I will encounter I already know its position in the sorted array. \\nLike I encountered 5 at position 2 then we know that this element should be at position 5 (1-based indexing).\\n# Sorting array in O(n)\\nSo what if we just swap the element at that positions, that would mean we fixed the current element position at its actual position in the sorted array but now we have some new element at the current position so we need to do the same thing with this element that we did above so that this element gets to it actual position and we keep doing this until the current element is not equal to its current position.\\n# Checking duplicate\\nNow in case when we encounter duplicate element then we must have already fixed this element place in the past, which mean at position equal to the current element in the array we already have this element which makes this our checking condition for a duplicate. Hence whenever we encounter this situation then it\\'s mean that this element is a duplicate.\\n\\nTime Complexity: O(n) \\nSpace Complexity: O(1)\\n\\nNote: The code below assume 0-based indexing.\\n```\\nint findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            while(nums[i]!=i+1) {\\n                int element = nums[i];\\n                if(nums[element-1]!=element) \\n\\t\\t\\t\\t\\tswap(nums[element-1],nums[i]);\\n                else \\n\\t\\t\\t\\t\\treturn element;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "If we can sort the given array in O(n) time then we can just find a duplicate in O(1) by checking adjacents.\\nBut we do not need to find the adjacents separately we can figure out the duplicate while sorting the array.\\n\\n# Intuition\\nSo it\\'s given that elements of the array are in the range from 1 to n, then it gives me intuition that while traversing the array, any element that I will encounter I already know its position in the sorted array. \\nLike I encountered 5 at position 2 then we know that this element should be at position 5 (1-based indexing).\\n# Sorting array in O(n)\\nSo what if we just swap the element at that positions, that would mean we fixed the current element position at its actual position in the sorted array but now we have some new element at the current position so we need to do the same thing with this element that we did above so that this element gets to it actual position and we keep doing this until the current element is not equal to its current position.\\n# Checking duplicate\\nNow in case when we encounter duplicate element then we must have already fixed this element place in the past, which mean at position equal to the current element in the array we already have this element which makes this our checking condition for a duplicate. Hence whenever we encounter this situation then it\\'s mean that this element is a duplicate.\\n\\nTime Complexity: O(n) \\nSpace Complexity: O(1)\\n\\nNote: The code below assume 0-based indexing.\\n```\\nint findDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            while(nums[i]!=i+1) {\\n                int element = nums[i];\\n                if(nums[element-1]!=element) \\n\\t\\t\\t\\t\\tswap(nums[element-1],nums[i]);\\n                else \\n\\t\\t\\t\\t\\treturn element;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1149317,
                "title": "6-different-ways-of-doing-this-bonus-cyclic-sort",
                "content": "Some of these are syntactic sugar, but cyclic sort is a different approach not given in LC solution page. If modifying the input is not allowed, use Floyd Cycle Detection algorithm as mentioned in LC solution.\\n\\n```java\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_CyclicSortWay(int[] nums) {\\n        int i = 0;\\n        while (i < nums.length) {\\n            if (nums[i] != nums[nums[i]]) swap(nums, i, nums[i]);\\n            else i++;\\n        }\\n        return nums[0];\\n    }\\n\\t\\n\\tpublic void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n\\n\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_FloydCycleDetection_AnotherWay(int[] nums) {\\n        if (nums.length == 0) return -1;\\n        int slow = nums[0], fast = nums[nums[0]];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n        slow = 0;\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_FloydCycleDetection(int[] nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        slow = nums[0];\\n\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_ModifyInput(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = abs(nums[i]);\\n            if (nums[val] < 0) return val;\\n            nums[val] *= -1;\\n        }\\n        return -1;\\n    }\\n\\n    // TC: O(n), SC: O(n)\\n    public int findDuplicate_SetApproach(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) return num;\\n            set.add(num);\\n        }\\n        return 0;\\n    }\\n\\n    // TC: O(nlogn), SC: O(1)\\n    public int findDuplicate_SortApproach(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) return nums[i];\\n        }\\n        return -1;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```java\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_CyclicSortWay(int[] nums) {\\n        int i = 0;\\n        while (i < nums.length) {\\n            if (nums[i] != nums[nums[i]]) swap(nums, i, nums[i]);\\n            else i++;\\n        }\\n        return nums[0];\\n    }\\n\\t\\n\\tpublic void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n\\n\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_FloydCycleDetection_AnotherWay(int[] nums) {\\n        if (nums.length == 0) return -1;\\n        int slow = nums[0], fast = nums[nums[0]];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n        slow = 0;\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_FloydCycleDetection(int[] nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        slow = nums[0];\\n\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n\\n    // TC: O(n), SC: O(1)\\n    public int findDuplicate_ModifyInput(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = abs(nums[i]);\\n            if (nums[val] < 0) return val;\\n            nums[val] *= -1;\\n        }\\n        return -1;\\n    }\\n\\n    // TC: O(n), SC: O(n)\\n    public int findDuplicate_SetApproach(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) return num;\\n            set.add(num);\\n        }\\n        return 0;\\n    }\\n\\n    // TC: O(nlogn), SC: O(1)\\n    public int findDuplicate_SortApproach(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) return nums[i];\\n        }\\n        return -1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070058,
                "title": "100-java-explanation-easy-to-understand",
                "content": "/**\\n        *The idea behind this problem is transforming the values to index (given in the problem  range [1, n]                      inclusive.)\\n         then mark the place by negating it \\n        * Now if there is a duplicate it will also go and try to negate but find it to be already negated that means \\n          we got our duplicate number.\\n        **/\\n\\t\\t\\n```\\nclass Solution {\\n   \\n    public int findDuplicate(int[] nums) {\\n    \\n        int val = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            val = Math.abs(nums[i]);\\n            val--;\\n            if(nums[val] < 0) {\\n                return  Math.abs(nums[i]);\\n            } else {\\n                nums[val] = -nums[val];\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    public int findDuplicate(int[] nums) {\\n    \\n        int val = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            val = Math.abs(nums[i]);\\n            val--;\\n            if(nums[val] < 0) {\\n                return  Math.abs(nums[i]);\\n            } else {\\n                nums[val] = -nums[val];\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705377,
                "title": "c-3-different-approaches",
                "content": "I\\'ve seen many solutions using Floyd\\'s algorithm, a few solutions using binary search but none using the bonus approach mentioned at the end!\\n\\n**Approach 1: Floyd\\'s Algorithm**\\n\\nMaintain 2 pointers, a tortoise moving one-step forward and a hare moving two-steps forward. You will need to spend time understanding this algorithms because at first it will seem like magic. I won\\'t go into the depth here but you can read [this](https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle) page which gives a short explanation as to why it works. For a more in-depth explanation, read [Wikipedia](https://en.wikipedia.org/wiki/Cycle_detection).\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint slow, fast;\\n\\tslow = fast = 0;\\n\\t\\n\\t// floyd\\'s algorithm\\n\\tdo {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[nums[fast]];\\n\\t} while (slow != fast);\\n\\n\\t// find the entrance to the cyle\\n\\tslow = 0;\\n\\twhile (slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[fast];\\n\\t}\\n\\n\\treturn slow;\\n}\\n```\\n\\n**Complexity:**\\n* Time: `O(n)`\\n* Space: `O(1)`\\n\\n\\n**Approach 2: Binary Search**\\n\\nWe know the range of the values are form `1` to `n`. We can binary search this range to find the duplicate element. At each step, we compute the `number of values \\u2264 mid`, let\\'s call this `x`. If `x` is greater than `mid`, then we know the range `1` to `mid` contains duplicates. If not, then the range `mid + 1` to `n` contains duplicates.\\n\\nUsing the property, we binary search on either the left side or the right side. Look into the implementation for more details.\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint mid, low = 1, high = nums.size();\\n\\n\\t// helper function\\n\\tauto good = [&](int x) -> bool {\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int& num: nums)\\n\\t\\t\\tcnt += num <= x;\\n\\t\\treturn cnt > x;\\n\\t};\\n\\n\\t// binary search\\n\\twhile (low < high) {\\n\\t\\tmid = (low + high) / 2;\\n\\t\\tif (good(mid))\\n\\t\\t\\thigh = mid;\\n\\t\\telse\\n\\t\\t\\tlow = mid + 1;\\n\\t}\\n\\n\\treturn high;\\n}\\n```\\n\\n**Complexity:**\\n* Time: `O(n \\u2022 log n)`\\n* Space: `O(1)`\\n\\n\\n**Bonus: Using the bit information**\\n\\nThis is perhaps the most different approach. Here, we keep track of the bit information in array called `bit`. For each _bit_ position from `0` to `31` (using zero-indexing), we count the number of ones present for each number from `1` to `n`. This array contains the count of ones in each bit position assuming there are no duplicates.\\n\\nNow what happens if there is a duplicate? Let\\'s say the duplicate is `11` or in binary `1011`. Then in each of the bit positions `{0, 1, 3}` there is an additional one.\\n\\nFrom this, we get the following: count the number of ones in each _bit_ position from `0` to `31` for each number in nums. If the value of ones is greater than the actual count stored in `bit[i]`, then add one to the position `i`.\\n\\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint dup = 0;\\n\\tvector<int> bit(32);\\n\\tint n = nums.size() - 1;\\n\\n\\t// precompute\\n\\tfor (int b = 0; b < 32; b++)\\n\\t\\tfor (int x = 1; x <= n; x++)\\n\\t\\t\\tbit[b] += (x >> b) & 1;\\n\\t\\n\\t// find the duplicate\\n\\tfor (int b = 0; b < 32; b++) {\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int& num: nums)\\n\\t\\t\\tcnt += (num >> b) & 1;\\n\\t\\tdup |= (cnt > bit[b]) << b;\\n\\t}\\n\\n\\treturn dup;\\n}\\n```\\n\\n**Complexity:**\\n* Time: `O(n \\u2022 32) = O(n)`\\n* Space: `O(32) = O(1)`\\n\\nPlease feel free to ask any questions you may have. Hopefully that helps!",
                "solutionTags": [],
                "code": "```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint slow, fast;\\n\\tslow = fast = 0;\\n\\t\\n\\t// floyd\\'s algorithm\\n\\tdo {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[nums[fast]];\\n\\t} while (slow != fast);\\n\\n\\t// find the entrance to the cyle\\n\\tslow = 0;\\n\\twhile (slow != fast) {\\n\\t\\tslow = nums[slow];\\n\\t\\tfast = nums[fast];\\n\\t}\\n\\n\\treturn slow;\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint mid, low = 1, high = nums.size();\\n\\n\\t// helper function\\n\\tauto good = [&](int x) -> bool {\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int& num: nums)\\n\\t\\t\\tcnt += num <= x;\\n\\t\\treturn cnt > x;\\n\\t};\\n\\n\\t// binary search\\n\\twhile (low < high) {\\n\\t\\tmid = (low + high) / 2;\\n\\t\\tif (good(mid))\\n\\t\\t\\thigh = mid;\\n\\t\\telse\\n\\t\\t\\tlow = mid + 1;\\n\\t}\\n\\n\\treturn high;\\n}\\n```\n```cpp\\nint findDuplicate(vector<int>& nums) {\\n\\tint dup = 0;\\n\\tvector<int> bit(32);\\n\\tint n = nums.size() - 1;\\n\\n\\t// precompute\\n\\tfor (int b = 0; b < 32; b++)\\n\\t\\tfor (int x = 1; x <= n; x++)\\n\\t\\t\\tbit[b] += (x >> b) & 1;\\n\\t\\n\\t// find the duplicate\\n\\tfor (int b = 0; b < 32; b++) {\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int& num: nums)\\n\\t\\t\\tcnt += (num >> b) & 1;\\n\\t\\tdup |= (cnt > bit[b]) << b;\\n\\t}\\n\\n\\treturn dup;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705366,
                "title": "total-fit-correct-way-in-js-floyd-s-tortoise-and-hare-algo",
                "content": "```\\n\\n// using floyd\\'s tortoise and hare algorithm\\nvar findDuplicate = function(nums) {\\n \\n let tortoise=nums[0];\\n let hare=nums[tortoise];\\n\\n // first phase tortoise will move 1 step at a time and hare will move 2   \\n while(tortoise !== hare)\\n {\\n  tortoise=nums[tortoise];\\n  hare=nums[nums[hare]];\\n }\\n    \\n tortoise=0;\\n \\n // In  second phase both will move one step at a time\\n while(tortoise !== hare)\\n {\\n  tortoise=nums[tortoise];\\n  hare=nums[hare];\\n }\\n\\n return hare;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n// using floyd\\'s tortoise and hare algorithm\\nvar findDuplicate = function(nums) {\\n \\n let tortoise=nums[0];\\n let hare=nums[tortoise];\\n\\n // first phase tortoise will move 1 step at a time and hare will move 2   \\n while(tortoise !== hare)\\n {\\n  tortoise=nums[tortoise];\\n  hare=nums[nums[hare]];\\n }\\n    \\n tortoise=0;\\n \\n // In  second phase both will move one step at a time\\n while(tortoise !== hare)\\n {\\n  tortoise=nums[tortoise];\\n  hare=nums[hare];\\n }\\n\\n return hare;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 72920,
                "title": "my-o-n-time-o-sqrt-n-space-solution",
                "content": "I understand that the problem explicitly asks for a constant space solution, however I found this algorithm that allows you to find duplicates in linear time using just sqrt(n) memory.\\n\\nOne of the advantages of this algorithm is that is also decides if there are no duplicates in the array (in this case I returned -1).\\n\\n**Explanation** \\n\\nSplit the numbers from 1 to n in sqrt(n) ranges so that range i corresponds to [sqrt(n) * i .. sqrt(n) * (i + 1)).\\n\\nDo one pass through the stream of numbers and figure out how many numbers fall in each of the ranges.\\n\\nAt least one of the ranges will contain more than sqrt(n) elements.\\n\\nDo another pass and process just those elements in the oversubscribed range.\\n\\nUsing a hash table to keep frequencies, you\\u2019ll find a repeated element.\\n\\nThis is O(sqrt(n)) memory and 2 sequential passes through the stream.\\n\\n```\\npublic class Solution {\\n    public int findDuplicate(int[] a) {\\n            int bucketLen = (int)Math.sqrt(a.length);\\n\\t    int[] freq = new int[bucketLen + 1];\\n\\t    for(Integer i : a) {\\n\\t        freq[Math.min(i/bucketLen - (i%bucketLen == 0?1:0), bucketLen)]++;\\n\\t    }\\n\\t    \\n\\t    int i = 0;\\n\\t    while(i < bucketLen && freq[i] <= bucketLen) i++;\\n\\t    \\n\\t    Set<Integer> found = new HashSet<Integer>();\\n\\t    for(Integer v : a) {\\n\\t        if(i*bucketLen < v && (i==freq.length-1 || v <= (i+1)*bucketLen)) {\\n\\t            if(found.contains(v)) return v;\\n\\t            found.add(v);\\n\\t        }\\n\\t    }\\n\\n\\t    return -1;\\n    }\\n}\\n```\\nHope you find this helpful :)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findDuplicate(int[] a) {\\n            int bucketLen = (int)Math.sqrt(a.length);\\n\\t    int[] freq = new int[bucketLen + 1];\\n\\t    for(Integer i : a) {\\n\\t        freq[Math.min(i/bucketLen - (i%bucketLen == 0?1:0), bucketLen)]++;\\n\\t    }\\n\\t    \\n\\t    int i = 0;\\n\\t    while(i < bucketLen && freq[i] <= bucketLen) i++;\\n\\t    \\n\\t    Set<Integer> found = new HashSet<Integer>();\\n\\t    for(Integer v : a) {\\n\\t        if(i*bucketLen < v && (i==freq.length-1 || v <= (i+1)*bucketLen)) {\\n\\t            if(found.contains(v)) return v;\\n\\t            found.add(v);\\n\\t        }\\n\\t    }\\n\\n\\t    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 72929,
                "title": "o-nlogn-binary-search-and-o-n-circle-detect",
                "content": "The special of this problem is its space limitation\\n\\n> 1. You must not modify the array (assume the array is read only).\\n> 2. You must use only constant, O(1) extra space.\\n\\nSo, we could turn to Binary Search on values (not the index). I'm still learning this approach. What I could conclude is that:\\n\\nSuppose there is an unsorted array with `n` elements, each element is less than `N`, how could we find the `k`th smallest element?\\n\\n![0_1480497634375_upload-efc9a5d3-221d-4080-aea3-104af07cea6f](/uploads/files/1480497637382-upload-efc9a5d3-221d-4080-aea3-104af07cea6f.png) \\n\\nWe could tweak it to fit finding the duplicate one:\\n\\n```ruby\\n  def find_duplicate(nums)\\n    left, right = 1, nums.max\\n\\n    while left < right\\n      mid = (left + right)/2\\n\\n      count = nums.count{|x| x <= mid}\\n\\n      if count > mid\\n        right = mid\\n      else\\n        left = mid + 1\\n      end\\n    end\\n\\n    left\\n  end\\n```\\n\\nP.S. There is also a `O(n)` solution. I'm working on it.\\n\\n- - -\\n\\n*Update*\\n\\nOh, I love this problem. The `O(n)` solution makes use of **Circle Detection** in a perfect way. I've checked several posts in the discussion. Here is my note:\\n\\nFirst, we could transfer the problem into a linked list one, as it says\\n\\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\\n\\n![0_1480513558264_upload-5ab3fbe9-fe5a-4fed-87d9-c8a6dc51a945](/uploads/files/1480513561443-upload-5ab3fbe9-fe5a-4fed-87d9-c8a6dc51a945.png)\\n\\nThen I learnt [Floyd's cycle-finding algorithm](https://www.wikiwand.com/en/Cycle_detection): Two pointers, `slow` runs 1 step each time and `fast` runs 2, would definitely meet if there is a cycle.\\n\\nWell, they might meet any position in the circle, how would we find the entry point?\\n\\n![0_1480514894297_LeetCode_287_Circle_Detect.2.png](/uploads/files/1480514898071-leetcode_287_circle_detect.2.png) \\n\\nWhat we know\\n\\n1. `fast` has run `a+b+c+b` steps, and `slow` with `a+b` steps\\n2. `fast` runs double steps of `slow`\\n\\nWe could conclude that\\n\\n```\\na+b+c+b = 2*(a+b)\\n# => a == c\\n```\\n\\nIt means, steps between start point to circle entry equals steps between meet point to circle entry. So when we find the meet point, we could set a new pointer at start position, which would meet `slow` at the entry point.\\n\\nCode\\n\\n```ruby\\n  def find_duplicate(nums)\\n    slow, fast = nums[0], nums[ nums[0] ]\\n\\n    # A loop guaranteed\\n    while slow != fast\\n      slow = nums[slow]\\n      fast = nums[ nums[fast] ]\\n    end\\n\\n    # Set a tag at start point. It would meet slow at the entry of circle.\\n    tag = 0\\n    while tag != slow\\n      tag  = nums[tag]\\n      slow = nums[slow]\\n    end\\n\\n    return slow\\n  end\\n\\n```\\n\\nReference:\\n\\n+ [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/linked_list_cycle.html)\\n\\n+ [My easy understood solution with O(n) time and O(1) space without modifying the array. With clear explanation.](https://discuss.leetcode.com/topic/25913/my-easy-understood-solution-with-o-n-time-and-o-1-space-without-modifying-the-array-with-clear-explanation)",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```ruby\\n  def find_duplicate(nums)\\n    left, right = 1, nums.max\\n\\n    while left < right\\n      mid = (left + right)/2\\n\\n      count = nums.count{|x| x <= mid}\\n\\n      if count > mid\\n        right = mid\\n      else\\n        left = mid + 1\\n      end\\n    end\\n\\n    left\\n  end\\n```\n```\\na+b+c+b = 2*(a+b)\\n# => a == c\\n```\n```ruby\\n  def find_duplicate(nums)\\n    slow, fast = nums[0], nums[ nums[0] ]\\n\\n    # A loop guaranteed\\n    while slow != fast\\n      slow = nums[slow]\\n      fast = nums[ nums[fast] ]\\n    end\\n\\n    # Set a tag at start point. It would meet slow at the entry of circle.\\n    tag = 0\\n    while tag != slow\\n      tag  = nums[tag]\\n      slow = nums[slow]\\n    end\\n\\n    return slow\\n  end\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 72969,
                "title": "three-different-solutions-from-worst-to-best-in-c-well-commented",
                "content": "  \\nThe first solution is quite intuitive and direct but it's not the answer since it will cost another extra O(n) space which is not allowed by the problem. But it's quite simple and easy-understanding, so here it is.\\n\\n----------\\n\\n\\n    //AC - 8ms - using linear space;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        int* arr = (int*)malloc(sizeof(int)*size);\\n        memset(arr, 0, sizeof(int)*size);\\n        for(int i = 0; i < size; i++)\\n        {\\n            arr[nums[i]]++;\\n            if(arr[nums[i]] > 1)\\n                return nums[i];\\n        }\\n        return 0;\\n    }\\n\\n\\n----------\\n\\nThe second solution is to use binary search to search the duplicate considering pigeon hole rule which is quite direct in this case. [1, n] inclusive in the array whose index ranges from [0, n] inclusive, so counting the number less than or equal to the middle can accelerate the searching process.\\n\\n    \\n    //nlogn time cost and constant space cost;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        int l=1, h=size-1;\\n        while(l < h)\\n        {\\n            int m = (l+h)/2;\\n            int count = 0;\\n            for(int i = 0; i < size; i++)\\n                if(nums[i]>=l && nums[i]<=m) count++;\\n            if(count <= m-l+1) l = m+1;\\n            else h = m;\\n        }\\n        return l;\\n    }\\n\\n\\n----------\\n\\nThe last solution is quite awesome adopting the feature of the linked list in this condition. Reading the comments can be enough to understand the whole thread.\\n    \\n    //AC - 4ms - using constant space and linear time;\\n    //similar to find the start of the loop in a linked list;\\n    //the integer is the pointer while the index is the link;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        if(size > 0)\\n        {\\n            int slow = nums[0];\\n            int fast = nums[nums[0]];\\n            while(slow != fast) //check the existence of the loop;\\n            {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n            }\\n            fast = 0;\\n            while(slow != fast) //find the start of the loop which means at least two integer are the same value;\\n            {\\n                slow = nums[slow];\\n                fast = nums[fast];\\n            }\\n            return slow;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "  \\nThe first solution is quite intuitive and direct but it's not the answer since it will cost another extra O(n) space which is not allowed by the problem. But it's quite simple and easy-understanding, so here it is.\\n\\n----------\\n\\n\\n    //AC - 8ms - using linear space;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        int* arr = (int*)malloc(sizeof(int)*size);\\n        memset(arr, 0, sizeof(int)*size);\\n        for(int i = 0; i < size; i++)\\n        {\\n            arr[nums[i]]++;\\n            if(arr[nums[i]] > 1)\\n                return nums[i];\\n        }\\n        return 0;\\n    }\\n\\n\\n----------\\n\\nThe second solution is to use binary search to search the duplicate considering pigeon hole rule which is quite direct in this case. [1, n] inclusive in the array whose index ranges from [0, n] inclusive, so counting the number less than or equal to the middle can accelerate the searching process.\\n\\n    \\n    //nlogn time cost and constant space cost;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        int l=1, h=size-1;\\n        while(l < h)\\n        {\\n            int m = (l+h)/2;\\n            int count = 0;\\n            for(int i = 0; i < size; i++)\\n                if(nums[i]>=l && nums[i]<=m) count++;\\n            if(count <= m-l+1) l = m+1;\\n            else h = m;\\n        }\\n        return l;\\n    }\\n\\n\\n----------\\n\\nThe last solution is quite awesome adopting the feature of the linked list in this condition. Reading the comments can be enough to understand the whole thread.\\n    \\n    //AC - 4ms - using constant space and linear time;\\n    //similar to find the start of the loop in a linked list;\\n    //the integer is the pointer while the index is the link;\\n    int findDuplicate(int* nums, int size)\\n    {\\n        if(size > 0)\\n        {\\n            int slow = nums[0];\\n            int fast = nums[nums[0]];\\n            while(slow != fast) //check the existence of the loop;\\n            {\\n                slow = nums[slow];\\n                fast = nums[nums[fast]];\\n            }\\n            fast = 0;\\n            while(slow != fast) //find the start of the loop which means at least two integer are the same value;\\n            {\\n                slow = nums[slow];\\n                fast = nums[fast];\\n            }\\n            return slow;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4063493,
                "title": "python-easy-find-the-duplicate-number",
                "content": "******First Approach:******  Modifying the original array (which is not allowed)\\n[see the successfully accepted Submission](https://leetcode.com/submissions/detail/1053371761/)\\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n\\n        nums.sort()\\n        \\n        length = len(nums)\\n\\n        for i in range(1, length):\\n            if nums[i] == nums[i - 1]:\\n                return nums[i]\\n\\n        return length\\n```\\n[see the successfully Accepted submission](https://leetcode.com/submissions/detail/1053371761/)\\nCode Intuition:\\n\\n1) **Sorting the List:** The first step is to sort the input list nums using `nums.sort()`. Sorting is performed to bring duplicate elements together. After sorting, if there are duplicates in the list, they will be adjacent to each other.\\n```\\nnums.sort()\\n```\\n\\n2) **Finding Duplicate by Scanning:** After sorting, the method enters a loop that starts from the second element `index 1` and goes up to the last element `index length - 1`. This is because, in a sorted list, duplicates will be adjacent to each other.\\n```\\nlength = len(nums)\\n```\\n3) **Comparing Adjacent Elements:** Inside the loop, it compares the current element at `index i (nums[i]) with the previous element at index i - 1 (nums[i - 1])`. If these two elements are equal, it means a duplicate has been found, and the method returns the duplicate value immediately.\\n```\\n        for i in range(1, length):\\n            if nums[i] == nums[i - 1]:\\n                return nums[I]\\n```\\n\\n4) **No Duplicate Found:** If the loop completes without finding any adjacent equal elements, it means there are no duplicates in the list. In this case, the method returns the `length` of the sorted list, which is length, as a signal that no duplicates were detected.\\n```\\nreturn length\\n```\\n\\n******Second Approach:****** without modifying the original array\\n[see the successfully accepted Submission](https://leetcode.com/submissions/detail/1053515625/)\\n\\nIt is not allowed to change the list(Thanks for LeetCode community who mentioned it). So let\\'s use another approach such as \"Floyd\\'s Tortoise and Hare\" (Cycle Detection) algorithm to find the duplicate element in the nums array without modifying it. It finds the element where the cycle (duplicate) starts in a linked-list-like representation of the array.\\n\\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        \\n        # 1) We need two pointers. Let\\'s Initialize them:\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        # 2) We must move the pointers: a) one pointer at a time and b) the other pointer twice as fast\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            \\n            # 3) When the pointers meet, it indicates the presence of a cycle\\n            if slow == fast:\\n                break\\n        \\n        # 4) The, we reset one pointer to the start\\n        slow = nums[0]\\n        \\n        # 5) Agian, we move pointers, this time we move both pointers one step at a time until they meet again\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        \\n        return slow \\n```\\n\\n![image](https://assets.leetcode.com/users/images/b76152d5-8713-43b5-afe8-a0dc7091caf7_1695112415.530607.jpeg)",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n\\n        nums.sort()\\n        \\n        length = len(nums)\\n\\n        for i in range(1, length):\\n            if nums[i] == nums[i - 1]:\\n                return nums[i]\\n\\n        return length\\n```\n```\\nnums.sort()\\n```\n```\\nlength = len(nums)\\n```\n```\\n        for i in range(1, length):\\n            if nums[i] == nums[i - 1]:\\n                return nums[I]\\n```\n```\\nreturn length\\n```\n```\\nclass Solution(object):\\n    def findDuplicate(self, nums):\\n        \\n        # 1) We need two pointers. Let\\'s Initialize them:\\n        slow = nums[0]\\n        fast = nums[0]\\n        \\n        # 2) We must move the pointers: a) one pointer at a time and b) the other pointer twice as fast\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            \\n            # 3) When the pointers meet, it indicates the presence of a cycle\\n            if slow == fast:\\n                break\\n        \\n        # 4) The, we reset one pointer to the start\\n        slow = nums[0]\\n        \\n        # 5) Agian, we move pointers, this time we move both pointers one step at a time until they meet again\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        \\n        return slow \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039712,
                "title": "1-method-c-java-python-javascript",
                "content": "Read Whole article : https://www.nileshblog.tech/find-duplicate-number/\\n\\nExplanation Eg and handwritten Example explanation  .\\nTime Complexity:\\n\\nO(n) \\n\\nTwo Pointer: O(n log n)\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n\\n![Uploading file...]()\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "Read Whole article : https://www.nileshblog.tech/find-duplicate-number/\\n\\nExplanation Eg and handwritten Example explanation  .\\nTime Complexity:\\n\\nO(n) \\n\\nTwo Pointer: O(n log n)\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/find-duplicate-number/\\n\\n![Uploading file...]()\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3567178,
                "title": "best-o-n-solution",
                "content": "# Approach\\nFloyd\\'s Cycle Detection Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        fast = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        fast = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893643,
                "title": "python-go-3-different-solutions-and-explanations",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F 3 Different Solutions and Explanations \\uD83D\\uDC95\\nApproach 1 and Approach 2 doesn\\'t follow the restriction\\n**You must solve the problem without modifying the array nums and uses only constant extra space.**\\n\\n## 1\\uFE0F\\u20E3 Counter Set Approach (\\u274CExtra Space):\\nSimply creat a hashMap to check whether current number is in our hashmap. If so, we find duplicate number.\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be length of nums\\n* Space: O(N): For counter set at worst take O(N)\\n## Code\\n**Python**\\n```python\\n# Counter Set O(N) | O(N)\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        counter = set()\\n        for num in nums:\\n            if num in counter:\\n                return num\\n            counter.add(num)\\n```\\n**Go**\\n```go\\n/* Counter Set O(N) | O(N) */\\nfunc findDuplicate(nums []int) int {\\n    counter := make(map[int]bool)\\n    for _, num := range(nums){\\n        if _, found := counter[num]; found{\\n            return num\\n        }\\n        counter[num] = true\\n    }\\n    return -1\\n}\\n```\\n## 2\\uFE0F\\u20E3 Index as a Hash Key. Approach (\\u274CModifying the Array):\\nSee [41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/), Since nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\\nWe could make certain index\\'s number negative to represent that current number had been visited.\\nNext time if we visit this index\\'s number find its negative means we found duplicate.\\n\\n**Algo**\\n1. targetIdx = abs(num) - 1 (0-index, so [1,n] would be maps to [0, n-1])\\n2. If nums[targetIdx] <0, visited this num return targetIdx + 1 (We don\\'t return num because num could be negative targetIdx is more straightforward)\\n\\t* Else num[targetIdx] * = -1\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be length of nums\\n* Space: O(1)\\n## Iterative Code\\n**Python**\\n```python\\n# Negative Marking O(N) | O(1)\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            # Find targetIdx\\n            targetIdx = abs(num) - 1\\n            # If already negative means duplicate\\n            if nums[targetIdx] < 0:\\n                return targetIdx + 1\\n            else:\\n                nums[targetIdx] *= -1\\n```\\n**Go**\\n```go\\n// /* Negative Marking O(N) | O(1) */\\nfunc findDuplicate(nums []int) int {\\n    for _, num := range(nums){\\n        // abs for num\\n        if num < 0 {\\n            num *= - 1 \\n        }\\n        // Find targetIdx\\n        targetIdx := num - 1\\n        // If already negative means duplicate\\n        if nums[targetIdx] < 0{\\n            return targetIdx + 1\\n        }\\n        // Make neagative\\n        nums[targetIdx] *= -1\\n    }\\n    return -1\\n}\\n```\\n\\n## 3\\uFE0F\\u20E3 Binary Search Approach:\\nThe way to implement binaray search. Would be counting the numbers before mid value\\nFor example\\n```\\nnums = [1,3,4,2,2] , left = 0, right = 4\\n1. mid = 2 => The numbers <= 2 is 3.\\nIt means we have duplicate number which is smaller than 2. So we search left. Right = 2 - 1\\n2. mid = 1 => The numbers <= 1 is 1.\\nIt means all value from 1 to 1 would not be duplicates\\n```\\nBy applying binary search, We could provide a solution without modifying the array nums and uses only constant extra space.\\n\\n**Algo**\\n1. Init left and right\\n2. Binary Search\\n\\t* Count the numbers in nums <= mid.\\n\\t* If count > mid:\\n\\tSet duplicate = left, and search left\\n\\t* Else:\\n\\tSearch right to find duplicates\\n\\n## Complexity Analysis\\n* Time: O(N logN): Let N be length of nums\\n* Space: O(1)\\n## Code\\n**Python**\\n```python\\n# Binary Search (NlogN) | O(1)     \\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            # Count numbers <= mid\\n            count = sum(num <= mid for num in nums)\\n            if count > mid:\\n                duplicate = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return duplicate\\n```\\n**Go**\\n```go\\n/* Binary Search (NlogN) | O(1) */\\nfunc findDuplicate(nums []int) int {\\n    left, right := 0, len(nums) - 1\\n    duplicate := 0\\n    for left <= right{\\n        mid := (left + right) / 2\\n        count := 0\\n        // Count numbers <= mid\\n        for _,num := range(nums){\\n            if num <= mid{\\n                count++\\n            }\\n        }\\n        // Search left\\n        if count > mid{\\n            duplicate = mid\\n            right = mid - 1\\n        } else { // Search right\\n            left = mid +1\\n        }      \\n    }\\n    return duplicate\\n}\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\n# Counter Set O(N) | O(N)\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        counter = set()\\n        for num in nums:\\n            if num in counter:\\n                return num\\n            counter.add(num)\\n```\n```go\\n/* Counter Set O(N) | O(N) */\\nfunc findDuplicate(nums []int) int {\\n    counter := make(map[int]bool)\\n    for _, num := range(nums){\\n        if _, found := counter[num]; found{\\n            return num\\n        }\\n        counter[num] = true\\n    }\\n    return -1\\n}\\n```\n```python\\n# Negative Marking O(N) | O(1)\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            # Find targetIdx\\n            targetIdx = abs(num) - 1\\n            # If already negative means duplicate\\n            if nums[targetIdx] < 0:\\n                return targetIdx + 1\\n            else:\\n                nums[targetIdx] *= -1\\n```\n```go\\n// /* Negative Marking O(N) | O(1) */\\nfunc findDuplicate(nums []int) int {\\n    for _, num := range(nums){\\n        // abs for num\\n        if num < 0 {\\n            num *= - 1 \\n        }\\n        // Find targetIdx\\n        targetIdx := num - 1\\n        // If already negative means duplicate\\n        if nums[targetIdx] < 0{\\n            return targetIdx + 1\\n        }\\n        // Make neagative\\n        nums[targetIdx] *= -1\\n    }\\n    return -1\\n}\\n```\n```\\nnums = [1,3,4,2,2] , left = 0, right = 4\\n1. mid = 2 => The numbers <= 2 is 3.\\nIt means we have duplicate number which is smaller than 2. So we search left. Right = 2 - 1\\n2. mid = 1 => The numbers <= 1 is 1.\\nIt means all value from 1 to 1 would not be duplicates\\n```\n```python\\n# Binary Search (NlogN) | O(1)     \\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            # Count numbers <= mid\\n            count = sum(num <= mid for num in nums)\\n            if count > mid:\\n                duplicate = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return duplicate\\n```\n```go\\n/* Binary Search (NlogN) | O(1) */\\nfunc findDuplicate(nums []int) int {\\n    left, right := 0, len(nums) - 1\\n    duplicate := 0\\n    for left <= right{\\n        mid := (left + right) / 2\\n        count := 0\\n        // Count numbers <= mid\\n        for _,num := range(nums){\\n            if num <= mid{\\n                count++\\n            }\\n        }\\n        // Search left\\n        if count > mid{\\n            duplicate = mid\\n            right = mid - 1\\n        } else { // Search right\\n            left = mid +1\\n        }      \\n    }\\n    return duplicate\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757502,
                "title": "c-using-fast-and-slow-pointer-approach",
                "content": "Using the idea of linked list cycle finding algorithm.\\n\\n\\tint findDuplicate(vector<int>& nums) {\\n\\t\\tint n=nums.size(),s=0,f=0;\\n\\t\\tdo{\\n\\t\\t\\ts=nums[s];\\n\\t\\t\\tf=nums[nums[f]];\\n\\t\\t}while(s!=f);\\n\\t\\ts=0;\\n\\t\\twhile(s!=f){\\n\\t\\t\\ts=nums[s];\\n\\t\\t\\tf=nums[f];\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n\\t\\nplease upvote :)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "Using the idea of linked list cycle finding algorithm.\\n\\n\\tint findDuplicate(vector<int>& nums) {\\n\\t\\tint n=nums.size(),s=0,f=0;\\n\\t\\tdo{\\n\\t\\t\\ts=nums[s];\\n\\t\\t\\tf=nums[nums[f]];\\n\\t\\t}while(s!=f);\\n\\t\\ts=0;\\n\\t\\twhile(s!=f){\\n\\t\\t\\ts=nums[s];\\n\\t\\t\\tf=nums[f];\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n\\t\\nplease upvote :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1699921,
                "title": "c-easy-solution-2-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        //TC: O(n)  AS:O(1)\\n\\t\\t/*First solution: In this we keep negating(nums[i]*(-1)) the nums[i]th position \\n\\t\\tWhen the duplicate element, let say at position nums[j], is encountered then on checking the nums[nums[j]], \\n\\t\\tif it is already negative that means this position has been traversed and it is encountered twice, So nums[j] gives the duplicate element. */\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[abs(nums[i])-1]<0)\\n                return abs(nums[i]);\\n            \\n            nums[abs(nums[i])-1]=(-1)*nums[abs(nums[i])-1];\\n            \\n        }\\n        return -1;\\n        \\n        //Floyd\\'s algorithm TC: O(n), AS: O(1)\\n        /*Here we consider that there is a presence of cycle just like in case of circular linked list. \\n\\t\\tAnd the starting point of the cycle is the duplicated number as once the list will return to it.*/\\n\\t\\t//eg: \\n\\t\\t// arr[] :  1,  4,  3,  2,  3\\n\\t\\t// idx  :   0   1   2   3   4\\n\\t\\t/*\\n\\t\\tStarting list traversal from nums[0] -> nums[nums[0]] -> nums[nums[0]] -> .......\\n\\t\\t      1 -> 4 -> 3 ->2 \\n\\t\\t\\t            ^   |\\n                        | __|\\n         */\\n        if(nums.size()==2)\\n            return nums[0];\\n        int slow=nums[0];\\n        int fast=nums[nums[0]];\\n        \\n        while(slow!=fast)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }\\n        \\n        fast=0;\\n        \\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }\\n        \\n        return slow;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        //TC: O(n)  AS:O(1)\\n\\t\\t/*First solution: In this we keep negating(nums[i]*(-1)) the nums[i]th position \\n\\t\\tWhen the duplicate element, let say at position nums[j], is encountered then on checking the nums[nums[j]], \\n\\t\\tif it is already negative that means this position has been traversed and it is encountered twice, So nums[j] gives the duplicate element. */\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[abs(nums[i])-1]<0)\\n                return abs(nums[i]);\\n            \\n            nums[abs(nums[i])-1]=(-1)*nums[abs(nums[i])-1];\\n            \\n        }\\n        return -1;\\n        \\n        //Floyd\\'s algorithm TC: O(n), AS: O(1)\\n        /*Here we consider that there is a presence of cycle just like in case of circular linked list. \\n\\t\\tAnd the starting point of the cycle is the duplicated number as once the list will return to it.*/\\n\\t\\t//eg: \\n\\t\\t// arr[] :  1,  4,  3,  2,  3\\n\\t\\t// idx  :   0   1   2   3   4\\n\\t\\t/*\\n\\t\\tStarting list traversal from nums[0] -> nums[nums[0]] -> nums[nums[0]] -> .......\\n\\t\\t      1 -> 4 -> 3 ->2 \\n\\t\\t\\t            ^   |\\n                        | __|\\n         */\\n        if(nums.size()==2)\\n            return nums[0];\\n        int slow=nums[0];\\n        int fast=nums[nums[0]];\\n        \\n        while(slow!=fast)\\n        {\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }\\n        \\n        fast=0;\\n        \\n        while(fast!=slow)\\n        {\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }\\n        \\n        return slow;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077997,
                "title": "python-floyd-s-cycle-detecting-algorithm-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow, fast = 0, 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        \\n        slow = 0\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```\\nThis is my first time posting on discussion, consider upvoting if this helps \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow, fast = 0, 0\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        \\n        slow = 0\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701358,
                "title": "c-bit-manipulation-simple-and-short",
                "content": "***Plz upvote if you like it***\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size(), res = 0;\\n        for (int p = 0; p < 32; ++ p) {\\n            int bit = (1 << p), a = 0, b = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (i & bit) ++a;\\n                if (nums[i] & bit) ++b;\\n            }\\n            if (b > a) res += bit;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size(), res = 0;\\n        for (int p = 0; p < 32; ++ p) {\\n            int bit = (1 << p), a = 0, b = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (i & bit) ++a;\\n                if (nums[i] & bit) ++b;\\n            }\\n            if (b > a) res += bit;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222352,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n**Time complexity:** O(N<sup>2</sup>)\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return A[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Solution 2: Sorting - Modifies the original array**\\n\\n**Time complexity:** `O(N log N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return A[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Solution 3: Negative Marking - Modifies the original array**\\n\\n- The idea is when visiting a number `i`, flip the number at index `i - 1` to negative. If the number at index `i - 1` is already negative, then `i` is the number that occurs more than once.\\n\\nTime complexity: `O(N)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int findDuplicate(int[] A)\\n    {\\n        for(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tint index = Math.abs(A[i]) - 1;\\n\\n\\t\\t\\tif(A[index] < 0)\\n\\t\\t\\t\\treturn index + 1;\\n            else\\n\\t\\t\\t    A[index] = -A[index];\\n\\t\\t}\\n        return -1;\\n    }\\n}\\n```\\n\\n**Solution 4: Using Set**\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(N)`\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return n;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Solution 5: Floyd\\'s Cycle Detection Algorithm**\\n\\n- The idea is to consider array items as linked list nodes. Any particular index is pointing to the value at that index, like `index -> A[index] -> A[A[index]]` and so on.\\n- For example- given array is `A = [1, 2, 3, 4, 5, 6, 3]`. In case of duplicate, two indexes will have same value and they will form a cycle just like in the image given below: So we can find the entry point of cycle in the linked-list and that will be our duplicate element.\\n\\n![image](https://assets.leetcode.com/users/pratik_patil/image_1548273971.png)\\n\\n**Algorithm:**\\n1. We maintain two pointers `fast` and `slow`\\n2. For each step `fast` will move to the index that is equal to` A[A[fast]]` which is two steps at a time and `slow` will move to the index `A[slow]` which is one step at a time. Eventually, `fast` and `slow` will meet in a cycle and the entry point of that circle will be the duplicate element.\\n3. When `fast == slow` that means now we are in a cycle.\\n4. Now we need to find entry point so we will start with `slow = 0` and visit one step at a time for both `fast` and `slow`. When `fast == slow` that will be entry point.\\n5. Return the entry point.\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        int slow = A[0];\\n        int fast = A[A[0]];\\n\\n        while (slow != fast) {\\n            slow = A[slow];\\n            fast = A[A[fast]];\\n        }\\n        slow = 0;\\n\\n        while (slow != fast) {\\n            slow = A[slow];\\n            fast = A[fast];\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return A[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return A[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int findDuplicate(int[] A)\\n    {\\n        for(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tint index = Math.abs(A[i]) - 1;\\n\\n\\t\\t\\tif(A[index] < 0)\\n\\t\\t\\t\\treturn index + 1;\\n            else\\n\\t\\t\\t    A[index] = -A[index];\\n\\t\\t}\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return n;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] A) {\\n        int slow = A[0];\\n        int fast = A[A[0]];\\n\\n        while (slow != fast) {\\n            slow = A[slow];\\n            fast = A[A[fast]];\\n        }\\n        slow = 0;\\n\\n        while (slow != fast) {\\n            slow = A[slow];\\n            fast = A[fast];\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 73058,
                "title": "a-pinch-of-invisible-cheat",
                "content": "I found a way to cheat by modifying the array but only during the algorithm time. The idea is simple : mark revealed case by inverting its content. If a case inverted more than once, then I've found the number that appears more than once.\\n\\nHere is a C++ implementation :\\n\\n    class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int n = -1;\\n            for(int i = 0; i < nums.size(); i++) {\\n                n = std::abs(nums[i]);\\n                if(nums[n] < 0) {\\n                    break;\\n                }\\n                else {\\n                    nums[n] *= -1;\\n                }\\n            }\\n            for(int j = 0; j < nums.size(); j++) {\\n                nums[j] = std::abs(nums[j]);\\n            }\\n            return n;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int n = -1;\\n            for(int i = 0; i < nums.size(); i++) {\\n                n = std::abs(nums[i]);\\n                if(nums[n] < 0) {\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4064102,
                "title": "simple-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet <Integer> set = new HashSet<>();\\n        for (int n : nums)\\n        {\\n            if (set.contains(n)){\\n                return n;\\n            }\\n            set.add(n);\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/7ebbc91e-6ce1-417c-a714-68a4ea1a91a5_1695122899.8916821.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet <Integer> set = new HashSet<>();\\n        for (int n : nums)\\n        {\\n            if (set.contains(n)){\\n                return n;\\n            }\\n            set.add(n);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062693,
                "title": "easy-c-slow-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Fast & Slow find the cycle entrance\\n    int findDuplicate(vector<int>& nums) {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n        do{\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }while(fast!=slow);\\n        slow=nums[0];\\n        while(slow!=fast){\\n            fast=nums[fast];\\n            slow=nums[slow];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Fast & Slow find the cycle entrance\\n    int findDuplicate(vector<int>& nums) {\\n        int slow=nums[0];\\n        int fast=nums[0];\\n        do{\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }while(fast!=slow);\\n        slow=nums[0];\\n        while(slow!=fast){\\n            fast=nums[fast];\\n            slow=nums[slow];\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062338,
                "title": "easy-solution-floyd-s-tortoise-and-hare-algorithm-cycle-detection-method-ez",
                "content": "# Intuition\\nThe intuition behind this approach is to use the Floyd\\'s Tortoise and Hare algorithm (Cycle Detection Algorithm) to find the duplicate element in the given `nums` array efficiently.\\n\\n\\n# Approach\\n1. Initialize two pointers, `first` and `second`, and start both of them at the first element of the `nums` array.\\n2. Use a loop to advance `first` by one step and `second` by two steps until they meet. This is the first phase of the algorithm and is used to detect the presence of a cycle in the array.\\n3. Once they meet (indicating the presence of a cycle), reset one of the pointers (e.g., `second`) to the first element of the array while keeping the other pointer (`first`) where it is.\\n4. Use another loop to advance both `first` and `second` by one step at a time until they meet again. This is the second phase of the algorithm and is used to find the entrance point of the cycle, which corresponds to the duplicate element.\\n5. Return the element where they meet as the duplicate element.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - The algorithm makes two passes through the array. The first pass detects the cycle, and the second pass finds the entrance point of the cycle.\\n- Space complexity: $$O(1)$$ - The algorithm uses only a constant amount of extra space for the two pointers (`first` and `second`).\\n\\nThis approach efficiently finds the duplicate element in the array with constant space complexity.\\n\\n\\n```python []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        first = nums[0]\\n        second = nums[0]\\n        \\n        while True:\\n            first = nums[first]\\n            second = nums[nums[second]]\\n            if first == second:\\n                break\\n        \\n        first = nums[0]\\n        while first != second:\\n            first = nums[first]\\n            second = nums[second]\\n        \\n        return first\\n\\n```\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int first = nums[0];\\n        int second = nums[0];\\n        do {\\n            first = nums[first];\\n            second = nums[nums[second]];\\n        } while (first != second);\\n        \\n        second = nums[0];\\n        while (first != second) {\\n            first = nums[first];\\n            second = nums[second];\\n        }\\n        \\n        return first; \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python []\\nclass Solution:\\n    def findDuplicate(self, nums):\\n        first = nums[0]\\n        second = nums[0]\\n        \\n        while True:\\n            first = nums[first]\\n            second = nums[nums[second]]\\n            if first == second:\\n                break\\n        \\n        first = nums[0]\\n        while first != second:\\n            first = nums[first]\\n            second = nums[second]\\n        \\n        return first\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831997,
                "title": "easy-fastest-slow-and-fast-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        while True:\\n            slow = nums[slow]\\n            fast= nums[nums[fast]]\\n            if slow == fast:    break\\n        \\n        fast = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        while True:\\n            slow = nums[slow]\\n            fast= nums[nums[fast]]\\n            if slow == fast:    break\\n        \\n        fast = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604045,
                "title": "java-linked-array-list",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while (true) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n\\n            if (slow == fast) {\\n                break;\\n            }\\n        }\\n\\n        slow = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019220,
                "title": "love-babbar-dsa-sheet",
                "content": "**Love babbar dsa sheet, Question 11 **\\n# Intuition\\nTo solve the question in linear time complexity and with simpler code\\n\\n# Approach\\nThe approach I used in this question is one of the most easiest method, at first i wrote 2 if condition. The first if condition will return 0, while there is no element in array and the second if condition will return the first element of array, while there will be only 1 or 2 element . Beacuse any one element will surely have it\\'s duplicate so in this case if there is only two elment in the array then simply the answer will be first or last element because both will be same.\\n\\nAfter the above process I sorted the array using begin and end indexes and afterward I used a for loop and checked that if element at ith index is same as i+1 or not .\\n\\nIf it is same then return that element, else iterate to the next index. \\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n<0)\\n        {\\n            return -1;\\n        }\\n        if(n<=2)\\n        {\\n            \\n            return nums[0];\\n        }\\n        //sort(nums , nums + n);\\n        sort(nums.begin() , nums.end());\\n        int ans ;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if (nums[i] == nums[i+1])\\n            {\\n                ans = nums[i] ;\\n            }\\n            \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n<0)\\n        {\\n            return -1;\\n        }\\n        if(n<=2)\\n        {\\n            \\n            return nums[0];\\n        }\\n        //sort(nums , nums + n);\\n        sort(nums.begin() , nums.end());\\n        int ans ;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if (nums[i] == nums[i+1])\\n            {\\n                ans = nums[i] ;\\n            }\\n            \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893702,
                "title": "java-easy-understandable-code",
                "content": "Method 1- Swap and Sort\\n```\\n//Sorting and Swapping \\n//Thus it modifies the Array.\\nclass Solution {\\n    public int findDuplicate(int[] arr) {\\n        int i = 0;\\n        while (i < arr.length) {\\n            if (arr[i] != i + 1) {\\n                int correct = arr[i] - 1;\\n                if (arr[i] != arr[correct])\\n                    swap(arr, i, correct);\\n                else\\n                    return arr[i];\\n\\t\\t\\t\\t\\t}\\n            else  i++;\\n\\t\\t\\t}\\n        return -1;\\n\\t\\t}\\n\\t\\t\\n    static void swap(int[] arr, int first, int second) {\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;}}\\n\\n```\\n\\nMethod-2\\nWithout Modifying The Array\\nHashSet\\n```\\npublic static int findDuplicate(int[] nums) { \\nSet<Integer> easy = new HashSet<>();\\nfor (int i = 0; i < nums.length; i++) {\\n if (!easy.add(nums[i])) { \\nreturn nums[i]; \\n} \\n} \\nreturn nums.length;\\n }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n//Sorting and Swapping \\n//Thus it modifies the Array.\\nclass Solution {\\n    public int findDuplicate(int[] arr) {\\n        int i = 0;\\n        while (i < arr.length) {\\n            if (arr[i] != i + 1) {\\n                int correct = arr[i] - 1;\\n                if (arr[i] != arr[correct])\\n                    swap(arr, i, correct);\\n                else\\n                    return arr[i];\\n\\t\\t\\t\\t\\t}\\n            else  i++;\\n\\t\\t\\t}\\n        return -1;\\n\\t\\t}\\n\\t\\t\\n    static void swap(int[] arr, int first, int second) {\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;}}\\n\\n```\n```\\npublic static int findDuplicate(int[] nums) { \\nSet<Integer> easy = new HashSet<>();\\nfor (int i = 0; i < nums.length; i++) {\\n if (!easy.add(nums[i])) { \\nreturn nums[i]; \\n} \\n} \\nreturn nums.length;\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811759,
                "title": "simple-java-code-in-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while(slow!=fast);\\n        \\n        fast = nums[0];\\n        while(slow!=fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0], fast = nums[0];\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while(slow!=fast);\\n        \\n        fast = nums[0];\\n        while(slow!=fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793567,
                "title": "c-intuition-floyds-cycle-brute-better-optimal",
                "content": "![image](https://assets.leetcode.com/users/images/67eb0744-1a38-46f3-8434-c8c3e736848c_1645602929.5012085.png)\\n![image](https://assets.leetcode.com/users/images/648b0615-9988-4e25-93f8-37b2f8648572_1645602939.7228956.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums){\\n        //floyd cycle\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow!=fast);\\n        fast = nums[0];\\n        while(slow!=fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums){\\n        //floyd cycle\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow!=fast);\\n        fast = nums[0];\\n        while(slow!=fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return slow;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665073,
                "title": "java-slow-and-fast-pointers-time-o-n-space-o-1",
                "content": "```\\n    /*\\n    approach 1:\\n    sort nums using cyclic sort\\n    \\n    go through each index\\n        if nums at index is not at its expected position, we found the number\\n        \\n    this approach runs in o(n) time complexity\\n    however, it modifies the input array which is not acceptable \\n\\t\\n\\t\\n    approach 2:\\n    using slow and fast pointers approach\\n    \\n    since there is a duplicate, while sorting there would be a cycle\\n    \\n    detect the cycle using slow and fast pointers, moving former once and latter twice\\n    \\n    once cycle is detected, move slow to the begining\\n    \\n    move both pointers once\\n    \\n    once the pointers meet, we found the beggining of the cycle, this is the repeating element\\n    \\n    */\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[nums[0]];\\n        \\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n        \\n        slow = 0;\\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    /*\\n    approach 1:\\n    sort nums using cyclic sort\\n    \\n    go through each index\\n        if nums at index is not at its expected position, we found the number\\n        \\n    this approach runs in o(n) time complexity\\n    however, it modifies the input array which is not acceptable \\n\\t\\n\\t\\n    approach 2:\\n    using slow and fast pointers approach\\n    \\n    since there is a duplicate, while sorting there would be a cycle\\n    \\n    detect the cycle using slow and fast pointers, moving former once and latter twice\\n    \\n    once cycle is detected, move slow to the begining\\n    \\n    move both pointers once\\n    \\n    once the pointers meet, we found the beggining of the cycle, this is the repeating element\\n    \\n    */\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[nums[0]];\\n        \\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n        \\n        slow = 0;\\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502658,
                "title": "90-fast-submission",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n    \\n        boolean[] n=new boolean[nums.length+1];\\n        \\n        for(int x:nums){\\n            \\n            if(n[x]==true) return x;\\n            else\\n                n[x]=true;   \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n    \\n        boolean[] n=new boolean[nums.length+1];\\n        \\n        for(int x:nums){\\n            \\n            if(n[x]==true) return x;\\n            else\\n                n[x]=true;   \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390736,
                "title": "c-find-the-duplicate-number-5-solutions",
                "content": "# **LeetCode + Todoist = Consistent Grind -- TRY [Code Task](https://codetask.vercel.app/)**\\n\\n**1. Sorting**\\n* **Time Complexcity : `O(n.log(n))`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n - 1; i++){\\n            if(nums[i] == nums[i + 1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**2. Hashmap**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(n)`**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++){\\n            mp[nums[i]]++;\\n            \\n            if(mp[nums[i]] > 1){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**3. Modifying Array**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int duplicate = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            int curr = abs(nums[i]);\\n            if(nums[curr] < 0){\\n                duplicate = curr;\\n                break;\\n            }\\n            \\n            nums[curr] *= -1;\\n        }\\n        \\n        return duplicate;\\n    }\\n};\\n```\\n\\n**4. Cycle Detection - Floyd Cycle Detection**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        \\n        fast = nums[0];\\n        \\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```\\n\\n**5. Cyclic Sort**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            if(nums[i] != nums[nums[i] - 1]){\\n                swap(nums[i], nums[nums[i] - 1]);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return nums[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n - 1; i++){\\n            if(nums[i] == nums[i + 1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++){\\n            mp[nums[i]]++;\\n            \\n            if(mp[nums[i]] > 1){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int duplicate = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            int curr = abs(nums[i]);\\n            if(nums[curr] < 0){\\n                duplicate = curr;\\n                break;\\n            }\\n            \\n            nums[curr] *= -1;\\n        }\\n        \\n        return duplicate;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        \\n        do{\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }while(slow != fast);\\n        \\n        fast = nums[0];\\n        \\n        while(slow != fast){\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        \\n        return slow;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while(i < n){\\n            if(nums[i] != nums[nums[i] - 1]){\\n                swap(nums[i], nums[nums[i] - 1]);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return nums[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931157,
                "title": "javascript-binary-search-explained",
                "content": "We are given an array of numbers of length `n + 1` in the range `[1, n]`\\n\\nExample:`[1,3,4,2,2]` \\n\\nMake a table for each number in the range and the count of how many numbers in `nums` are `<=` to that number.\\n\\n| Number | Count |\\n|-|-|\\n| 1 | 1 |\\n| 2 | 3 |\\n| 3 | 4 |\\n| 4 | 5 |\\n\\nFrom this we can see the duplicate number is the first number where the count is greater than our number. \\n\\nWe don\\'t need to do a binary search over the given `nums` array, we want to do a binary search over the *range* of numbers given. \\n\\nStepping through the example...\\n\\nFirst iteration:\\n**left = 1**\\n**right = 4**\\n**mid = 2**\\n\\nFor the midpoint of 2 there is a count of 3 numbers in `nums` that are `<=` to 2 so we should move the right boundary to this point.\\n\\nNext iteration:\\n**left = 1**\\n**right = 2**\\n**mid = 1**\\n\\nFor this midpoint we have a count of 1, so we know this point is to the left of our duplicate and should move our left point to the right\\n\\nNow `left === right` and the while loop terminates. The duplicate number is 2\\n\\n\\n```\\nvar findDuplicate = function(nums) {\\n  let left = 1\\n  let right = nums.length - 1\\n\\n  const getCount = mid => {\\n    let count = 0\\n\\n    for (const num of nums) {\\n      if (num <= mid) {\\n        count++\\n      }\\n    }\\n\\n    return count\\n  }\\n\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2)\\n    const count = getCount(mid)\\n\\n    if (count > mid) {\\n      right = mid\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n\\n  return left\\n}\\n```\\n\\n```\\nTime: O(nlogn)\\nSpace: O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nvar findDuplicate = function(nums) {\\n  let left = 1\\n  let right = nums.length - 1\\n\\n  const getCount = mid => {\\n    let count = 0\\n\\n    for (const num of nums) {\\n      if (num <= mid) {\\n        count++\\n      }\\n    }\\n\\n    return count\\n  }\\n\\n  while (left < right) {\\n    const mid = left + Math.floor((right - left) / 2)\\n    const count = getCount(mid)\\n\\n    if (count > mid) {\\n      right = mid\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n\\n  return left\\n}\\n```\n```\\nTime: O(nlogn)\\nSpace: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705425,
                "title": "c-12ms-11mb-with-modification-of-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++){\\n            int val = abs(nums[i]);\\n            if (nums[val] < 0) return val;\\n            nums[val] = -nums[val];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++){\\n            int val = abs(nums[i]);\\n            if (nums[val] < 0) return val;\\n            nums[val] = -nums[val];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658972,
                "title": "video-tutorial-with-some-extra-constraints-nicely-explained",
                "content": "Found a really good explaination after working very hard\\nhttps://www.youtube.com/watch?v=MrHbSiQGvLk&t=14s\\nits really unique way to solve this problem by buketing",
                "solutionTags": [],
                "code": "Found a really good explaination after working very hard\\nhttps://www.youtube.com/watch?v=MrHbSiQGvLk&t=14s\\nits really unique way to solve this problem by buketing",
                "codeTag": "Unknown"
            },
            {
                "id": 443011,
                "title": "accepted-java-binary-search-solution-meet-all-requirements",
                "content": "Idea: \\nGiven those requirements, we know that we cannot sort the array, edit the array in place or create a new array with length N. So, we could use binary search to meet the time complexity.\\n\\nAlgorithm: \\nCouting element whose value is equal or smaller than n/2. If the number of these element is larger than n/2. It means that the duplicate element must exist in range [1, n/2]. And vice versa the duplicate element must exist in range [n/2, n]\\n\\nCode:\\n\\t\\n\\tclass Solution {\\n        public int findDuplicate(int[] nums) {\\n        \\n        int i = 0, j = nums.length - 1;\\n        while (i <= j) {\\n            \\n            int mid = (i + j) / 2;\\n            \\n            int count = 0;\\n            for (int n : nums) {\\n                if (n <= mid) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > mid) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        \\n        return i;\\n\\t\\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int findDuplicate(int[] nums) {\\n        \\n        int i = 0, j = nums.length - 1;\\n        while (i <= j) {\\n            \\n            int mid = (i + j) / 2;\\n            \\n            int count = 0;\\n            for (int n : nums) {\\n                if (n <= mid) {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 261325,
                "title": "clarification-on-description",
                "content": "\"There is only one duplicate number in the array, but it could be repeated more than once.\"\\nDoes this mean that the whole array could be consisted of a single number? E.g. is this a legitimate case:\\n```\\n[4,4,4,4,4,4,4,4]\\n```\\nThis would mean we can\\'t use XOR to find the duplicate.",
                "solutionTags": [],
                "code": "```\\n[4,4,4,4,4,4,4,4]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251549,
                "title": "java-o-n-time-and-o-1-space-solution-with-two-pointers-and-mod-operator",
                "content": "This solution is similar to finding cycle in a LinkedList by using Two pointers, the slow one and the fast one.\\nAdditionally mod operator % can help nicely to go in a circle until you find the duplicates.\\nIt is important to increment one of the pointers if they are equal.\\n\\n```\\nint findDuplicate(int[] nums) {\\n        int slow = 0, fast = 1;\\n        int n = nums.length;\\n        while (nums[slow] != nums[fast]) {\\n            slow = (slow + 1) % n;\\n            fast = (fast + 2) % n;\\n            if (fast == slow) fast = (fast + 1) % n;\\n        }\\n        return nums[slow];\\n    }\\t\\n```",
                "solutionTags": [],
                "code": "```\\nint findDuplicate(int[] nums) {\\n        int slow = 0, fast = 1;\\n        int n = nums.length;\\n        while (nums[slow] != nums[fast]) {\\n            slow = (slow + 1) % n;\\n            fast = (fast + 2) % n;\\n            if (fast == slow) fast = (fast + 1) % n;\\n        }\\n        return nums[slow];\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 73052,
                "title": "16-ms-c-o-n-time-o-1-space-solution",
                "content": "Very straight forward solution:\\n\\n1) Just count how many 1 should appear on each bit from 1 to n\\n\\n2) and count again how many actually appears\\n\\n3) set the bit with extra 1s to 1 and return the result\\n\\n\\n===============*^^*====================\\n\\nShort explanation:\\n\\nSay you happen to have 1 to n plus x, then you have extra 1 and extra 0 at places that x has 1 and 0.\\n\\n If you have more than two x, then for each additional x you have to delete any number from 1 to n and add an x, which will only add to the number of 1s, if not remain unchanged, in the place that have extra 1s. \\n\\nIn this case I scan each element once for each bit. Since there are at most 64 bits or 32 bits I consider it a O(n) solution. I improved it a little with scanning only the number of bits needed.\\n\\n    int findDuplicate(vector<int>& nums) {\\n        int result = 0, count,bit,i;\\n        \\n        for(bit = 1; bit >0 && bit < nums.size(); bit <<= 1 )\\n        {\\n            count = 0;\\n            for(i = 0;i<nums.size();i++) count += bool(nums[i]&bit) - bool(i&bit);\\n            if(count > 0) result |= bit;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Very straight forward solution:\\n\\n1) Just count how many 1 should appear on each bit from 1 to n\\n\\n2) and count again how many actually appears\\n\\n3) set the bit with extra 1s to 1 and return the result\\n\\n\\n===============*^^*====================\\n\\nShort explanation:\\n\\nSay you happen to have 1 to n plus x, then you have extra 1 and extra 0 at places that x has 1 and 0.\\n\\n If you have more than two x, then for each additional x you have to delete any number from 1 to n and add an x, which will only add to the number of 1s, if not remain unchanged, in the place that have extra 1s. \\n\\nIn this case I scan each element once for each bit. Since there are at most 64 bits or 32 bits I consider it a O(n) solution. I improved it a little with scanning only the number of bits needed.\\n\\n    int findDuplicate(vector<int>& nums) {\\n        int result = 0, count,bit,i;\\n        \\n        for(bit = 1; bit >0 && bit < nums.size(); bit <<= 1 )\\n        {\\n            count = 0;\\n            for(i = 0;i<nums.size();i++) count += bool(nums[i]&bit) - bool(i&bit);\\n            if(count > 0) result |= bit;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 73076,
                "title": "two-short-versions-7-line-binary-search-solution-o-nlogn-and-4-line-slow-fast-pointer-loop-detection-o-n",
                "content": "The basic idea is to do binary search, just to partition the array into two subarray, one (G) with elements that are larger than mid, and the other (LE) with elements no larger than mid. If LE has more than mid elements then that means the duplicated element is in the range [left, mid], otherwise, the duplicated one should be in the range [mid+1, right], then for each loop, update the left, right ([left, right] is the possible values of the duplicated element) accordingly.\\n \\n \\n\\n      class Solution {\\n        public:\\n            int findDuplicate(vector<int>& nums) {\\n                int len = nums.size(), i, left = 1, right = len-1, mid, count;\\n                while(left<right)\\n                {\\n                    mid = (left+right)>>1;\\n                    for(i=0, count=0; i<len;++i) if(nums[i]<=mid) ++count; // count LE elements\\n                    if(count>mid) right = mid; // update left/right\\n                    else left = mid+1;\\n                }\\n                return left;\\n            }\\n        };\\n\\n\\nAnother one (learned from other posts) is to use the array elements as array indices (or linked list indices) and reuse the solution for linked list loop detection problem (slow/fast pointers). The key is the starting point should be nums.size() since no element in the array (in [1, nums.size()-1]) will have such value  \\n\\n    class Solution {\\n    public:\\n        int findDuplicate(vector<int>& nums) {\\n            int n=nums.size(), slow, fast;\\n            for(slow=nums[n-1], fast = nums[slow-1]; slow!=fast; slow = nums[slow-1], fast = nums[nums[fast-1]-1]);\\n            for(slow=n; slow!=fast; slow = nums[slow-1], fast = nums[fast-1]);\\n            return slow;        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int findDuplicate(vector<int>& nums) {\\n                int len = nums.size(), i, left = 1, right = len-1, mid, count;\\n                while(left<right)\\n                {\\n                    mid = (left+right)>>1;\\n                    for(i=0, count=0; i<len;++i) if(nums[i]<=mid) ++count; // count LE elements\\n                    if(count>mid) right = mid; // update left/right\\n                    else left = mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4062454,
                "title": "2-lines-of-code-with-2-step-explanation",
                "content": "# Approach\\n*1) First we will define a HashSet, Because as we know that hash set will help us to find the duplicate values.*\\n*2) We will iterate through the for loop. So, if the set doesn\\'t contains of that particular number means it will add the number in to that set. If the number is already present in that set means it will return the number. If there is no duplicate means we will return -1.*\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer>set=new HashSet();\\n        for(int i:nums){\\n            if(!set.add(i)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer>set=new HashSet();\\n        for(int i:nums){\\n            if(!set.add(i)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785249,
                "title": "simple-java-two-approaches",
                "content": "\\n# Using Bit Manipulation\\n- Time complexity:$$O(N *log *N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(32)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length, bits[]=new int[32], a, b, res=0;\\n        for(int i=0;i<n;i++){\\n            a=nums[i];\\n            b=i+1;\\n\\n            for(int j=0;a>0 || b>0;j++){\\n                if((a&1)>0) bits[j]++;\\n                a=a>>1;\\n                if(i!=(n-1) && ((b&1)>0)) bits[j]--;\\n                b=b>>1;\\n            }\\n        }\\n        for(int i=0;i<32; i++)\\n            if(bits[i]>0) res|=1<<i;\\n        return res;\\n    }\\n}\\n```\\n\\n# Using Floyd\\'s Cycle Detection Algorithm\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        // Floyd\\'s Graph cycle detection\\n        int slow=0, fast=0;\\n        do{\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }while(slow!=fast);\\n        slow=0;\\n        do{\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }while(slow!=fast);\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length, bits[]=new int[32], a, b, res=0;\\n        for(int i=0;i<n;i++){\\n            a=nums[i];\\n            b=i+1;\\n\\n            for(int j=0;a>0 || b>0;j++){\\n                if((a&1)>0) bits[j]++;\\n                a=a>>1;\\n                if(i!=(n-1) && ((b&1)>0)) bits[j]--;\\n                b=b>>1;\\n            }\\n        }\\n        for(int i=0;i<32; i++)\\n            if(bits[i]>0) res|=1<<i;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        // Floyd\\'s Graph cycle detection\\n        int slow=0, fast=0;\\n        do{\\n            slow=nums[slow];\\n            fast=nums[nums[fast]];\\n        }while(slow!=fast);\\n        slow=0;\\n        do{\\n            slow=nums[slow];\\n            fast=nums[fast];\\n        }while(slow!=fast);\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545293,
                "title": "java-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> states = new HashSet<Integer>();\\n\\n        for (int num : nums) {\\n            if (states.contains(num)) {\\n                return num;\\n            }\\n            else {\\n                states.add(num);\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> states = new HashSet<Integer>();\\n\\n        for (int num : nums) {\\n            if (states.contains(num)) {\\n                return num;\\n            }\\n            else {\\n                states.add(num);\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502589,
                "title": "python-best-time-and-space-complexity",
                "content": "We can use the negative sign mark to remember occurance of each num in nums.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            ind = abs(num)\\n            \\n            if nums[ind] < 0:\\n                return ind\\n            \\n            nums[ind] *= -1 \\n\\n```\\n\\n# Example\\n```\\nnums = [1,2,3,2]\\n\\n0:\\nind = 1\\nnums = [1,-2,3,2]\\n\\n1:\\nind = 2\\nnums = [1,-2,-3,2]\\n\\n2:\\nind = 3\\nnums = [1,-2,-3,-2]\\n\\n3:\\nind = 2\\nnums[ind] < 0  -- result.\\n```\\n\\nPlease upvote if you like this solution.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for num in nums:\\n            ind = abs(num)\\n            \\n            if nums[ind] < 0:\\n                return ind\\n            \\n            nums[ind] *= -1 \\n\\n```\n```\\nnums = [1,2,3,2]\\n\\n0:\\nind = 1\\nnums = [1,-2,3,2]\\n\\n1:\\nind = 2\\nnums = [1,-2,-3,2]\\n\\n2:\\nind = 3\\nnums = [1,-2,-3,-2]\\n\\n3:\\nind = 2\\nnums[ind] < 0  -- result.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267009,
                "title": "c-1-line-solution-best-use-of-swapsort",
                "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n         while(nums[0]!=nums[nums[0]]){ swap(nums[0],nums[nums[0]]); } return nums[0];\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n         while(nums[0]!=nums[nums[0]]){ swap(nums[0],nums[nums[0]]); }",
                "codeTag": "Java"
            },
            {
                "id": 3219510,
                "title": "o-n-time-o-1-space-complexity-6-line-without-reordering-array-c-easy-short-solution",
                "content": "# Intuition\\nSimple & Rare solution using Array element as a index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[abs(nums[i])] > 0){\\n                nums[abs(nums[i])] = -nums[abs(nums[i])];\\n            }\\n            else{\\n                return abs(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(nums[abs(nums[i])] > 0){\\n                nums[abs(nums[i])] = -nums[abs(nums[i])];\\n            }\\n            else{\\n                return abs(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209876,
                "title": "o-n-time-complexity-easiest-and-simple-line-of-code",
                "content": "# Intuition\\n\\n\\n# Approach\\nswap the no with there index if the no ocuurs twice than break and come out of loop and print element present nums[0]\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        while(nums[0]!=nums[nums[0]])\\n        {\\n            swap(nums[0],nums[nums[0]]);\\n\\n        }\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        while(nums[0]!=nums[nums[0]])\\n        {\\n            swap(nums[0],nums[nums[0]]);\\n\\n        }\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175004,
                "title": "face-to-face-interview-o-1-space-complexity",
                "content": "# Intuition\\nSWAP SORT\\n\\n# Approach\\nHere one element is extra which is repeated.\\nWe have to place all the element at the index where the element has the right place.\\nWhat is the right place?\\nEX : [2,1,3,4,2]\\nRight place : [1,2,3,4,2]\\nEach element should present at the index i-1.\\n1 at index 0.\\n2 at index 1.\\n....\\nAfter we get each element at right place.We have to traverse the array and chack which element is not present at their right place.\\nWhich is our ans.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // FOR SWAPPING\\n    void swap(vector<int>&nums,int i,int j){\\n        int d=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=d;\\n    }\\n\\n    \\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size(),i=0;\\n        // PLACING THE ELEMENT AT THE RIGHT PLACE.\\n        while(i<n){\\n            if(nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int d=-1;\\n\\n        // CHECKING THE ELEMENT PRESENT AT THEIR RIGHT PLACE OR NOT.\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=(i+1)){\\n                return nums[i];\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // FOR SWAPPING\\n    void swap(vector<int>&nums,int i,int j){\\n        int d=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=d;\\n    }\\n\\n    \\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.size(),i=0;\\n        // PLACING THE ELEMENT AT THE RIGHT PLACE.\\n        while(i<n){\\n            if(nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int d=-1;\\n\\n        // CHECKING THE ELEMENT PRESENT AT THEIR RIGHT PLACE OR NOT.\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=(i+1)){\\n                return nums[i];\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023792,
                "title": "slow-fast-method-time-o-n-space-o-1-full-explanation-with-diagram-4ms-only",
                "content": "# \\uD83D\\uDC22/\\uD83D\\uDC07: Slow / Fast Method\\n- Time: O(n) & Space: O(1) without modifying the array\\n- Floyd\\'s Algorithm\\n- \\u2705: Full Explanation with DIAGRAM\\n- \\uD83D\\uDD25: 4ms only\\n\\n# \\uD83E\\uDD14: ???\\n\\n- Main Class there are\\n- all example possible to understand the method more nicely\\n- aka, corner cases\\n- which are because of which you are unable to understand\\n- or is confusing you\\n- draw it and you will understand\\n- like below\\n\\n# \\uD83D\\uDCD2: Note\\n\\n- create Main.java file locally and try to run by you self\\n- also\\n- create your own diagram for other example\\n- and try running locally\\n-\\n- i have shown for\\n- { 2, 6, 4, 1, 7, 1, 5, 3, 10, 11, 8, 12, 9 }\\n\\n# \\uD83D\\uDD22: Values\\n\\n![](https://assets.leetcode.com/users/images/086348d3-69be-416a-8fff-24d1b47d4c81_1673250562.5988944.png)\\n\\n![](https://assets.leetcode.com/users/images/21cd76aa-f16e-4451-a389-f5c9c2bedea9_1673251563.3783538.png)\\n\\n# \\uD83D\\uDDE8\\uFE0F: Its Diagram\\n\\n- create 3 diff loops .... logically for this example\\n- but algorith will work for 1st loop only\\n\\n\\n![](https://assets.leetcode.com/users/images/a977cd64-6097-4cfc-b808-f5721ae42bab_1673252033.228035.png)\\n\\n![](https://assets.leetcode.com/users/images/cd2b7936-56e2-4a89-a77b-36e1de87786c_1673252265.003069.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/f5752e75-0409-4696-838a-fd7718b7849a_1673252574.755807.png)\\n\\n\\n# \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB: Code With Explanation\\n\\n```java\\n\\n// slow, fast method\\n\\n// To Code : ? min\\n// Execution : ? ms\\n\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution s = new Solution();\\n\\t\\tint arr[];\\n\\t\\tarr = new int[] { 2, 6, 4, 1, 3, 1, 5 };\\n\\t\\tarr = new int[] { 2, 5, 9, 6, 9, 3, 8, 9, 7, 1 };\\n\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 5, 2 };\\n        // special condition // intersection and duplicate is same\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 5, 6, 2 };\\n        // never visit 5 while finding intersection ... but will after\\n\\n\\t\\tarr = new int[] { 3, 1, 3, 4, 2, 5, 6 };\\n\\t\\t// not consider as element only\\n\\t\\t// 1, 5, 6 .... is never never visited\\n\\t\\t// as index and its value is same\\n\\t\\t// aka, self single element loop 1 --> 1 --> 1 --> 1\\n\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 2 };\\n\\t\\tarr = new int[] { 2, 6, 4, 1, 7, 1, 5, 3, 10, 11, 8, 12, 9 };\\n\\t\\t// creating its own loops\\n\\t\\t// --> 10 --> 8 --> 10\\n\\t\\t// --> 9 ---> 11 --> 12 --> 9\\n\\t\\t// which is not a part of main which will form loop\\n\\n\\t\\tSystem.out.println(\"Ans:- \" + s.findDuplicate(arr));\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic int findDuplicate(int[] nums) {\\n\\t\\tint slow = 0, fast = 0;\\n\\t\\tint new_slow = -1; // intersection / new slow\\n\\t\\tint dup = -1; // duplicate\\n\\n        // finding intersection\\n\\t\\tdo {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\n\\t\\t\\tSystem.out.print(String.format(\"slow: %d, fast: %d\\\\n\", slow, fast));\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tslow = 0;\\n\\t\\tnew_slow = fast; // intersection and new new slow\\n\\t\\tSystem.out.println(\"Intersection:- \" + new_slow + \"\\\\n\");\\n\\n        // finding duplicate\\n\\t\\twhile (new_slow != slow) {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tnew_slow = nums[new_slow];\\n\\n\\t\\t\\tSystem.out.println(String.format(\"slow: %d, new_slow: %d\", slow, new_slow));\\n\\t\\t}\\n\\n\\t\\tdup = new_slow;\\n\\n\\t\\tSystem.out.println(\"Duplicate:- \" + dup);\\n\\t\\treturn dup;\\n\\t}\\n}\\n\\n// can do without using new_slow and dup\\n// using fast only as variable\\n// but using new variables here to understand the problem\\n\\n\\n```\\n\\n# \\uD83D\\uDDDC\\uFE0F: Compress version\\n\\n- short version of above code\\n- without explanation\\n- also without new_slow and dup\\n    - which was for explanation\\n\\n```java\\n\\nclass Solution {\\n\\tpublic int findDuplicate(int[] nums) {\\n\\t\\tint slow = 0, fast = 0;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tslow = 0;\\n\\t\\twhile (fast != slow) {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[fast];\\n\\t\\t}\\n\\n\\t\\treturn fast;\\n\\t}\\n}\\n\\n\\n```\\n\\n# More Detail\\n\\n- Approach 7: Floyd\\'s Tortoise and Hare (Cycle Detection)\\n- https://leetcode.com/problems/find-the-duplicate-number/solutions/127594/find-the-duplicate-number/\\n\\n\\n.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```java\\n\\n// slow, fast method\\n\\n// To Code : ? min\\n// Execution : ? ms\\n\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\npublic class Main {\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution s = new Solution();\\n\\t\\tint arr[];\\n\\t\\tarr = new int[] { 2, 6, 4, 1, 3, 1, 5 };\\n\\t\\tarr = new int[] { 2, 5, 9, 6, 9, 3, 8, 9, 7, 1 };\\n\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 5, 2 };\\n        // special condition // intersection and duplicate is same\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 5, 6, 2 };\\n        // never visit 5 while finding intersection ... but will after\\n\\n\\t\\tarr = new int[] { 3, 1, 3, 4, 2, 5, 6 };\\n\\t\\t// not consider as element only\\n\\t\\t// 1, 5, 6 .... is never never visited\\n\\t\\t// as index and its value is same\\n\\t\\t// aka, self single element loop 1 --> 1 --> 1 --> 1\\n\\n\\t\\tarr = new int[] { 1, 3, 4, 2, 2 };\\n\\t\\tarr = new int[] { 2, 6, 4, 1, 7, 1, 5, 3, 10, 11, 8, 12, 9 };\\n\\t\\t// creating its own loops\\n\\t\\t// --> 10 --> 8 --> 10\\n\\t\\t// --> 9 ---> 11 --> 12 --> 9\\n\\t\\t// which is not a part of main which will form loop\\n\\n\\t\\tSystem.out.println(\"Ans:- \" + s.findDuplicate(arr));\\n\\t}\\n}\\n\\nclass Solution {\\n\\tpublic int findDuplicate(int[] nums) {\\n\\t\\tint slow = 0, fast = 0;\\n\\t\\tint new_slow = -1; // intersection / new slow\\n\\t\\tint dup = -1; // duplicate\\n\\n        // finding intersection\\n\\t\\tdo {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\n\\t\\t\\tSystem.out.print(String.format(\"slow: %d, fast: %d\\\\n\", slow, fast));\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tslow = 0;\\n\\t\\tnew_slow = fast; // intersection and new new slow\\n\\t\\tSystem.out.println(\"Intersection:- \" + new_slow + \"\\\\n\");\\n\\n        // finding duplicate\\n\\t\\twhile (new_slow != slow) {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tnew_slow = nums[new_slow];\\n\\n\\t\\t\\tSystem.out.println(String.format(\"slow: %d, new_slow: %d\", slow, new_slow));\\n\\t\\t}\\n\\n\\t\\tdup = new_slow;\\n\\n\\t\\tSystem.out.println(\"Duplicate:- \" + dup);\\n\\t\\treturn dup;\\n\\t}\\n}\\n\\n// can do without using new_slow and dup\\n// using fast only as variable\\n// but using new variables here to understand the problem\\n\\n\\n```\n```java\\n\\nclass Solution {\\n\\tpublic int findDuplicate(int[] nums) {\\n\\t\\tint slow = 0, fast = 0;\\n\\n\\t\\tdo {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[nums[fast]];\\n\\t\\t} while (slow != fast);\\n\\n\\t\\tslow = 0;\\n\\t\\twhile (fast != slow) {\\n\\t\\t\\tslow = nums[slow];\\n\\t\\t\\tfast = nums[fast];\\n\\t\\t}\\n\\n\\t\\treturn fast;\\n\\t}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891669,
                "title": "kotlin-iterative-o-n-o-1",
                "content": "```\\nclass Solution {\\n    fun findDuplicate(nums: IntArray): Int {\\n        var slow = 0\\n        var fast = 0\\n        \\n        while(true) {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if (fast == slow) break\\n        }\\n\\n        var slow2 = 0\\n        while(slow != slow2) {\\n            slow = nums[slow]\\n            slow2 = nums[slow2]\\n        }\\n\\n        return slow\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    fun findDuplicate(nums: IntArray): Int {\\n        var slow = 0\\n        var fast = 0\\n        \\n        while(true) {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if (fast == slow) break\\n        }\\n\\n        var slow2 = 0\\n        while(slow != slow2) {\\n            slow = nums[slow]\\n            slow2 = nums[slow2]\\n        }\\n\\n        return slow\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872160,
                "title": "go-binsearch",
                "content": "# Code\\n```\\nfunc lessOrEqual(nums []int, n int) int {\\n\\tcount := 0\\n\\tfor i := range nums {\\n\\t\\tif nums[i] <= n {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\nfunc findDuplicate(nums []int) int {\\n\\tleft, right := 1, len(nums)-1\\n\\tfor left < right {\\n\\t\\tmid := left + (right-left)/2\\n\\n\\t\\tif lessOrEqual(nums, mid) > mid {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lessOrEqual(nums []int, n int) int {\\n\\tcount := 0\\n\\tfor i := range nums {\\n\\t\\tif nums[i] <= n {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\nfunc findDuplicate(nums []int) int {\\n\\tleft, right := 1, len(nums)-1\\n\\tfor left < right {\\n\\t\\tmid := left + (right-left)/2\\n\\n\\t\\tif lessOrEqual(nums, mid) > mid {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764484,
                "title": "java-easy-to-understand-3-approaches-clean-code",
                "content": "Upvote if the solution helped :) || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- || are all my optimized leetcode solutions.\\n```\\n// Optimised Solution Without Modifying The Array: TC: O(N) SC: O(1)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int stable = nums[0];\\n        int fast = nums[0];\\n        \\n        do{\\n            \\n            stable = nums[stable];\\n            fast = nums[nums[fast]];\\n            \\n        }while(stable != fast);\\n        \\n        stable = nums[0];\\n        \\n        while(stable != fast){\\n            stable = nums[stable];\\n            fast = nums[fast];\\n        }\\n        \\n        return stable;\\n        \\n    }\\n}\\n\\n\\n\\n// Optimised Solution In One Loop (With Array Modification) TC: O(n) SC: O(1)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        while(nums[0] != nums[nums[0]]){\\n            int next = nums[nums[0]];\\n            nums[nums[0]] = nums[0];\\n            nums[0] = next;\\n        }\\n        \\n        return nums[0];\\n        \\n    }\\n}\\n\\n\\n// Brute Force Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        // Using HashSet To Store Unique Values\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        //Traversing Through The Array\\n        for(int num : nums){\\n            \\n            // Whenever set.add() returnns false, Return The Number As Its A Duplicate\\n            if(!set.add(num)){\\n                //Returning Duplicate\\n                return num;\\n            }\\n        }\\n        \\n        // Default Return In Case No Duplicate Is Found\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Optimised Solution Without Modifying The Array: TC: O(N) SC: O(1)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int stable = nums[0];\\n        int fast = nums[0];\\n        \\n        do{\\n            \\n            stable = nums[stable];\\n            fast = nums[nums[fast]];\\n            \\n        }while(stable != fast);\\n        \\n        stable = nums[0];\\n        \\n        while(stable != fast){\\n            stable = nums[stable];\\n            fast = nums[fast];\\n        }\\n        \\n        return stable;\\n        \\n    }\\n}\\n\\n\\n\\n// Optimised Solution In One Loop (With Array Modification) TC: O(n) SC: O(1)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        while(nums[0] != nums[nums[0]]){\\n            int next = nums[nums[0]];\\n            nums[nums[0]] = nums[0];\\n            nums[0] = next;\\n        }\\n        \\n        return nums[0];\\n        \\n    }\\n}\\n\\n\\n// Brute Force Solution TC: O(n) SC: O(n)\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        // Using HashSet To Store Unique Values\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        //Traversing Through The Array\\n        for(int num : nums){\\n            \\n            // Whenever set.add() returnns false, Return The Number As Its A Duplicate\\n            if(!set.add(num)){\\n                //Returning Duplicate\\n                return num;\\n            }\\n        }\\n        \\n        // Default Return In Case No Duplicate Is Found\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670100,
                "title": "python-3-line-solution-faster-than-90-35-users",
                "content": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in nums:\\n            nums[abs(i)-1] *= -1\\n            if nums[abs(i)-1] > 0: return abs(i)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in nums:\\n            nums[abs(i)-1] *= -1\\n            if nums[abs(i)-1] > 0: return abs(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133134,
                "title": "python-3-o-n-one-line-solution-set-math",
                "content": "```\\nclass Solution:\\n\\tdef findDuplicate(self, nums: List[int]) -> int:\\n        return (sum(nums) - sum(set(nums))) // (len(nums) - len(set(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findDuplicate(self, nums: List[int]) -> int:\\n        return (sum(nums) - sum(set(nums))) // (len(nums) - len(set(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894073,
                "title": "a-note-on-binary-search-a-must-read",
                "content": "# **DISCLAIMER**\\nWe want to present a full solution that **satisfies the requirements** of the problem: **not modifying the array** (so no negative marking, no sorting, etc.) and **using at most O(1) extra memory**.\\n```\\n```\\n# **A COUPLE OF FACTS**\\n* **FACT I:** if we want to do binary search on an array, the array **must** be sorted.\\n* **FACT II:** for this problem we can (pretend to \\uD83D\\uDE09) create a sorted *helper* array so we can achieve our goal with binary search **without** modifying `nums` or using more than O(1) extra memory. However this will compromise execution time: **The time complexity of this solution is O(n log(n))**.\\n```\\n```\\n# **THE IDEA**\\nLet\\'s **pretend** for a second that the condition of using at most O(1) extra space is not *required*.\\n\\nGiven the array `nums` consider the array `helper` where `helper[i]` is equal to the number of elements in the array `nums` that are **smaller than** `i`. It is **always** true that `helper[i] <= helper[j]` if `i < j`, so `helper` **is** an array sorted in non-decreasing order (which will be crucial so that we can do binary search on it!!). \\n\\nIf `nums` was (some permutation of) the array `[0, 1, 2, ..., n - 1]`, this `helper` array would look like `[0, 1, 2, 3, ..., n - 1]` (same array as `sorted(nums)`!). This is, however, not the case for this problem, as there is one element that is repeated **at least once**.\\n\\nIf, for example, we had `nums = [4, 5, 6, 7, 4, 2, 3, 4]` our helper array would be `helper = [0, 0, 0, 1, 2, 5, 6, 7]`. It is a nice array sorted in non-decreasing order. Notice too that *almost everywhere* it is true that `helper[i + 1] - helper[i] <= 1`.\\n\\nExamining our array `nums` we can see that the repeated number is `4` **and** *the* one jump we can see in `helper` is precisely from `2` to `5`. This should come as no surprise: if we sorted `nums` we would get `[2, 3, 4, 4, 4, 5, 6, 7]`. Notice how `helper` and `sorted(nums)` coincide from `5` onwards? This is true since `5` is the **smallest** number that is **larger than the repeated number**. (I\\'ll let you think on that fact, we can discuss further in the comments section if it is not clear why this is always true.) This property can be translated as *\"`5` is the first index for which it\\'s not true that `helper[i] < i`\"*.\\n\\nThis is the **key** into how we\\'ll use `helper` to find our repeated number using binary search: We will be looking for the one jump in `helper`. Once we find where `helper` jumps to, we\\'ll know that the repeated number is equal to `jump - 1`. \\n```\\n```\\n# **HOW TO PROCEED WITHOUT USING MORE THAN CONSTANT EXTRA MEMORY?**\\nNow that we know how we want to make use of `helper`, we will **fake it** so we do not have to take the *extra O(n) space* it would need. \\n\\nConsider the function\\n```\\n        def search(idx: int) -> bool:\\n            count = 0\\n            for i in range(n + 1):\\n                if nums[i] < idx:\\n                    count += 1\\n            return count < idx\\n```\\nThis function will mimic the properties of `helper` we want. Notice that for `0 < i`,  `search(i) == True` if and only if `helper[i] < i`. So, we are looking for the smallest `0 < i` such that `search(i) == False`. Once we find it we\\'ll have that the anwer is `i - 1`.\\n\\n# **LET\\'S BE CAREFUL WITH EDGE CASES**\\nConsider the input `nums = [n, n, ..., n, n]`. We have that  `helper = [0, 0, ..., 0, 0]` (so `search(i)` is **always** `True` for `0 < i`). To remedy this, we will set our initial conditions as\\n```\\n        left = 1\\n        right = n + 1  # it is always true that search(n + 1) == False\\n```\\n\\n# **WE ARE NOW READY TO DO BINARY SEARCH**\\nWe\\'ll keep iterating until it is no longer true that `left < right`.\\n\\nOn each iteration we will:\\n* set `mid = (left + right) // 2`\\n* check `search(mid)` (remember we are looking for the smallest `i` such that `search(i) == False`)\\n\\t* if `True` we\\'ll update `left = mid + 1` (the `i` we are looking for is definitely after `mid`)\\n\\t* if `False` we\\'ll update `right = mid` (the `i` we are looking for might be `mid` or smaller)\\n\\nOnce we are out of the loop, we have that the answer is `left - 1`.\\n\\n**Thanks for coming to my TED talk!!** \\uD83E\\uDD73\\n&#8718;\\n\\n\\n# **THE WHOLE SOLUTION**\\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n    \\n        n = len(nums) - 1\\n        \\n        def search(num: int) -> bool:\\n            count = 0\\n            for i in range(n + 1):\\n                if nums[i] < num:\\n                    count += 1\\n            return count < num\\n        \\n        left = 1\\n        right = n + 1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if search(mid):\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left - 1\\n```\\n# **COMMENTS**\\nThe `search` function requires O(n) time, so **this solution runs in O(n log(n)) time.**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n        def search(idx: int) -> bool:\\n            count = 0\\n            for i in range(n + 1):\\n                if nums[i] < idx:\\n                    count += 1\\n            return count < idx\\n```\n```\\n        left = 1\\n        right = n + 1  # it is always true that search(n + 1) == False\\n```\n```\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n    \\n        n = len(nums) - 1\\n        \\n        def search(num: int) -> bool:\\n            count = 0\\n            for i in range(n + 1):\\n                if nums[i] < num:\\n                    count += 1\\n            return count < num\\n        \\n        left = 1\\n        right = n + 1\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if search(mid):\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894044,
                "title": "3-line-solution-easy-to-understand-but-no-faster",
                "content": "var findDuplicate = function(nums) {\\n    nums.sort();\\n\\n    for (let i = 0; i < nums.length; i+=2) {\\n        if (nums[i] === nums[i+1] || nums[i] === nums[i-1]) return nums[i];\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var findDuplicate = function(nums) {\\n    nums.sort();\\n\\n    for (let i = 0; i < nums.length; i+=2) {\\n        if (nums[i] === nums[i+1] || nums[i] === nums[i-1]) return nums[i];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1706093,
                "title": "problem-solved-why-xor-doesn-t-work",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& arr) {\\n        int xor1 = arr[0];\\n    for(int i=1;i<arr.size();i++){\\n        xor1 ^= arr[i];\\n    }\\n    for(int i=1;i<arr.size();i++){\\n        xor1 ^= i;\\n    }\\n    return xor1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& arr) {\\n        int xor1 = arr[0];\\n    for(int i=1;i<arr.size();i++){\\n        xor1 ^= arr[i];\\n    }\\n    for(int i=1;i<arr.size();i++){\\n        xor1 ^= i;\\n    }\\n    return xor1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423541,
                "title": "c-floyd-s-tortoise-hare-method-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) \\n    {\\n        // Treat the whole nums array as a linked list.\\n        // Each entry in the array is a node.\\n        // The val of each node is the index of next node it is pointing to.\\n        // ^ this is possible due to the [1,n] domain\\n        // Eg. [1,3,4,2,2] : 1 points to 3, 3 points to 2, etc.\\n        // Since there is a duplicate number, we know one of the nodes is guaranteed\\n        // to be pointed-to by > 1 other node.\\n        // ^ This means that the linked list has a cycle.\\n        // We can utilize Floyd\\'s Tortoise and Hare method to detect the start of the\\n        // cycle. \\n        // This start of the cycle is the double pointed-to number, aka, the duplicate.\\n        \\n        // Floyd\\'s tortoise and hare method.\\n        // 2 ptrs, 1 traverses 2x as fast\\n        // Traverse until they meet\\n        int i = nums[i], j = nums[nums[j]];\\n        while (i != j)\\n        {\\n            i = nums[i];\\n            j = nums[nums[j]];\\n        }\\n        \\n        // Set one of them back to the start and traverse normally until they meet\\n        i = 0;\\n        while (i != j)\\n        {\\n            i = nums[i];\\n            j = nums[j];\\n        }\\n        \\n        // Meeting point is the duplicate number\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) \\n    {\\n        // Treat the whole nums array as a linked list.\\n        // Each entry in the array is a node.\\n        // The val of each node is the index of next node it is pointing to.\\n        // ^ this is possible due to the [1,n] domain\\n        // Eg. [1,3,4,2,2] : 1 points to 3, 3 points to 2, etc.\\n        // Since there is a duplicate number, we know one of the nodes is guaranteed\\n        // to be pointed-to by > 1 other node.\\n        // ^ This means that the linked list has a cycle.\\n        // We can utilize Floyd\\'s Tortoise and Hare method to detect the start of the\\n        // cycle. \\n        // This start of the cycle is the double pointed-to number, aka, the duplicate.\\n        \\n        // Floyd\\'s tortoise and hare method.\\n        // 2 ptrs, 1 traverses 2x as fast\\n        // Traverse until they meet\\n        int i = nums[i], j = nums[nums[j]];\\n        while (i != j)\\n        {\\n            i = nums[i];\\n            j = nums[nums[j]];\\n        }\\n        \\n        // Set one of them back to the start and traverse normally until they meet\\n        i = 0;\\n        while (i != j)\\n        {\\n            i = nums[i];\\n            j = nums[j];\\n        }\\n        \\n        // Meeting point is the duplicate number\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343891,
                "title": "test-case-2-2-2-2-2",
                "content": "Can anyone please help me understand why the below test case is valid:\\n\\t```2,2,2,2,2```\\n\\tBecause in the question it clearly specifies exactly one element is repeated. Seems like I\\'m missing something here.",
                "solutionTags": [],
                "code": "```2,2,2,2,2```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255914,
                "title": "python-o-n-solution-without-extra-space",
                "content": "by seeing contraints 1 <= nums[i] <= n , we can se every number in array will be in range 1 to n.\\nso we will iterate through array and make index of current number negative ,so whenever we find same number ,we will check index of that number,if it\\'s negative ,then return that number\\nexample:\\n3 4 5 6 1 3\\nwe start iterating first we get 3 so we will make index 3 number negative\\n3 4 5 -6 1 3\\n\\nwhen we came at last 3 of array we will check index 3 which is negative,so we will return that\\n\\n\\n```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        for n in nums:\\n            m=abs(n)\\n            if nums[m-1]<0:\\n                return m\\n            else:\\n                nums[m-1]*=-1",
                "solutionTags": [],
                "code": "by seeing contraints 1 <= nums[i] <= n , we can se every number in array will be in range 1 to n.\\nso we will iterate through array and make index of current number negative ,so whenever we find same number ,we will check index of that number,if it\\'s negative ,then return that number\\nexample:\\n3 4 5 6 1 3\\nwe start iterating first we get 3 so we will make index 3 number negative\\n3 4 5 -6 1 3\\n\\nwhen we came at last 3 of array we will check index 3 which is negative,so we will return that\\n\\n\\n```\\ndef findDuplicate(self, nums: List[int]) -> int:\\n        for n in nums:\\n            m=abs(n)\\n            if nums[m-1]<0:\\n                return m\\n            else:\\n                nums[m-1]*=-1",
                "codeTag": "Python3"
            },
            {
                "id": 1225316,
                "title": "my-attempt-to-explain-binary-search-solution-code-in-java",
                "content": "I found this solution from one of the top rated [post](https://leetcode.com/problems/find-the-duplicate-number/discuss/72844/Two-Solutions-(with-explanation):-O(nlog(n))-and-O(n)-time-O(1)-space-without-changing-the-input-array), but still, it took me a while to understand it. I am writing this post as an attempt to explain the solution much clearer, hopefully it can help some people.\\n\\nLet\\'s begin:\\n\\nThe question is saying that we have `n+1` slots, which will be filled by numbers from `1 to n`. As a more concrete example, let\\'s suppose `n=4`, we will have 5 slots and the numbers will be `1,2,3,4` with one of them being the duplicate.\\n\\nLet\\'s suppose the duplicated number is `2`, we will get an array like in **Example 1**\\n```\\nnums = [1,3,4,2,2]\\n```\\nLet\\'s sort the array first to make thing clearer.\\n```\\nnums = [1,2,2,3,4]\\n```\\nFor each `num` in `nums`, if we try to find the the count of all numbers that are `<=num`, we will get the following results.\\n```\\nnums = [1,2,2,3,4]\\ncount:  1 3 3 4 5\\n// some other example\\nnums2 = [1,2,2,2,4]\\ncount:   1 4 4 4 5\\nnums3 = [1,2,3,3,3]\\ncount:   1 2 5 5 5\\n```\\nThe number `nums[2]` has `nums[0] nums[1] nums[2]` as the  number smaller or equal than itself, so the count is `3`.\\nThe pattern is that *when the preceding number is duplicated, the following count will be greater than itself.*\\n\\nBut without sorting, how do we apply binary search?\\n\\nAnswer is: the index of an array is always sorted, we can use the index to represent each number in the array. Maybe the number does not exist in the array, but binary search will close the search space to only 1 number(index), such that to the left of this number(index-1), the count is lower or equal.\\n\\nBack to our unsorted example\\n```\\nnums = [1,3,4,2,2]\\ncount:  1 4 5 3 3\\n```\\nThe first number we are testing is `2`, which is the mid index. Notice the `nums[2]` is `4`, but we do not care. \\n\\n`count=3` which is greater than `2`, so `2` must be to the right of our target. And we shrink the search space to (0,2]. \\n\\nThis time `mid=0+(2-0)/2`, which is `1`. But the `count=1`, which is less than or equal to `1`, meaning we are to the left to our target. And that\\'s how we finally converge to index `2`, which is also the answer.\\n\\nIn conclusion, we are going to do the count `logn` times, because it\\'s binary search. And for each count we will go through `n` numbers. So the time complexity is `O(nlogn)` and constant space.\\n\\n\\nThe code is pretty straight forward, just be mindful that we are binary searching on the index, which is sorted.\\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int low=0, high=nums.length-1;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int num:nums){\\n                if(num<=mid) count++;\\n            }\\n            if(count<=mid){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        // return low or high, since they are the same\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nnums = [1,3,4,2,2]\\n```\n```\\nnums = [1,2,2,3,4]\\n```\n```\\nnums = [1,2,2,3,4]\\ncount:  1 3 3 4 5\\n// some other example\\nnums2 = [1,2,2,2,4]\\ncount:   1 4 4 4 5\\nnums3 = [1,2,3,3,3]\\ncount:   1 2 5 5 5\\n```\n```\\nnums = [1,3,4,2,2]\\ncount:  1 4 5 3 3\\n```\n```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int low=0, high=nums.length-1;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int num:nums){\\n                if(num<=mid) count++;\\n            }\\n            if(count<=mid){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        // return low or high, since they are the same\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998555,
                "title": "java-o-n-time-o-1-space-another-way",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[Math.abs(nums[i])];\\n            \\n            if (num >= 0)  {\\n\\t\\t\\t\\t// mark visited number\\n                nums[Math.abs(nums[i])] *= -1;\\n            } else {\\n\\t\\t\\t\\t// means visiting second time\\n                return Math.abs(nums[i]);\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[Math.abs(nums[i])];\\n            \\n            if (num >= 0)  {\\n\\t\\t\\t\\t// mark visited number\\n                nums[Math.abs(nums[i])] *= -1;\\n            } else {\\n\\t\\t\\t\\t// means visiting second time\\n                return Math.abs(nums[i]);\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960449,
                "title": "error",
                "content": "The question says that **There is only one duplicate number in nums, return this duplicate number.**\\nBut one of the test case is: [2, 2, 2, 2, 2].\\nWhy??",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 943483,
                "title": "o-1-space-and-o-n-time-solution",
                "content": "This question is same as leetcode hard question First Positive Missing no. if you solve it in O(1) space\\njust thaat here no -ve nos. are allowed so we don\\'t have to check for them\\nhttps://leetcode.com/problems/first-missing-positive/\\nHere we know that there are n+1 no.s all in range of 1 to n so it is certain that one no has to repeat. Now we should try to set them in ascending each no \\'n\\' at position \\'n-1\\' unless \\'n\\' is already present there which will be case if n repeats \\na[0] -> 1\\na[1] -> 2\\nand so on......\\n\\nNow the last element of array will give us the 1st repeating no.\\nIt will even work of testcases when a no. repeats more then twice - like - [1,1,1]\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            while(nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        return nums[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            while(nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        return nums[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907205,
                "title": "c-o-n-time-o-1-space-using-floyd-s-tortoise-and-hare",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findDuplicate(vector<int> &nums)\\n    {\\n        int slow = nums[0];\\n        int fast = nums[nums[0]];\\n\\n        while (fast != slow)\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n\\n        fast = 0;\\n        while (slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        //slow or fast doesn\\'t matter here\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findDuplicate(vector<int> &nums)\\n    {\\n        int slow = nums[0];\\n        int fast = nums[nums[0]];\\n\\n        while (fast != slow)\\n        {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        }\\n\\n        fast = 0;\\n        while (slow != fast)\\n        {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n\\n        //slow or fast doesn\\'t matter here\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865153,
                "title": "two-o-n-solutions-set-and-cycledetection",
                "content": "```\\nclass Solution {\\n    /**\\n     * First approac is very simple, since we know that there must be at least one \\n     *  duplicate number and the largest number is n, we create an array of n elements\\n     *  and check each element after we seen it in the nums array.\\n     *  \\n     *  If at one point we see an element that is already checked in the array, we found\\n     *  the duplicate number\\n     *\\n     *  Time complexity: O(N)\\n     *  Space complexity: O(N)\\n     *   public int findDuplicate(int[] nums) {\\n     *       boolean[] check = new boolean[nums.length];\\n     *       for (int i = 0; i < nums.length; i++) {\\n     *           if (check[nums[i]]) return nums[i];\\n     *\\n     *           check[nums[i]] = true;\\n     *       }\\n     *\\n     *       return 0;\\n     *   }\\n     ***/\\n    \\n    /**\\n     * The second approach use a fast and slow pointers approach to find the starting\\n     * point of a cycle in a linked list.\\n     *\\n     * The fast pointer will always step over 2 nodes, the slow pointer will always step over 1 node\\n     * Since there is a cycle in the list, the 2 pointers will eventually meet each other.\\n     *\\n     * After that we just bring one pointer back to the start, and then make them both step over 1\\n     * node at a time, when they meet each other, we have found the start of the cycle.\\n     *\\n     * For more detailed explanation: Please see the Solution section.\\n     * Time complexity: O(N)\\n     * Space complexity: O(1)\\n     */\\n    public int findDuplicate(int[] nums) {\\n        int fastPointer = 0, slowPointer = 0;\\n        \\n\\t\\t// Phase 1: Try to make them meet each other\\n        do \\n        {\\n            fastPointer = nums[nums[fastPointer]];\\n            slowPointer = nums[slowPointer];\\n        }\\n        while (fastPointer != slowPointer);\\n        \\n\\t\\t// Phase 2: Bring the slow pointer to the start and make them move over 1 by 1\\n        slowPointer = 0;\\n        while (slowPointer != fastPointer) {\\n            slowPointer = nums[slowPointer];\\n            fastPointer = nums[fastPointer];\\n        }\\n        \\n        return slowPointer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n     * First approac is very simple, since we know that there must be at least one \\n     *  duplicate number and the largest number is n, we create an array of n elements\\n     *  and check each element after we seen it in the nums array.\\n     *  \\n     *  If at one point we see an element that is already checked in the array, we found\\n     *  the duplicate number\\n     *\\n     *  Time complexity: O(N)\\n     *  Space complexity: O(N)\\n     *   public int findDuplicate(int[] nums) {\\n     *       boolean[] check = new boolean[nums.length];\\n     *       for (int i = 0; i < nums.length; i++) {\\n     *           if (check[nums[i]]) return nums[i];\\n     *\\n     *           check[nums[i]] = true;\\n     *       }\\n     *\\n     *       return 0;\\n     *   }\\n     ***/\\n    \\n    /**\\n     * The second approach use a fast and slow pointers approach to find the starting\\n     * point of a cycle in a linked list.\\n     *\\n     * The fast pointer will always step over 2 nodes, the slow pointer will always step over 1 node\\n     * Since there is a cycle in the list, the 2 pointers will eventually meet each other.\\n     *\\n     * After that we just bring one pointer back to the start, and then make them both step over 1\\n     * node at a time, when they meet each other, we have found the start of the cycle.\\n     *\\n     * For more detailed explanation: Please see the Solution section.\\n     * Time complexity: O(N)\\n     * Space complexity: O(1)\\n     */\\n    public int findDuplicate(int[] nums) {\\n        int fastPointer = 0, slowPointer = 0;\\n        \\n\\t\\t// Phase 1: Try to make them meet each other\\n        do \\n        {\\n            fastPointer = nums[nums[fastPointer]];\\n            slowPointer = nums[slowPointer];\\n        }\\n        while (fastPointer != slowPointer);\\n        \\n\\t\\t// Phase 2: Bring the slow pointer to the start and make them move over 1 by 1\\n        slowPointer = 0;\\n        while (slowPointer != fastPointer) {\\n            slowPointer = nums[slowPointer];\\n            fastPointer = nums[fastPointer];\\n        }\\n        \\n        return slowPointer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855884,
                "title": "c-logic-solution-explained-follow-ups-beats-98-in-runtime-94-less-space",
                "content": "\\n```\\nclass Solution\\n{\\npublic:\\n    int findDuplicate(vector<int> &nums)\\n    {\\n        int visited;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n\\t\\t  // We know that all the elements in the array are upto n only.\\n\\t\\t  // So, we choosing a num(starting) and marking as visited.\\n            visited = abs(nums[i]);\\n            if (nums[visited] < 0) // This will found the duplicate element and returns\\n                return visited;\\n            else\\n                nums[visited] = -nums[visited]; // Marking as Visited\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findDuplicate(vector<int> &nums)\\n    {\\n        int visited;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n\\t\\t  // We know that all the elements in the array are upto n only.\\n\\t\\t  // So, we choosing a num(starting) and marking as visited.\\n            visited = abs(nums[i]);\\n            if (nums[visited] < 0) // This will found the duplicate element and returns\\n                return visited;\\n            else\\n                nums[visited] = -nums[visited]; // Marking as Visited\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808217,
                "title": "java-binary-search-on-range-o-n-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isDuplicateRange(int l, int r, int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] >= l && nums[i] <= r)\\n                ++count;\\n        }\\n        return r - l + 1 < count;\\n    }\\n    \\n    public int findDuplicate(int[] nums) {\\n        int N = nums.length - 1;\\n        int l = 1;\\n        int r = N;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isDuplicateRange(l, mid, nums)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isDuplicateRange(int l, int r, int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] >= l && nums[i] <= r)\\n                ++count;\\n        }\\n        return r - l + 1 < count;\\n    }\\n    \\n    public int findDuplicate(int[] nums) {\\n        int N = nums.length - 1;\\n        int l = 1;\\n        int r = N;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isDuplicateRange(l, mid, nums)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763624,
                "title": "without-sorting-and-fast-slow-pointers-o-n-time-and-o-1-space-easy-solution",
                "content": "```\\n\\nint findDuplicate(vector<int>& nums) {\\n        int i=0,num;\\n        do\\n        {\\n            if(nums[i]>0){\\n            num = nums[i];\\n            nums[i] = -nums[i];\\n            i = num;\\n            }\\n            else return i;\\n        }while(true);\\n    }\\n\\n\\n```\\n\\t\\n\\t\\n\\tExample: Array a [2,3,4,1,2] \\n\\tAnswer is 2.\\n\\tThe solution approach is, as the values in the array are indexes of array(1,2,3....,n-1), you can itearate through array \\n    by using the value as index, and mark visited values as negative.If we find negative value while iterating that means\\n    we have visited that array value,that index will be the answer.\\n\\tWe iterate from start\\n\\ta[0] = 2  -----> mark it as negative a[0] = -2.\\n\\tnow we\\'ll visit 2nd index element, as value obtained from a[0] is 2,\\n\\ta[2] = 4 ------> mark it as negative a[2] = -4.\\n\\tnow we\\'ll visit 4th index element, as value obtained from a[2] is 4,\\n\\ta[4] = 2 ------>mark it as negative a[4] = -2.\\n\\tnow we\\'ll visit 2nd index element,as value obtained from a[4] is 2\\n\\ta[2] = -4 , which is already negative means we have visited index 2 twice, means there are two 2 values in array.\\n\\tReturn the value 2.\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Array",
                    "Graph"
                ],
                "code": "```\\n\\nint findDuplicate(vector<int>& nums) {\\n        int i=0,num;\\n        do\\n        {\\n            if(nums[i]>0){\\n            num = nums[i];\\n            nums[i] = -nums[i];\\n            i = num;\\n            }\\n            else return i;\\n        }while(true);\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 704931,
                "title": "cpp-binary-search-o-1-space-explained",
                "content": "Since we have ``` n+1 ``` elements in ``` nums ``` which consists of  ``` n ``` distinct elements so to find that one duplicate element we can use the binary search to find out in the following way : \\n1. first set ```start=1``` and ```end=n``` \\n2. begin with while loop under the condition ```end>start```\\n3. find ```mid``` using ```mid=start+(end-start)/2``` . Note : ``` mid=(start+end)/2``` can leads to integer overflow.\\n4.  then run a for loop through the array to find the number of elements that are less than or equal to ```mid``` ( count of elements which are less than or equal to ```mid``` )\\n5.  then check if the count ```tmp``` is greater then ```mid``` or not. if greater than make ``` end=mid``` it is because we have```n``` distinct elements from ```[1,n]``` in the ```nums``` which is of size ```n+1``` so if ```tmp``` is greater than ```mid``` it means that that extra element is in the left array of mid.\\n6.  same we will do if ```tmp```is less than ```mid``` we will make ```start=mid+1```\\n\\n```\\nclass Solution {\\npublic:\\n    #define sz size()\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.sz;\\n        if(n==0)\\n            return -1;\\n        int start,end;\\n        start=1;\\n        end=n;\\n        while(start<end){\\n            int m=(start+end)/2;\\n            int tmp=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<=m)\\n                    tmp++;\\n            }\\n            if(tmp>m)\\n                end=m;\\n            else \\n                start=m+1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` n+1 ```\n``` nums ```\n``` n ```\n```start=1```\n```end=n```\n```end>start```\n```mid```\n```mid=start+(end-start)/2```\n``` mid=(start+end)/2```\n```mid```\n```mid```\n```tmp```\n```mid```\n``` end=mid```\n```n```\n```[1,n]```\n```nums```\n```n+1```\n```tmp```\n```mid```\n```tmp```\n```mid```\n```start=mid+1```\n```\\nclass Solution {\\npublic:\\n    #define sz size()\\n    int findDuplicate(vector<int>& nums) {\\n        int n=nums.sz;\\n        if(n==0)\\n            return -1;\\n        int start,end;\\n        start=1;\\n        end=n;\\n        while(start<end){\\n            int m=(start+end)/2;\\n            int tmp=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<=m)\\n                    tmp++;\\n            }\\n            if(tmp>m)\\n                end=m;\\n            else \\n                start=m+1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688720,
                "title": "c-easy-to-understand-solution-using-loop-detection",
                "content": "Just like detecting loops in a linked list, the repeated integer can be detected in the current question.\\n```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        do{\\n            p1 = nums[p1];\\n            p2 = nums[nums[p2]];\\n        }while(p1!=p2);\\n        p2 = 0;\\n        while(p1!=p2){\\n            p1 = nums[p1];\\n            p2 = nums[p2];\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        do{\\n            p1 = nums[p1];\\n            p2 = nums[nums[p2]];\\n        }while(p1!=p2);\\n        p2 = 0;\\n        while(p1!=p2){\\n            p1 = nums[p1];\\n            p2 = nums[p2];\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566929,
                "title": "java-solution-0ms-tortoise-and-hare-method",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int tortoise=nums[0];\\n        int hare=nums[0];\\n        while(true)\\n        {\\n            tortoise=nums[tortoise];\\n            hare=nums[nums[hare]];\\n            if(tortoise==hare)\\n                break;\\n        }\\n        int ptr1=nums[0];\\n        int ptr2=tortoise;\\n        while(ptr1!=ptr2)          \\n        {\\n            ptr1=nums[ptr1];\\n            ptr2=nums[ptr2];\\n        } \\n        return ptr1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int tortoise=nums[0];\\n        int hare=nums[0];\\n        while(true)\\n        {\\n            tortoise=nums[tortoise];\\n            hare=nums[nums[hare]];\\n            if(tortoise==hare)\\n                break;\\n        }\\n        int ptr1=nums[0];\\n        int ptr2=tortoise;\\n        while(ptr1!=ptr2)          \\n        {\\n            ptr1=nums[ptr1];\\n            ptr2=nums[ptr2];\\n        } \\n        return ptr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468062,
                "title": "time-o-n-space-o-1-no-cycle-detection-algorithm",
                "content": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return -1;\\n        \\n        int[] hashmap = new int[32];\\n        int[] map = new int[32];\\n        \\n        Arrays.fill(hashmap, 0);\\n        Arrays.fill(map, 0);\\n        \\n        int n = nums.length;\\n        \\n\\t\\t//Step 1\\n        for(int i = 1; i < n; i++){\\n            int temp = i;\\n            int idx = 0;\\n            while(temp > 0){\\n                if((temp & 1) == 1)\\n                    hashmap[idx]++;\\n                temp = temp >> 1;\\n                idx ++;\\n            }\\n        }\\n        \\n\\t\\t\\n\\t\\t//Step 2\\n        for(int i = 0; i < nums.length; i++){\\n            int temp = nums[i];\\n            int idx = 0;\\n            while(temp > 0){\\n                if((temp & 1) == 1)\\n                    map[idx]++;\\n                temp = temp >> 1;\\n                idx++;\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n\\t\\t//Step 3 and 4\\n        for(int i = 0; i < 32; i++){\\n            if(map[i] > hashmap[i])\\n                result = result | (1 << i);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\\n\\n1.  First count the number of occurence of bit set to 1 at each bit position (i. e. from position 1 to position 32) for range 1 to n both inclusive, used int array \"hashmap\" to do so.\\n2.  Count the number of occurence of bit set to 1 at each bit position (i. e. from position 1 to position 32) for numbers given in the array, used int array \"map\" to do so.\\n3. If a number \\'x\\' is repeated in the array then for each bit position \\'pos\\' set to 1 in number \\'x\\', map[pos] > hashmap[pos] holds true.\\n4. Using map[pos] > hashmap[pos], extract all the bit positions set to 1 in number \\'x\\'.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return -1;\\n        \\n        int[] hashmap = new int[32];\\n        int[] map = new int[32];\\n        \\n        Arrays.fill(hashmap, 0);\\n        Arrays.fill(map, 0);\\n        \\n        int n = nums.length;\\n        \\n\\t\\t//Step 1\\n        for(int i = 1; i < n; i++){\\n            int temp = i;\\n            int idx = 0;\\n            while(temp > 0){\\n                if((temp & 1) == 1)\\n                    hashmap[idx]++;\\n                temp = temp >> 1;\\n                idx ++;\\n            }\\n        }\\n        \\n\\t\\t\\n\\t\\t//Step 2\\n        for(int i = 0; i < nums.length; i++){\\n            int temp = nums[i];\\n            int idx = 0;\\n            while(temp > 0){\\n                if((temp & 1) == 1)\\n                    map[idx]++;\\n                temp = temp >> 1;\\n                idx++;\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n\\t\\t//Step 3 and 4\\n        for(int i = 0; i < 32; i++){\\n            if(map[i] > hashmap[i])\\n                result = result | (1 << i);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435964,
                "title": "swift-hare-and-tortoise-solution",
                "content": "```\\nclass Solution {\\n    func findDuplicate(_ nums: [Int]) -> Int {\\n        var slow = 0\\n        var fast = 0\\n        repeat {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        } while slow != fast\\n        var first = 0\\n        repeat {\\n            first = nums[first]\\n            slow = nums[slow]\\n        } while slow != first\\n        return first\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findDuplicate(_ nums: [Int]) -> Int {\\n        var slow = 0\\n        var fast = 0\\n        repeat {\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n        } while slow != fast\\n        var first = 0\\n        repeat {\\n            first = nums[first]\\n            slow = nums[slow]\\n        } while slow != first\\n        return first\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421860,
                "title": "simple-python-code-using-set-data-structure-this-is-just-a-discussion-for-fun",
                "content": "**Note:**\\nThis code might not satisfy the space constraint of the problem, but is a very simple code that is plausible to come up with during an interview. \\nIf your answer is cycle detection during an interview, the interviewer will know for sure that you have seen the solution before. \\n\\n**Code:**\\n```\\n    def findDuplicate(self, nums):\\n\\t\\treturn (sum(nums) - sum(set(nums))) // (len(nums) - len(set(nums)))\\n```\\n\\n**Explanation:**\\nThe idea is that set of the input array does not contain any repetion. This can be better seen by an example:\\n```\\nnums = [1, 4, 4, 2, 4]\\nset(nums) = {1, 2, 4}\\n\\nsum(nums) = 15\\nsum(set(nums)) = 7\\n\\n (sum(nums) - sum(set(nums))) = 8\\n ```\\n This difference is due to the fact that  number 4 is repeated twice in the nums. The number of the repetion can be calculated as:\\n ```\\n (len(nums) - len(set(nums))) = 2\\n ```\\n And we will have the duplicate number as mentioned in the code:\\n ```\\n (sum(nums) - sum(set(nums))) / (len(nums) - len(set(nums))) = 8 / 2 = 4\\n ```\\n",
                "solutionTags": [],
                "code": "```\\n    def findDuplicate(self, nums):\\n\\t\\treturn (sum(nums) - sum(set(nums))) // (len(nums) - len(set(nums)))\\n```\n```\\nnums = [1, 4, 4, 2, 4]\\nset(nums) = {1, 2, 4}\\n\\nsum(nums) = 15\\nsum(set(nums)) = 7\\n\\n (sum(nums) - sum(set(nums))) = 8\\n ```\n```\\n (len(nums) - len(set(nums))) = 2\\n ```\n```\\n (sum(nums) - sum(set(nums))) / (len(nums) - len(set(nums))) = 8 / 2 = 4\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 348239,
                "title": "simple-code-in-go-4ms-beats-99-6",
                "content": "The main idea is the same with problem Linked List Cycle II,https://leetcode.com/problems/linked-list-cycle-ii/.\\nUse two pointers the fast and the slow.\\nThe fast one goes forward two steps each time, while the slow one goes only step each time.\\nThey must meet the same item when slow==fast.\\nIn fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0].\\nNext we just need to find the entry point.\\nWe use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle.\\ntime o(n)\\tspace o(1)\\n```\\nfunc findDuplicate(nums []int) int {\\n    slow := nums[0]\\n    fast := nums[nums[0]]\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[nums[fast]]\\n    }\\n    fast = 0\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[fast]\\n    }\\n    return fast\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc findDuplicate(nums []int) int {\\n    slow := nums[0]\\n    fast := nums[nums[0]]\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[nums[fast]]\\n    }\\n    fast = 0\\n    for slow != fast {\\n        slow = nums[slow]\\n        fast = nums[fast]\\n    }\\n    return fast\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566173,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1568383,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1905163,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1696638,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1938978,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1566775,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1575004,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1570524,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 2063753,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1575808,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1566173,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1568383,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1905163,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1696638,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1938978,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1566775,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1575004,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1570524,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 2063753,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 1575808,
                "content": [
                    {
                        "username": "lord_of_the_bits",
                        "content": "[2,2,2,2,2]\\n \\n How is the above input valid?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@bhaskar126](/bhaskar126)  in these problem the nums element will check that element is present in or not for that we are checking num[i] as outer loop\\nbut for second number we are again checking for i+1 for array/nums range \\nif we sort the nums then [2, 2, 2], it might come for that we are using i+1 checking for other element if all  element are same then then it will return max occurance or return the first element .\\nthankyou \\n\\n"
                    },
                    {
                        "username": "bhaskar126",
                        "content": "[@Hritik__k](/Hritik__k)  The question states that nums will contain n + 1 integers, where each integer is in range [1, n]. So if n == 2, then the test case should be [2, 2, 2], where nums size is satisfying the condition of being equal to n +1. But if we consider n == 4, then also it would satisfy the condition as each  integer is in range [1, 4] and nums size is  4+1"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@Hritik__k](/Hritik__k) \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\" I do not see the phrase \"if a number exists\" you have mentioned. And testcases do not help. How am I supposed to know what they meant before I start solving completely different problem and fail."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@Charlemagne5t](/Charlemagne5t) No the question means that if a number exist in nums then it appears only once expect a single value which can appear >1 times"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@harsh_reality_](/harsh_reality_)  but it should be \\u201Cat most once\\u201D. It is not clear that \\u201Conce\\u201D means 0 or 1 times. I am not native English speaker but never in my life I\\u2019ve heard \\u201Conce\\u201D as \\u201Czero times\\u201D. "
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@Anuj3366](/Anuj3366)  and floyds algo. is also involved"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "[@TanveerSingh](/TanveerSingh) Read the question properly\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "exactly"
                    },
                    {
                        "username": "karansisodiya",
                        "content": "[@Lokesh_kumar22](/Lokesh_kumar22)  In constraints it has been mentioned All the integers in nums appear only once except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "All the integers in nums appear only once except for precisely one integer which \"appears two or more times.\"\\n\\nRead questions carefully"
                    },
                    {
                        "username": "justintam556",
                        "content": "I had a similar idea. If there as only one \\'duplicate\\' not only one \\'repeating number\\' you could calculate the duplicate number by comparing an expected sum of the number to the actual sum. the duplicate number would have been the difference."
                    },
                    {
                        "username": "Anuj3366",
                        "content": "just do it using cycle sort"
                    },
                    {
                        "username": "Lokesh_kumar22",
                        "content": "2 is in the range and only it is repeating can you please explain how this test case is wrong ??"
                    },
                    {
                        "username": "ZishanAbder",
                        "content": "Same question"
                    },
                    {
                        "username": "challenai",
                        "content": "don\\'t struggle with this kind of misleading problem, my advice is throw it to wastebasket and let it go :)"
                    },
                    {
                        "username": "robertointerview",
                        "content": "[@alanacevedo](/alanacevedo) yeah... poorly worded... it should say \"all integers .... appear at most once... except...\""
                    },
                    {
                        "username": "bhargav1811",
                        "content": "This test case should be in the listed down in the example !!!"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "It is valid because only **one number is being repeated five time** and the number is in the range. "
                    },
                    {
                        "username": "alanacevedo",
                        "content": "Wondering the same. Constraints says\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times"
                    },
                    {
                        "username": "kumar_Aman1",
                        "content": "only one element can repeat more than once ,  here \"2\" is repeating ."
                    },
                    {
                        "username": "noobcoder1729",
                        "content": "each nums[i] is in the range [1,4]. "
                    },
                    {
                        "username": "kishan9192",
                        "content": "One of the solutions mentioned uses Sorting, \\nIt\\'s written in the constraints that **You must not modify the array, assume it\\'s read only**\\n\\n"
                    },
                    {
                        "username": "user5693U",
                        "content": "[@Crispy_coffee](/Crispy_coffee)  why?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you fool \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "johnnychang",
                        "content": "No one in this world can solve it in a 45 mins interview with optimal solution without already seen this question."
                    },
                    {
                        "username": "verhitel",
                        "content": "Also it might be interesting to know how many people can fully understand a solution in 45 min, if they see the question and optimal solution first time."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "Attention all the people who are complaining that [2, 2, 2, 2,2]. The problem statement says that all the integers in array are in the range of 1 to n , and only one number is repeated. But the problem doesn\\'t say that the integer that is repeated, is repeated only twice, so the repeated integer can be repeated more than twice . \\nThey specifically mentioned this in the constraints => \"All the integers in nums appear only once except for precisely one integer which appears two or more times.\".\\nHence [2,2,2,2,2] is valid af.\\n"
                    },
                    {
                        "username": "user2636BW",
                        "content": "question clearly states that :\\n\"There is only one repeated number in nums, return this repeated number.\""
                    },
                    {
                        "username": "Satwik_18",
                        "content": "question says there must be n+1 elements in num, which specifies the value of num in the question\\n"
                    },
                    {
                        "username": "shivam_gupta01",
                        "content": "exactly, also it is showing valid in my case\n\n![ScreenshotS (134)](C:\\Users\\acer\\Pictures\\Screenshots)"
                    },
                    {
                        "username": "gouravrout",
                        "content": "1 must be there\\n"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@Davidfaleye360](/Davidfaleye360) no. the numbers range from 1 to n does not mean 1 or n must exist. it means nums[i] must be 1,n or the numbers between them. if n is 4, there should not be a number in nums greater than 4 or less than 1"
                    },
                    {
                        "username": "nikalinov",
                        "content": "valid af :D:D:D"
                    },
                    {
                        "username": "srivkrnt",
                        "content": "In constraints the problem says\\n\\n`\\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\\n`\\n\\nit should be updated to \\n`\\nAll the integers in nums appear at most once except for precisely one integer which appears two or more times.\\n`\\n\\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@desertf33](/desertf33) you can say that because you already know the actual problem. If the problem were that everybody thought it was then you wouldn\\u2019t have been complaining that you thought that they meant 0+ times logic. How am I supposed to know what they implicitly meant. \\u201COnce\\u201D usually means 1 time at least not at most. "
                    },
                    {
                        "username": "desertf33",
                        "content": "[@Charlemagne5t](/Charlemagne5t)All the elephants that have appeared before my eyes appear only once except one elephant which I have seen more than once. The question defines the domain which is (numbers that appear in nums) it is not talking about numbers that dont appear."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@HIMANSHU73](/HIMANSHU73) so when you say \\u201DI\\u2019ve seen an elephant only once\\u201D it means that you\\u2019ve seen it 0 or 1 times?  Discription is unclear and misleading especially without a testcase where numbers are missing. "
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "They didn\\'t say they will come as compulsory !\\nIf they will come, they will definitely appear once only !\\n"
                    },
                    {
                        "username": "jamiryo",
                        "content": "This page helped me a lot to understand the problem, if you are having difficulties just read that:\\n\\n[http://keithschwarz.com/interesting/code/?dir=find-duplicate][1]\\n\\n\\n  [1]: http://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "cmhandan",
                        "content": "thanks for this link sharing\\n"
                    },
                    {
                        "username": "AnnoyingJeff",
                        "content": "[@ivan_azarov](/ivan_azarov) I\\'d say it\\'s easy considering the intuitive approach. The requirement to use only constant extra space was a bit misleading to me. But if take into account that the auxiliary array is constant space too - it\\'s a few-liner for three mins. \\nFor sure it\\'s not Knuth\\'s God-like solution :)"
                    },
                    {
                        "username": "ivan_azarov",
                        "content": "> This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\n> and I have only met one person (Keith Amling) who could solve it in less time\n> than this.\n\nOh well, that's clearly medium"
                    },
                    {
                        "username": "nitesr",
                        "content": "My submission failed with [2,2,2,2,2] input test case which is not valid. The constraints say that only one number is repeated more than once in the range of 1..n."
                    },
                    {
                        "username": "shakthisri",
                        "content": "Yeah only one number (i.e 2) is repeated more than once here. The question wasn\\'t that \"the number would repeat only once\". It was \"only one number is repeated more than once\". [1,2,1,2,3] is invalid but [1,1,1,2] or [1,1,1] are both valid.\\n"
                    },
                    {
                        "username": "shivi_2021",
                        "content": "how is this not a valid testcase? can u explain??"
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "OK i don\\'t need a solution but i am not sure if one of the test cases with [2,2,2,2,2] doesn\\'t violate the requirements of the question"
                    },
                    {
                        "username": "darpanbalar01",
                        "content": "Under constraints. It\\'s mentioned that one element can repeat two or more times"
                    },
                    {
                        "username": "luanct",
                        "content": "I remembered I knew how to solve this question after watching this video LOL\\nhttps://www.youtube.com/watch?v=pKO9UjSeLew"
                    },
                    {
                        "username": "HikuMai",
                        "content": "hahaha, same to me too."
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Same here!"
                    },
                    {
                        "username": "stani",
                        "content": "\\nThe num of n consecutive numbers is n*(n+1)/2\\n\\nIf only one number if repeated then the answer is sum(nums) - n*(n+1)/2, where n is len(nums)-1\\n\\nThe test case where this solution fails is \\n[2,2,2,2,2]\\n\\nExpected: 2\\nOutput: 0 \\n\\nThis test case does not make any sense."
                    },
                    {
                        "username": "VishalBhargav",
                        "content": "that\\'s the catch bro unless it\\'s easy  question"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I had the same algo solution and failed at [2,2,2,2,2]\\nThis question and examples were prepared to answer them only one way which Floyd\\'s Circle Algorithm"
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "this will fail for all the testcases where the sum (nums) == n*(n+1)/2 where n = len(nums)-1\\n"
                    },
                    {
                        "username": "vanhalen5150",
                        "content": "This is not the only test case where the formula fails btw, it also fails for cases such as [1,2,2,2].\n\n[2,2,2,2,2] is a valid test case because all of the numbers in the array lie between 1 and 4(length of array - 1), and only one of these numbers is repeated."
                    }
                ]
            },
            {
                "id": 2007594,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1758901,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1576901,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 2064182,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 2063729,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1567753,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1567745,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1569275,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1575341,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1576785,
                "content": [
                    {
                        "username": "RafaelAbreu",
                        "content": "How is this a medium question?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Constraints + follow up"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Most of the solutions use either O(n) extra space or modify the array when it is specified that we can\\'t do either of them."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "what is this testcase :(\\nInput\\n[2,2,2,2,2]\\nOutput\\n0\\nExpected\\n2"
                    },
                    {
                        "username": "mredwan",
                        "content": "yeah, if you find the duplicate then you\\'ll have to return the value. note: duplicate means more than 1 value, not necessarily it will have just 2 value"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/zPEEyvu\"><img src=\"https://i.imgur.com/zPEEyvu.jpg\" title=\"source: imgur.com\" width=\"350px\" /></a>"
                    },
                    {
                        "username": "aadithya18",
                        "content": "My exact reaction bro\\n"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Questions like these and median of two sorted array doesn\\'t check the logical thinking properly cuz you can rarely solve it correctly without being familiar with it  "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution \\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-duplicate-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 8 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n**Approach 2:** Set \n\n  \n**Approach 3:** Negative Marking\n\n  \n**Approach 4:** .1: Array as HashMap (Recursion)\n\n  \n**Approach 5:** .2: Array as HashMap (Iterative)\n\n  \n**Approach 6:** Binary Search\n\n  \n**Approach 7:** Sum of Set Bits\n\n  \n**Approach 8:** Floyd's Tortoise and Hare (Cycle Detection)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ColinBin",
                        "content": "There are n + 1 nodes labeled 0, 1, ... n. All values are in [1, n] and assume the value stands for the node to be pointed to, which means each node will point to one of the nodes whose label is in [1, n]. Thus at least one node labeled in [1, n] will be pointed to by two nodes (pigeonhole theory). \\n\\nIf, for now, we do not consider the first node labeled 0, there are n remaining nodes and n edges, which forms a directed graph and each node must have one and only one edge going outwards (and must point to one of these n nodes). This means each connected component* formed by these nodes has a cycle (I think it can be proved). \\n\\nWhen we start from node labeled 0, we are just pointing to one of the connected components and detect the cycle. \\n\\n* connected component: not necessarily fully connected, but any node not in the cycle can reach the cycle."
                    },
                    {
                        "username": "rocmeister",
                        "content": ">This means each connected component* formed by these nodes has a cycle (I think it can be proved).\n\nHere's my attempt to prove a cycle must exist in this problem in general. Suppose we want to build an acyclic counter-example, we can start from index 0, assign a value x, go to node with index x, rinse and repeat. Notice this action is essentially building and following a continuous chain of nodes.\n\nWe want to avoid any cycle so need to avoid assigning x if node with index x has already been used (i.e. a node on the current chain). We can obey this rule all the way until the very last unassigned node (whatever its index is in [1,n]). At this point, we have assigned n nodes so far, and so have no distinct value left to assign any more, so this node has to point to an old node somewhere on the chain, thus forming a cycle."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/15183a39-a86a-4494-8651-761e5fca54b0_1622549508.4418294.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/bef17160-9436-406e-bab6-92d3daf812c9_1622549519.2117782.png)\\n\\n\\nCLICK LIKE?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Floyd-Warschall is an algorith to find the shortest path between every pair of nodes in a graph: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n\\nI think you mean: Floyd\\'s tortoise and hare algorithm:  https://en.wikipedia.org/wiki/Cycle_detection"
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/88a6608b-136b-4659-aefb-f83a77ec9ee1_1653151161.881874.jpeg)\\n"
                    }
                ]
            },
            {
                "id": 1569313,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1568632,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 2063943,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1575266,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1571534,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1966604,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1567944,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1574973,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1574936,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1571533,
                "content": [
                    {
                        "username": "qiuyu8290",
                        "content": "Even after knowing the hint to use hare and tortoise, it still takes me hours to understand. Especially if for some indexes what will happen if num[index] = index;"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "From an article shared in the chat:\n\n`This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.`\n\nSo have do people expect candidates to solve this at an interview? I guess one is supposed to memorize the solution to solve it... "
                    },
                    {
                        "username": "Preethika11",
                        "content": "Descrition says array will have n+1 => 1 to n and one of them will be repeated. But one of the test case does not comply the description"
                    },
                    {
                        "username": "bharathgowda29",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM)  sorting the array is considered as modifying only. it will obvisouly accept because the compilers are not yet that level smart. but in a face to face interview, you will be sent home if you use sorting even after mentioning not to modify array or use extra space"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "[@Rahul_Mishra_RM](/Rahul_Mishra_RM) In this problem, Leetcode doesn\\'t explicitly check if you\\'ve modified the array since it only checks if the value you return from the function matches the expected output"
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "santanusen",
                        "content": "Seems Knuth took a day to solve this. Leetcode feels this is a medium."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yeah, it should be hard."
                    },
                    {
                        "username": "sushil7",
                        "content": "Not sure if this is a valid test case based on the question"
                    },
                    {
                        "username": "papapapa",
                        "content": "* find a big non-exist prime number ( magic number )\\n* go through the list, if the number is dividable by the magic number, it is the solution.\\n* other wise, multiply the number by the magic number\\n* scan again, un touch the array.\\n\\n* Space complexity O(1)\\n* Time Complexity O(N)\\n\\nSee code:\\nhttps://github.com/zyzyis/OneSizeDoesFitAll/blob/master/src/FindTheDuplicateNumber.c"
                    },
                    {
                        "username": "prashant_04",
                        "content": "but what if you multiple it by 2 and then by 3 so now it gets divisible by 6. So in that case it wont be the correct answer "
                    },
                    {
                        "username": "prototye",
                        "content": "I highly doubt that Floyd Warshall himself can solve this problem"
                    },
                    {
                        "username": "AldenDaniels",
                        "content": "[@Mister_CK](/Mister_CK) Plus, they\\'re algorithm is unrelated to this (it\\'s Floyd\\'s other algorithm that is)"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@Mister_CK](/Mister_CK) \\uD83D\\uDE02\\uD83D\\uDE02 nice\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Robert Floyd and Stephen Warshall are two different people :P "
                    },
                    {
                        "username": "alonso",
                        "content": "You are talking about duplicated numbers, then the expected input is: [1, 2, 2, 3] but I received an input like: [2, 2, 2] that's not a duplicated number, is a triplicated, and the algorithm to approach this problem is different."
                    },
                    {
                        "username": "kartikchausali12345",
                        "content": "not able to understand that how they are bound to meet at duplicate number when they starts moving at same speed considering fast pointer is at start.\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "Count them backwards from the second rendezvous point. You\\'ll see that it takes exactly same number of steps to reach the first element of the list and the fast-slow rendezvous."
                    },
                    {
                        "username": "abaran803",
                        "content": "Here in the problem, it is mentioned that \\'only one repeated number in nums\\' but when I use algorithm of sum of n-1 elements and sum of all elements in array it show error the the test case for that error contain multiple 2(more than 2 times)."
                    },
                    {
                        "username": "infinnie",
                        "content": "https://leetcode.com/submissions/detail/52270763/\\n\\nI guess most of the JavaScript solutions have the space complexity of O(n)."
                    },
                    {
                        "username": "shirayair",
                        "content": "from my understanding of your solution, you use an array \"t[]\" of length o(n) , which is not constant extra space as required in this problem.. Am I wrong?"
                    }
                ]
            },
            {
                "id": 1567763,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064997,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064340,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064193,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064169,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064061,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2064006,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 2063813,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 1963071,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 1771244,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Full Explained C++ || Java || Python Solution\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-find-the-duplicate-number-element-c-java-python-solution/"
                    },
                    {
                        "username": "NikolayNahimov",
                        "content": "C++ version uses O(n) extra memory. Should be constant.\nPython version modifies the array which is prohibited."
                    },
                    {
                        "username": "Kathy99",
                        "content": "For people who have not heard of Floyd\\'s algorithm for cycle detection, it\\'s nearly impossible to solve the problem in interviews. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "If they give you this question, they probably don\\'t want to hire you."
                    },
                    {
                        "username": "AlexChaloner",
                        "content": "All of this confusion would be easily solved if there was an extra example of [1, 1, 1, 1]. The examples and general phrasing of the question misleads people."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think you are right. The question is clear, but many leetcode users are not native english speakers and have problems understanding the question."
                    },
                    {
                        "username": "isusel",
                        "content": "Really liked this problem.\\nTry representing the array as a singly linked list. Then this problem is reduced to searching of the loop entery point in the list."
                    },
                    {
                        "username": "tree9",
                        "content": "Indeed. But the question is HOW does one come up with the thought of representing the array as a singly linked list. "
                    },
                    {
                        "username": "sergei99",
                        "content": "So let's allocate a bit map of $$10^5$$ bits and use it throughout the series. Is it a constant space? Yes it is. Moreover, it's nothing comparing to fluctuations of the submission statistics - the memory usage could easily differ by 100-200k from one submission to another.\nAnd I've already submitted a \"proper\" solution weeks ago...\n\nP.S. STL bitset took exactly same time and space as the fast-slow stuff.\nA custom bitset was 1.5 times faster and took slightly less memory than two pointers approach.\nYeah, efficient programming is not about group thinking whatsoever..."
                    },
                    {
                        "username": "khe1154",
                        "content": "i think this is a hard question"
                    },
                    {
                        "username": "sergei99",
                        "content": "The hardest questions are those marked Easy. It takes ages to achieve 99.5% there because the top is overpopulated.\\nThe questions marked Hard are much easier in this sense: the are just a few top level solutions, typically from senior algorithmists who don\\'t take microoptimizing seriously, and as such a simple tuning may win the top by a large margin."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "same"
                    },
                    {
                        "username": "meanup",
                        "content": "Test Cases for future me.\n[1,1]\n[1,1,2]\n[1,2,2]\n[2,1,1]\n[2,1,2]\n[1,3,4,2,1]\n[1,4,4,2,4]\n[3,2,2,2,4]\n[2,1,1,1,4]\n[4,3,1,4,2]\n[8,1,1,1,2,7,4,3,1,1]\n[7,9,7,4,2,8,7,7,1,5]\n[2,5,9,6,9,3,8,9,7,1]\n[1,5,5,6,2,8,4,7,5,5]\n[8,1,1,9,5,4,2,7,3,6]\n[3,1,1,6,1,2,4,9,8,7]\n[9,4,9,5,7,2,8,9,3,9]\n[5,4,7,8,1,2,3,1,1,9]\n[2,2,2,2,2,2,2,2,2,2]\n[3,2,5,14,5,5,19,18,11,10,1,4,5,5,5,5,12,5,17,5]\n[14,16,12,1,16,17,6,8,5,19,16,13,16,3,11,16,4,16,9,7]\n[18,13,14,17,9,19,7,17,4,6,17,5,11,10,2,15,8,12,16,17]\n[8,7,1,10,17,15,18,11,16,9,19,12,5,14,3,4,2,13,18,18]\n[29,27,9,2,30,29,29,14,48,18,46,43,8,39,44,49,37,4,20,29,36,38,29,29,42,41,22,7,47,25,11,33,29,16,35,45,29,28,3,32,5,15,17,31,6,40,26,21,12,29]\n[85,42,42,42,51,17,42,42,40,99,75,42,42,12,87,42,92,30,42,42,42,42,39,86,42,22,49,53,42,42,42,42,33,1,21,65,70,9,88,46,42,42,81,15,68,42,26,67,34,31,82,42,5,42,50,66,58,42,42,57,42,42,42,16,42,42,42,42,20,23,42,42,79,89,45,28,42,42,7,42,13,83,74,42,42,69,43,27,71,10,42,72,42,42,78,98,11,25,42,2]\n[75,75,75,75,75,91,75,75,75,75,75,75,30,75,75,78,75,75,75,75,75,7,79,93,75,75,15,75,75,75,75,75,75,4,75,75,21,75,75,19,75,59,75,76,75,75,75,75,75,75,75,33,75,75,75,58,75,75,5,75,97,81,48,42,75,87,75,75,25,27,94,20,75,75,75,29,75,75,86,67,75,75,75,65,75,75,75,75,75,39,75,56,75,75,75,75,3,75,75,75]"
                    },
                    {
                        "username": "useNavigate",
                        "content": "who would have thought this is linked list cycle detection problem "
                    },
                    {
                        "username": "milanthakor",
                        "content": "If I am not wrong, the Floyd\\'s algorithm works here because the array size is n+1 and elements are in the range [1, n]. If the array size is \"n\", this won\\'t work because the index with value \"n\" would go out of bound. And if the elements range from [0, n] and element at index 0 is \"0\", the algo will go in infinite loop. Can anyone please confirm?"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Yes, your understanding is correct."
                    },
                    {
                        "username": "Rahul_Mishra_RM",
                        "content": "Hey did you use sorting? I sorted the array but still it accepted my solution...... Now I\\'m confused in these two things :\\n1)Is sorting an array not taken as modifying it?\\n2)If yes, then how did it get accepted?\\nAny help would be greatly appreciated"
                    },
                    {
                        "username": "heg816",
                        "content": "For most problems, unless explicitly declared, a solution will not be rejected as long as it solves the problem, given that it doesn\\'t eggregioulsy exceed memory or time limits. If doing so will cause a submission to be rejected, as far as I know it will be stated in the description that a custom judge is used."
                    }
                ]
            },
            {
                "id": 1690495,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1575518,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1574161,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1573767,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1573194,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1572799,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1572695,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 1571532,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 2075567,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 2074743,
                "content": [
                    {
                        "username": "cfwang",
                        "content": "Best question ever invented"
                    },
                    {
                        "username": "praneethn",
                        "content": "Input\\n[2,2,2,2,2]\\nOutput\\n6\\nExpected\\n2\\n\\n\\nThe description says \"There is only one repeated number in num\""
                    },
                    {
                        "username": "kwu30",
                        "content": "https://docs.google.com/presentation/d/1vw8wehzngGtwxMk8c2tYKgLurmNelVdftzwgYmwyAqc/edit?usp=sharing"
                    },
                    {
                        "username": "jupaoljpol",
                        "content": "The description sais:\\n\\n*\"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)\"*\\n\\nTherefore it means an array of length n=6 will contain numbers from 1 to 6 right?\\n\\nI was checking the official posted solution using fast/slow cycle detection algorithm in Java and it doesn\\'t respect this constraint, it assumes the array will actually contain numbers from 0 to n - 1 or in this example from 0 to 5. I tested it with a 6 (n) and it failed as I was expecting it, however when you submit** their solution it passes all test cases**.\\n\\nSo I think the description constraint is misleading and it should be updated.\\n\\nAny thoughts?"
                    },
                    {
                        "username": "lixuefeng01",
                        "content": "actually we can tranform the array to a graph(actually a link list), a[i] is the next number of i, so [1,3,4,2,2] will be a graph like this: 1 -> 3 -> 2 <-> 4,\\nyou can see there is a circle in a graph, and the first number in the circle is the answer. so we remember the two pointers method to sove this problem."
                    },
                    {
                        "username": "jstraj",
                        "content": "If you are looking for the proof of Tortoise & Hare problem. This is a very good one: https://stackoverflow.com/a/6110767"
                    },
                    {
                        "username": "superflb",
                        "content": "Is there a way to solve the problem meanwhlile still meet all requirements?"
                    },
                    {
                        "username": "monkeyGoCrazy",
                        "content": "Can some one give me some detailed and mathematic solutions on this issue?"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "can we use another data structure like dictionary or sets??"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would use O(n) extra space. You have to use pointers."
                    },
                    {
                        "username": "sergei99",
                        "content": "Only if it fits constant extra space ($$O(1)$$)."
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "how is this question medium ? why is it not easy ? Is there any other approach that I am missing ?"
                    },
                    {
                        "username": "gauravbisht126",
                        "content": "[@Tom_Dev](/Tom_Dev) haha sarcasm I see"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it should be hard. Maybe you are a super programmer."
                    }
                ]
            },
            {
                "id": 2071612,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2071121,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2065936,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064880,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064795,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064760,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064693,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064646,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064614,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064605,
                "content": [
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "in these problem \\n1. we have to sort the array/list so that our element get order well\\n nums.sort()\\n2. if there is any duplicate element then it will beside the number duplicate were the time will take less time complexity after sort() will get less\\n3.then we go with outer for loop which start with 0\\nfor i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n4.and the inner loop will start with i+1 to the Len(array/list)\\n5. then we will check one condition we the array[I]==array[j] or not.\\nif nums[i]==nums[j]:\\n\\n6.if yes then return array[I]\\n return nums[i]\\n7.else return  Len(array)\\n return len(nums)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "[@sergei99](/sergei99) we are not modify brother we are only arranging the element"
                    },
                    {
                        "username": "sergei99",
                        "content": "The task states the original array is not to be modified."
                    },
                    {
                        "username": "abhinandan103",
                        "content": "Question says there is only one repeated number.\\nBut the testcase 18/58 has the below input:\\nnums =\\n[2,2,2,2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is only one repeated number, 2."
                    },
                    {
                        "username": "_shubham_bisht_",
                        "content": "we can approach this problem by fast and slow concept which we apply in link list... i think this will help you\\n"
                    },
                    {
                        "username": "JefSmith",
                        "content": "class Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n why does it show  `time limit exceeded` error for the above code while submitting "
                    },
                    {
                        "username": "JefSmith",
                        "content": "[@mritunjayt140](/mritunjayt140) Understood\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@mritunjayt140](/mritunjayt140) You must solve the problem without modifying the array nums and uses only constant extra space. So sorting, array and hashing are not allowed."
                    },
                    {
                        "username": "mritunjayt140",
                        "content": "Because the limits are n=10^5,  your algo is of O(n^2) time complexity, while the constraint allows only less than equal O(n * log n).\\nO(n * log n) generallly indicates some sort of sorting or you can store these no in an array.\\nSo explore solution with sorting or array or hashing"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because the brute force method is too slow. Use Floyd's algorithm for detecting cycles in linked lists. This is a hard question."
                    },
                    {
                        "username": "KushagraDhelia",
                        "content": "Can anyone help its showing \"Time Limit Exceeded\" for a very big and complex input \\n\\nnums =\\n[21212,16431,40942,74790,97759,27803,81513,70172,50495,33308,65846,33282,53857,80666,74276,47203,73584,14672,74304,50789,34525,28884,37352,79601,19576,38094,69614,39639,77579,95428,52945,13745,92483,29320,22010,11813,96921,35301,20148,70348,76185,48505,4694,48229,47705,35737,75395,31554,83483,47735,63623,93769,62118,76709,4843,69869,37987,40770,23800,61463,90322,23190,81344,82492,27195,25418,60721,70658,69315,18711,31671,12118,31340,36909,92720,28712,91117,89087,62126,1823,73820,85094,91206,66856,45415,70491,66396,5964,28403,70728,38240,53644,57158,8944,11542,13891,94155,1446,88215,42827,970,92587,73160,89196,78529,7848,12572,80149,71209,64020,55479,68440,27563,31975,65736,13602,56022,15566,89248,79085,77889,17979,61739,44613,36064,734,56202,22000,37435,75527,89302,49278,3648,92855,55462,32260,38690,20372,37077,75034,53459,47769,58........\\n\\n\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "obbl",
                        "content": "I remember an old youtube video named \"if programming was an anime\". What a wonderful piece of content"
                    },
                    {
                        "username": "hanjyun",
                        "content": "This question is too strong.\\nI\\'m too weak.\\nI\\'m running out of ideas.\\nI can\\'t solve this medium problem.\\nHow can I even be a real engineer?\\nHow am I gonna get into Google?\\nKUSO!"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "This is a hard problem. use Floyd\\'s Algorithm for detecting Cycles in linked Lists."
                    },
                    {
                        "username": "sergei99",
                        "content": "Watch \"Office Space\" (1999)"
                    },
                    {
                        "username": "trpaslik",
                        "content": "This is an awesome problem but should be marked as hard."
                    },
                    {
                        "username": "Ayushtiwary",
                        "content": "Study the concept of loop in a linked list, then try this question...maybe you will get the approach\\n"
                    },
                    {
                        "username": "gennarofalco12",
                        "content": "Rak Rules.\\n"
                    }
                ]
            },
            {
                "id": 2064604,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064573,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064554,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064497,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064486,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064482,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064447,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064435,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064399,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064337,
                "content": [
                    {
                        "username": "omprakashpandit524",
                        "content": "class Find1{\\n    public:\\n    int Solve1(vector<int> &nums){\\n        int s = nums.size();\\n        int n = s(s+1)/2;\\n        int add = 0;\\n        for(int i=0; i<=si; i++){\\n            add += nums[i];\\n        }\\n        int r = unsigned(add - n);\\n        return r;\\n    } \\n};\\n\\nclass Find : public Find1{\\n    public:\\n    int Solve(vector<int> & nums){\\n        if(nums.size()==0) return 0;\\n        return Solve1(nums);\\n    }\\n};\\n\\nclass Solution {\\npublic:  // jay siya ram\\n    int findDuplicate(vector<int>& nums){\\n        Find f;\\n        return f.Solve(nums);\\n    }\\n};\\n\\n\\n\\nLine 5: Char 18: error: called object type \\'int\\' is not a function or function pointer\\n        int n = s(s+1)/2;\\n                ~^\\n\\n\\nwhy i am getting error"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because you are using s like a function call: s(s+1)/2\\nBut it is an int variable."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int findDuplicate(int[] nums) {\\n        nums=mergesort(nums);\\n        int i=0;\\n        for(;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                break;\\n            }\\n        }\\n        return nums[i];\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user1109ZQ",
                        "content": "Why is it marked as medium? It\\'s so easy that I could hardly believe my eyes. 5 lines of code to add, less than 1 minute of work, no need to strain the brain at all. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then you are a super developer. I think this question is even hard."
                    },
                    {
                        "username": "psionl0",
                        "content": "Yes, it is easy if you ignore the instruction to use O(1) space."
                    },
                    {
                        "username": "Dreary22",
                        "content": "  `class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int n, ans = 0;\\n        while(nums.size()!=n){\\n            for(int i = n + 1; i < nums.size(); i++){\\n                if(nums[n]==nums[i]){\\n                    ans = nums[n];\\n                } \\n            }\\n            n++;\\n        }\\n        return ans;\\n    }\\n};`\\n\\nWith this code test 53 not passing :c"
                    },
                    {
                        "username": "sergei99",
                        "content": "It's surprising that the previous 52 pass. Your code is using an uninitialized variable `n`, making the result effectively random."
                    },
                    {
                        "username": "nishantv",
                        "content": "1. There is only one repeated number in nums\\n2. All the integers in nums appear only once except for precisely one integer which appears two or more times.\\n\\nBoth the statements appear to be contradicting in itself. For [2,2,2,2,2] it needs to be mentioned as:\\n\"All the integers in nums might appear at most once except for precisely one integer which appears two or more times\""
                    },
                    {
                        "username": "dgalifanidov0",
                        "content": "I had a test example consisting of 160,000 characters that simply did not allow me to execute the program on time."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "how will you prove that at least on duplicate number must exist in nums\\nexample `nums = [1,4,3,2,2]`\\n\\n```\\nlength = nums.length // 5\\nmax = Math.max(...nums) // 4\\n// constraint 1 <= n\\n```\\n\\nis this a proof?"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "good question"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The time complexity is the main hard part of this question, doing it in linear search is the only viable option since binary search would not work. \\nAlso, the examples just don\\'t do this question a good justice."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You can use Floyd\\'s algorithm for detecting cycles in linked lists."
                    },
                    {
                        "username": "abhijeettripathia",
                        "content": "Some are using Sorts method, but If we use Array.sort won\\'t we be modifying the Array?..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Sorting the original array or making a copy is not allowed."
                    }
                ]
            },
            {
                "id": 2064327,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064304,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064283,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064260,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064192,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064043,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2064020,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2063972,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2063962,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2063961,
                "content": [
                    {
                        "username": "huntxr",
                        "content": "Most of the solutions given either use O(n) space or modify the existing array, which is specified explicitly not to."
                    },
                    {
                        "username": "udhy",
                        "content": "\"This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve and I have only met one person (Keith Amling) who could solve it in less time than this.\"\\n\\nSource: https://keithschwarz.com/interesting/code/?dir=find-duplicate"
                    },
                    {
                        "username": "udhy",
                        "content": "And they marked it as medium :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I broke my mind getting a solution.\nThe real solution is old and elegant, but it has so much assumptions inside.\nGet everything why this must work and your brain explodes.\n\n\n1.Values represent a graph with indices, \n2.Pigeonhole cycle inside, \n3.the graph can be cutted in different parts but first value points on right subgraph, \n4.after doing tortoise hare and resetting one to the start, both are the same distance to the needed value....\n\nThis one feels hard 0.0\nIs this so classical everybody must know it well?"
                    },
                    {
                        "username": "ghoshsreeja02",
                        "content": "Question is not right..\\nnums = [2,2,2,2] should not be a valid test case."
                    },
                    {
                        "username": "sergei99",
                        "content": "What makes you think so?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "mortum5",
                        "content": "There is clearly something wrong in this problem. I found exactly one solution with linear complexity and constant extra space - it is the well-known definition of the Floyd cycle. And in the case [2,2,2,2,2,2,2,2,2,2,2,2] that someone mentioned, there is no problem. But the real problem arises in the case of [0,1,2,3,4,5,5,5], because this is not a real linked list, but just an array of pointers. And in this case, all values x_{i} = i are just separate cycles. And Floyd can\\'t find a duplicate number in this case, am I right?"
                    },
                    {
                        "username": "mortum5",
                        "content": "[@desertf33](/desertf33) Ohh... You are right"
                    },
                    {
                        "username": "desertf33",
                        "content": "I think that is why 0 is not allowed?"
                    },
                    {
                        "username": "naresh_05",
                        "content": "Time Limit Exceeded \\n\\nclass Solution:\\n    def findDuplicate(self, nums: list[int]) -> int:\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if nums[i]==nums[j] and i!=j and i>j:\\n                    return nums[i]\\nthis is my code\\nalmost pass 51 testcase\\n\\nany suggesuggestions \\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use Floyd\\'s algorithm to detect cycles in linked lists."
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Haha I learned the approach to this problem in one of Joma Tech's video! \nUse the tortoise & hare approach(double pointer approach)  for linear time and constant space :)\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Question is very unclear...\\nAll the integers in nums appear *only once* except for precisely one integer which appears two or more times.\\nWhy [2,2,2,2,2] is valid testcase?\\nTo make problem clear, plz change the constraint to *atmost once*  instead of only once"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "except for precisely one integer which appears two or more times."
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "### floyd cycle"
                    },
                    {
                        "username": "santanusen",
                        "content": "The follow up to prove there are duplicates -\\nNumbers are in the range ```[1, n]```, thus the number of unique values is ```n```.\\nArray size is ```n + 1```. Thus, to fill ```n + 1``` slots with max ```n``` values there must be duplicates (pigeonhole principle)."
                    }
                ]
            },
            {
                "id": 2063942,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063896,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063882,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063854,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063836,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063763,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063752,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063733,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2063722,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2062875,
                "content": [
                    {
                        "username": "gauthamkrishnan543",
                        "content": "[2,2,2,2,2] is an invalid input anyway.\nThe size of the array as in question is n+1. For the above input n=2, size of the array must be 3."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Pretty tricky question!"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I wasn\\'t expecting [2,2,2,2,2]"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "There are multiple approaches for this problem\n1) Sorting-tc o(n log n) sc-o(1) it modifies input array that violates the description.\n2) Hashmap-tc o(n) sc-o(n) it uses extra space that violates description.\n3) Binary search tc-o(n log n) sc-o(1) it is a good solution but doesn't meet the requirements of follow up.\n4) Linked list cycle tc-o(n) sc-o(1) it is the most optimized solution."
                    },
                    {
                        "username": "aitachii",
                        "content": "Usually, if `nums[i]` is between `[1,n]`, the problem is a pseudo-linked list problem."
                    },
                    {
                        "username": "ssj0936",
                        "content": "A easy question acted like medium yesterday, and a medium act like hard today. What\\'s next day? Plz stop destroying my confidence."
                    },
                    {
                        "username": "JaidinHamilton",
                        "content": "My program works but I received a, \"Time Limit Exceeded,\" message before optimizing it. Can anyone explain this Time Limit Exceeded message? Is it a part of the assignment or an incentive to pay for premium?"
                    },
                    {
                        "username": "luanct",
                        "content": "It means your code works at some cases but fails at some cases with huge dataset. You need to optimize your code to reduce the runtime."
                    },
                    {
                        "username": "HikuMai",
                        "content": "wow, this is sweat as honey comparing those hard days T-T"
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Note: Only one integer can appear 2 or more times"
                    },
                    {
                        "username": "GBenakidis",
                        "content": "If the input of the function is [2,2,2,2,2], here\\'s what will happen step by step, explained simply:\\n\\n1. Two pointers start at the first number, which is 2.\\n\\n2. They both move one step at a time. So, they are still at 2.\\n\\n3. They keep moving, but they can\\'t find a meeting point because the whole array is like a big loop of 2s.\\n\\n4. So, they just keep going around in this loop of 2s forever.\\n\\n5. The function will never stop, and it won\\'t be able to find a duplicate number because there\\'s no end to the loop.\\n\\nIn this special case where the array only contains the same number (2 in this case), the algorithm won\\'t work because there\\'s no distinct duplicate. It\\'s like running in circles and never reaching a different number."
                    }
                ]
            },
            {
                "id": 2061414,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2053366,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2046505,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2043727,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2037865,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2019609,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2017584,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2012423,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2004705,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1996991,
                "content": [
                    {
                        "username": "tree9",
                        "content": "For anyone who's struggling to understand, please watch this: https://www.youtube.com/watch?v=wjYnzkAhcNk very very crisp explanation."
                    },
                    {
                        "username": "Forneus07",
                        "content": "Can anyone help me with the follow-up question:\\n `How can we prove that at least one duplicate number must exist in nums?`"
                    },
                    {
                        "username": "KhannaShivang",
                        "content": "Because the array is of size and contain elements 1 to n if each element is present only once it will have n elements so to make n+1 at least one element should be repeated"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Looks like people need to learn how to read questions before they start learning coding. LOL. \\nI see discussions and solutions of this problem are filled up to the brim with people asking about >2 repeated number or giving solutions with altering the original array / space complexity not O(1) / time complexity not linear. GOSH!!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is surely a 'typical medium' problem *sarcasm*."
                    },
                    {
                        "username": "0xeddies",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "BHAGWAN_388",
                        "content": "what is wrong in my code,\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    int sum;\\n     int d;\\n     int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n        }\\n        int s=n*(n-1)/2;\\n        d=sum-s;\\n        return d;\\n    }\\n};\\nRuntime Error\\nLine 8: Char 17: runtime error: signed integer overflow: 2147445990 + 78429 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:17:17\\n\\n\\n\\n"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "Why put a crucial piece of information down the bottom. Put it up the top ffs."
                    },
                    {
                        "username": "ajbil3112",
                        "content": "why is this approach wrong ?\\nint curr_sum = accumulate(nums.begin(),nums.end(),0);\\n        int  n= nums.size();\\n        int sumSupposedToBe = (n*(n+1))/2;\\n        int diff = sumSupposedToBe - curr_sum;\\n        return n - diff;"
                    },
                    {
                        "username": "_nfactorial",
                        "content": "This should be labeled easy, use a set to keep track of duplicates"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@georgezakharov](/georgezakharov) They don\\'t understand the question and use hash maps."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "useNavigate",
                        "content": "you might need to re read the question again "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think, this is a hard problem."
                    },
                    {
                        "username": "User147077",
                        "content": "the problem description states that the solution requires constant space."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Problem can be approached by creating an empty set first and then traversing through the array and checking if the current element is present in set or not, if it is return the number if it isn\\'t add number to the set. This way our worst case time complexity is O(n) where n is size of array, and when the last element of array is repeated."
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "Here it is mentioned that you can\\'t use any extra space like a map or set. The problem explicitly says that you have to solve it with O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1994373,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1988036,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1978884,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1971097,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1964434,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1960944,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1960225,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1959178,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1957157,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1956558,
                "content": [
                    {
                        "username": "amitkrdce",
                        "content": "`All the integers in nums appear only once except for precisely one integer which appears two or more times.`\\nshould read\\n`All the integers in nums appear only once except for precisely one integer which appears twice.`\\n\\nIf only one integer is duplicate, you cannot have `two or more times`."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "you can"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "remember in this particular problem, hare and tortoise algorithm only works because each integer is in the range of 1 to n(input size). "
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "merko to yehi samajh aaya ki sort karo agar i or i+1 wala equal to direct return ni to return last index wala value kyunki agar koi bhi ni mila to last wala to hoga hi\\n"
                    },
                    {
                        "username": "noormukeri96",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            for (int j=1;j<nums.size();j++)\\n            {\\n                if (nums[i]==nums[j])\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n};\\n\\n\\nwhat is wrong i cant figure it out or my approach is not correct "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to use for (int j = i + 1 ..\\nBut an O(n^2) algorithm  exceeds the time limit."
                    },
                    {
                        "username": "Gyanuraj",
                        "content": "[2,2,2,2,2] I don\\'t know if the Constraints are valid or not but with the help of the Positioning method we can pass this test case:\\nint findDuplicate(vector<int>& nums) {\\n         while(nums[0]!= nums[nums[0]])\\n         {\\n             swap(nums[0], nums[nums[0]]);\\n         }\\n         return nums[0];\\n    }"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Modifying the array is not allowed."
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "can we use Counter() function to this problem?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "it should \"atleast one repeated number\" in nums i guess"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "no, only one"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "fun fact its an easy question it can be solved using cyclic sort and binary search algorithm\\n"
                    },
                    {
                        "username": "shrey802",
                        "content": "nums =\\n[9210,13786,95454,1917,26877,37457,68295,10739,41724,37322,12857,45119,66953,28144,93145,82652,34431,49756,68202,21777,60934,99266,32064,62911,62479,41726,78317,15091,47638,55976,24932,1467,93286,72437,72039,40631,90770,8770,19842,17454,42260,77138,75484,30189,11162,4968,2095,52703,62380,19873,17395,16260,22130,89045,68728,97418,68558,53779,25475,80780,34197,15213,95314,3251,55609,25895,31018,69246,52220,84585,67981,24302,15490,71398,13802,68297,30243,80324,18097,86318,27622,39542,69715,65977,52176,9261,50090,56827,48028,9785,89589,35155,36948,80579,84295,76808,90751,61402,63282,70546,26310,81986,89472,38331,77772,60087,30421 ....\\n\\n\\nwhy am I getting error in this!"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "Probably you use more than constant space"
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "when question states that there is only one repeated number that how can [2,2,2,2,2] be a valid test case "
                    },
                    {
                        "username": "Hariom-mishra",
                        "content": "[@That_Dancing_Sandwich](/That_Dancing_Sandwich)  understood, thank you"
                    },
                    {
                        "username": "That_Dancing_Sandwich",
                        "content": "All the integers in nums appear only once except for precisely one integer which appears two or more times. read carefully"
                    }
                ]
            },
            {
                "id": 1945324,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1931228,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1925487,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1921511,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1901708,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1900873,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1883259,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1872869,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1872209,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1870919,
                "content": [
                    {
                        "username": "akshaydusad",
                        "content": "If I create an array of length `10^5`, does that count as constant extra space?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Hell NO"
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Floyd\\'s fast-slow algorithm"
                    },
                    {
                        "username": "Mohd_umer",
                        "content": "[2,2,2,2,2] i don\\'t think this answer is correct in leetcode because same submission to coding ninja that was output is same input to get a 6 answer and my answer is correct but the test cases was wrong to this output to 6."
                    },
                    {
                        "username": "manavbhagat747",
                        "content": "Best and simple aproach is to use negative marking as we have done in Find Missing Positive No problem..\\n `for(int i=0;i<nums.size();i++){\\n            if(nums[abs(nums[i])] < 0) return abs(nums[i]);\\n            else{\\n                nums[abs(nums[i])] = 0 - nums[abs(nums[i])];\\n            }\\n        }\\n        return -1;`"
                    },
                    {
                        "username": "psionl0",
                        "content": "As long as you restore the array to its original state (all positives) before returning this would comply with the rules given in the description."
                    },
                    {
                        "username": "sspenst",
                        "content": "I used O(n) extra space and my solution was accepted."
                    },
                    {
                        "username": "user7570G",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        freq={}\\n        count=0\\n        for i in nums:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i]=1\\n        for key,value in freq.items():\\n            if value>1:\\n                count=key\\n                break\\n        return count"
                    },
                    {
                        "username": "Aayushleetcode",
                        "content": "In the question it says there is only 1 repeated number is array but the few test cases have more than 1 repeated numbers in the array. "
                    },
                    {
                        "username": "ian-h",
                        "content": "this should be an easy question"
                    },
                    {
                        "username": "pavangokarlag",
                        "content": "I think their is mistake in testcase 11 i.e [2,2,2,2,2]  it is clearly mentioned in the problem that it only contains one element repeated once ->(There is only one repeated number in nums, return this repeated number.) I stuck here.\\n"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "not work with XOR since XOR only find duplicate number only so we have to use this\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < nums.size(); i++) {\\n            count[nums[i]]++;\\n            if (count[nums[i]] > 1) {\\n                return nums[i];\\n            }\\n        }\\n        return -1; // indicates that no duplicate was found\\n    }\\n};\\nint his we simply count number of duplicate array come"
                    }
                ]
            },
            {
                "id": 1870203,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1865590,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1857657,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1836067,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1828312,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1809976,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1807137,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1799909,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1799614,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1797788,
                "content": [
                    {
                        "username": "mdmasidulhasan27",
                        "content": "There is no logic for test case [1,4,4,2,4] where is 3 here?\\nThe problem says something and testcase is illogical.\\nDear respective [@LeetCode](/LeetCode)] take initiative on this problem."
                    },
                    {
                        "username": "aryamicksingh",
                        "content": "I have seen Joma solve this :D"
                    },
                    {
                        "username": "Dhabot",
                        "content": "Question could be more clearer. Something like \"Only one number in the range[1,n] can repeat 1 to n+1 times\""
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution:\\n \\npublic int findDuplicate(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ele = -1;\\n        for(int i : nums){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n            }else{\\n                ele= i;\\n                break;\\n            }\\n        }\\n        return ele;\\n    }"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int low = 1, high = nums.size() - 1, cnt;\\n        \\n        while(low <=  high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            cnt = 0;\\n            // cnt number less than equal to mid\\n            for(int n : nums)\\n            {\\n                if(n <= mid)\\n                    ++cnt;\\n            }\\n            // binary search on left\\n            if(cnt <= mid)\\n                low = mid + 1;\\n            else\\n            // binary search on right\\n                high = mid - 1;\\n            \\n        }\\n        return low;\\n    }\\n\\t// for github repository link go to my profile.\\n};"
                    },
                    {
                        "username": "dm-vev",
                        "content": "nums = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] in testcase, its broken(python)"
                    },
                    {
                        "username": "akash368",
                        "content": " `class Solution {\\n    public int findDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                set.add(nums[i]);\\n            }\\n        }\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ Solution Easy:\\n `int findDuplicate(vector<int>& nums) {\\n        int repeating = 0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1;i<=nums.size(); i++){\\n            if(count[i]>1)repeating=i;\\n        }\\n        return repeating;\\n    }\\n"
                    },
                    {
                        "username": "Ianthetryer",
                        "content": "Would never have figured this out without looking at the solution. Really annoying but thought provoking problem."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "did you know this is a linked list problem?"
                    }
                ]
            },
            {
                "id": 1795216,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1792233,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1787388,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1771441,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1765256,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1757581,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1750745,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1745317,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1736573,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1726338,
                "content": [
                    {
                        "username": "ksvijayan06",
                        "content": "Tip TC: O(N) AS: O(1) no Floyd\\'s Algo require\\n\\nIDEA:\\n1. remember the array contain only 1 to array.size -1  values [1,2,3,4,4]\\n2. so every value is perfectly fit in array index\\n3. iterate the array make the array ele as negative if you again going to look the ele if it is neg so already one ele make  it as neg so the current ele is op\\n `public int findDuplicate(int[] arr) {`\\n      `  int size = arr.length;`\\n  ` for (int i = 0; i < size; i++) {`\\n    `    int index = Math.abs(arr[i]);`\\n     `   if (arr[index] > 0) {`\\n         `   arr[index] = -arr[index];`\\n       ` } else {`\\n           ` return Math.abs(arr[i]);`\\n      `  }`\\n  `  }`\\n    `return -1;`\\n   ` }`\\n"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "[2,2,2,2,2]\\nWrong test case."
                    },
                    {
                        "username": "shilbabun491",
                        "content": "1. First apply cyclic sort .\\n1.i.  if(arr[i] != arr[correctIndex]){\\n                swap(arr , i ,correctIndex);\\n            }else{\\n                i++;\\n            }\\n//where correctIndex = arr[i] - 1;\\n2.  // need to check for tehe element which is repeated twice\\n        for(int index = 0 ; index < arr.length ; index++){\\n            if(arr[index] != index + 1){\\n                return arr[index];\\n            }\\n        }"
                    },
                    {
                        "username": "nandoaires",
                        "content": "How come this is not an easy exercise?\\n\\nA solution is basically using a set saving the numbers that I passed. When a number you passed is already in the set, return that number.\\n\\nO(n) space, O(n) time."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The problem description says \"You must solve the problem **without** modifying the array nums and uses only **constant** extra space.\""
                    },
                    {
                        "username": "noob_coder63",
                        "content": "In the Linked List Cycle Method why a \"do- while\" loop is required. why can\\'t we use a simple \"while\" loop?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "vivan_19",
                        "content": "Why does the O(n) solution with two runners for i and j and using a while loop to iterate and compare nums[i] and nums[j] time out, but not the O(nlogn) binary search solution?"
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "`    def findDuplicate(self, nums: List[int]) -> int:`\\n`        se = set(nums)`\\n`        return (sum(nums) - sum(se))//(len(nums)-len(se))`"
                    },
                    {
                        "username": "aachy",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n    map<int, int> mp;\\n    for (int i = 0; i < nums.size(); ++i)\\n    {\\n        mp[nums[i]]++;\\n        if (mp[nums[i]] > 1)\\n        {\\n            return nums[i];\\n        }\\n    }\\n    return 0;        \\n    }\\n};"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "coming from neetcode.io roadmap. why is this a linked list problem?"
                    }
                ]
            },
            {
                "id": 1724029,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1723883,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1719686,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717328,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1717045,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716312,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715488,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1704103,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1677919,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1675203,
                "content": [
                    {
                        "username": "Aniket_456",
                        "content": " `your inline code...your inline code...`\\nint findDuplicate(vector<int>& nums) {\\n      \\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//find duplicate element present in an array\\nvoid finddupele(int *arr, int n)\\n{\\n    set<int>s;\\n    sort(arr,arr+n);\\n     for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==arr[i+1])\\n        {\\n            s.insert(arr[i]);\\n        }\\n    }\\n   for (auto it = s.begin(); it !=s.end(); ++it)\\n   {\\n        cout << \\' \\' << *it;\\n   }\\n    return 0;\\n}"
                    },
                    {
                        "username": "Abhay_Agrawal",
                        "content": "public int findDuplicate(int[] nums) {\\n         int n = nums.length;\\n         int temp = nums[0];\\n         int res = 0;\\n         for(int i = 1; i < nums.length; i++){\\n             temp ^= nums[i];\\n             if(temp == 0){\\n                 res = nums[i];\\n                 break;\\n             }\\n         }\\n         return res;\\n    }\\n\\n\\nI have tried using it with bitwise XOR, as we know that in XOR(1^1 = 0 & 1^0 = 1).\\nexample [1,2,3,4,5] = 1^2^3^4^5 > 0.\\nif any number will repeat then it will become 0.\\nI used this logic and find when my solution becoming zero that\\'s when the repeated number should come.\\nBut, I don\\'t know why this is not working. Would anyone help me?\\nThank, you in Advance... "
                    },
                    {
                        "username": "priyanshu_ch18",
                        "content": "why it shows time limit exceeded??\\n\\n\\nfor i in nums:\\n            g=nums.count(i)\\n            if g>1:\\n                return i\\n                break"
                    },
                    {
                        "username": "1337n00b",
                        "content": "here is my solution which is correct according to the question but the testcase [2,2,2,2,2] should not be there according to the question. \\n ` int findDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int sum = 0; \\n        long long int summation = ((n-1)*((n-1)+1))/2;\\n        for(int i = 0; i < n ; i++)\\n        {\\n                sum +=nums[i];\\n        }\\n        cout<<summation<< \" \"<< sum;\\n        return (sum - summation);\\n    }`"
                    },
                    {
                        "username": "neo9729",
                        "content": "This question tests your problem reading skills"
                    },
                    {
                        "username": "ALOK_16",
                        "content": "Can someone find the mistake or optimise it ,\\nfor me it showing 53/58 testcase are passed.\\n\\n\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              if(nums[i]==nums[j]){\\n                  ans = nums[i];\\n              }\\n          }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lupin_1107",
                        "content": "nums value ranging form 1 to 4 only?"
                    },
                    {
                        "username": "shubham23701",
                        "content": "class Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1]<0:\\n                return abs(nums[i])\\n            else:\\n                nums[abs(nums[i])-1]*=-1\\n#this may help you"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int  numss;\\n    sort(nums.begin(),nums.end());\\n    for(int i=0;i<nums.size()-1;i++)\\n    {\\n        if(nums[i]==nums[i+1])\\n        {\\n            numss=nums[i];\\n        }\\n    }\\n         return numss;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]