[
    {
        "title": "3Sum Closest",
        "question_content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 7883,
                "title": "c-solution-o-n-2-using-sort",
                "content": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "solutionTags": [],
                "code": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 7871,
                "title": "python-o-n-2-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 7873,
                "title": "a-n-2-solution-can-we-do-better",
                "content": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "solutionTags": [],
                "code": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "codeTag": "Unknown"
            },
            {
                "id": 8026,
                "title": "python-solution-two-pointer",
                "content": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1042348,
                "title": "faster-solution-about-95-faster-and-easy-solution-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/9acbb0ae-649b-4891-bdb3-21d55ae09a3e_1612031949.8420494.png)\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```Hey Folk I\\'m using Two Pointer technique technique if you really want to appreciate and fount it batter*** please Up vote Thank You:)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778177,
                "title": "python3-runtime-52-ms-faster-than-99-77",
                "content": "Easy recursive solution, works for any k, not only for 3\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365626,
                "title": "c-python-two-pointers-clean-concise",
                "content": "**Idea**\\n- Sort `nums` in increasing order.\\n- Let\\'s fix `nums[i]` by iterating `i` in range `[0..n-2]`, we using 2 pointers to find 2 elements in range `[i+1..n-1]`, so that `nums[i] + nums[l] + nums[r]` will have minimum difference with our `target`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^3` is number of elements in array `nums`.\\n- Space: from `O(sorting)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147500,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352747,
                "title": "java-3-pointers-explained",
                "content": "**Idea:** Similar to [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n* If sum of numbers at these 3 pointers equals target, then exit with target\\n* Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n* Else move the end pointer backwards because the sum is too high\\n* Keep a running minimum difference to find the closest the sum gets to target\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\nArrays.sort uses dual pivot quick sort which takes extra O(n) space\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7987,
                "title": "12-lines-concise-and-easy-understand-c-solultion",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2194572,
                "title": "python-accepted-solution-getting-tle-now",
                "content": "It seems like ~250 new test cases have been added to the problem recently which are now causing TLEs to previously accepted programs. See this submission of mine from March 2022 - https://leetcode.com/submissions/detail/666408027/. The same is now getting a TLE even after adding the optimization of skipping computations for duplicate elements.  \\n\\n**Solution which got accepted before but now giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\\n\\n\\n**Optimized solution - also giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7913,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**3Sum Closest** https://leetcode.com/problems/3sum-closest/\\n\\n**Brute-force: O(N^3)**\\n* Brute force solution will be O(N^3). We end up testing every subset and update the closest sum in every iteration.\\n\\n**Two Pointer Solution: O(N^2)**\\n* We can use the two pointer method to reduce complexity to O(N^2). We begin by sorting the array.\\n* Now we use three indices i,j and k. We iterate i from 0 to N (actually till N-2 is fine). We initialize j to i+1 and k to N-1.\\n* Now we compute curr_sum = nums[i]+nums[j]+nums[k]. If this equals target, we have the closest sum.\\n* Otherwise update closest_sum using the rule abs(curr_sum-target) < abs(closest_sum-target).\\n* Now what if curr_sum is less than target. Should we test (nums[i]+nums[j]+nums[k-1]), (nums[i]+nums[j]+nums[k-2]), (nums[i]+nums[j]+nums[k-3]) ? The answer is NO. All of these triplets will be less than curr_sum. And curr_sum is less than target - so there is no point testing these triplets. We must move forward by advancing j to j + 1 in the hope to get a larger triplet. This is the main intuition in this problem.\\n* You can visualize (6) by thinking all possible triplet sums sorted and arranged on a number line. When you find a curr_sum less than target, you increase curr_sum by increasing j. When you find a curr_sum less more than target, you reduce curr_sum by reducing k\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365711,
                "title": "c-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481580,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Sort the input array\\n2. Use two pointers `left` & `right` to calculate a local sum, compare the target with the local sum\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736495,
                "title": "java-fastest-and-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/5c5c0ba7-1c0d-4826-9c1e-c86de4dcb9db_1688821081.4729018.png)\\n\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164611,
                "title": "logical-thinking-with-code-beats-99-33",
                "content": "**Logical Thinking**\\nIf a candidate number `nums[pre]` is given, the problem is decreased to the **Two-sum Closest** problem -  find two integers in nums such that the sum is closest to `target - nums[pre]`. We need to try all possible `nums[pre]`.\\nWe\\'d better sort `nums[]` first. In this way, we can apply **Binary Search** in `2Sum Closest` rather than **Exhaustive Search**.\\n\\n**Trick**\\nThe condition to terminate **Binary Search** is not \\'`no searching space`\\' but \\'`not enough searching space`\\' for we need to maintain two valid candidates in the searching space `[lo, hi]` both inclusive.\\n\\n**Clear Code**\\n```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179560,
                "title": "c-two-pointer-approach-3-sum-variation",
                "content": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3116265,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159984,
                "title": "something-wrong-with-python3-interpreter",
                "content": "Something is wrong with the way the leetcode environment is processing python3 code! It is executing most code in far longer than it should.\\n\\nAt first I thought I just had a poor solution, but then I noticed that mine was functionally identical to the \\'correct\\' ones. I then copy and pasted previous examples of middle of the road times (~300ms): now they are exceeding time limit or are in the 9000ms+ range!\\n\\nConsider the following - its not my code, but an \"example 290ms\" one:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```\\n\\nThis code copy pasted in exceeds the time limit, rather than being in the ~300ms range.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7963,
                "title": "u3010python-u3011beating-95-solution-with-two-pointers-u3010o-n-2-u3011",
                "content": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2674627,
                "title": "java-sorting-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938326,
                "title": "most-efficient-python-code-that-beats-90-submissions-with-easiest-explanation",
                "content": "**Intution:**\\nWe\\'ll use **Three-pointer** approach in this question.\\nSort the given list in ascending order.\\nA pointer lets say \\'i\\' will be used to iterate through the given list nums.\\nWithin that loop, two more pointers lets say \\'start\\' and \\'end\\' would be initialised as follows:\\n\\tstart=i+1\\n\\tend=len(nums)-1\\nNow within this loop we will run another loop until the value of start in less than end.\\nTake a variable lets say \\'sum\\' to store value of nums[i]+nums[start]+nums[end].\\nIn this loop we would be checking for **3 conditions**.\\n**Condition 1:**\\nif **sum==target**, the sum contains the required answer as the minimum possible difference between any two numbers is 0 and sum-target will also give 0 in this case.\\n**Condition 2:**\\nif difference in target and sum is less than value contained by our \\'diff\\' variable(initialized with maximum possible value) the the diff would become equal to the absolute difference in target and sum and answer variable \\'ans\\' would be assigned the value of \\'sum\\', as this sum gives the minimum difference till now.\\n**Condition 3:\"**\\nWe\\'ll check if the value of sum is greater than target then the end will be decremented by one or else the start in incremented by one in case the sum is less than target.\\n**Code:**\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n^2)\\nSpace Complexity:\\nO(1) [constant]\\n**PLEASE UPVOTE THE ANSWER TO MOTIVATE ME FOR CONTINUING THE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493316,
                "title": "c-java-python-javascript-o-n-2logn-using-two-pointers",
                "content": "# Intuition:\\n\\nThe problem requires us to find a triplet of numbers in the given array, such that their sum is closest to the given target. We can use the two-pointer approach along with sorting the array to solve this problem.\\n\\n# Approach:\\n\\n1. Sort the given array in non-descending order.\\n2. Initialize a variable closest_sum to store the closest sum found so far. Set it initially to the sum of first three elements in the sorted array.\\n3. Loop over the array from i=0 to i=n-3, where n is the size of the array.\\n4. For each i, initialize two pointers, left and right, to i+1 and n-1 respectively.\\n5. While left < right, calculate the sum of the current triplet, sum = nums[i] + nums[left] + nums[right].\\n6. If sum is equal to the target, we have found the closest sum possible, so we can return it immediately.\\n7. If sum is less than target, increment left by 1. This will increase the sum, and we may get a closer sum.\\n8. If sum is greater than target, decrement right by 1. This will decrease the sum, and we may get a closer sum.\\n9. After each iteration of the inner loop, check if the absolute difference between sum and target is less than the absolute difference between closest_sum and target. If it is, update closest_sum to sum.\\n10. Return closest_sum after the loop ends.\\n# Complexity:\\n- Time Complexity: Sorting the array takes O(nlogn) time. The two-pointer approach runs in O(n^2) time. Therefore, the overall time complexity of the solution is O(n^2logn).\\n\\n- Space Complexity: We are not using any extra space in the solution. Therefore, the space complexity of the solution is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365598,
                "title": "3sum-closest-easy-w-approach-c-java",
                "content": "# **APPROACH:**\\n* Given an `array nums with n integers` and `one target`. We have to find `three integers` in nums such that the **sum is closest to the target**. We will return the sum of the three integers. \\n* We can take one assumption that each input would have exactly one solution. \\n\\n**TESTCASE:**\\nIf the given array is like `[-1,2,1,-4]` and the target is `1`, then the triplet will be `[-1,2,1]` this has the closest sum, that is `2`.\\n\\n# **ALGORITHM:**\\n\\n* Sort the array nums, ans := 0, diff := Infinity, n := size of nums\\n* for i in range 0 to n \\u2013 1\\n\\t* left := i + 1, right := n \\u2013 1\\n\\t* while left < right\\n\\t\\t* temp := nums[left] + nums[right] + nums[i]\\n\\t\\t* If `|target \\u2013 temp| < diff`, then ans := temp and diff := |target \\u2013 temp|\\n\\t\\t* If `temp = target`, then return temp, \\n\\t\\t* Otherwise when `temp > target`, then decrease right by 1, else increase left by 1\\n* return ans\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n`In Java`\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848622,
                "title": "java-simple-and-readable-solution-two-pointer",
                "content": "We can regard this quesiton as : \\na+b+c+min(difference) ? target \\nsum = a+b+c\\nthen we transferred the question sucessfully as Two Pointers.\\n\\nSo what we need now is the minimum diff and return sum(which is target - diff) at last\\nWatch out that diff could be both positive and negative, thus just comparing diff is meaningless.\\nWe can slove this by updating the diff original value IFF its absolute value smaller.\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430115,
                "title": "7-lines-code-with-detailed-explanation-of-approach-for-beginners-o-n-2-beginner-coders",
                "content": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 7906,
                "title": "7ms-and-o-n-2-java-solution",
                "content": "My solution does not need compare each sum ,just need to compare possible sum ,so can save time.\\n\\n    public class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }\\n                else{\\n                    while(low<high&&nums[low]+nums[high]<target-nums[i]) low++;\\n                    if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low-1]+nums[high];\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067315,
                "title": "faster-c-solution-o-n-3-o-n-2-40ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a variation of 2Sum and especially 3Sum problem. In 3Sum, we choose a triplet and checks its sum equal to 0(target). here we have to find the sum of triplet closest to target. so use the same approach as we have used in 3Sum problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst thing is to think how you can get closest sum. For this sort the vector for easiness. \\nif sum is greater then target, but we need sum closest, that is ,**the minimum sum greater than equal to target** declare min1 variable with **min1 = INT_MAX - 10000;** we did -10000 so that we can get rid of TLE.  and same for when sum is smaller than target , that is, **the greatest sum smaller than equal to target** for this declare, **max1 = INT_MIN + 10000** . if sum is equal to target return the sum. \\n\\nnow the question is which variale min1, max1 we have to return, for this, find the absolute difference of min1, max1 with target and return min1 or max1 as per the minimum diff obtained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173514,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Fix one var\\n- iterate the other two pointers nested\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899603,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675008,
                "title": "c-solution-with-explanations-brute-force-to-optimal-solution-explained",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- A basic approach using 3loops.\\n- We calculate the sum of 3 elements & store the difference of sum and target.\\n- If the difference is less than the minimum value we expected, then we\\u2019ll store the sum as ans.\\n- **Time complexity:** O(n^3).\\n\\n### Solution 02\\n\\n- Here we sort the array & will use 2 pointers to get the sum.\\n- Fix an index ***i*** & ***left=i+1, right=n-1.***\\n- If the sum of the 3 elements is less than the target, then we\\u2019ll shift the left pointer which will increase the value.\\n- Else we will shift right to decrease sum value.\\n- Also, we\\u2019ll calculate the difference and store in ***mn*** & update ***ans.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365863,
                "title": "python3-detailed-explanation-of-naive-2-pointer-solutions",
                "content": "## 0. Understanding the Problem\\nGiven:\\n- an array `nums`\\n- an integer `target`\\n\\nGoal: To find the sum of 3 numbers in `nums` that is closest to `target`.\\n\\nExample explaination:\\nnums = [-1,2,1,-4], target = 1\\n\\nThere are multiple possible combinations of which we have to find the minimum summing case. Infact there are nC3 total combinations.\\n\\nFor the given case, 2 is the solution, given by (-1, 2, 1).\\n\\n\\n## 1. Naive Solution\\nSince there are 3 numbers we need to take the sum of, we can simply loop and find the answer.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\\n\\n## 2. Observations\\n- The question asks for the `sum` and not the three numbers/indices themselves, this means operations like **sorting** could help us.\\n- The sort function takes `O(Nlog(N))` time. (The space complexity depends on what algorithm you choose to use. Heap sort takes `O(1)` space (its in-place). Merge sort takes `O(N)` space.) This time is also lesser than `O(N^3)` and `O(N^2)`.\\n- Considering the array sorted, what more can we derive?\\n\\nOne possible Solution:\\nInstead of 3 nested loops, we can have two nested loops and one binary search running, taking time complexity `O(N^2log(N) + Nlog(N))`. Which is the same as `O(N^2log(N))`. This is clearly better than `O(N^3).`\\n\\nThere\\'s one last observation needed for the best solution. \\nThe purpose of the loop is to \"specify\" one variable. When we do `for i in range(n)`, we specify the value for `i` for the loops nested inside of it (think about it, its trivial). Once we specify three of the values, we can make a comparison with `target` and decide whether to make it answer or not. This is the logic behind the three nested loops of the naive solution.\\n\\nBUT, note how once the array is sorted, we have a definite measurement of how the elements are palced. We can reuse this fact and have **two pointers**. One from `i+1`, called `l` and the other from `n-1`, called `r`, both going in the opposite directions. `l` goes to the right and `r` to the left. We can **greedily search for the answer**!\\n\\n*Since the array is sorted, we can always decide whether to move the `l` or the `r` pointer.*\\n\\nHow? Let\\'s see below!\\n\\n## 3. Optimal Solution\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```\\n\\nTime complexity: `O(Nlog(N) + N^2)`. `Nlog(N)` for the merge sort operation and `N^2` for the for loop & then the search from `l` to `r` (this will take up the entire range from `[i+1, n-1]`).\\n\\nSpace complexity: `O(N)` for the merge sort.\\n\\nQuestions? Feel free to ask below! Comments and criticisms are greatly appreciated. An upvote means this explaination helped you out :D\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7972,
                "title": "share-my-24-line-java-code-beats-94-57-run-times",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }\\n                    else if (sum > target) {\\n                        if (sum-target < diff) {\\n                            diff = sum-target;\\n                            closest = sum;\\n                        }\\n                        --j;\\n                    } else {\\n                        if (target-sum < diff) {\\n                            diff = target-sum;\\n                            closest = sum;\\n                        }\\n                        ++i;\\n                    }\\n                }\\n            }\\n            return closest;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }",
                "codeTag": "Java"
            },
            {
                "id": 3471166,
                "title": "beats-93-beginner-friendly-cpp-and-python-code-easy-to-understand",
                "content": "# Intuition\\nPLZ upvote if you like this\\n\\n# Python Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381792,
                "title": "easy-java-approach-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the input array nums to enable the two-pointer approach, which helps in efficiently finding the three integers with the closest sum to the target value.\\n\\nInitialize closestSum and minDiff to large values, as placeholders for the closest sum and minimum difference between sum and target, respectively.\\n\\nLoop through the array from index 0 to nums.length - 2, as the three-pointer approach requires at least three elements to find a sum.\\n\\nInside the loop, set up two pointers, left and right, to the elements immediately after the current element and the last element of the array, respectively.\\n\\nUse a while loop to continuously move the left and right pointers towards each other until they meet or cross each other.\\n\\nCalculate the current sum by adding the values at the current element, nums[left], and nums[right].\\n\\nCalculate the absolute difference between the current sum and the target value, and update minDiff and closestSum if the current difference is smaller than the previous minimum difference.\\n\\nIf the current sum is less than the target, increment the left pointer to consider a larger value.\\n\\nIf the current sum is greater than the target, decrement the right pointer to consider a smaller value.\\n\\nIf the current sum is equal to the target, return it as the closest sum.\\n\\nAfter the loop completes, return the closestSum as the final result, which represents the three integers in the array whose sum is closest to the target value. Note that the returned value may be greater or smaller than the target, depending on the input array and target value. Thus, the caller can check the actual difference between the returned sum and the target value if needed. Also, note that this code assumes that the input array nums has at least three elements. If that\\'s not guaranteed, appropriate error handling or input validation should be added. Additionally, the code assumes that the\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070001,
                "title": "easiest-c-solution-using-for-loop-and-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297535,
                "title": "python-two-pointer-solution-sped-up-with-binary-search-avoiding-tle",
                "content": "This solution runs in around 250ms to 300ms (faster than 80%) https://leetcode.com/submissions/detail/749879788/. Other two two-pointer solutions tend to be TLE since the new test cases were added. \\nIn the 3sum solution the update rule starts with\\n```\\nk = i+1\\nj = len(nums) - 1\\n```\\nand then increments these:\\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```\\nHowever, instead of updating these incrementally we can directly fast-forward them using binary search. i.e. at minimum nums[k] would have to be to flip the if statement is target - num[i] - nums[j]. The same logic can be applied to update j using binary search. \\n```\\ndef threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n \\n        best = None\\n        \\n        # The window is: [i, k, j]\\n        # Valid range for i:\\n        for i in range(0, len(nums) - 2):\\n            # Instead of incrementaly updating the j and k,\\n            # we can use binary search to find the next viable value\\n            # for each.\\n            # We pingpong between updating j and k\\n            pingpong = 0\\n            \\n            # Pick a k (j will be overriden on first pass)\\n            k = i+1\\n            j = len(nums)\\n\\n            while j > i + 2:\\n                if pingpong%2 == 0:\\n                    # Decrease j until sum can be less than target\\n                    targetVal = target - nums[i] - nums[k]\\n                    newj = bisect_left(nums, targetVal, k+1, j-1)\\n                    # There is no possible update to j, can stop\\n                    # searching\\n                    if newj == j:\\n                        break\\n                    j = newj\\n                    pingpong += 1\\n                else:\\n                    # Increase k until sum can exceed target\\n                    targetVal = target - nums[i] - nums[j]\\n                    k = bisect_left(nums, targetVal, i+1, j-1)\\n                    if nums[k] > targetVal and k > i+1:\\n                        k = k - 1\\n                    pingpong += 1\\n\\n                new = nums[i] + nums[k] + nums[j]\\n                if best is None or (abs(best - target) > abs(target - new)):\\n                    best = new\\n\\n                if best == target:\\n                    return target\\n\\n        return best",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nk = i+1\\nj = len(nums) - 1\\n```\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674384,
                "title": "python-solution-defeat-the-new-test-cases",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467590,
                "title": "javascript-99",
                "content": "Doing the Blind 75 List and posting all solutions.\\n\\n```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365667,
                "title": "python-two-pointers-2sum-explained",
                "content": "Very similar to the problem **15**, also 2 pointers idea. Now, instead of looking for sums equal to `target`, we perform 2 pointers and look for sums which are around `target`, that is if sum becomes bigger than `target` we move end pointer and in opposite case we move beg pointer. \\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n)` or `O(log n)` depening on sort function.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```\\n\\n#### Remark\\nThere are couple of optimization to make it work faster: `if ans == target: break` before the last return statement, and not using lambda functions to get min.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317287,
                "title": "c-solution-with-proper-explaination",
                "content": "This problem is variation of **2 sum**  poblem where we need to find the pairs equivalent to the given target.\\nThe 2 sum problem is further extended to **3 sum** where we need to return the tripet of array which is equal to 0.\\nHow this problem 3 sum closest is extension of 3 sum : \\nhere we just need to find three integers of nums vector that has closest sum to the given target.**\\n\\n**Steps to find closest 3 sum to the given target:**\\n1) sort the array(through sorting we can increase the efficiency of the solution)\\n   unless and until the array is sorted applying two pointer doesn\\'t make sense.\\n2)  use two pointer approach \\n3)  make a left pointing next to i and a right pointer at the end of it\\n4)  make a curr_sum variable \\n5)  check for the condition if target - curr_sum < min_diff\\n6)  if curr_sum > target than decrement the right pointer \\n7)  else increment left pointer.\\n **Time complexity - O(N^2)** \\n **space complexity - O(1)** as no extra space required\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```\\n**please upvote if you like the  solution and do comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159459,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8022,
                "title": "4-ms-c-solution-sample",
                "content": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "solutionTags": [],
                "code": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448416,
                "title": "c-very-easy-solution-beginner-friendly-two-pointers",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404344,
                "title": "java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678631,
                "title": "this-brute-force-solution-is-fast-and-here-is-why",
                "content": "## The solution\\n\\nMost solutions in the discussion are O(n^2) and take about 500ms+ in python3, some even got TLE if it lacks some early-stopping checks. However, the solution from here https://leetcode.com/problems/3sum-closest/discuss/778177/Python3-%3A-Runtime%3A-52-ms-faster-than-99.77, while using a brute-force approach, can reach under 200ms, which is significantly faster than other theoretically better O(n^2) solutions. His solution is as follow:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\\n\\n## Why on earth it is so fast ?\\nThe reason is smart prunning, more specifially these 2 checks speed up the code significantly:\\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\\nAnd to understand this, let\\'s look at some math. \\n\\nMathematically, if elements in nums are uniformly distributed then the distribution of all possible 3sum would be a bell curve that looks look like this. This is called [Irwin\\u2013Hall distribution or uniform sum distribution.](https://en.wikipedia.org/wiki/Irwin\\u2013Hall_distribution)\\n\\n![image](https://assets.leetcode.com/users/images/9349442b-52d4-4d30-80c5-e82f93ffd73e_1665281362.0298378.png)\\n \\nSo a random target would likely to be close to the mean of all possible 3sum, which means it would lie near the middle of the bell curve. So these 2 above checks essentially bypass many candidates that are too big (sum of numbers near the end) or too small (sum of numbers near the start). And by using recursion, this logic is applied at every k, effectively pruning a lot of cases. \\n\\nYou can check this by counting the number of times these 2 checks help the function return early.\\n\\n## Make it even faster\\n\\nBut that\\'s not all, the solution can be further optimized by changing the linear search in the base case\\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\\nto binary search\\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```\\nThis in theory is faster than the original solution. However for `len(nums) < 1000` which is small, the improvement is neligible.  \\n\\n## Final words\\nI think it is important to understand thoroughly why a solution is fast, rather than just judging it based solely on the big-O upper bound. \\n\\nIf you find this helpful, please leave  an upvote. Thank you",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677097,
                "title": "java-sort-and-two-pointers",
                "content": "# Intuition\\nWe need to find the closest triplet that sums to target.\\n\\nThe brute force way is to iterate `O(n^3)` and to try all triplets. We can do better.\\n\\nIf we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is `[-2,0,1,3,4,6,7]` and our target is `2` we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in `O(n)`.\\n\\nWe can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element `i` at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\nTo make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810579,
                "title": "c-easy-to-understand-simple-tc-o-n-2-sc-o-1-100",
                "content": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451359,
                "title": "python-easy-approach-beats-100-memory",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 278202,
                "title": "c-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083996,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nSorting & Two Pointer \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812696,
                "title": "c-java-python-javascript",
                "content": "![Screenshot 2023-07-25 at 10.14.24 AM.png](https://assets.leetcode.com/users/images/7c652887-773d-4629-8591-0183ac74f26b_1690260281.8217592.png)\\n\\n\\n## \\uD83C\\uDF38\\uD83E\\uDDE9 Problem Statement \\uD83E\\uDDE9\\uD83C\\uDF38\\n- Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\\n\\n- Return the sum of the three integers.\\n\\n- *You may assume that each input would have **exactly one solution**.*\\n\\n#### \\uD83D\\uDD2E Example 1 :- \\n```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\\n#### \\uD83D\\uDD2E Example 2 :- \\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\\n\\n## \\uD83E\\uDDE0 Optimal Approach Based on Sorting and Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n- The threeSumClosest function takes a vector nums and an integer target as input and returns an integer representing the sum of three elements closest to the target.\\n- It starts by sorting the input vector nums in ascending order using sort.\\n- Then, it iterates through the vector using a for-loop for each index i from 0 to n - 2, where n is the size of the vector.\\n- Inside the loop, it calls the Solve function, which uses a two-pointer approach to find the closest sum for the current index i.\\n- The Solve function uses two pointers, L and R, initialized to i + 1 and n - 1, respectively. It moves the pointers towards each other while calculating the sum of three elements (nums[x] + nums[L] + nums[R]) and updating the ans and mx variables based on the difference from the target.\\n- After iterating through all possible combinations of three elements, the function returns the final ans, which represents the sum of three elements closest to the target value.\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB Code \\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\\n\\n#### \\uD83C\\uDF38 Complexity\\n- Time complexity : $$O(n^2)$$\\n- Space complexity : $$O(1)$$\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB All Code \\n\\n- Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n- Python\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\\n- Javascript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675029,
                "title": "optimal-o-n-2-o-n-two-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282243,
                "title": "to-avoid-tle-in-python-optimization-tricks",
                "content": "You can optimize the classic approach to avoid TLE in Python. \\n\\nGiven the value of k, I pick the two rightmost numbers (which means it\\'s the largest value possible given k) and see if it\\'s still less than target. Ff it is, we use continue to avoid having the while loop run because it won\\'t get closer to the target than that.\\nSame logic can be applied to the other case where we pick the two left most points and if it\\'s greater than the target, we continue, but we can actually use break this time because we don\\'t need to even check larger values of k.\\n```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109008,
                "title": "python-easy-o-n-2",
                "content": "We assign the max and minimum value that we need to get.\\n**Sort the array.**\\n\\nWe iterate once to get one value. Then we put tw pointers , one at start and other at end.\\n\\n* If present value is in between min and max values we take that as answer and update min max.\\n* If value is less than min , increase the starting pointer\\n* If value is more than max, decrease the end pointer.\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2af13d6a-eaf0-491c-b710-ce227b31a353_1654332780.6307957.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498887,
                "title": "c-8-ms-faster-than-82-29",
                "content": "**Runtime: 8 ms, faster than 82.29% of C++ online submissions for 3Sum Closest.\\nMemory Usage: 8.7 MB, less than 77.36% of C++ online submissions for 3Sum Closest.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }\\n            \\n            fix += 1;\\n            \\n        }\\n        return tmp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 7961,
                "title": "simple-code-c",
                "content": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "solutionTags": [],
                "code": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7915,
                "title": "sharing-my-java-optimized-solution-5ms-beats-99-9",
                "content": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "solutionTags": [],
                "code": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678639,
                "title": "shortest-sol-using-python-professional-code",
                "content": "\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953872,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792491,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693054,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\n// We need to find the closest triplet that sums to target.\\n\\n// The brute force way is to iterate O(n^3) and to try all triplets. We can do better.\\n\\n// If we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is [-2,0,1,3,4,6,7] and our target is 2 we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in O(n).\\n\\n// We can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element i at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\n// To make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }\\n            \\n        }\\n        \\n        return closest;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2674362,
                "title": "python-implementation-with-two-pointers-open-question-about-runtime",
                "content": "**Python Implementation**\\nTwo pointers approach, similar with the solution of Question [_**3Sum**_](https://leetcode.com/problems/3sum/)\\n\\n```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\\n\\nBefore post this solution, I want to use the block if-statement to improve the readibility of the one-line statement. But it failed with TLE.\\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```\\n\\n### Open questions\\n - Do you have any idea on this?\\n - What\\'s the difference between the runtime of one-line if-statement and block if-statement in Python?\\n\\n![image](https://assets.leetcode.com/users/images/940686eb-abbd-42e0-91e3-cff4d8f88682_1665191244.2602255.png)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674295,
                "title": "daily-leetcoding-challenge-october-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2253091,
                "title": "c-fully-explained-with-intuition-and-steps",
                "content": "**Intuition** \\n\\nThe first thing which comes to our mind is taking the sum of all possible triplets and finding which sum is nearest to the target. However, this method is brute force and hence time consuming. It has a time complexity of O(n^3).\\n\\nNow, let\\'s try to optimise it. \\n\\nForget about 3 sum closest, think about 2 sum closest first. If we had to find pair whose sum is closest to target, what would we have done? Again the brute force approach would have been to find all possible pairs and comparing the sums with the target. It will have time complexity  of O(n^2). However, we could solve it by just sorting the array and using double pointer approach. We could take 2 pointers and find the sum of those and then change the position of pointers by comparing the sum with target. This will cost us O(nlogn) time complexity. \\n\\nBetter, isn\\'t it?\\n\\nWhy not do the same thing in 3 sum closest? The worst time it could take is O(n^2)\\n\\n**Steps**\\n1. Sort the nums vector\\n2. Fix a particular element say ```nums[i]```\\n2. Now every time you fix one element in nums, take a starting pointer ```i+1``` and ending pointer ```nums.size()-1```\\n3. While the starting pointer is less than ending pointer, keep comparing the absolute difference of sum (```sum = nums[i] + nums[start] + nums[end]```) with target.\\n3. If  ```sum > target``` decrement end pointer ```end--```\\n4. If  ```sum < target``` increment start pointer ```start++```\\n5. If ```sum==target``` just return target\\n6. Keep a variable ans to store the sum which is closest to target and keep updating the ans in each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```nums[i]```\n```i+1```\n```nums.size()-1```\n```sum = nums[i] + nums[start] + nums[end]```\n```sum > target```\n```end--```\n```sum < target```\n```start++```\n```sum==target```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227046,
                "title": "python-tle-for-o-n2-new-test-cases",
                "content": "Last time I did this question was on 16-06-2022, there were 132 cases. Leetcode has added new cases (current total = 381) since then and now my same solution is TLE.\\n\\nI am using the sort + two-pointer approach, and there is proof by contradiction, there is no better solution possible. The question is giving TLE for other submitted (top-votes discussion) solutions as well.\\nMy Python Solution\\n```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2193901,
                "title": "python-modified-3sum-approach",
                "content": "![image](https://assets.leetcode.com/users/images/10e73d09-7878-4a90-867d-fdf00e56ebc2_1656379823.6041436.jpeg)\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169868,
                "title": "python-solution-beats-83-240ms",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "codeTag": "Java"
            },
            {
                "id": 1447243,
                "title": "c-solution-4ms-98-63-5-7mb-92-88",
                "content": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366451,
                "title": "c-3-clean-approaches-go-from-naive-to-best",
                "content": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362223,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 447655,
                "title": "java-6ms-o-n-2-solution",
                "content": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260076,
                "title": "python-clear-solution-with-comments-o-n-2",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7885,
                "title": "12-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8004,
                "title": "self-explanatory-java-solution-using-two-pointers",
                "content": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7921,
                "title": "my-enhanced-n-2-answer-could-be-n-logn-minimum-time-12ms",
                "content": "The outer loop is same as most people;\\nFor the inner while loop, instead of gradually doing left++, right--, I use binary search to find the closest match.  Binary search interval should be [left+1, right-1].  I use STL <algorithm> lower_bound function.\\n\\nIf current num[left]+num[right] is greater than target, then we want to move \"right\" to the left, because num[right] is too big.\\n\\nWe use lower_bound to find a number that is closest to the \"final target\". i.e., target - num[i] - num[left], \\nIf lower_bound return  the iterator points to num[right], then we simply do right--, because that means the biggest number we can try next is num[right-1]\\n\\nIf current num[left]+num[right] is less than target, then we want to move \"left\" to the right, because num[left] is too small. \\nSearch  the \"final target\". i.e., target - num[i] - num[right], \\nIf lower_bound return  the iterator points to num[right], then that means all numbers in interval [left+1, right-1] are all too small to meet the target. Thus, we only need to calculate num[i]+num[right-1]+num[right] and see how close it is to the target. Then we break the while loop.\\n\\n    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    } \\n                    if(sum > new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[left]);\\n                        if (it == num.begin()+right) {\\n                            right--;\\n                        } else {\\n                          right = distance(num.begin(), it);\\n                        }\\n                      //  right--;     //original code\\n                    } else if (sum < new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[right]);\\n                        if( it == num.begin()+right) {  //cannot find anything big enough\\n                            left = right -1;\\n                            if ( std::abs(num[left]+num[right]+num[i] - target) < std::abs(closest-target) ) {\\n                                closest = num[left]+num[right]+num[i];\\n                            }                         \\n                            break;\\n                        } else {\\n                            left = distance(num.begin(), it);\\n                        }\\n                        \\n                        //  left++;   //original code\\n                    }\\n                    \\n                }\\n            }\\n            return closest;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3938010,
                "title": "swift-c-python-java-easy-to-understand-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|ans|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Swift\\n```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\\n# Java\\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889785,
                "title": "simple-solution-beats-95-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586091,
                "title": "three-sum-closest-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is same as the three sum which is by using three pointers,the only difference here to find the closest sum to target is to check if the absolute difference between the sum and the target is smaller than the absolute difference between closest and the target. If so, update closest to the current sum.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335232,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695684,
                "title": "c-binary-search-o-nlogn-faster-than-99",
                "content": "* Firstly, sort the vector.\\n* Then, take first and last pointers(here, i and j) as first and last elements of the vector.\\n* Now, binary search over the remaining vector and find when the difference of the target and the sum -- (nums[i] + nums[j] + nums[mid] ), where mid is from the binary search. \\n* Now, likewise increase or decrease the mid acc to requirement (less or more than target).\\n* Fix, where the abs dif. is least. Store it. \\n* Now, acc to the sign of dif., increment or decrement i or j. Continue until i>j. \\n\\nThe code - \\n\\n```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676920,
                "title": "python-99-62-faster-with-comments",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676452,
                "title": "c-two-pointer-o-n-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676281,
                "title": "java-98-23-two-pointers-binary-search",
                "content": "**Upvote  if you\\'re not greedy)))**\\n# Complexity\\n- Time complexity: n*log(n)\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675165,
                "title": "python-95-fast-with-binary-search-fewer-steps-in-the-inner-loop-still-o-n-2-in-time",
                "content": "Determine the initial pointers at the value of half of \\'target\\' - \\'nums[i]\\' by binary search, instead of two edges. This should have fewer inner loop steps.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674477,
                "title": "java-98-faster-code-easy-solution",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674375,
                "title": "c-python-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546678,
                "title": "python-beginner-friendly-fast-two-pointers",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431292,
                "title": "python-c-java-kotlin-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q16. 3Sum Closest***\\nGiven an integer array `nums` of length `n` and an integer `targe`t, find three integers in nums such that the sum is closest to `target`.\\n\\nReturn the sum of the three integers.\\n\\nYou may assume that each input would have exactly one solution.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\\n**Runtime:**  53 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n**Runtime:**  174 ms\\t\\n**Memory Usage:**  48.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:**  247 ms\\t\\n**Memory Usage:**  16.4 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Kotlin  Code** :\\n**Your runtime beats 89.21 % of kotlin submissions.**\\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```\\n**Runtime:**  971 ms\\t\\n**Memory Usage:**  51.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424972,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125533,
                "title": "easy-c-solution-0-n-2-two-pointer-approach",
                "content": "The Naive approach of this is used a three pointers and calculate the diff i.e` target-(nums[i] +nums[j] +nums[k])` and check if this is closet to target if yes then `update `else check another index...\\nIn this way We take 0(n^3) time complexity...\\n\\nCan We do better?? .......\\nYes We can\\n\\nNow suppose if i give u a problem to find the two integer which is closest to target and the array is sorted then how can you solve.......?\\n**Ans**- Obviously first thing come in my mind is use of two pointer `si,ei` where `si=0` and` ei=n-1`\\nand it takes 0(n) time complexity;...................Algo(1)\\n\\nNow we use two pointer approach in given array for every array index element how.? Lets understand..\\n\\nsuppose `target=x`\\nand i want to find three integers sum which is closest to target..\\nnow we break this into subproblem..\\nie. if at` index i` then our new target is find` target-(nums[i)` from `si=i+1` to `ei=n-1` by using Algo(1) we disscused previously \\nInitially our global` clsdiff `variable is used update when we find` diff` which is less than our` clsdiff` \\nand when we update then we store three integers in `a,b,c`\\n\\nHere is code...\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```\\n** Time Complextiy-0(n^2) space complexity-0(1)**\\n\\n***Please upvote if you find helpful***\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899763,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1541433,
                "title": "c-simple-solution-beats-90",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1453442,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186601,
                "title": "javascript-beats-99-60",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 553528,
                "title": "java-o-n-2-solution-using-sort-adds-on-twosum",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550566,
                "title": "python-o-n-2-easy-to-follow-solution",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419093,
                "title": "multiple-approaches-with-explanation",
                "content": "##### Approach 1: Brute Force Solution\\n```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n#####\\tAssumption: \\n- The min value is the sum of the first three elements in the given array and we use this as our starting point to look for the minimum value that is closest to the target\\n##### Complexity\\n- Time Complexity: O(n^3)\\n- Space Complexity: O(n)\\n\\n##### Approach 2:  Two Pointer Solution\\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n##### Complexity\\n- Time Complexity: O(n^2)\\n- Space Complexity: O(n)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395240,
                "title": "python-2-pointer-solution",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301562,
                "title": "python-solution-40ms-beat-99",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229111,
                "title": "rust-0ms",
                "content": "Unfortunately with range iterators it\\'s much slower.\\n\\n```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128797,
                "title": "python-44ms-beats-100-00",
                "content": "In each loop,\\nI judge if current number plus two largest numbers less than target,\\nor current number plus two lowest numbers greater than target.\\n\\n```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "solutionTags": [],
                "code": "```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7971,
                "title": "a-12ms-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }\\n            \\n            int left, right;\\n            sort(nums.begin(),nums.end());\\n            \\n            for(int i = 0; i < (len - 2); i++) {\\n                left = i + 1;\\n                right = len - 1;\\n                while(left < right) {\\n                    sum = nums[i] + nums[left] + nums[right];\\n                    if(abs(sum - target) <= dif) {\\n                        dif = abs(sum - target);\\n                        minsum = sum;\\n                    }\\n                    if(sum > target) right--;\\n                    if(sum < target) left++;\\n                    if(sum == target) return minsum;\\n                }\\n            }\\n            return minsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8011,
                "title": "java-o-n-2-clean-and-clear-solution",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }\\n            }\\n            return target + min_diff;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 8044,
                "title": "my-aceepted-o-n-2-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n        \\t\\t\\tif(sum>(target-num[i]))\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\thigh--;\\n    \\t\\t\\t\\t}\\n        \\t\\t\\telse\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\tlow++;\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn clostSum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3823730,
                "title": "java-python-c-js-solution-simple-and-explained-commented-multiple-language",
                "content": "# Intuition\\nOur aim is to find the three integers whose sum is closest to the given target value. To achieve this, the array is first sorted in ascending order, and then two pointers (j and k) are used to scan the array from the start and end while maintaining a variable closestSum to track the closest sum found so far.\\n\\n# Approach\\n1. Sort the input array nums in ascending order using Arrays.sort(nums).\\n2. Initialize the variable closestSum to store the closest sum of three integers found so far. Set it to the sum of the first three elements of the sorted array (nums[0] + nums[1] + nums[2]).\\n3. Iterate through the array using a loop with an index variable \\'i\\'. The loop runs from index 0 to \\'nums.length - 2\\' to ensure enough elements are available for forming triplets.\\n4. For each \\'i\\' index, initialize two pointers \\'j\\' and \\'k\\'. \\'j\\' starts from \\'i+1\\', and \\'k\\' starts from \\'nums.length - 1\\'.\\n5. Use a while loop with conditions \\'j < k\\' to explore all possible combinations of triplets.\\n6. Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n7. Check if the current sum is closer to the target than the previous closest sum using the helper function compare.\\n8. If the current sum is closer to the target, update the closestSum to the current sum.\\n9. If the sum is less than the target, increment \\'j\\' to move towards higher values and potentially get closer to the target sum.\\n10. If the sum is greater than the target, decrement \\'k\\' to move towards lower values and potentially get closer to the target sum.\\n11. Continue this process until \\'j\\' becomes greater than or equal to \\'k\\'.\\n12. The process is repeated for all \\'i\\' indices to find the three integers whose sum is closest to the target.\\n13. Return the closestSum, which represents the sum of the three integers that have the closest sum to the given target value.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\nwhere n is number of elements in array\\n\\n- Space complexity:\\nO(1)\\n\\n# Request\\n![LeetCode Upvote Request.webp](https://assets.leetcode.com/users/images/2798aaa4-6440-43bb-9d13-a925e5491c2f_1690459953.7107084.webp)\\n\\n\\n# Code\\n- JAVA\\n```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\\n\\n- Python\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\\n\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\\n\\n- JavaScript\\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748757,
                "title": "easy-solution-using-sorting-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682363,
                "title": "c-easy-solutions-simple-explanation-two-pointer-approach",
                "content": "# Intuition\\n- Sorting the array is crucial for applying the two-pointer technique. It allows us to efficiently move the pointers towards each other, converging on the closest sum to the target.\\n- By iterating over each element as the first element of the triplet, we ensure that we explore all possible combinations and find the closest sum.\\n- The two-pointer technique helps us explore different combinations of elements without having to consider every possible triplet, significantly reducing the time complexity.\\n- By updating the minimum difference (diff) and the closest sum (ans) whenever a closer sum is found, we ensure that we have the correct answer when the algorithm finishes.\\n- Overall, the intuition behind this approach is to use the sorted nature of the array and the two-pointer technique to efficiently explore different combinations of elements and find the closest sum to the target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the array in ascending order.\\n- Initialize variables for the minimum difference (diff) and the closest triplet sum (ans).\\n- Iterate over each element in the array.\\n- Use two pointers (left and right) to find the closest triplet sum to the target.\\n- Calculate the current triplet sum.\\n- Update diff and ans if the current sum is closer to the target.\\n- Adjust the pointers based on the value of the current sum.\\n- Repeat steps 5-7 until the pointers meet.\\n- Return the closest triplet sum (ans).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n^2) due to the nested loops, where n is the size of the input array.\\n{ Sorting the array using sort(nums.begin(), nums.end()) takes O(n log n) time, where n is the size of the input array nums.\\nThe main part of the code consists of nested loops. The outer loop iterates n times, and the inner while loop, in the worst case, iterates n/2 times (when j and k start from the opposite ends of the array).\\nThus, the overall time complexity is O(n log n + n^2), which simplifies to O(n^2) since n^2 dominates n log n. }\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(1) because the code uses a constant amount of additional space to store variables (diff, ans, n, i, j, k, and sum). The space required does not depend on the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633271,
                "title": "easy-to-understand-c-solution-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567201,
                "title": "bruteforce-o-n-3-to-optimized-o-nlog-n-n-2-code",
                "content": "# 1. Brute Force Code\\n### Approach\\nBrute Force Approach - Checking for all the possible triplets and then finding the closestSum be analysing the closeness of the currentSum by target. \\n\\n### Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\\n\\n# 2. Optimized 2 Pointers Code\\n### Approach\\n- Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n- If sum of numbers at these 3 pointers equals target, then exit with target\\n- Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n- Else move the end pointer backwards because the sum is too high\\n- Keep a running minimum difference to find the closest the sum gets to target \\n\\n### Complexity\\n- Time complexity: O(nlog(n) + n^2)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282146,
                "title": "java-runtime-17ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275736,
                "title": "easy-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237073,
                "title": "javascript-best-way-explanation-easy-to-solve",
                "content": "\\n# Approach\\n i Use a two-pointer approach to find the three integers in nums that add up to the closest sum to target. The algorithm first sorts the input array in ascending order. It then initializes the closest sum to the sum of the first three elements in the sorted array.\\n\\nThe algorithm then iterates through each element of the array, treating it as the first element of a possible three-sum combination. For each first element, it uses two pointers, left and right, to search for the two other elements that sum to the closest possible value to target. The pointers start at the first element after the first element and at the last element of the array, respectively. The pointers move towards each other until they meet. For each combination of `nums[i]`, `nums[left`], and `nums[right]`, the algorithm computes the sum and checks if it is closer to target than the current closest sum. If it is, the closest sum is updated. Finally, the algorithm returns the closest sum found.\\n\\ni assume that the input array nums has at least three elements. If the input array has fewer than three elements, the implementation may produce incorrect results. To handle this case, additional logic would be needed to check the length of the input array before attempting to find the closest three-sum.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220908,
                "title": "triple-threat-finding-the-closest-three-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use a similar approach to the three sum problem. We first sort the input array and fix the first element in the triplet. Then, we use two pointers to search for the remaining two elements such that the sum is closest to the target.\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the input array nums.\\n\\n- Initialize a variable diff to store the difference between the target and the sum of the triplet. Initialize a variable res to store the sum of the closest triplet found so far.\\n\\n- Loop over the input array nums from the first element to the second last element.\\n\\n- Initialize two pointers left and right to search for the remaining two elements such that the sum is closest to the target.\\n\\n- While left < right, calculate the sum of the triplet nums[i] + nums[left] + nums[right].\\n\\n- If the absolute difference between the target and the sum is less than the absolute difference between the target and the current value of res, update res to the sum.\\n\\n- If the sum is less than the target, increment the left pointer. Otherwise, decrement the right pointer.\\n- Return the value of res.\\n# Complexity\\n- Time complexity: The time complexity of the above algorithm is $$O(n^2)$$, where n is the length of the input array nums. This is because we have two nested loops to search for the remaining two elements such that the sum is closest to the target.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the above algorithm is $$O(1)$$ because we are using constant extra space to store the variables diff and res.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811774,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811445,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2753073,
                "title": "python-solution-two-pointers",
                "content": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 2677030,
                "title": "brute-force-optimized-faster-than-98",
                "content": "## Brute Force Solution: O(n^3)\\n```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\\n\\n## Optimized Solution. Break problem into two sum. O(n^2)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```\\n\\n**Do give a rep if you find the solution helpful ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676496,
                "title": "python",
                "content": "**The Logic**:\\nFirst we sort `nums` in O(nLogn).\\nThen, we fix one number by looping through the `nums`. As soon as one number is fixed - we can iterate two other numbers simultaneously. How? Let `hi = len(nums) - 1` and `lo = i + 1` where `i` is fixed (first out of three numbers).\\nWe sum the numbers - `s`. If it is lower than the `target` - what can we do? We can only increase `lo` by one - because `nums` are sorted. By that, we are trying to increase the sum `s`. We keep moving `lo` by one until `s` is lower than the `target`. As soon as we got a number higher than the `target`, we can try to decrease it. Either we decrease `lo` by one - but we already had it before. Or we can decrease `hi` by one. So, the total sum should be decreased, because the array is sorted.\\nThus we have one loop and one nested loop - O(N^2).\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675865,
                "title": "rust-33-ms-fastest-100-two-pointers-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/817764364/) employs a two-pointers approach with sorting. It demonstrated **33 ms runtime (100.00%)** and used **2.2 MB memory (15.46%)**. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675826,
                "title": "easy-cpp-2-pointer-simple-approach",
                "content": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2675529,
                "title": "python-two-pointer-solution-with-explanation",
                "content": "sort ```nums``` first, we can check the largest three and smallest three values,\\n\\nif the sum of smallest three values is greater than or equal to ```target```, return it\\nif the sum of largest three values is smaller than or equal to ```target```, return it\\n\\nand fix one value```pivot```, and find the other two value is the closet to the ``` target ``` in the ```[l, r]```.\\n\\nbecause ```nums``` is sorted,\\n\\nif the sum of the smallest two value ```nums[l] + nums[l+1]``` is greater than or equal to ```delta```, which means all the pair in the current and next iteration are greater than ```delta```, no need to check them, just return ```ans```\\n\\nif the sum of the largest two value ```nums[r-1] + nums[r]``` is smaller than or equal to ```delta```, which means all the pair in the current iteration are smaller than ```delta```, no need to check them, just go to the next iteration\\n\\ntc is ```O(N^2)```, sc is ```O(1)```\\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```target```\n```target```\n```pivot```\n``` target ```\n```[l, r]```\n```nums```\n```nums[l] + nums[l+1]```\n```delta```\n```delta```\n```ans```\n```nums[r-1] + nums[r]```\n```delta```\n```delta```\n```O(N^2)```\n```O(1)```\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675440,
                "title": "python-easy-o-n-2-solution-with-removed-iteration-for-same-set-of-3-values",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675018,
                "title": "cpp-solution-notes-video-explanation-how-to-approach-this-problem",
                "content": "Please visit my channel, and support me by liking, sharing, and subscribing my channel.\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CclNyWEnp2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n# Notes:\\n\\n![image](https://assets.leetcode.com/users/images/d40168a9-8bde-4a33-a0a6-cf43e25fa7b2_1665209465.7496073.png)\\n![image](https://assets.leetcode.com/users/images/6af06b4f-60f2-4326-afb0-114902c92b05_1665209488.0175567.png)\\n** second ++;\\n\\n\\n# Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674491,
                "title": "c-python-short-concise-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674469,
                "title": "daily-leetcode-solution-3-sum-closest",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674460,
                "title": "16-python-java-c-javascript-solutions",
                "content": "Python:\\n```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\\nJava:\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\\nC++:\\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\\nJavascript:\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674413,
                "title": "c-two-pointer-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1;\\n            int k=n-1;\\n        \\n            while(j<k)\\n            {\\n                 int sum=nums[i]+nums[j]+nums[k];\\n                \\n                if(abs(sum-target) < diff)\\n                {\\n                    diff=abs(sum-target);\\n                    Res=sum;\\n                }\\n                \\n                if(sum > target) k--;\\n                \\n                else j++;\\n            }\\n        }        \\n        \\n       return Res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2594279,
                "title": "python-2-pointer-binary-search-beats-95",
                "content": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2540163,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "codeTag": "Unknown"
            },
            {
                "id": 2437125,
                "title": "easy-to-understand-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372577,
                "title": "c-two-pointers-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361234,
                "title": "easy-c-solution-with-explanation-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319319,
                "title": "java-runtime-6ms-faster-than-99-65",
                "content": "When we add two mathematical properties, we can shorten the time to reach the target.\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/4e41cbb9-f0db-441d-bd5d-bb8847d546d1_1658521667.3858693.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257327,
                "title": "c-n-2-two-pointer",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2227280,
                "title": "python-solution-for-381-test-cases",
                "content": "I got around 960 ms runtime for this solution with 381 test cases. I tried to handle some edge cases such as if target is less than sum of first 3 digits and if target is greater than sum of last 3 digits.\\nMy solution:\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183372,
                "title": "go-o-n-2-clean-with-explanation",
                "content": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138304,
                "title": "simple-c-solution-using-two-pointer",
                "content": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137805,
                "title": "javascript-solution",
                "content": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2133259,
                "title": "best-solution-fastest-easy-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989154,
                "title": "java-two-pointers-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985131,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957202,
                "title": "c-easy-to-understand-solution-o-n-2-two-pointer",
                "content": "***Please upvote if you find the solution helpful to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955777,
                "title": "clean-commented-java-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619838,
                "title": "python-3-pointer-solution-simple-explanation-96-faster-96-ms",
                "content": "![image](https://assets.leetcode.com/users/images/5c780459-a159-4be4-978c-72a4ec4609ab_1639058651.4989543.png)\\nFix one of the pointers at index `i` then do the typical two-sum problem with indices `j` and `k` on the remaining elements that is not at index `i`. After `i` loops through the entire array once or when you find a difference of `0`, then you have the 3sum solution.\\n```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609485,
                "title": "c-similar-to-3sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546228,
                "title": "simple-to-understand-using-2-pointer-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542595,
                "title": "very-easy-js-solution",
                "content": "TC: O(N*N)\\nSC: O(1)\\n\\n```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402681,
                "title": "3sum-closest-two-pointers-python3",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366055,
                "title": "3sum-closest-easy-to-understand-c",
                "content": "Store all possible sum and then find the answer\\'s index using upperbound.\\nTime Complexity O(n^2)\\nwhere n = size of the nums vector.\\n\\nclass Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }\\n    }\\n    sort(store.begin(),store.end());\\n    int ind = upper_bound(store.begin(),store.end(),target)-store.begin();\\n\\t\\n    if(ind==store.size())  return store[ind-1];\\n    if(ind==0) return store[0];\\n    int dif1 = abs(store[ind]-target);\\n    int dif2 = abs(target-store[ind-1]);\\n    if(min(dif1,dif2)==dif1) return store[ind];\\n    return store[ind-1];\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1744801,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1729330,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2017604,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2010783,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1946972,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1838611,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1749948,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1746883,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1733038,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1576653,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2039112,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2018257,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2008595,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2005976,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1975228,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1965422,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1902008,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1900256,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1898570,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1835746,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1819662,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807387,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807374,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798513,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798512,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1797041,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1779724,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1767723,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1761945,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1753078,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1752585,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1715276,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1714059,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1713632,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1701042,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1696065,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1671256,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1648663,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1637889,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1636388,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            }
        ]
    }
]