[
    {
        "title": "Number of Lines To Write String",
        "question_content": "You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of 'a', widths[1] is the width of 'b', and so on.\nYou are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s.\nReturn an array result of length 2 where:\n\n\tresult[0] is the total number of lines.\n\tresult[1] is the width of the last line in pixels.\n\n&nbsp;\nExample 1:\n\nInput: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: [3,60]\nExplanation: You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide.\nExample 2:\n\nInput: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\"\nOutput: [2,4]\nExplanation: You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide.\n&nbsp;\nConstraints:\n\n\twidths.length == 26\n\t2 <= widths[i] <= 10\n\t1 <= s.length <= 1000\n\ts contains only lowercase English letters.",
        "solutions": [
            {
                "id": 120666,
                "title": "easy-solution-6-lines-c-java-python",
                "content": "Very self-explaining codes.\\n\\nNote from description:\\n* The length of S will be in the range ```[1, 1000]```.\\n* S will only contain lowercase letters.\\n* widths is an array of length 26.\\n\\nC++\\n```\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int res = 1, cur = 0;\\n        for (char c : S) {\\n            int width = widths[c - \\'a\\'];\\n            res = cur + width > 100 ? res + 1 : res;\\n            cur = cur + width > 100 ? width : cur + width;\\n        }\\n        return {res, cur};\\n    }\\n```\\nJava:\\n```\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int res = 1, cur = 0;\\n        for (char c : S.toCharArray()) {\\n            int width = widths[c - \\'a\\'];\\n            res = cur + width > 100 ? res + 1 : res;\\n            cur = cur + width > 100 ? width : cur + width;\\n        }\\n        return new int[] {res, cur};\\n    }\\n```\\nPython\\n```\\n    def numberOfcurs(self, widths, S):\\n        res, cur = 1, 0\\n        for i in S:\\n            width = widths[ord(i) - ord(\\'a\\')]\\n            res += 1 if cur + width > 100 else 0\\n            cur = width if cur + width > 100 else cur + width\\n        return [res, cur]\\n\\t",
                "solutionTags": [],
                "code": "```[1, 1000]```\n```\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int res = 1, cur = 0;\\n        for (char c : S) {\\n            int width = widths[c - \\'a\\'];\\n            res = cur + width > 100 ? res + 1 : res;\\n            cur = cur + width > 100 ? width : cur + width;\\n        }\\n        return {res, cur};\\n    }\\n```\n```\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int res = 1, cur = 0;\\n        for (char c : S.toCharArray()) {\\n            int width = widths[c - \\'a\\'];\\n            res = cur + width > 100 ? res + 1 : res;\\n            cur = cur + width > 100 ? width : cur + width;\\n        }\\n        return new int[] {res, cur};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 120695,
                "title": "regex",
                "content": "```\\ndef number_of_lines(widths, s)\\n  a = s.gsub(/./) { \"a#{\\'.\\' * (widths[$&.ord - 97] - 2)}b\" }.scan(/a.{,98}b/)\\n  [a.size, a[-1].size]\\nend\\n```\\nI replace for example a letter of width `6` by the string `a....b`. Then use regex `/a.{,98}b/` to create optimal lines.",
                "solutionTags": [],
                "code": "```\\ndef number_of_lines(widths, s)\\n  a = s.gsub(/./) { \"a#{\\'.\\' * (widths[$&.ord - 97] - 2)}b\" }.scan(/a.{,98}b/)\\n  [a.size, a[-1].size]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2595859,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int count=1;\\n        int sum=0;\\n        for(char i:s.toCharArray()){\\n            if((sum+widths[i-\\'a\\'])<=100)sum+=widths[i-\\'a\\'];\\n            else {\\n                sum=widths[i-\\'a\\'];\\n                count++;\\n            }\\n        }\\n        return new int[]{count,sum};\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int count=1;\\n        int sum=0;\\n        for(char i:s.toCharArray()){\\n            if((sum+widths[i-\\'a\\'])<=100)sum+=widths[i-\\'a\\'];\\n            else {\\n                sum=widths[i-\\'a\\'];\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 120668,
                "title": "c-straightforward",
                "content": "    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int lines = 1; vector<int> res;\\n        int occupied_width = 0, len = S.length();\\n        \\n        for(int i = 0; i < len; i++) {\\n            if((occupied_width + widths[S[i] - \\'a\\']) > 100) {\\n                lines++;\\n                occupied_width = 0;\\n            }\\n            occupied_width += widths[S[i] - \\'a\\'];\\n        }\\n        \\n        res.push_back(lines);\\n        res.push_back(occupied_width);\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int lines = 1; vector<int> res;\\n        int occupied_width = 0, len = S.length();\\n        \\n        for(int i = 0; i < len; i++) {\\n            if((occupied_width + widths[S[i] - \\'a\\']) > 100) {\\n                lines++;\\n                occupied_width = 0;\\n            }\\n            occupied_width += widths[S[i] - \\'a\\'];\\n        }\\n        \\n        res.push_back(lines);\\n        res.push_back(occupied_width);\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2452066,
                "title": "c-for-beginners",
                "content": "We simply keep counting the current sum of pixels, and as soon as it exceeds 100, increment the lines required by one.\\n\\n\\tvector<int> numberOfLines(vector<int>& widths, string s) {\\n        int cnt=1, currSum=0;\\n        \\n        for (int i=0;i<s.size();i++) {\\n            currSum += widths[s[i]-\\'a\\'];\\n            if(currSum > 100) {\\n                currSum = widths[s[i]-\\'a\\'];\\n                cnt++;\\n            }\\n        }\\n        \\n        return {cnt,currSum};\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We simply keep counting the current sum of pixels, and as soon as it exceeds 100, increment the lines required by one.\\n\\n\\tvector<int> numberOfLines(vector<int>& widths, string s) {\\n        int cnt=1, currSum=0;\\n        \\n        for (int i=0;i<s.size();i++) {\\n            currSum += widths[s[i]-\\'a\\'];\\n            if(currSum > 100) {\\n                currSum = widths[s[i]-\\'a\\'];\\n                cnt++;\\n            }\\n        }\\n        \\n        return {cnt,currSum};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1434696,
                "title": "c-easy-to-understand-100-faster",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        int count=1;\\n        if(s.length()==0)\\n        return {0,0};    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum+=widths[s[i]-\\'a\\'];\\n            if(sum>100)\\n            {\\n                sum=widths[s[i]-\\'a\\'];\\n                count++;\\n            }   \\n        }   \\n        vector<int> ans;\\n        ans.push_back(count);\\n        ans.push_back(sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        int count=1;\\n        if(s.length()==0)\\n        return {0,0};    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum+=widths[s[i]-\\'a\\'];\\n            if(sum>100)\\n            {\\n                sum=widths[s[i]-\\'a\\'];\\n                count++;\\n            }   \\n        }   \\n        vector<int> ans;\\n        ans.push_back(count);\\n        ans.push_back(sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508209,
                "title": "javascript-simple-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} widths\\n * @param {string} S\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, S) {\\n  let lines = 1;\\n  let last = 0;\\n  const base = \\'a\\'.charCodeAt(0);\\n  for (let i = 0; i < S.length; i++) {\\n    const width = widths[S.charCodeAt(i) - base];\\n    last += width;\\n    if (last > 100) {\\n      lines++;\\n      last = width;\\n    }\\n  }\\n  return [lines, last];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} widths\\n * @param {string} S\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, S) {\\n  let lines = 1;\\n  let last = 0;\\n  const base = \\'a\\'.charCodeAt(0);\\n  for (let i = 0; i < S.length; i++) {\\n    const width = widths[S.charCodeAt(i) - base];\\n    last += width;\\n    if (last > 100) {\\n      lines++;\\n      last = width;\\n    }\\n  }\\n  return [lines, last];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498470,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        abc = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        abc_dict = {c:i for i, c in enumerate(abc)}\\n        n = 0\\n        lines = 1\\n\\n        for c in S:\\n            n += widths[abc_dict[c]]\\n            if n == 100:\\n                lines += 1\\n                n = 0\\n                continue\\n            elif n > 100:\\n                lines += 1\\n                n = widths[abc_dict[c]]\\n                \\n        return(lines, n)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        abc = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        abc_dict = {c:i for i, c in enumerate(abc)}\\n        n = 0\\n        lines = 1\\n\\n        for c in S:\\n            n += widths[abc_dict[c]]\\n            if n == 100:\\n                lines += 1\\n                n = 0\\n                continue\\n            elif n > 100:\\n                lines += 1\\n                n = widths[abc_dict[c]]\\n                \\n        return(lines, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235298,
                "title": "java-bruteforce-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int total=0;\\n        int count=0;\\n        String str=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            char a=s.charAt(i);\\n            int ele=widths[a-\\'a\\']; \\n            if(total+ele<=100){\\n               str+=Character.valueOf(a).toString();\\n               total=total+ele; \\n            }else{\\n                count++;\\n                str=Character.valueOf(a).toString();\\n                total=ele;\\n            }           \\n        }\\n         if(!str.equals(\"\")) count++;\\n         int[] array=new int[2];\\n         array[0]=count;\\n         array[1]=total;\\n         return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int total=0;\\n        int count=0;\\n        String str=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            char a=s.charAt(i);\\n            int ele=widths[a-\\'a\\']; \\n            if(total+ele<=100){\\n               str+=Character.valueOf(a).toString();\\n               total=total+ele; \\n            }else{\\n                count++;\\n                str=Character.valueOf(a).toString();\\n                total=ele;\\n            }           \\n        }\\n         if(!str.equals(\"\")) count++;\\n         int[] array=new int[2];\\n         array[0]=count;\\n         array[1]=total;\\n         return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854003,
                "title": "just-1-loop-java-98-faster",
                "content": "```Don\\'t forget to upvote if you find it useful```\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int res1=0,res0=0;\\n        int length = s.length();\\n        for(int i=0;i<length;i++){\\n            res1+=widths[s.charAt(i)-\\'a\\'];\\n            if(res1>100){\\n                res0++;\\n                res1=0;\\n                i--;\\n            }\\n        }\\n        return new int[]{res0+1,res1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Don\\'t forget to upvote if you find it useful```\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int res1=0,res0=0;\\n        int length = s.length();\\n        for(int i=0;i<length;i++){\\n            res1+=widths[s.charAt(i)-\\'a\\'];\\n            if(res1>100){\\n                res0++;\\n                res1=0;\\n                i--;\\n            }\\n        }\\n        return new int[]{res0+1,res1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300227,
                "title": "python-super-easy-solution-faster-than-99-submission",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        a_dict = {l:w for l,w in zip(\"abcdefghijklmnopqrstuvwxyz\",widths)}\\n        r_count, rp_count = 1, 0\\n        for i in range(len(s)):\\n            rp_count += a_dict[s[i]]\\n            if rp_count > 100:\\n                rp_count = a_dict[s[i]]\\n                r_count += 1\\n        return [r_count, rp_count]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        a_dict = {l:w for l,w in zip(\"abcdefghijklmnopqrstuvwxyz\",widths)}\\n        r_count, rp_count = 1, 0\\n        for i in range(len(s)):\\n            rp_count += a_dict[s[i]]\\n            if rp_count > 100:\\n                rp_count = a_dict[s[i]]\\n                r_count += 1\\n        return [r_count, rp_count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033554,
                "title": "python-understandable-solution-unlike-description-with-explanation",
                "content": "**Explanation**\\nWe loop through each character in `s`, and each time we see what width it is. If the final width is above 100, then we make a new line. We return the number of lines and the final width.\\n\\n```\\nclass Solution(object):\\n    def numberOfLines(self, widths, s):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        lines = 1\\n        width = 0\\n        for char in s:\\n            w = widths[ord(char) - ord(\\'a\\')]\\n            width += w\\n            if width > 100:\\n                lines += 1\\n                width = w\\n        return [lines, width]\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, s):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        lines = 1\\n        width = 0\\n        for char in s:\\n            w = widths[ord(char) - ord(\\'a\\')]\\n            width += w\\n            if width > 100:\\n                lines += 1\\n                width = w\\n        return [lines, width]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349936,
                "title": "very-easy-java-solution-with-comment-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution \\n{\\n    public int[] numberOfLines(int[] widths, String s)\\n    {\\n        char chrs[]=s.toCharArray();\\n        int len=chrs.length;\\n        \\n        int line=1, size=0;\\n        for(int i=0; i<len; i++)\\n        {\\n            char tempCh=chrs[i];\\n            //agar mera current size k saath aur ek char add karne se size 100pixel k equal or 100 se chota raha..\\n            if((size+widths[tempCh%97])<=100)\\n            {\\n                //toh karo add...\\n                size+=widths[tempCh%97];\\n            }\\n            else\\n            {\\n                //nahi toh line no. badao aur agli line pe jao jiska size us naya wala charracter ke size se shuru hoga....\\n                line++;\\n                size=widths[tempCh%97];\\n            }\\n        }\\n        \\n        int res[]={line, size};\\n        return res;\\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] numberOfLines(int[] widths, String s)\\n    {\\n        char chrs[]=s.toCharArray();\\n        int len=chrs.length;\\n        \\n        int line=1, size=0;\\n        for(int i=0; i<len; i++)\\n        {\\n            char tempCh=chrs[i];\\n            //agar mera current size k saath aur ek char add karne se size 100pixel k equal or 100 se chota raha..\\n            if((size+widths[tempCh%97])<=100)\\n            {\\n                //toh karo add...\\n                size+=widths[tempCh%97];\\n            }\\n            else\\n            {\\n                //nahi toh line no. badao aur agli line pe jao jiska size us naya wala charracter ke size se shuru hoga....\\n                line++;\\n                size=widths[tempCh%97];\\n            }\\n        }\\n        \\n        int res[]={line, size};\\n        return res;\\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923434,
                "title": "easy-if-else-solution-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        lines = width = 0\\n        \\n        for i in S:\\n            x = widths[ord(i) - ord(\\'a\\')]\\n            if width + x == 100:\\n                lines += 1\\n                width = 0\\n            elif width + x > 100:\\n                lines += 1\\n                width = x\\n            else:\\n                width += x\\n        if width != 0:\\n            lines += 1\\n        return [lines, width]\\n```\\nFor more such questions:https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        lines = width = 0\\n        \\n        for i in S:\\n            x = widths[ord(i) - ord(\\'a\\')]\\n            if width + x == 100:\\n                lines += 1\\n                width = 0\\n            elif width + x > 100:\\n                lines += 1\\n                width = x\\n            else:\\n                width += x\\n        if width != 0:\\n            lines += 1\\n        return [lines, width]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646530,
                "title": "two-method-easy-to-read-20ms-python3-beats-99",
                "content": "dict\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        dic = {}\\n        for i,num in enumerate(alpha):\\n        \\tdic[num] = widths[i]\\n        line = 1\\n        count = 0\\n        for i in S:\\n        \\tcount += dic[i]\\n        \\tif count > 100:\\n        \\t\\tline += 1\\n        \\t\\tcount = dic[i]\\n        return [line, count]\\n```\\nASCII\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        line = 1\\n        count = 0\\n        for i in S:\\n        \\tcount += widths[ord(str(i))-97]\\n        \\tif count > 100:\\n        \\t\\tline += 1\\n        \\t\\tcount = widths[ord(str(i))-97]\\n        return [line, count]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        dic = {}\\n        for i,num in enumerate(alpha):\\n        \\tdic[num] = widths[i]\\n        line = 1\\n        count = 0\\n        for i in S:\\n        \\tcount += dic[i]\\n        \\tif count > 100:\\n        \\t\\tline += 1\\n        \\t\\tcount = dic[i]\\n        return [line, count]\\n```\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        line = 1\\n        count = 0\\n        for i in S:\\n        \\tcount += widths[ord(str(i))-97]\\n        \\tif count > 100:\\n        \\t\\tline += 1\\n        \\t\\tcount = widths[ord(str(i))-97]\\n        return [line, count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515186,
                "title": "806-javascript-one-line-solution",
                "content": "This is more performant than I expected.\\n\\n> Runtime: **52 ms**, faster than *90.63%* of JavaScript online submissions\\n> Memory Usage: **35.6 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\nconst numberOfLines = (widths, s) =>\\n  [...s]\\n    .map(c => widths[c.charCodeAt(0) - 97])\\n    .reduce(\\n      (acc, curr) => [\\n        acc[0] + (100 < acc[1] + curr ? 1 : 0),\\n        100 < acc[1] + curr ? curr : acc[1] + curr,\\n      ],\\n      [s.length ? 1 : 0, 0],\\n    );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst numberOfLines = (widths, s) =>\\n  [...s]\\n    .map(c => widths[c.charCodeAt(0) - 97])\\n    .reduce(\\n      (acc, curr) => [\\n        acc[0] + (100 < acc[1] + curr ? 1 : 0),\\n        100 < acc[1] + curr ? curr : acc[1] + curr,\\n      ],\\n      [s.length ? 1 : 0, 0],\\n    );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098905,
                "title": "easy-java-solution-beginners-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        if(s.length()==0)\\n        return new int[]{0,0};\\n        int[] ans=new int[]{1,0};\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int temp=widths[s.charAt(i)-\\'a\\'];\\n            if(temp+sum<=100)\\n            {\\n                sum+=temp;\\n            }\\n            else \\n            {\\n                ans[0]++;\\n                sum=temp;\\n            }\\n        }\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        if(s.length()==0)\\n        return new int[]{0,0};\\n        int[] ans=new int[]{1,0};\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int temp=widths[s.charAt(i)-\\'a\\'];\\n            if(temp+sum<=100)\\n            {\\n                sum+=temp;\\n            }\\n            else \\n            {\\n                ans[0]++;\\n                sum=temp;\\n            }\\n        }\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026085,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] arr = new int[2];\\n        int x = 1;\\n        int sum = 0;\\n        for(char c : s.toCharArray()){\\n            int char_width = widths[c - \\'a\\'];\\n            if(char_width + sum > 100){\\n                x++;\\n                sum = 0;\\n            }\\n            sum += char_width;            \\n        }\\n        arr[0] = x;\\n        arr[1] = sum;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] arr = new int[2];\\n        int x = 1;\\n        int sum = 0;\\n        for(char c : s.toCharArray()){\\n            int char_width = widths[c - \\'a\\'];\\n            if(char_width + sum > 100){\\n                x++;\\n                sum = 0;\\n            }\\n            sum += char_width;            \\n        }\\n        arr[0] = x;\\n        arr[1] = sum;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888333,
                "title": "c-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int l=0,r=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(l+widths[(char)s[i]-97] > 100)\\n            {\\n                r++;\\n                l=widths[(char)s[i]-97];\\n            }\\n            else\\n                l+=widths[(char)s[i]-97];\\n        }\\n        return {r,l};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int l=0,r=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(l+widths[(char)s[i]-97] > 100)\\n            {\\n                r++;\\n                l=widths[(char)s[i]-97];\\n            }\\n            else\\n                l+=widths[(char)s[i]-97];\\n        }\\n        return {r,l};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738578,
                "title": "easy-java-solution-100-faster",
                "content": "class Solution {\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum =0;\\n        int count =1;\\n        for(int i=0; i<s.length(); i++){\\n           char ch = s.charAt(i);\\n           int p = ch - \\'a\\';\\n           if(widths[p] + sum >100){\\n               count++;\\n               sum = widths[p];\\n           }\\n            else{\\n                sum = sum + widths[p];\\n            }\\n       } \\n        int [] arr = {count, sum};\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum =0;\\n        int count =1;\\n        for(int i=0; i<s.length(); i++){\\n           char ch = s.charAt(i);\\n           int p = ch - \\'a\\';\\n           if(widths[p] + sum >100){\\n               count++;\\n               sum = widths[p];\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1988033,
                "title": "easy-o-n-js-solution",
                "content": "\\tvar numberOfLines = function(widths, s) {\\n\\t\\tlet lines = 1;\\n\\t\\tlet sum = 0;\\n\\n\\t\\tfor(let i=0; i<s.length; i++){\\n\\t\\t\\tlet num = s.charCodeAt(i) - 97;\\n\\t\\t\\tif(sum + widths[num] <= 100){\\n\\t\\t\\t\\tsum += widths[num];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\t\\tsum = widths[num];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn [lines, sum];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numberOfLines = function(widths, s) {\\n\\t\\tlet lines = 1;\\n\\t\\tlet sum = 0;\\n\\n\\t\\tfor(let i=0; i<s.length; i++){\\n\\t\\t\\tlet num = s.charCodeAt(i) - 97;\\n\\t\\t\\tif(sum + widths[num] <= 100){\\n\\t\\t\\t\\tsum += widths[num];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlines++;\\n\\t\\t\\t\\tsum = widths[num];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn [lines, sum];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1965820,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int line=0;\\n        int pix=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i)-97;\\n            pix=pix+widths[a];\\n            if(pix==100)\\n            {\\n                line++;\\n                if(i!=s.length()-1)\\n                {\\n                    pix=0;\\n                }\\n            }\\n            else if(pix>100)\\n            {\\n                i--;\\n                line++;\\n                pix=0;\\n            }\\n        }\\n        if(pix>0 && pix!=100)\\n        {\\n            line++;\\n        }\\n        int[] result=new int[2];\\n        result[0]=line;\\n        result[1]=pix;\\n        return result;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int line=0;\\n        int pix=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i)-97;\\n            pix=pix+widths[a];\\n            if(pix==100)\\n            {\\n                line++;\\n                if(i!=s.length()-1)\\n                {\\n                    pix=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1890946,
                "title": "number-of-lines-to-write-string-solution-java",
                "content": "class Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        final int MAX_WIDTH = 100;\\n        int linesCount = 1, curWidth = 0;\\n        int length = S.length();\\n        for (int i = 0; i < length; i++) {\\n            char c = S.charAt(i);\\n            int width = widths[c - \\'a\\'];\\n            if (curWidth + width <= MAX_WIDTH)\\n                curWidth += width;\\n            else {\\n                linesCount++;\\n                curWidth = width;\\n            }\\n        }\\n        return new int[]{linesCount, curWidth};\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        final int MAX_WIDTH = 100;\\n        int linesCount = 1, curWidth = 0;\\n        int length = S.length();\\n        for (int i = 0; i < length; i++) {\\n            char c = S.charAt(i);\\n            int width = widths[c - \\'a\\'];\\n            if (curWidth + width <= MAX_WIDTH)\\n                curWidth += width;\\n            else {\\n                linesCount++;\\n                curWidth = width;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1170893,
                "title": "python3-97-faster-solution",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        count = ans =  wi = 0\\n        s = list(s)\\n        while s:\\n            val = ord(s[0]) - 97\\n            \\n            if(widths[val] + wi > 100):\\n                wi = 0\\n                count += 1\\n            \\n            wi += widths[val]\\n            \\n            s.pop(0)\\n        return([count + 1 , wi])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        count = ans =  wi = 0\\n        s = list(s)\\n        while s:\\n            val = ord(s[0]) - 97\\n            \\n            if(widths[val] + wi > 100):\\n                wi = 0\\n                count += 1\\n            \\n            wi += widths[val]\\n            \\n            s.pop(0)\\n        return([count + 1 , wi])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100059,
                "title": "java-100-faster",
                "content": "```\\npublic int[] numberOfLines(int[] widths, String s) {\\n        int width=0;\\n        int noOflines=1;\\n        for(int i=0;i<s.length();i++){\\n            if(width+widths[s.charAt(i)-97]<=100){\\n                width+=widths[s.charAt(i)-97];\\n            }else{\\n                width=widths[s.charAt(i)-97];\\n                noOflines++;\\n            }\\n        }\\n        return new int[]{noOflines,width};\\n    }\\n```\\n\\nPlease upvote if you like the solution :)",
                "solutionTags": [],
                "code": "```\\npublic int[] numberOfLines(int[] widths, String s) {\\n        int width=0;\\n        int noOflines=1;\\n        for(int i=0;i<s.length();i++){\\n            if(width+widths[s.charAt(i)-97]<=100){\\n                width+=widths[s.charAt(i)-97];\\n            }else{\\n                width=widths[s.charAt(i)-97];\\n                noOflines++;\\n            }\\n        }\\n        return new int[]{noOflines,width};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135366,
                "title": "my-python-solutuin-beats-99-61",
                "content": "a=0\\n        b=1\\n        for c in S:\\n            if a <=100-width[ord(c)-97]:\\n                a+=width[ord(c)-97]\\n            else:\\n                b+=1\\n                a=0\\n                a+=width[ord(c)-97]\\n        return [b,a]",
                "solutionTags": [],
                "code": "a=0\\n        b=1\\n        for c in S:\\n            if a <=100-width[ord(c)-97]:\\n                a+=width[ord(c)-97]\\n            else:\\n                b+=1\\n                a=0\\n                a+=width[ord(c)-97]\\n        return [b,a]",
                "codeTag": "Unknown"
            },
            {
                "id": 120763,
                "title": "c-minimalism",
                "content": "If the letter cannot fit into the current line, we round the total width to the next 100. Now, we can divide the total width by 100 to see how many lines we have and use modulo to determine the width of the current (last) line. \\n```\\nvector<int> numberOfLines(vector<int>& ws, string s, int w = 0) {\\n  for (int c : s) \\n      w = ws[c-\\'a\\'] + (w % 100 + ws[c-\\'a\\'] > 100 ? w + 100 - w % 100 : w);\\n  return { w / 100 + 1, w % 100 };\\n}\\n```\\n**Update**\\nThere is a missing test case when the last line fills exactly 100 characters, and the following code addresses that.\\n```CPP\\nvector<int> numberOfLines(vector<int>& ws, string s, int w = 0) {\\n  for (int c : s) \\n      w = ws[c - \\'a\\'] + (w % 100 + ws[c-\\'a\\'] > 100 ? w + 100 - w % 100 : w);\\n  return { w / 100 + (w % 100 > 0), w % 100 > 0 ? w % 100 : w ? 100 : 0 };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> numberOfLines(vector<int>& ws, string s, int w = 0) {\\n  for (int c : s) \\n      w = ws[c-\\'a\\'] + (w % 100 + ws[c-\\'a\\'] > 100 ? w + 100 - w % 100 : w);\\n  return { w / 100 + 1, w % 100 };\\n}\\n```\n```CPP\\nvector<int> numberOfLines(vector<int>& ws, string s, int w = 0) {\\n  for (int c : s) \\n      w = ws[c - \\'a\\'] + (w % 100 + ws[c-\\'a\\'] > 100 ? w + 100 - w % 100 : w);\\n  return { w / 100 + (w % 100 > 0), w % 100 > 0 ? w % 100 : w ? 100 : 0 };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733389,
                "title": "easy-solution-100-faster-with-explanation",
                "content": "# Approach\\nThe given solution tackles the problem of determining the number of lines needed to write a given string `s` using an array of character widths `widths`.\\n\\nHere\\'s an overview of the approach:\\n\\n1. Create an integer array `res` to store the resulting number of lines and the width of the last line.\\n2. Initialize `lines` and `width` variables to keep track of the current line count and width.\\n3. Iterate through each character, `c`, in the string `s` using a `foreach` loop.\\n4. For each character, calculate its width by accessing the corresponding value in the `widths` array using `widths[c - \\'a\\']`.\\n5. Check if adding the character\\'s width to the current line width exceeds the limit of 100 pixels:\\n   - If it does, increment the line count (`lines++`) and set `width` to the character\\'s width since it will be the width of the next line.\\n   - If it doesn\\'t, add the character\\'s width to the current line width (`width += charWidth`).\\n6. After processing all the characters, assign the line count and the width of the last line to `res[0]` and `res[1]`, respectively.\\n7. Return the `res` array as the result.\\n\\nThis approach iterates through each character of the string `s` and calculates the line count and width of the last line based on the character widths. It avoids the need for a separate map or lookup table, as it directly accesses the `widths` array using the character\\'s ASCII value. The time complexity of this solution is O(n), where n is the length of the string `s`. The space complexity is O(1) since the `res` array has a fixed size.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] res = new int[2];\\n\\n        int lines = 1;\\n        int width = 0;\\n\\n        for (char c : s.toCharArray()) {\\n            int charWidth = widths[c - \\'a\\'];\\n            if (width + charWidth > 100) {\\n                lines++;\\n                width = charWidth;\\n            } else {\\n                width += charWidth;\\n            }\\n        }\\n\\n        res[0] = lines;\\n        res[1] = width;\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] res = new int[2];\\n\\n        int lines = 1;\\n        int width = 0;\\n\\n        for (char c : s.toCharArray()) {\\n            int charWidth = widths[c - \\'a\\'];\\n            if (width + charWidth > 100) {\\n                lines++;\\n                width = charWidth;\\n            } else {\\n                width += charWidth;\\n            }\\n        }\\n\\n        res[0] = lines;\\n        res[1] = width;\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471335,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int lines = 1, width = 0;\\n        for(char c : s) {\\n            int w = widths[c-\\'a\\'];\\n            width += w;\\n            if(width > 100) {\\n                ++lines;\\n                width = w;\\n            }\\n        }\\n        return {lines, width};\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, width = 1, 0\\n        for char in s:\\n            cur_width = widths[ord(char)-97]\\n            if width + cur_width <= 100:\\n                width += cur_width\\n            else:\\n                lines += 1\\n                width = cur_width\\n        return [lines, width]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int lines = 1, width = 0;\\n        for(char c : s) {\\n            int w = widths[c-\\'a\\'];\\n            width += w;\\n            if(width > 100) {\\n                ++lines;\\n                width = w;\\n            }\\n        }\\n        return {lines, width};\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, width = 1, 0\\n        for char in s:\\n            cur_width = widths[ord(char)-97]\\n            if width + cur_width <= 100:\\n                width += cur_width\\n            else:\\n                lines += 1\\n                width = cur_width\\n        return [lines, width]\\n```\n```Java []\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352377,
                "title": "number-of-lines-to-write-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int i=0, j, lines=1, width_sum=0;\\n        vector<int> arr;\\n        while(i<s.length())\\n        {\\n            j = s[i]-97;\\n            if((width_sum+widths[j])<=100)\\n            {\\n                width_sum += widths[j];\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                width_sum = 0;\\n            }\\n        }\\n        arr.push_back(lines);\\n        arr.push_back(width_sum);\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int i=0, j, lines=1, width_sum=0;\\n        vector<int> arr;\\n        while(i<s.length())\\n        {\\n            j = s[i]-97;\\n            if((width_sum+widths[j])<=100)\\n            {\\n                width_sum += widths[j];\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                width_sum = 0;\\n            }\\n        }\\n        arr.push_back(lines);\\n        arr.push_back(width_sum);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122306,
                "title": "java-solution-with-without-hash-maps-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        // Using hashmap :-\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//first we stored all the values of alphabets in hashmap;\\n        int line = 1 ; int sum = 0 ;\\n//integers that we will be using;\\n        for(int i = 0 ; i < str.length() ; i++){\\n            hm.put(str.charAt(i),widths[i]);\\n        }\\n//then we iterated in the string s to check if the sum is\\n//greater than 100 pixels we add a new line;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char t = s.charAt(i);\\n            if(sum+hm.get(t)<=100){\\n                sum=sum+hm.get(t);\\n            }else{\\n                line++;\\n                sum=hm.get(t);\\n            }\\n        }\\n//then we return the line and pixels in the last line ;\\n        return new int[]{line,sum};\\n        \\n        //without hashmap using arrays:-\\n        int line = 1 ; int sum = 0 ;\\n//here we have done the same thing but without using the hashmap\\n//here we will be using the given array widths to add in the sum ;\\n        for(int i = 0 ; i < s.length() ;i++){\\n            int temp = widths[s.charAt(i) - \\'a\\'];\\n            sum = sum + temp ;\\n            if(sum > 100){\\n                line++;\\n                sum = temp;\\n            }\\n        }\\n//then we return the line and pixels in the last line ;\\n        return new int[]{line,sum} ;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        // Using hashmap :-\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//first we stored all the values of alphabets in hashmap;\\n        int line = 1 ; int sum = 0 ;\\n//integers that we will be using;\\n        for(int i = 0 ; i < str.length() ; i++){\\n            hm.put(str.charAt(i),widths[i]);\\n        }\\n//then we iterated in the string s to check if the sum is\\n//greater than 100 pixels we add a new line;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char t = s.charAt(i);\\n            if(sum+hm.get(t)<=100){\\n                sum=sum+hm.get(t);\\n            }else{\\n                line++;\\n                sum=hm.get(t);\\n            }\\n        }\\n//then we return the line and pixels in the last line ;\\n        return new int[]{line,sum};\\n        \\n        //without hashmap using arrays:-\\n        int line = 1 ; int sum = 0 ;\\n//here we have done the same thing but without using the hashmap\\n//here we will be using the given array widths to add in the sum ;\\n        for(int i = 0 ; i < s.length() ;i++){\\n            int temp = widths[s.charAt(i) - \\'a\\'];\\n            sum = sum + temp ;\\n            if(sum > 100){\\n                line++;\\n                sum = temp;\\n            }\\n        }\\n//then we return the line and pixels in the last line ;\\n        return new int[]{line,sum} ;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078551,
                "title": "beats-99-76-solutions-easy-to-understand-o-n-tc-python-code-by-bolt-coding",
                "content": "# Explanation\\nAt first we are initializing pix to 0, min no of lines which will be there is always 1, i for keeping count of index, and a which is ascii of \\'a\\'.\\nWe are then iterating through the s - list of words. In case pix size is <= 100 we increment the pix, incase pix > 100 we increment the line number and initialize the pix back to 0. So now when the while loop ends but pix <= 100 it will print the pix of last line. This way we can print line number and pix in last line.\\n\\n# Complexity\\n- Time complexity: O(n) as we are using a single while loop to iterate over the list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) as we are using variables to keep track on number of lines and pixel size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, width: List[int], s: str) -> List[int]:\\n        pix = 0\\n        line = 1\\n        i = 0\\n        a = 97\\n        while i<len(s):\\n            if pix<=100:\\n                pix+=width[ord(s[i])-a]\\n                i+=1\\n                if pix>100:\\n                    line+=1\\n                    pix=0\\n                    i-=1\\n        return [line, pix]\\n\\n\\n\\n```\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, width: List[int], s: str) -> List[int]:\\n        pix = 0\\n        line = 1\\n        i = 0\\n        a = 97\\n        while i<len(s):\\n            if pix<=100:\\n                pix+=width[ord(s[i])-a]\\n                i+=1\\n                if pix>100:\\n                    line+=1\\n                    pix=0\\n                    i-=1\\n        return [line, pix]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890787,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int c=0,a=1;\\n        for(int i=0;i<s.length();i++){\\n            int ch=s[i]-\\'a\\';\\n            if((c+widths[ch])>100){\\n                c=widths[ch];\\n                a++; \\n            }\\n            else\\n            c+=widths[ch];\\n        }\\n        return {a,c};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int c=0,a=1;\\n        for(int i=0;i<s.length();i++){\\n            int ch=s[i]-\\'a\\';\\n            if((c+widths[ch])>100){\\n                c=widths[ch];\\n                a++; \\n            }\\n            else\\n            c+=widths[ch];\\n        }\\n        return {a,c};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776504,
                "title": "java-average-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646278,
                "title": "implementation-in-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int []ans=new int[2];\\n        int m=0,t;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            t=(int)s.charAt(i)-97;\\n          \\n            m+=widths[t];\\n            if(m>100)\\n            {\\n                ans[0]++;\\n                m=widths[t];\\n            }\\n        }\\n        ans[1]=m;\\n        ans[0]++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int []ans=new int[2];\\n        int m=0,t;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            t=(int)s.charAt(i)-97;\\n          \\n            m+=widths[t];\\n            if(m>100)\\n            {\\n                ans[0]++;\\n                m=widths[t];\\n            }\\n        }\\n        ans[1]=m;\\n        ans[0]++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548897,
                "title": "js-very-easy-solution-with-o-n-100",
                "content": "```\\nvar numberOfLines = function(widths, s) {\\n    let currentSumPixels = 0;\\n    const output = [1, 0];\\n    for (let i = 0; i < s.length; i++) {\\n        const indexOfChar = s.charCodeAt(i) - 97;\\n        currentSumPixels += widths[indexOfChar];\\n        if (currentSumPixels > 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n            i--;\\n        } else if (currentSumPixels === 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n        }\\n    }\\n    \\n    output[1] = currentSumPixels || 100;\\n    if (!currentSumPixels) output[0]--;\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfLines = function(widths, s) {\\n    let currentSumPixels = 0;\\n    const output = [1, 0];\\n    for (let i = 0; i < s.length; i++) {\\n        const indexOfChar = s.charCodeAt(i) - 97;\\n        currentSumPixels += widths[indexOfChar];\\n        if (currentSumPixels > 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n            i--;\\n        } else if (currentSumPixels === 100) {\\n            currentSumPixels = 0;\\n            output[0]++;\\n        }\\n    }\\n    \\n    output[1] = currentSumPixels || 100;\\n    if (!currentSumPixels) output[0]--;\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2441031,
                "title": "python-hash-table-fast-and-low-memory-usage-97-6",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        d = dict(zip([chr(i) for i in range(97, 123)], widths))\\n        lineNumber, lineWidth = 1, 0\\n        for _ in s:\\n            if lineWidth + d[_] <= 100: lineWidth += d[_]\\n            else:\\n                lineNumber += 1\\n                lineWidth = d[_]\\n        return [lineNumber, lineWidth]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        d = dict(zip([chr(i) for i in range(97, 123)], widths))\\n        lineNumber, lineWidth = 1, 0\\n        for _ in s:\\n            if lineWidth + d[_] <= 100: lineWidth += d[_]\\n            else:\\n                lineNumber += 1\\n                lineWidth = d[_]\\n        return [lineNumber, lineWidth]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208621,
                "title": "python3-runtime-42ms-67-78-memory-13-9mb-19-81",
                "content": "```\\nclass Solution:\\n#     Runtime: 42ms 67.78% Memory: 13.9mb 19.81%\\n# O(n) || O(1)\\n    def numberOfLines(self, widths, s):\\n        newLine = 1\\n        \\n        width = 0\\n        \\n        for char in s:\\n            charWidth = widths[ord(char) - ord(\\'a\\')]\\n            \\n            if charWidth + width > 100:\\n                newLine += 1\\n                width = 0\\n                \\n            width += charWidth\\n                \\n        return [newLine, width]  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     Runtime: 42ms 67.78% Memory: 13.9mb 19.81%\\n# O(n) || O(1)\\n    def numberOfLines(self, widths, s):\\n        newLine = 1\\n        \\n        width = 0\\n        \\n        for char in s:\\n            charWidth = widths[ord(char) - ord(\\'a\\')]\\n            \\n            if charWidth + width > 100:\\n                newLine += 1\\n                width = 0\\n                \\n            width += charWidth\\n                \\n        return [newLine, width]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054270,
                "title": "c-easy-solution-faster-than-100-o-n",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line_num=1, line_width=0, char_width;\\n        \\n        for (char i: s) {\\n            char_width = widths[(i-\\'a\\')];\\n            if ((line_width + char_width) > 100) {\\n\\t\\t\\t\\t// adding newline\\n                line_num++;\\n                line_width = 0;\\n            }\\n            \\n            line_width += char_width;\\n        }\\n        \\n        return {line_num, line_width}; // it will be automatically converted to vector\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line_num=1, line_width=0, char_width;\\n        \\n        for (char i: s) {\\n            char_width = widths[(i-\\'a\\')];\\n            if ((line_width + char_width) > 100) {\\n\\t\\t\\t\\t// adding newline\\n                line_num++;\\n                line_width = 0;\\n            }\\n            \\n            line_width += char_width;\\n        }\\n        \\n        return {line_num, line_width}; // it will be automatically converted to vector\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050841,
                "title": "javascript-solution-one-liner",
                "content": "```\\nconst numberOfLines = (widths, s) => s.split(\\'\\').reduce((res, c, i) => ([\\n    res[1] + widths[s.charCodeAt(i) - 97] > 100 ? res[0] + 1 : res[0],\\n    res[1] + widths[s.charCodeAt(i) - 97] > 100 ? widths[s.charCodeAt(i) - 97] : res[1] + widths[s.charCodeAt(i) - 97],\\n]), [1, 0]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numberOfLines = (widths, s) => s.split(\\'\\').reduce((res, c, i) => ([\\n    res[1] + widths[s.charCodeAt(i) - 97] > 100 ? res[0] + 1 : res[0],\\n    res[1] + widths[s.charCodeAt(i) - 97] > 100 ? widths[s.charCodeAt(i) - 97] : res[1] + widths[s.charCodeAt(i) - 97],\\n]), [1, 0]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028695,
                "title": "simple-solution-using-python",
                "content": "Runtime: 22 ms\\nMemory Usage: 13.9 MB\\n\\nCreate a dictionary where keys are a to z and values are their corresponding widths given in the problem. After that iterate through the string s and add value to the variable sum1 by taking values from the dictionary and while iterating if the sum1 + width of a string is less than equal to 100 then add the value of width in sum1 else make sum1 = 0 and increment the line. At the end return sum1 and line.\\nAny suggestions and feedbacks are welcome.\\n\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        dict1 = {}\\n        for i in range(97,123):\\n            dict1[chr(i)] = widths[i-97]\\n            \\n        sum1 = 0\\n        line = 1\\n        \\n        for i in range(len(s)):\\n            if sum1 + dict1[s[i]] <= 100:\\n                sum1+=dict1[s[i]]        \\n                \\n            else:\\n                sum1 = 0\\n                sum1+=dict1[s[i]]\\n                line+=1\\n                \\n        return [line,sum1]\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        dict1 = {}\\n        for i in range(97,123):\\n            dict1[chr(i)] = widths[i-97]\\n            \\n        sum1 = 0\\n        line = 1\\n        \\n        for i in range(len(s)):\\n            if sum1 + dict1[s[i]] <= 100:\\n                sum1+=dict1[s[i]]        \\n                \\n            else:\\n                sum1 = 0\\n                sum1+=dict1[s[i]]\\n                line+=1\\n                \\n        return [line,sum1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010889,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n    vector<int>result;\\n        int count=0,line=1;\\n        for(int i=0;i<s.size();i++){\\n           int z = widths[ s[i]-\\'a\\'];\\n            if(count+z>100){\\n               count =z;\\n                line++;\\n            }\\n            else {\\n                count= count+z;\\n            }     \\n        }\\n        result.push_back(line);\\n        result.push_back(count);\\n     return result;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n    vector<int>result;\\n        int count=0,line=1;\\n        for(int i=0;i<s.size();i++){\\n           int z = widths[ s[i]-\\'a\\'];\\n            if(count+z>100){\\n               count =z;\\n                line++;\\n            }\\n            else {\\n                count= count+z;\\n            }     \\n        }\\n        result.push_back(line);\\n        result.push_back(count);\\n     return result;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943586,
                "title": "java-0ms",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines =0;\\n        int sum=0;\\n        int [] res= new int[2];\\n     \\n         for ( int i=0; i<s.length(); i++){\\n             sum+=widths[s.charAt(i)-\\'a\\']  ;\\n             if(sum>100){\\n                 sum=0;\\n                 lines++;\\n                 i--;\\n             }\\n         }\\n           res[0]=++lines;  res[1]=sum;\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines =0;\\n        int sum=0;\\n        int [] res= new int[2];\\n     \\n         for ( int i=0; i<s.length(); i++){\\n             sum+=widths[s.charAt(i)-\\'a\\']  ;\\n             if(sum>100){\\n                 sum=0;\\n                 lines++;\\n                 i--;\\n             }\\n         }\\n           res[0]=++lines;  res[1]=sum;\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893289,
                "title": "python-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines = 1\\n        pix_per_line = 0\\n        for i in s:\\n            if widths[ord(i) - 97] + pix_per_line <= 100:\\n                pix_per_line += widths[ord(i) - 97]\\n            else:\\n                lines += 1\\n                pix_per_line = widths[ord(i) - 97]\\n        return [lines, pix_per_line]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines = 1\\n        pix_per_line = 0\\n        for i in s:\\n            if widths[ord(i) - 97] + pix_per_line <= 100:\\n                pix_per_line += widths[ord(i) - 97]\\n            else:\\n                lines += 1\\n                pix_per_line = widths[ord(i) - 97]\\n        return [lines, pix_per_line]",
                "codeTag": "Java"
            },
            {
                "id": 1845904,
                "title": "runtime-52-ms-faster-than-100-00-javascript",
                "content": "Runtime: 52 ms, faster than 100.00% of JavaScript online submissions for Number of Lines To Write String.\\nMemory Usage: 42.5 MB, less than 35.48% of JavaScript online submissions for Number of Lines To Write String.\\n\\n```\\nvar numberOfLines = function (widths, s) {\\n  let lines = 0;\\n  let lastLine = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    let wid = widths[s[i].charCodeAt(0) - 97];\\n\\n    if (lastLine + wid <= 100) {\\n      lastLine += wid;\\n    } else if (lastLine + wid > 100) {\\n      lastLine = wid;\\n      lines++;\\n    }\\n\\n    if (lastLine === 100 && i !== s.length - 1) {\\n      lines++;\\n      lastLine = 0;\\n    }\\n  }\\n  if (lastLine <= 100) lines++;\\n  return [lines, lastLine];\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/d5a2d549-eda5-4348-b686-293815a0c1e0_1647174487.6723025.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfLines = function (widths, s) {\\n  let lines = 0;\\n  let lastLine = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    let wid = widths[s[i].charCodeAt(0) - 97];\\n\\n    if (lastLine + wid <= 100) {\\n      lastLine += wid;\\n    } else if (lastLine + wid > 100) {\\n      lastLine = wid;\\n      lines++;\\n    }\\n\\n    if (lastLine === 100 && i !== s.length - 1) {\\n      lines++;\\n      lastLine = 0;\\n    }\\n  }\\n  if (lastLine <= 100) lines++;\\n  return [lines, lastLine];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840437,
                "title": "simple-c-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int countLine = 1;\\n        int countPixel = 0;\\n        int lastCount = 0;\\n        \\n        for(auto i:s) {\\n            if(countPixel+widths[i-\\'a\\'] <=100) {\\n                countPixel+= widths[i-\\'a\\'];\\n            } else {\\n                countPixel = widths[i-\\'a\\'];\\n                countLine++;\\n            }\\n            lastCount = countPixel;\\n        }\\n        \\n        return vector<int>({countLine, countPixel});\\n    }\\n};\\n```\\n\\nIf you like it do upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int countLine = 1;\\n        int countPixel = 0;\\n        int lastCount = 0;\\n        \\n        for(auto i:s) {\\n            if(countPixel+widths[i-\\'a\\'] <=100) {\\n                countPixel+= widths[i-\\'a\\'];\\n            } else {\\n                countPixel = widths[i-\\'a\\'];\\n                countLine++;\\n            }\\n            lastCount = countPixel;\\n        }\\n        \\n        return vector<int>({countLine, countPixel});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761065,
                "title": "simple-c-solution-0ms-100-less-space",
                "content": "Please upvote if you like the code. It is always a great motivation to write more :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) \\n    {\\n        int line = 1, currentLine = 0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(currentLine + widths[s[i]-\\'a\\'] > 100)\\n            {\\n                line++;\\n                currentLine = widths[s[i]-\\'a\\'];\\n            }\\n            else\\n                currentLine += widths[s[i]-\\'a\\'];\\n        }\\n        \\n        vector<int> res;\\n        \\n        res.push_back(line);\\n        res.push_back(currentLine);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) \\n    {\\n        int line = 1, currentLine = 0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(currentLine + widths[s[i]-\\'a\\'] > 100)\\n            {\\n                line++;\\n                currentLine = widths[s[i]-\\'a\\'];\\n            }\\n            else\\n                currentLine += widths[s[i]-\\'a\\'];\\n        }\\n        \\n        vector<int> res;\\n        \\n        res.push_back(line);\\n        res.push_back(currentLine);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723043,
                "title": "python-solution-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 24ms   -   97.63%\\n#   Memory: 13.8MB  -   99.57%\\n\\n######################################################\\n\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        # lines[0] will store how many lines are there\\n        # lines[1] will store pixels valus of last line\\n        lines = [0, 0]\\n        # Stores pixel value of each line\\n        pixels = 0\\n        \\n        for char in s:\\n            # If adding char to current line exceeds the max pixel length which\\n            # is 100, we go to next line, so we increase lines[0] by 1\\n            # In next line we write the current char, so pixels will be \\n            # reinitialized with the pixel width of cuurent char\\n            if widths[ord(char) - 97] + pixels > 100:\\n                lines[0] += 1\\n                pixels = widths[ord(char) - 97]\\n            # Else, we add current char to current line and increase the pixels\\n            # to pixels + width of current char\\n            else:\\n                pixels += widths[ord(char) - 97]\\n        # After loop ends we haven\\'t added last line. So we increase lines[0] by\\n        # 1 and pixels will have pixel value of last line. So we store it in \\n        # lines[1]\\n        lines[0] += 1\\n        lines[1] = pixels\\n        return lines\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 24ms   -   97.63%\\n#   Memory: 13.8MB  -   99.57%\\n\\n######################################################\\n\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        # lines[0] will store how many lines are there\\n        # lines[1] will store pixels valus of last line\\n        lines = [0, 0]\\n        # Stores pixel value of each line\\n        pixels = 0\\n        \\n        for char in s:\\n            # If adding char to current line exceeds the max pixel length which\\n            # is 100, we go to next line, so we increase lines[0] by 1\\n            # In next line we write the current char, so pixels will be \\n            # reinitialized with the pixel width of cuurent char\\n            if widths[ord(char) - 97] + pixels > 100:\\n                lines[0] += 1\\n                pixels = widths[ord(char) - 97]\\n            # Else, we add current char to current line and increase the pixels\\n            # to pixels + width of current char\\n            else:\\n                pixels += widths[ord(char) - 97]\\n        # After loop ends we haven\\'t added last line. So we increase lines[0] by\\n        # 1 and pixels will have pixel value of last line. So we store it in \\n        # lines[1]\\n        lines[0] += 1\\n        lines[1] = pixels\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597740,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        let (mut num_lines, mut last_line) = (0, 0);\\n        for width in s.as_bytes().iter().map(|b| widths[(*b - b\\'a\\') as usize]) {\\n            last_line += width;\\n            if last_line > 100 {\\n                last_line = width;\\n                num_lines += 1;\\n            }\\n        }\\n        vec![num_lines + 1, last_line]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        let (mut num_lines, mut last_line) = (0, 0);\\n        for width in s.as_bytes().iter().map(|b| widths[(*b - b\\'a\\') as usize]) {\\n            last_line += width;\\n            if last_line > 100 {\\n                last_line = width;\\n                num_lines += 1;\\n            }\\n        }\\n        vec![num_lines + 1, last_line]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1586834,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int line=0;\\n        int pix=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i)-97;\\n            pix=pix+widths[a];\\n            if(pix==100)\\n            {\\n                line++;\\n                if(i!=s.length()-1)\\n                {\\n                    pix=0;\\n                }\\n            }\\n            else if(pix>100)\\n            {\\n                i--;\\n                line++;\\n                pix=0;\\n            }\\n        }\\n        if(pix>0 && pix!=100)\\n        {\\n            line++;\\n        }\\n        int[] result=new int[2];\\n        result[0]=line;\\n        result[1]=pix;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int line=0;\\n        int pix=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=s.charAt(i)-97;\\n            pix=pix+widths[a];\\n            if(pix==100)\\n            {\\n                line++;\\n                if(i!=s.length()-1)\\n                {\\n                    pix=0;\\n                }\\n            }\\n            else if(pix>100)\\n            {\\n                i--;\\n                line++;\\n                pix=0;\\n            }\\n        }\\n        if(pix>0 && pix!=100)\\n        {\\n            line++;\\n        }\\n        int[] result=new int[2];\\n        result[0]=line;\\n        result[1]=pix;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584954,
                "title": "python-easy-solution",
                "content": "Here we start from x=1 since it represents first line .\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        l=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\\n        \\n        x=1\\n        s1=0\\n        for i in s:\\n            a=l.index(i)\\n            if(s1+widths[a]>100):\\n                s1=widths[a]\\n                x+=1\\n            else:\\n                s1=s1+widths[a]\\n        return([x,s1])\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        l=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\\n        \\n        x=1\\n        s1=0\\n        for i in s:\\n            a=l.index(i)\\n            if(s1+widths[a]>100):\\n                s1=widths[a]\\n                x+=1\\n            else:\\n                s1=s1+widths[a]\\n        return([x,s1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462559,
                "title": "javascript-solution-easy",
                "content": "\\nvar numberOfLines = function(arr, s) {\\n\\n    var res =  [];\\n    \\n    let line = 1;\\n    let last = 0;\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const temp = arr[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        if(last + temp > 100){\\n            line++;\\n            last = 0;\\n            last = temp;\\n        }else{\\n            last += temp;\\n        }\\n    }\\n    \\n    res.push(line);   \\n    res.push(last);\\n\\n    return res;\\n};",
                "solutionTags": [],
                "code": "\\nvar numberOfLines = function(arr, s) {\\n\\n    var res =  [];\\n    \\n    let line = 1;\\n    let last = 0;\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const temp = arr[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n        if(last + temp > 100){\\n            line++;\\n            last = 0;\\n            last = temp;\\n        }else{\\n            last += temp;\\n        }\\n    }\\n    \\n    res.push(line);   \\n    res.push(last);\\n\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1462515,
                "title": "java-1ms-easy-code",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int line = 0;\\n        int countline = 1;\\n        for(int i=0; i<s.length(); i++){\\n            int ch = s.charAt(i);\\n            int f = widths[ch - \\'a\\'];\\n            //System.out.println(ch);\\n            if((line+f)<=100){\\n                line += f;\\n            }\\n            else{\\n                countline++;\\n                line = 0;\\n                i--;\\n            }\\n        }\\n        \\n        ans[0] = countline;\\n        ans[1] = line;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int line = 0;\\n        int countline = 1;\\n        for(int i=0; i<s.length(); i++){\\n            int ch = s.charAt(i);\\n            int f = widths[ch - \\'a\\'];\\n            //System.out.println(ch);\\n            if((line+f)<=100){\\n                line += f;\\n            }\\n            else{\\n                countline++;\\n                line = 0;\\n                i--;\\n            }\\n        }\\n        \\n        ans[0] = countline;\\n        ans[1] = line;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393626,
                "title": "java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int count=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int curr=(int)s.charAt(i)-97;\\n            int val=widths[curr];\\n            if(sum+val>100)\\n            {\\n                count++;\\n                sum=val;\\n            }\\n            else\\n            {\\n                sum=sum+val;\\n            }\\n        }\\n        int ret[]={count+1,sum};\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int count=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int curr=(int)s.charAt(i)-97;\\n            int val=widths[curr];\\n            if(sum+val>100)\\n            {\\n                count++;\\n                sum=val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1385970,
                "title": "python3-fast-using-ord",
                "content": "\\n\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, tmp = 1, 0\\n        for c in s:\\n            if tmp + widths[ord(c)-97] > 100:\\n                lines += 1\\n                tmp = 0\\n                \\n            tmp += widths[ord(c)-97]\\n        \\n        return [lines, tmp]",
                "solutionTags": [],
                "code": "\\n\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, tmp = 1, 0\\n        for c in s:\\n            if tmp + widths[ord(c)-97] > 100:\\n                lines += 1\\n                tmp = 0\\n                \\n            tmp += widths[ord(c)-97]\\n        \\n        return [lines, tmp]",
                "codeTag": "Java"
            },
            {
                "id": 1372343,
                "title": "py-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines=0\\n        width=0\\n        for i in s:\\n            if(width+widths[ord(i)-97]<=100):\\n                width+=widths[ord(i)-97]\\n            else:\\n                width=0\\n                width+=widths[ord(i)-97]\\n                lines+=1\\n        return [lines,width] if width==0 else [lines+1,width]\\n        \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines=0\\n        width=0\\n        for i in s:\\n            if(width+widths[ord(i)-97]<=100):\\n                width+=widths[ord(i)-97]\\n            else:\\n                width=0\\n                width+=widths[ord(i)-97]\\n                lines+=1\\n        return [lines,width] if width==0 else [lines+1,width]\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338444,
                "title": "c-solution-faster-than-90",
                "content": "```\\npublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        var line = 0;\\n        var last = 0;\\n        var c = 0;\\n        foreach(var n in s.Select(x=>widths[(int)x-(int)\\'a\\'])){\\n            if(c+n>100){\\n                last = c;\\n                line++;\\n                c = n;\\n            }else{\\n                c += n;\\n            }\\n        }\\n        if(c>0) line++;\\n        last = c;\\n        return new int[]{line, last};\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        var line = 0;\\n        var last = 0;\\n        var c = 0;\\n        foreach(var n in s.Select(x=>widths[(int)x-(int)\\'a\\'])){\\n            if(c+n>100){\\n                last = c;\\n                line++;\\n                c = n;\\n            }else{\\n                c += n;\\n            }\\n        }\\n        if(c>0) line++;\\n        last = c;\\n        return new int[]{line, last};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329517,
                "title": "c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int length=0,line=1;\\n        for(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t\\t// If adding the length of the next letter results in a line width greater than 100, move to new line and \\n\\t\\t\\t// reinitialize the value of length to the length of that letter\\n            if(length+widths[s[i]-\\'a\\']>100){\\n                length=widths[s[i]-\\'a\\'];\\n                line++;\\n            }   \\n\\t\\t\\t\\n\\t\\t\\t// If that is ot the case, simply add the length of that letter and move ahead\\n            else\\n                length+=widths[s[i]-\\'a\\'];\\n        }\\n        return {line,length};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int length=0,line=1;\\n        for(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t\\t// If adding the length of the next letter results in a line width greater than 100, move to new line and \\n\\t\\t\\t// reinitialize the value of length to the length of that letter\\n            if(length+widths[s[i]-\\'a\\']>100){\\n                length=widths[s[i]-\\'a\\'];\\n                line++;\\n            }   \\n\\t\\t\\t\\n\\t\\t\\t// If that is ot the case, simply add the length of that letter and move ahead\\n            else\\n                length+=widths[s[i]-\\'a\\'];\\n        }\\n        return {line,length};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328427,
                "title": "python3-olution",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        su, c = 0, 1\\n        for i in s:\\n            x = widths[ord(i)-97]\\n            su += x\\n            if su > 100:\\n                su = x\\n                c += 1\\n        return [c,su]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        su, c = 0, 1\\n        for i in s:\\n            x = widths[ord(i)-97]\\n            su += x\\n            if su > 100:\\n                su = x\\n                c += 1\\n        return [c,su]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327430,
                "title": "python3-another-thinking-by-dict",
                "content": "\\n\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        mapping = dict(zip(alpha,widths))\\n        \\n        sum_score = 0\\n        count = 1\\n        for i in range(len(s)):\\n            if (sum_score+mapping[s[i]] <= 100):\\n                sum_score += mapping[s[i]]\\n            else :\\n                sum_score = mapping[s[i]]\\n                count += 1\\n                \\n        return [count,sum_score]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        mapping = dict(zip(alpha,widths))\\n        \\n        sum_score = 0\\n        count = 1\\n        for i in range(len(s)):\\n            if (sum_score+mapping[s[i]] <= 100):\\n                sum_score += mapping[s[i]]\\n            else :\\n                sum_score = mapping[s[i]]\\n                count += 1\\n                \\n        return [count,sum_score]",
                "codeTag": "Unknown"
            },
            {
                "id": 1280955,
                "title": "c-solution-faster-than-100-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> output;\\n        \\n        int i,sum=0,count=1;\\n        int len=s.length();\\n        \\n        for(i=0;i<len;i++){            \\n            // index=s[i]-97;\\n            sum=sum+widths[s[i]-97];\\n            if(sum>100){\\n                count++;\\n                sum=0;\\n                i--;\\n            }\\n            \\n        }\\n        \\n        \\n        output.push_back(count);\\n        output.push_back(sum);\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> output;\\n        \\n        int i,sum=0,count=1;\\n        int len=s.length();\\n        \\n        for(i=0;i<len;i++){            \\n            // index=s[i]-97;\\n            sum=sum+widths[s[i]-97];\\n            if(sum>100){\\n                count++;\\n                sum=0;\\n                i--;\\n            }\\n            \\n        }\\n        \\n        \\n        output.push_back(count);\\n        output.push_back(sum);\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274202,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n      let s = s.bytes().map(|x| (x - 97) as usize).collect::<Vec<usize>>();\\n      let (mut lines, mut width) = (1,0);\\n      for index in s {\\n          let w = widths[index];\\n          width+=w;\\n          if width > 100 {\\n              lines+=1;\\n              width=w;\\n          }\\n      }\\n      vec![lines,width as i32]  \\n    }\\n}\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n      let s = s.bytes().map(|x| (x - 97) as usize).collect::<Vec<usize>>();\\n      let (mut lines, mut width) = (1,0);\\n      for index in s {\\n          let w = widths[index];\\n          width+=w;\\n          if width > 100 {\\n              lines+=1;\\n              width=w;\\n          }\\n      }\\n      vec![lines,width as i32]  \\n    }\\n}\\n\\t\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215203,
                "title": "python-3-89-simple-solution",
                "content": "\\t\\n\\tclass Solution:\\n\\t\\tdef numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n\\t\\t\\tdict1 = dict(zip(string.ascii_lowercase, widths))\\n\\t\\t\\tline, pixel = 1, 0\\n\\t\\t\\tfor x in s:\\n\\t\\t\\t\\tif pixel + dict1[x] <= 100:\\n\\t\\t\\t\\t\\tpixel += dict1[x] \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tline += 1\\n\\t\\t\\t\\t\\tpixel = 0\\n\\t\\t\\t\\t\\tpixel += dict1[x]  \\n\\t\\t\\treturn [line, pixel]\\n",
                "solutionTags": [],
                "code": "\\t\\n\\tclass Solution:\\n\\t\\tdef numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n\\t\\t\\tdict1 = dict(zip(string.ascii_lowercase, widths))\\n\\t\\t\\tline, pixel = 1, 0\\n\\t\\t\\tfor x in s:\\n\\t\\t\\t\\tif pixel + dict1[x] <= 100:\\n\\t\\t\\t\\t\\tpixel += dict1[x] \\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tline += 1\\n\\t\\t\\t\\t\\tpixel = 0\\n\\t\\t\\t\\t\\tpixel += dict1[x]  \\n\\t\\t\\treturn [line, pixel]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1066236,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        count, sum = 1, 0\\n        for i in s:\\n            a = widths[ord(i) - 97]\\n            sum += a\\n            if sum > 100:\\n                count += 1\\n                sum = a\\n        return [count, sum]\\n```\\n**If you like the solution, please vote for this.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        count, sum = 1, 0\\n        for i in s:\\n            a = widths[ord(i) - 97]\\n            sum += a\\n            if sum > 100:\\n                count += 1\\n                sum = a\\n        return [count, sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060826,
                "title": "java-ez-pz",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int lines=1;\\n        int value=0;\\n        int hun=0;\\n        for(char ch : s.toCharArray()){\\n            value = widths[ch - \\'a\\'];\\n            if(hun+value <=100){\\n                hun+=value;\\n            }\\n            else{\\n                lines++;\\n                hun = value;\\n            }\\n        }\\n        ans[0]= lines;\\n        ans[1]= hun;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int lines=1;\\n        int value=0;\\n        int hun=0;\\n        for(char ch : s.toCharArray()){\\n            value = widths[ch - \\'a\\'];\\n            if(hun+value <=100){\\n                hun+=value;\\n            }\\n            else{\\n                lines++;\\n                hun = value;\\n            }\\n        }\\n        ans[0]= lines;\\n        ans[1]= hun;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036378,
                "title": "c-beats-100-well-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line=1, sum=0; //Prepare the return variables\\n        for(char c:s) //Scan through each char of the string\\n        {\\n            sum+=widths[c-\\'a\\']; //Add the corresponding pixel width to the sum\\n            if(sum>100) sum=widths[c-\\'a\\'], line++;  //If sum is greater than 100, update the sum and line   \\n        }\\n        return {line, sum};\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line=1, sum=0; //Prepare the return variables\\n        for(char c:s) //Scan through each char of the string\\n        {\\n            sum+=widths[c-\\'a\\']; //Add the corresponding pixel width to the sum\\n            if(sum>100) sum=widths[c-\\'a\\'], line++;  //If sum is greater than 100, update the sum and line   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1029632,
                "title": "java-easy-solution-100-faster-clean-code",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        \\n        int lines=0;\\n        int pixels=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            pixels+=widths[s.charAt(i)-97];\\n            if(pixels>100)\\n            {\\n                lines++;\\n                i--;\\n                pixels=0;\\n            }\\n        }\\n        return new int[]{lines+1,pixels};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        \\n        int lines=0;\\n        int pixels=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            pixels+=widths[s.charAt(i)-97];\\n            if(pixels>100)\\n            {\\n                lines++;\\n                i--;\\n                pixels=0;\\n            }\\n        }\\n        return new int[]{lines+1,pixels};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018264,
                "title": "python-solution",
                "content": "\\tresult = [1, 0]\\n\\tfor c in s:\\n\\t\\tw = widths[ord(c) - ord(\\'a\\')]\\n\\t\\tif result[1] + w <= 100:\\n\\t\\t\\tresult[1] += w\\n\\t\\telse:\\n\\t\\t\\tresult[0] += 1\\n\\t\\t\\tresult[1] = w\\n\\treturn result",
                "solutionTags": [],
                "code": "\\tresult = [1, 0]\\n\\tfor c in s:\\n\\t\\tw = widths[ord(c) - ord(\\'a\\')]\\n\\t\\tif result[1] + w <= 100:\\n\\t\\t\\tresult[1] += w\\n\\t\\telse:\\n\\t\\t\\tresult[0] += 1\\n\\t\\t\\tresult[1] = w\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 876377,
                "title": "python-beats-95",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str):\\n        lines = 1\\n        curline = 0\\n        \\n        for i in S:\\n            x = widths[ord(i)-ord(\\'a\\')]\\n            if curline+x <= 100:\\n                curline += x\\n            else:\\n                lines += 1\\n                curline = x\\n                \\n        return [lines, curline]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str):\\n        lines = 1\\n        curline = 0\\n        \\n        for i in S:\\n            x = widths[ord(i)-ord(\\'a\\')]\\n            if curline+x <= 100:\\n                curline += x\\n            else:\\n                lines += 1\\n                curline = x\\n                \\n        return [lines, curline]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868393,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    private static final int MAX_UNITS_PER_LINE = 100;\\n    \\n    public int[] numberOfLines(int[] widths, String S) {\\n        int lineCount = 1;\\n        int lastLineUnitCount = 0;\\n        \\n        for(int i = 0; i < S.length(); i++) {\\n            int val = widths[S.charAt(i) - \\'a\\'];\\n            lastLineUnitCount += val;\\n            if(lastLineUnitCount > MAX_UNITS_PER_LINE) {\\n                lineCount++;\\n                lastLineUnitCount = val;\\n            }\\n        }\\n        \\n        return new int[] {lineCount, lastLineUnitCount};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MAX_UNITS_PER_LINE = 100;\\n    \\n    public int[] numberOfLines(int[] widths, String S) {\\n        int lineCount = 1;\\n        int lastLineUnitCount = 0;\\n        \\n        for(int i = 0; i < S.length(); i++) {\\n            int val = widths[S.charAt(i) - \\'a\\'];\\n            lastLineUnitCount += val;\\n            if(lastLineUnitCount > MAX_UNITS_PER_LINE) {\\n                lineCount++;\\n                lastLineUnitCount = val;\\n            }\\n        }\\n        \\n        return new int[] {lineCount, lastLineUnitCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843801,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int l = 1, w = 0;\\n\\n        for (char s : S) {\\n            int t = widths[s - \\'a\\'];\\n            \\n            if (t <= 100 - w)\\n                w += t;\\n            else {\\n                ++l;\\n                w = t;\\n            }\\n        }\\n\\n        return {l,w};\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n    def numberOfLines(self, widths, S):\\n        l, w = 1, 0\\n\\n        for s in S:\\n            t = widths[ord(s) - ord(\\'a\\')]\\n            \\n            if t <= 100 - w:\\n                w += t\\n            else:\\n                l += 1\\n                w = t\\n\\n        return [l,w]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int l = 1, w = 0;\\n\\n        for (char s : S) {\\n            int t = widths[s - \\'a\\'];\\n            \\n            if (t <= 100 - w)\\n                w += t;\\n            else {\\n                ++l;\\n                w = t;\\n            }\\n        }\\n\\n        return {l,w};\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numberOfLines(self, widths, S):\\n        l, w = 1, 0\\n\\n        for s in S:\\n            t = widths[ord(s) - ord(\\'a\\')]\\n            \\n            if t <= 100 - w:\\n                w += t\\n            else:\\n                l += 1\\n                w = t\\n\\n        return [l,w]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599733,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n        int lines=1,lastLine=0,temp=0;\\n        for(int i=0;i<S.length();i++)\\n        {\\n            int width=widths[S.charAt(i)-\\'a\\'];\\n            temp+=width;\\n            if(temp<100)\\n            {\\n                lastLine=temp;\\n            }\\n            else if(temp==100)\\n            {\\n                lines++;\\n                temp=0;\\n                lastLine=0;\\n            }\\n            else\\n            {\\n                lines++;\\n                temp=0;\\n                temp+=width;\\n                lastLine=temp;\\n            }\\n        }\\n        \\n        int[] out=new int[2];\\n        out[0]=lines;out[1]=lastLine;\\n     \\n    return out;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n        int lines=1,lastLine=0,temp=0;\\n        for(int i=0;i<S.length();i++)\\n        {\\n            int width=widths[S.charAt(i)-\\'a\\'];\\n            temp+=width;\\n            if(temp<100)\\n            {\\n                lastLine=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 549219,
                "title": "rust-functional-solution",
                "content": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        if s.len() == 0 {\\n            return vec![0, 0];\\n        }\\n        \\n        let (line, acc) = s\\n            .chars()\\n            .map(|chr| alpha_index(chr))\\n            .map(|chr_ind| widths[chr_ind])\\n            .fold((1, 0), |(line, acc), cur| {\\n                if acc + cur > 100 {\\n                    (line + 1, cur)\\n                } else {\\n                    (line, acc + cur)\\n                }\\n            });\\n\\n        vec![line, acc]\\n    }\\n}\\n\\nfn alpha_index(chr: char) -> usize {\\n    if chr >= \\'a\\' && chr <= \\'z\\' {\\n        (chr as usize) - (\\'a\\' as usize)\\n    } else {\\n        panic!(\"unsupported character\")\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        if s.len() == 0 {\\n            return vec![0, 0];\\n        }\\n        \\n        let (line, acc) = s\\n            .chars()\\n            .map(|chr| alpha_index(chr))\\n            .map(|chr_ind| widths[chr_ind])\\n            .fold((1, 0), |(line, acc), cur| {\\n                if acc + cur > 100 {\\n                    (line + 1, cur)\\n                } else {\\n                    (line, acc + cur)\\n                }\\n            });\\n\\n        vec![line, acc]\\n    }\\n}\\n\\nfn alpha_index(chr: char) -> usize {\\n    if chr >= \\'a\\' && chr <= \\'z\\' {\\n        (chr as usize) - (\\'a\\' as usize)\\n    } else {\\n        panic!(\"unsupported character\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541927,
                "title": "javascript-solution-with-explanation",
                "content": "Totally forgot charCodeAt was a thing, so here\\'s how I did it:\\n```\\nvar numberOfLines = function(widths, S) {\\n\\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\")\\n    let lines = 1;\\n    \\n    let lineWidth = 0;\\n    S.split(\"\").forEach(char => {\\n        let charWidth = widths[alphabet.indexOf(char)]\\n        \\n        if(lineWidth + charWidth <= 100){\\n            lineWidth += charWidth\\n        } else {\\n            lines++\\n            lineWidth = charWidth\\n        }\\n    })\\n    \\n    return [lines,lineWidth]\\n};\\n```\\n\\nUsing the alphabet array, we get an array of letters. The indexes of these letters match up with those in widths. To access that index in widths, we just get the index of what the letter is in alphabet. For example, F is the fifth index of alphabet (index 4). To get its width, we would do widths[4] to see its width.\\n\\nFrom there we have lineWidth, which starts off as zero. For every character in string, we get its width via the method above and see if adding this width to lineWidth would exceed 100. If it doesn\\'t, we just add the character\\'s width to lineWidth. This means lineWidth will successively grow larger until it comes across a character whose width would cause it to exceed 100. \\n\\nWhen that happens, we add 1 to lines (keeps track of how many lines needed), and reset lineWidth to the width of the current character since we are starting a new line. When we\\'re done going through all the characters, lineWidth will be some amount. Be sure to return it along with the total number of lines.\\n",
                "solutionTags": [],
                "code": "```\\nvar numberOfLines = function(widths, S) {\\n\\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".split(\"\")\\n    let lines = 1;\\n    \\n    let lineWidth = 0;\\n    S.split(\"\").forEach(char => {\\n        let charWidth = widths[alphabet.indexOf(char)]\\n        \\n        if(lineWidth + charWidth <= 100){\\n            lineWidth += charWidth\\n        } else {\\n            lines++\\n            lineWidth = charWidth\\n        }\\n    })\\n    \\n    return [lines,lineWidth]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523351,
                "title": "straight-forward-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int countLines = 1, countWidth = 0;\\n        if (S == \"\") {\\n            return new int[]{0, 0};\\n        }\\n        char[] chars = S.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            int w = widths[chars[i]-\\'a\\'];\\n            countWidth += w;\\n            if (countWidth > 100) {\\n                countWidth = w;\\n                countLines++;\\n            }\\n        }\\n        return new int[]{countLines, countWidth};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int countLines = 1, countWidth = 0;\\n        if (S == \"\") {\\n            return new int[]{0, 0};\\n        }\\n        char[] chars = S.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            int w = widths[chars[i]-\\'a\\'];\\n            countWidth += w;\\n            if (countWidth > 100) {\\n                countWidth = w;\\n                countLines++;\\n            }\\n        }\\n        return new int[]{countLines, countWidth};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460478,
                "title": "100-javascript-solution",
                "content": "```\\nvar numberOfLines = function (widths, S) {\\n  let _S = S.split(\"\");\\n  let sum = 0, lines = 0;\\n  for (let i = 0; i < _S.length; i++){\\n    sum += widths[_S[i].charCodeAt(0) - 97];\\n    if (sum === 100) {\\n      sum = 0;\\n      lines++;\\n    } else if (sum > 100) {\\n      sum = 0;\\n      lines++;\\n      i--;\\n    }\\n  }\\n  if (sum === 100) {\\n    return [lines, sum]\\n  }\\n  return [lines+1, sum];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfLines = function (widths, S) {\\n  let _S = S.split(\"\");\\n  let sum = 0, lines = 0;\\n  for (let i = 0; i < _S.length; i++){\\n    sum += widths[_S[i].charCodeAt(0) - 97];\\n    if (sum === 100) {\\n      sum = 0;\\n      lines++;\\n    } else if (sum > 100) {\\n      sum = 0;\\n      lines++;\\n      i--;\\n    }\\n  }\\n  if (sum === 100) {\\n    return [lines, sum]\\n  }\\n  return [lines+1, sum];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434774,
                "title": "java-simple-solution-faster-than-100",
                "content": "```\\npublic int[] numberOfLines(int[] widths, String S) {\\n\\tint lineWidth = 0, lines = 1;\\n\\tfor(char c:S.toCharArray()) {\\n\\t\\tint letterWidth = widths[c-\\'a\\'];\\n\\t\\tif(lineWidth + letterWidth <= 100) {\\n\\t\\t\\tlineWidth += letterWidth;\\n\\t\\t} else {\\n\\t\\t\\tlineWidth = letterWidth;\\n\\t\\t\\tlines++;\\n\\t\\t}\\n\\t}\\n\\tint sol[] = {lines, lineWidth};\\n\\treturn sol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] numberOfLines(int[] widths, String S) {\\n\\tint lineWidth = 0, lines = 1;\\n\\tfor(char c:S.toCharArray()) {\\n\\t\\tint letterWidth = widths[c-\\'a\\'];\\n\\t\\tif(lineWidth + letterWidth <= 100) {\\n\\t\\t\\tlineWidth += letterWidth;\\n\\t\\t} else {\\n\\t\\t\\tlineWidth = letterWidth;\\n\\t\\t\\tlines++;\\n\\t\\t}\\n\\t}\\n\\tint sol[] = {lines, lineWidth};\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396131,
                "title": "easy-python-using-dict-or-ord",
                "content": "Please note the single comment with the ord() function that could replace the alphabet dictionary. ord(\\'a\\') is 97.\\n```\\n        alphabet = {\\'a\\': 0, \\'b\\': 1, \\'c\\': 2, \\'d\\': 3, \\'e\\': 4, \\'f\\': 5, \\'g\\': 6, \\'h\\': 7, \\'i\\': 8, \\'j\\': 9, \\'k\\': 10, \\'l\\': 11, \\'m\\': 12, \\'n\\': 13, \\'o\\': 14, \\'p\\': 15, \\'q\\': 16, \\'r\\': 17, \\'s\\': 18, \\'t\\': 19, \\'u\\': 20, \\'v\\': 21, \\'w\\': 22, \\'x\\': 23, \\'y\\': 24, \\'z\\': 25}\\n        count, total = 1, 0\\n        for char in S:\\n            value = widths[alphabet[char]]\\n            # could also use value = widths[ord(char)-97]\\n            if total + value <= 100:\\n                total += value\\n            else:\\n                count += 1\\n                total = value\\n        return [count, total]\\n```",
                "solutionTags": [],
                "code": "```\\n        alphabet = {\\'a\\': 0, \\'b\\': 1, \\'c\\': 2, \\'d\\': 3, \\'e\\': 4, \\'f\\': 5, \\'g\\': 6, \\'h\\': 7, \\'i\\': 8, \\'j\\': 9, \\'k\\': 10, \\'l\\': 11, \\'m\\': 12, \\'n\\': 13, \\'o\\': 14, \\'p\\': 15, \\'q\\': 16, \\'r\\': 17, \\'s\\': 18, \\'t\\': 19, \\'u\\': 20, \\'v\\': 21, \\'w\\': 22, \\'x\\': 23, \\'y\\': 24, \\'z\\': 25}\\n        count, total = 1, 0\\n        for char in S:\\n            value = widths[alphabet[char]]\\n            # could also use value = widths[ord(char)-97]\\n            if total + value <= 100:\\n                total += value\\n            else:\\n                count += 1\\n                total = value\\n        return [count, total]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322718,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int lines =0;\\n        int last_line_size=0;\\n        static const int LEN = 100;\\n       for(int i=0,n=S.size();i<n;++i)\\n       {\\n           char c = S[i];\\n           int len = widths[c-\\'a\\'];\\n\\t\\t   //write on current line \\n           if(LEN-last_line_size >= len)\\n           {\\n              last_line_size+= len;\\n           }else  //move to next line\\n           {\\n               ++lines;\\n               last_line_size= len;\\n           }\\n       }\\n        return {lines+1,last_line_size};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int lines =0;\\n        int last_line_size=0;\\n        static const int LEN = 100;\\n       for(int i=0,n=S.size();i<n;++i)\\n       {\\n           char c = S[i];\\n           int len = widths[c-\\'a\\'];\\n\\t\\t   //write on current line \\n           if(LEN-last_line_size >= len)\\n           {\\n              last_line_size+= len;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 280849,
                "title": "easy-to-understand-python-solution-36ms-only",
                "content": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        dic={}\\n        for i,j in zip(string.ascii_lowercase,widths):\\n            dic[i]=j\\n        sumd=0\\n        line=1\\n        line_dic={}\\n        for i in S:\\n            if(sumd+dic[i]>100):\\n                line_dic[line]=sumd\\n                line+=1\\n                sumd=0                \\n            sumd+=dic[i]\\n        line_dic[line]=sumd\\n        return [line,line_dic[line]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], S: str) -> List[int]:\\n        dic={}\\n        for i,j in zip(string.ascii_lowercase,widths):\\n            dic[i]=j\\n        sumd=0\\n        line=1\\n        line_dic={}\\n        for i in S:\\n            if(sumd+dic[i]>100):\\n                line_dic[line]=sumd\\n                line+=1\\n                sumd=0                \\n            sumd+=dic[i]\\n        line_dic[line]=sumd\\n        return [line,line_dic[line]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244713,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int line=1,unit=0;\\n        for(auto c:S)\\n        {\\n            unit+=widths[c-\\'a\\'];\\n            if(unit>100)\\n            {\\n                unit=widths[c-\\'a\\'];\\n                line++;\\n            }\\n        }\\n        vector<int> res;\\n        res.push_back(line);\\n        res.push_back(unit);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n        int line=1,unit=0;\\n        for(auto c:S)\\n        {\\n            unit+=widths[c-\\'a\\'];\\n            if(unit>100)\\n            {\\n                unit=widths[c-\\'a\\'];\\n                line++;\\n            }\\n        }\\n        vector<int> res;\\n        res.push_back(line);\\n        res.push_back(unit);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211157,
                "title": "c-solution",
                "content": "```\\nint *numberOfLines(int *widths, int widthsSize, char *S, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = 2));\\n    int lines = 1, remain = 0;\\n    char *p = S;\\n    while (*p != \\'\\\\0\\') {\\n        int width = widths[*p - \\'a\\'];\\n        if (remain + width > 100) {\\n            lines++;\\n            remain = width;\\n        } else if (remain + width == 100) {\\n            lines++;\\n            remain = 0;\\n        } else {\\n            remain += width;\\n        }\\n        p++;\\n    }\\n    result[0] = lines;\\n    result[1] = remain;\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint *numberOfLines(int *widths, int widthsSize, char *S, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = 2));\\n    int lines = 1, remain = 0;\\n    char *p = S;\\n    while (*p != \\'\\\\0\\') {\\n        int width = widths[*p - \\'a\\'];\\n        if (remain + width > 100) {\\n            lines++;\\n            remain = width;\\n        } else if (remain + width == 100) {\\n            lines++;\\n            remain = 0;\\n        } else {\\n            remain += width;\\n        }\\n        p++;\\n    }\\n    result[0] = lines;\\n    result[1] = remain;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161221,
                "title": "java-4-liner-solution",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n    int reqWidth = 0;      \\n        \\n    for(int i=0;i<S.length();i++){\\n        reqWidth += (reqWidth%100 + widths[S.charAt(i)-\\'a\\'])>100 ?(widths[S.charAt(i) - \\'a\\'] + (100 - reqWidth%100)):widths[S.charAt(i)- \\'a\\'];            \\n    }                 \\n        return new int[]{reqWidth/100+1,reqWidth%100};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n    int reqWidth = 0;      \\n        \\n    for(int i=0;i<S.length();i++){\\n        reqWidth += (reqWidth%100 + widths[S.charAt(i)-\\'a\\'])>100 ?(widths[S.charAt(i) - \\'a\\'] + (100 - reqWidth%100)):widths[S.charAt(i)- \\'a\\'];            \\n    }                 \\n        return new int[]{reqWidth/100+1,reqWidth%100};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160165,
                "title": "simple-swift-solution",
                "content": "```\\nclass Solution {\\n    func numberOfLines(_ widths: [Int], _ S: String) -> [Int] {\\n        var numOfLine = 1\\n        var numOfUnit = 0\\n        var sum = 0\\n\\n        for code in S.unicodeScalars {\\n            let index: Int = Int(code.value - 97)\\n            sum += widths[index]\\n            if sum > 100 { // \\u9700\\u8981\\u6362\\u884C\\n                numOfLine += 1\\n                sum = widths[index]\\n            }\\n        }\\n\\n        numOfUnit = sum\\n\\n        return [numOfLine, numOfUnit]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numberOfLines(_ widths: [Int], _ S: String) -> [Int] {\\n        var numOfLine = 1\\n        var numOfUnit = 0\\n        var sum = 0\\n\\n        for code in S.unicodeScalars {\\n            let index: Int = Int(code.value - 97)\\n            sum += widths[index]\\n            if sum > 100 { // \\u9700\\u8981\\u6362\\u884C\\n                numOfLine += 1\\n                sum = widths[index]\\n            }\\n        }\\n\\n        numOfUnit = sum\\n\\n        return [numOfLine, numOfUnit]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158036,
                "title": "easy-java-using-character-s-ascii-values",
                "content": "```\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int[] result = new int[2];\\n        int lineValue = 0;\\n        int numLines = 1;\\n        int charVal;\\n        for (int i = 0; i < S.length(); i++) {\\n            charVal = widths[S.charAt(i) - 97];\\n            lineValue += charVal;\\n            if (lineValue > 100) {\\n                lineValue = 0;\\n                numLines++;\\n                lineValue += charVal;\\n            }\\n        }\\n        result[0] = numLines;\\n        result[1] = lineValue;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int[] result = new int[2];\\n        int lineValue = 0;\\n        int numLines = 1;\\n        int charVal;\\n        for (int i = 0; i < S.length(); i++) {\\n            charVal = widths[S.charAt(i) - 97];\\n            lineValue += charVal;\\n            if (lineValue > 100) {\\n                lineValue = 0;\\n                numLines++;\\n                lineValue += charVal;\\n            }\\n        }\\n        result[0] = numLines;\\n        result[1] = lineValue;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 149754,
                "title": "easy-java-solution",
                "content": "```\\n\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n        int width=0,count=1;\\n        for(int i=0;i<S.length();i++)\\n        {\\n            width = width + widths[S.charAt(i) - \\'a\\'];\\n            if(width > 100)\\n            {\\n                count++;\\n                width=widths[S.charAt(i) - \\'a\\'];\\n            }       \\n        }\\n         return new int[] {count, width};\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        \\n        int width=0,count=1;\\n        for(int i=0;i<S.length();i++)\\n        {\\n            width = width + widths[S.charAt(i) - \\'a\\'];\\n            if(width > 100)\\n            {\\n                count++;\\n                width=widths[S.charAt(i) - \\'a\\'];\\n            }       \\n        }\\n         return new int[] {count, width};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145598,
                "title": "python-code-beat-100-for-general-case",
                "content": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        dict_letter_widths=dict(zip(list(\\'abcdefghijklmnopqrstuvwxyz\\'),widths))\\n        S_width=[dict_letter_widths[s] for s in S]\\n        rows=1\\n        start=0\\n        for idx, each_w in enumerate(S_width):\\n            if sum(S_width[start:idx+1])>100:\\n                rows+=1\\n                start=idx\\n        \\n        last_row=sum(S_width[start:])\\n        return [rows,last_row] \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        dict_letter_widths=dict(zip(list(\\'abcdefghijklmnopqrstuvwxyz\\'),widths))\\n        S_width=[dict_letter_widths[s] for s in S]\\n        rows=1\\n        start=0\\n        for idx, each_w in enumerate(S_width):\\n            if sum(S_width[start:idx+1])>100:\\n                rows+=1\\n                start=idx\\n        \\n        last_row=sum(S_width[start:])\\n        return [rows,last_row] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 140136,
                "title": "straightforward-java",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int[] result = new int[2];\\n        result[0] = 1;\\n        for(char c : S.toCharArray()){\\n            int next = widths[c - \\'a\\'];\\n            if(next + result[1] > 100){\\n                result[0]++;\\n                result[1] = 0;\\n            }\\n            result[1] += next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        int[] result = new int[2];\\n        result[0] = 1;\\n        for(char c : S.toCharArray()){\\n            int next = widths[c - \\'a\\'];\\n            if(next + result[1] > 100){\\n                result[0]++;\\n                result[1] = 0;\\n            }\\n            result[1] += next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131362,
                "title": "my-python-script",
                "content": "class Solution:\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}\\n        for i in S:\\n            dic[i] = widths[ord(i) - ord(\\'a\\')]\\n        count = 0\\n        tmp = 0\\n        for i in S:\\n            tmp+= dic[i]\\n            if tmp ==100:\\n                count += 1\\n                tmp = 0\\n\\t\\t\\t\\t\\t elif tmp>100:\\n\\t\\t\\t\\t\\t     count += 1\\n\\t\\t\\t\\t\\t\\t\\t tmp = 0\\n\\t\\t\\t\\t\\t\\t\\t tmp += dic[i]\\n\\t\\t\\tres = []\\n\\t\\t\\tif tmp != 0:\\n\\t\\t\\t    count += 1\\n\\t\\t\\tres.append(count)\\n\\t\\t\\tres.append(tmp)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "class Solution:\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 124249,
                "title": "my-swift-answer",
                "content": "```\\nfunc numberOfLines(_ widths: [Int], _ S: String) -> [Int] {\\n        var asciiArray = S.unicodeScalars.filter{$0.isASCII}.map{Int($0.value) - 97}\\n        var totalUnits = 0\\n        var line = 1\\n        for i in 0..<asciiArray.count {\\n            if (totalUnits + widths[asciiArray[i]]) > 100 {\\n                line = line + 1\\n                totalUnits = widths[asciiArray[i]]\\n            }\\n            else {\\n                totalUnits = totalUnits + widths[asciiArray[i]]\\n            }\\n        }\\n        \\n        return [line, totalUnits]\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numberOfLines(_ widths: [Int], _ S: String) -> [Int] {\\n        var asciiArray = S.unicodeScalars.filter{$0.isASCII}.map{Int($0.value) - 97}\\n        var totalUnits = 0\\n        var line = 1\\n        for i in 0..<asciiArray.count {\\n            if (totalUnits + widths[asciiArray[i]]) > 100 {\\n                line = line + 1\\n                totalUnits = widths[asciiArray[i]]\\n            }\\n            else {\\n                totalUnits = totalUnits + widths[asciiArray[i]]\\n            }\\n        }\\n        \\n        return [line, totalUnits]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 120746,
                "title": "my-easy-c-solution",
                "content": "```\\nint* numberOfLines(int* widths, int widthsSize, char* S, int* returnSize) {\\n    int i = 0;\\n    int len = 0;\\n    int sumWidth = 0;\\n    \\n    // algo\\n    for(i = 0 ; S[i] ; i++) {\\n        len = len + widths[S[i] - \\'a\\'];\\n        if(len > 100) {\\n            len = 0;\\n            sumWidth++;\\n            i--;\\n        }\\n    }\\n    \\n    // return code\\n    *returnSize = 2;\\n    int* res = (int *)malloc(sizeof(int) * (*returnSize));\\n    res[0] = sumWidth + 1;\\n    res[1] = len;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* numberOfLines(int* widths, int widthsSize, char* S, int* returnSize) {\\n    int i = 0;\\n    int len = 0;\\n    int sumWidth = 0;\\n    \\n    // algo\\n    for(i = 0 ; S[i] ; i++) {\\n        len = len + widths[S[i] - \\'a\\'];\\n        if(len > 100) {\\n            len = 0;\\n            sumWidth++;\\n            i--;\\n        }\\n    }\\n    \\n    // return code\\n    *returnSize = 2;\\n    int* res = (int *)malloc(sizeof(int) * (*returnSize));\\n    res[0] = sumWidth + 1;\\n    res[1] = len;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 120724,
                "title": "easy-to-understand-python-33ms",
                "content": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        total = 0\\n        lines = 0\\n        for char in S:\\n            total += widths[ord(char) - ord(\"a\")]\\n            # move to a new line\\n            if total > 100:\\n                total = widths[ord(char) - ord(\"a\")]\\n                lines += 1\\n            \\n        return [lines+1, total]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, S):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type S: str\\n        :rtype: List[int]\\n        \"\"\"\\n        total = 0\\n        lines = 0\\n        for char in S:\\n            total += widths[ord(char) - ord(\"a\")]\\n            # move to a new line\\n            if total > 100:\\n                total = widths[ord(char) - ord(\"a\")]\\n                lines += 1\\n            \\n        return [lines+1, total]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120702,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        char[] cArr = S.toCharArray();\\n        \\n        int width = 0, lineCount = 1;\\n        for(char c : cArr){\\n            if(width + widths[c - \\'a\\'] > 100){\\n                lineCount++;\\n                width = 0;\\n            }\\n            width += widths[c - \\'a\\'];\\n        }\\n        \\n        return new int[]{lineCount, width};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String S) {\\n        char[] cArr = S.toCharArray();\\n        \\n        int width = 0, lineCount = 1;\\n        for(char c : cArr){\\n            if(width + widths[c - \\'a\\'] > 100){\\n                lineCount++;\\n                width = 0;\\n            }\\n            width += widths[c - \\'a\\'];\\n        }\\n        \\n        return new int[]{lineCount, width};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120664,
                "title": "accepted-java-solution",
                "content": "```\\n\\tpublic int[] numberOfLines(int[] widths, String S) {\\n\\t\\tint[] res = { 0, 0 };\\n\\t\\tif (S == null || S.length() == 0) {\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint lastLineLength = 0;\\n\\t\\tint lineCount = 1;\\n\\n\\t\\tfor (char c : S.toCharArray()) {\\n\\t\\t\\tint wordlLength = widths[c - \\'a\\'];\\n\\t\\t\\tif (lastLineLength + wordlLength > 100) {\\n\\t\\t\\t\\t++lineCount;\\n\\t\\t\\t\\tlastLineLength = wordlLength;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlastLineLength += wordlLength;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[0] = lineCount;\\n\\t\\tres[1] = lastLineLength;\\n\\t\\treturn res;\\n\\n\\t}\\n\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] numberOfLines(int[] widths, String S) {\\n\\t\\tint[] res = { 0, 0 };\\n\\t\\tif (S == null || S.length() == 0) {\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint lastLineLength = 0;\\n\\t\\tint lineCount = 1;\\n\\n\\t\\tfor (char c : S.toCharArray()) {\\n\\t\\t\\tint wordlLength = widths[c - \\'a\\'];\\n\\t\\t\\tif (lastLineLength + wordlLength > 100) {\\n\\t\\t\\t\\t++lineCount;\\n\\t\\t\\t\\tlastLineLength = wordlLength;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlastLineLength += wordlLength;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[0] = lineCount;\\n\\t\\tres[1] = lastLineLength;\\n\\t\\treturn res;\\n\\n\\t}\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 120646,
                "title": "my-simple-6-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n\\tint cnt = 1, cur = 0;\\n\\tfor (char c : S) {\\n\\t    int t = widths[c - \\'a\\'];\\n\\t    if (cur + t > 100) ++cnt;\\n\\t    cur = (cur + t > 100) ? t : cur + t;\\n\\t}\\n\\treturn {cnt, cur};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string S) {\\n\\tint cnt = 1, cur = 0;\\n\\tfor (char c : S) {\\n\\t    int t = widths[c - \\'a\\'];\\n\\t    if (cur + t > 100) ++cnt;\\n\\t    cur = (cur + t > 100) ? t : cur + t;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4104946,
                "title": "beat-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private static final int LINE_WIDTH_PX = 100;\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines = 0;\\n        int lastLineWidth = 0;\\n\\n        for (int i = 0, limit = s.length(), line = LINE_WIDTH_PX; i < limit; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n\\n            int width = widths[c];\\n\\n            // start new line?\\n            if (line + width > LINE_WIDTH_PX) {\\n                line = width;\\n                lines++;\\n            } else {\\n                line += width;\\n            }\\n\\n            lastLineWidth = line;\\n        }\\n\\n        return new int[] {lines, lastLineWidth};\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int LINE_WIDTH_PX = 100;\\n\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines = 0;\\n        int lastLineWidth = 0;\\n\\n        for (int i = 0, limit = s.length(), line = LINE_WIDTH_PX; i < limit; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n\\n            int width = widths[c];\\n\\n            // start new line?\\n            if (line + width > LINE_WIDTH_PX) {\\n                line = width;\\n                lines++;\\n            } else {\\n                line += width;\\n            }\\n\\n            lastLineWidth = line;\\n        }\\n\\n        return new int[] {lines, lastLineWidth};\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096825,
                "title": "easy-best-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int i=0, j, lines = 1, widthSum = 0;\\n        vector<int> arr;\\n        while(i < s.length())\\n        {\\n            j = s[i] - 97;\\n            if((widthSum + widths[j]) <= 100)\\n            {\\n                widthSum += widths[j];\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                widthSum = 0;\\n            }\\n        }\\n        arr.push_back(lines);\\n        arr.push_back(widthSum);\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int i=0, j, lines = 1, widthSum = 0;\\n        vector<int> arr;\\n        while(i < s.length())\\n        {\\n            j = s[i] - 97;\\n            if((widthSum + widths[j]) <= 100)\\n            {\\n                widthSum += widths[j];\\n                i++;\\n            }\\n            else\\n            {\\n                lines++;\\n                widthSum = 0;\\n            }\\n        }\\n        arr.push_back(lines);\\n        arr.push_back(widthSum);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096180,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef func(widths,s):\\n    t=0\\n    l=[]\\n    k=0\\n    for i in range(len(s)):\\n        t+=widths[ord(s[i])-ord(\\'a\\')]\\n        k+=widths[ord(s[i])-ord(\\'a\\')]\\n        if t==100:\\n            l.append(t)\\n            t=0\\n        elif t>=100:\\n            t-=widths[ord(s[i])-ord(\\'a\\')]\\n            l.append(t)\\n            t=widths[ord(s[i])-ord(\\'a\\')]\\n    if k!=sum(l):\\n        l.append(k-sum(l))\\n    print(l)\\n    return [len(l),l[-1]]\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        return func(widths,s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef func(widths,s):\\n    t=0\\n    l=[]\\n    k=0\\n    for i in range(len(s)):\\n        t+=widths[ord(s[i])-ord(\\'a\\')]\\n        k+=widths[ord(s[i])-ord(\\'a\\')]\\n        if t==100:\\n            l.append(t)\\n            t=0\\n        elif t>=100:\\n            t-=widths[ord(s[i])-ord(\\'a\\')]\\n            l.append(t)\\n            t=widths[ord(s[i])-ord(\\'a\\')]\\n    if k!=sum(l):\\n        l.append(k-sum(l))\\n    print(l)\\n    return [len(l),l[-1]]\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        return func(widths,s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094896,
                "title": "1-for-loop-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Don\\'t forget to use \\'i--\\' when the linewidth > 100\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} widths\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, s) {\\n    let string = \"abcdefghijklmnopqrstuvwxyz\";\\n    string = string.split(\"\");\\n    let width = 0;\\n    let lastline = 0;\\n    let line = 0;\\n    for(let i =0;i<s.length;i++){\\n        const index = string.indexOf(s[i]);\\n        width+=widths[index];\\n        if((lastline += widths[index]) > 100){\\n            lastline = 0;\\n            line++\\n            i--\\n        }\\n        if(i == s.length-1 && lastline != 0) line++;\\n\\n    }\\n\\n    result = [line++,lastline]\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} widths\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, s) {\\n    let string = \"abcdefghijklmnopqrstuvwxyz\";\\n    string = string.split(\"\");\\n    let width = 0;\\n    let lastline = 0;\\n    let line = 0;\\n    for(let i =0;i<s.length;i++){\\n        const index = string.indexOf(s[i]);\\n        width+=widths[index];\\n        if((lastline += widths[index]) > 100){\\n            lastline = 0;\\n            line++\\n            i--\\n        }\\n        if(i == s.length-1 && lastline != 0) line++;\\n\\n    }\\n\\n    result = [line++,lastline]\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090237,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int total_lines =0;\\n        int curr_pixel=0;\\n        for (int i = 0; i <s.length() ;i++ ) {\\n            if(curr_pixel+widths[s.charAt(i)-\\'a\\']>100){\\n                curr_pixel=0;\\n                total_lines++;\\n            }\\n            curr_pixel+=widths[s.charAt(i)-\\'a\\'];\\n        }\\n        ans[0]=total_lines+1;\\n        ans[1]=curr_pixel;\\n        return ans;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] ans = new int[2];\\n        int total_lines =0;\\n        int curr_pixel=0;\\n        for (int i = 0; i <s.length() ;i++ ) {\\n            if(curr_pixel+widths[s.charAt(i)-\\'a\\']>100){\\n                curr_pixel=0;\\n                total_lines++;\\n            }\\n            curr_pixel+=widths[s.charAt(i)-\\'a\\'];\\n        }\\n        ans[0]=total_lines+1;\\n        ans[1]=curr_pixel;\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089279,
                "title": "easy-java-solution-beats-100-with-time-and-90-with-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         \\n        int l=1;\\n        int ans=0;\\n\\n    for(char c:s.toCharArray()){\\n        int a = widths[c-\\'a\\'];\\n        if(ans+a>100){\\n            ans =a;\\n            l++;\\n        }\\n        else\\n        ans=ans+a;      \\n    \\n    }\\n    int [] x={l,ans};\\n    return x;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         \\n        int l=1;\\n        int ans=0;\\n\\n    for(char c:s.toCharArray()){\\n        int a = widths[c-\\'a\\'];\\n        if(ans+a>100){\\n            ans =a;\\n            l++;\\n        }\\n        else\\n        ans=ans+a;      \\n    \\n    }\\n    int [] x={l,ans};\\n    return x;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087778,
                "title": "beats-100-memory-leveraging-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to iterate through the input string `s`, calculate the width of each character based on the `widths` array, and keep track of the current row and count of characters in that row. When the count exceeds a certain limit (in this case, 100), we move to the next row.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables `row` to `1` (to represent the first row) and `count` to `0` (to keep track of character count in the current row).\\n2. Iterate through each character in the input string `s`.\\n3. For each character, calculate its width using the `widths` array based on its `ASCII` code.\\n4. Check if adding the character\\'s width to the current `count` would exceed the row width limit of `100`. If it does, increment the `row` counter, decrement `i` to process the same character in the next row, and reset `count` to 0. Continue to the next character.\\n5. If adding the character\\'s width doesn\\'t exceed the row width limit, update `count` with the new width.\\n6. Finally, return an array containing the `row` count and the remaining `count` (characters in the last row).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. O(n) -->\\nThe time complexity of this solution is `O(n)`, where `n` is the length of the input string `s`. We iterate through the string once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. O(n) -->\\nThe space complexity of this solution is `O(1)` since we use a constant amount of additional space regardless of the input size. We only maintain a few variables to store row count and character count.\\n\\n\\n# Code\\n```\\nfunction numberOfLines(widths: number[], s: string): number[] {\\n    let row = 1;\\n    let count = 0;\\n    for(let i = 0; i < s.length; i++){\\n        const width = widths[s.charCodeAt(i) - 97];\\n        if(count + width > 100) { row++; i--; count = 0; continue; }\\n        count += width;\\n    }\\n\\n    return [row, count];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numberOfLines(widths: number[], s: string): number[] {\\n    let row = 1;\\n    let count = 0;\\n    for(let i = 0; i < s.length; i++){\\n        const width = widths[s.charCodeAt(i) - 97];\\n        if(count + width > 100) { row++; i--; count = 0; continue; }\\n        count += width;\\n    }\\n\\n    return [row, count];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084849,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfLines(self, widths, s):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        count = 0 \\n        line = 0\\n        for i in s:\\n            v=widths[ord(i)-ord(\\'a\\')]\\n            if count+v>100:\\n                count=v\\n                line+=1\\n            else:\\n                count+=v\\n        return [line+1,count]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfLines(self, widths, s):\\n        \"\"\"\\n        :type widths: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        count = 0 \\n        line = 0\\n        for i in s:\\n            v=widths[ord(i)-ord(\\'a\\')]\\n            if count+v>100:\\n                count=v\\n                line+=1\\n            else:\\n                count+=v\\n        return [line+1,count]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084728,
                "title": "number-of-lines-to-write-string-java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] res = new int[2];\\n        int sumCount = 1;\\n        int sumOfLine = 0;\\n        for (char c:s.toCharArray()) {\\n            if((sumOfLine=sumOfLine+widths[(int)c - 97])<=100){\\n                sumOfLine-=widths[(int)c - 97];\\n                sumOfLine+=widths[(int)c - 97];\\n            }else {\\n                sumCount++;\\n                sumOfLine = 0;\\n                sumOfLine+=widths[(int)c - 97];            }\\n        }\\n        res[0] = sumCount;\\n        res[1] = sumOfLine;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] res = new int[2];\\n        int sumCount = 1;\\n        int sumOfLine = 0;\\n        for (char c:s.toCharArray()) {\\n            if((sumOfLine=sumOfLine+widths[(int)c - 97])<=100){\\n                sumOfLine-=widths[(int)c - 97];\\n                sumOfLine+=widths[(int)c - 97];\\n            }else {\\n                sumCount++;\\n                sumOfLine = 0;\\n                sumOfLine+=widths[(int)c - 97];            }\\n        }\\n        res[0] = sumCount;\\n        res[1] = sumOfLine;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080224,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum=0,c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((sum+widths[s.charAt(i)-\\'a\\'])>100)\\n            {\\n                sum=widths[s.charAt(i)-\\'a\\'];\\n                c++;\\n                continue;\\n            }\\n            else \\n            {\\n                sum=sum+widths[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n        }\\n        if(sum>0)\\n        {\\n            c++;\\n        }\\n        int a[]=new int[2];\\n        a[0]=c;\\n        a[1]=sum;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum=0,c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((sum+widths[s.charAt(i)-\\'a\\'])>100)\\n            {\\n                sum=widths[s.charAt(i)-\\'a\\'];\\n                c++;\\n                continue;\\n            }\\n            else \\n            {\\n                sum=sum+widths[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n        }\\n        if(sum>0)\\n        {\\n            c++;\\n        }\\n        int a[]=new int[2];\\n        a[0]=c;\\n        a[1]=sum;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077223,
                "title": "c-simple-solution-beats-100",
                "content": "# Intuition\\nThe intuition behind the provided code is to efficiently determine how many lines are needed to write a given string \\'s\\' while ensuring that each line does not exceed 100 pixels in width. To achieve this, the code iterates through each character in the input string \\'s\\' and keeps track of the current line\\'s width (\\'curr\\'). When adding the width of a character to \\'curr\\' would exceed 100 pixels, the code starts a new line, increments the line count, and resets \\'curr\\' to the width of the current character. This process continues until all characters in \\'s\\' are processed, providing the total number of lines needed and the width of the last line.\\n\\n# Approach\\nThe approach taken in the code is straightforward and efficient. It utilizes a single pass through the input string \\'s\\', making it linear in terms of time complexity. By keeping track of the current line\\'s width and resetting it as needed, the code ensures that no line exceeds the specified width constraint. The use of a \\'result\\' vector with two elements simplifies the storage of the output, allowing for the easy retrieval of the total number of lines and the width of the last line. Overall, this approach efficiently solves the problem of formatting a string within pixel constraints.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<int> numberOfLines(std::vector<int> &widths, std::string s) {\\n        int curr = 0;\\n        std::vector<int> result = {1, 0};\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (curr + widths[s[i] - 97] > 100) {\\n                curr = 0;\\n                result[0]++;\\n            }\\n            curr += widths[s[i] - 97];\\n        }\\n        result[1] = curr;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> numberOfLines(std::vector<int> &widths, std::string s) {\\n        int curr = 0;\\n        std::vector<int> result = {1, 0};\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (curr + widths[s[i] - 97] > 100) {\\n                curr = 0;\\n                result[0]++;\\n            }\\n            curr += widths[s[i] - 97];\\n        }\\n        result[1] = curr;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072334,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        int[] result = new int[2];\\n        int lineCount = 0;\\n        int currentLinewidth = 0;\\n        for(int i=0; i<s.Length; i++){\\n            if(currentLinewidth + widths[(int)s[i]-97] <=100){\\n                currentLinewidth += widths[((int)s[i])-97];\\n            }\\n            else{\\n                lineCount++;\\n                currentLinewidth = widths[((int)s[i])-97];\\n            }\\n        }\\n        result[0]= currentLinewidth > 0 ? ++lineCount : lineCount;\\n        result[1]=currentLinewidth;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        int[] result = new int[2];\\n        int lineCount = 0;\\n        int currentLinewidth = 0;\\n        for(int i=0; i<s.Length; i++){\\n            if(currentLinewidth + widths[(int)s[i]-97] <=100){\\n                currentLinewidth += widths[((int)s[i])-97];\\n            }\\n            else{\\n                lineCount++;\\n                currentLinewidth = widths[((int)s[i])-97];\\n            }\\n        }\\n        result[0]= currentLinewidth > 0 ? ++lineCount : lineCount;\\n        result[1]=currentLinewidth;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068183,
                "title": "c-simple-math",
                "content": "# No need desctiption\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int l = 1;\\n        int sum = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if (sum + widths[s[i] - \\'a\\'] > 100) {\\n                l++;\\n                sum = 0;\\n            }\\n            sum += widths[s[i] - \\'a\\'];\\n        }\\n        return {l, sum};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int l = 1;\\n        int sum = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            if (sum + widths[s[i] - \\'a\\'] > 100) {\\n                l++;\\n                sum = 0;\\n            }\\n            sum += widths[s[i] - \\'a\\'];\\n        }\\n        return {l, sum};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054779,
                "title": "easiest-code-with-no-extra-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int arr[] = new int[2];\\n        for(char ch : s.toCharArray()){\\n            if(arr[1]+widths[ch-\\'a\\'] > 100){\\n                arr[0]++;\\n                arr[1] = 0;\\n            }\\n            arr[1] += widths[ch-\\'a\\'];\\n        }\\n        if(arr[1] > 0)\\n            arr[0]++;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int arr[] = new int[2];\\n        for(char ch : s.toCharArray()){\\n            if(arr[1]+widths[ch-\\'a\\'] > 100){\\n                arr[0]++;\\n                arr[1] = 0;\\n            }\\n            arr[1] += widths[ch-\\'a\\'];\\n        }\\n        if(arr[1] > 0)\\n            arr[0]++;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051790,
                "title": "1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines=0;\\n        int width=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            int x=ch-\\'a\\';\\n            sum+=widths[x];\\n            if(sum==100)\\n            {\\n                lines++;\\n                width=sum;\\n                sum=0;\\n            }\\n            if(sum>100)\\n            {\\n                lines++;\\n                width=sum-widths[x];\\n                sum=widths[x];\\n            }\\n        }\\n\\n        if(sum!=0)\\n        {\\n            lines++;\\n            width=sum;\\n        }\\n\\n        int answer[]=new int[2];\\n        answer[0]=lines;\\n        answer[1]=width;\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int lines=0;\\n        int width=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            int x=ch-\\'a\\';\\n            sum+=widths[x];\\n            if(sum==100)\\n            {\\n                lines++;\\n                width=sum;\\n                sum=0;\\n            }\\n            if(sum>100)\\n            {\\n                lines++;\\n                width=sum-widths[x];\\n                sum=widths[x];\\n            }\\n        }\\n\\n        if(sum!=0)\\n        {\\n            lines++;\\n            width=sum;\\n        }\\n\\n        int answer[]=new int[2];\\n        answer[0]=lines;\\n        answer[1]=width;\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043915,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} widths\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, s) {\\n  let width = 0;\\n  let slength = 1; // Initialize to 1 for the first line\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (width + widths[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)] > 100) {\\n      slength++;\\n      width = 0;\\n    }\\n    width += widths[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n  }\\n\\n  return [slength, width];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} widths\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar numberOfLines = function(widths, s) {\\n  let width = 0;\\n  let slength = 1; // Initialize to 1 for the first line\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (width + widths[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)] > 100) {\\n      slength++;\\n      width = 0;\\n    }\\n    width += widths[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)];\\n  }\\n\\n  return [slength, width];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043045,
                "title": "simple-and-easily-understandable-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> ans(2,0);\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = widths[s[i]-\\'a\\'];\\n            if(sum+num<=100)\\n            {\\n                sum+=num;\\n            }\\n            else\\n            {\\n                ans[0]++;\\n                sum = num;\\n            }\\n        }\\n        ans[1] = sum;\\n        if(sum)\\n            ans[0]++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> ans(2,0);\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = widths[s[i]-\\'a\\'];\\n            if(sum+num<=100)\\n            {\\n                sum+=num;\\n            }\\n            else\\n            {\\n                ans[0]++;\\n                sum = num;\\n            }\\n        }\\n        ans[1] = sum;\\n        if(sum)\\n            ans[0]++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042712,
                "title": "k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int l(char c, vector<int>& widths) {\\n    int asint = c - \\'a\\';\\n    return widths[asint];\\n  }\\n\\n public:\\n  vector<int> numberOfLines(vector<int>& widths, string s) {\\n    vector<int> res(2);\\n    int lineCount = 1;\\n    int curTotal = 0;\\n    for (char c: s) {\\n      int w = l(c,widths);\\n      if (curTotal+w > 100) {\\n        curTotal=w;\\n        lineCount++;\\n      } else {\\n        curTotal+=w;\\n      }\\n    }\\n    res[0] = lineCount;\\n    res[1] = curTotal;\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n  int l(char c, vector<int>& widths) {\\n    int asint = c - \\'a\\';\\n    return widths[asint];\\n  }\\n\\n public:\\n  vector<int> numberOfLines(vector<int>& widths, string s) {\\n    vector<int> res(2);\\n    int lineCount = 1;\\n    int curTotal = 0;\\n    for (char c: s) {\\n      int w = l(c,widths);\\n      if (curTotal+w > 100) {\\n        curTotal=w;\\n        lineCount++;\\n      } else {\\n        curTotal+=w;\\n      }\\n    }\\n    res[0] = lineCount;\\n    res[1] = curTotal;\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040002,
                "title": "fastest-c-beats-100-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: Asymptotically -> O(n^2), practically -> O(n), because we traversed the array only once. And thus, TC only depends on the size of the array (linear).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) No extra space used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> ans;\\n        int i=0;\\n        int cnt=0;\\n        int row=0;\\n        while(i<s.size())\\n        {\\n            int count=0;\\n            cnt=0;\\n\\n            while(i<s.size() and (cnt+widths[s[i]-\\'a\\'])<=100)\\n            {\\n                cnt+=widths[s[i]-\\'a\\'];\\n                i++;\\n            }\\n            row+=1;\\n        }\\n        return {row,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> ans;\\n        int i=0;\\n        int cnt=0;\\n        int row=0;\\n        while(i<s.size())\\n        {\\n            int count=0;\\n            cnt=0;\\n\\n            while(i<s.size() and (cnt+widths[s[i]-\\'a\\'])<=100)\\n            {\\n                cnt+=widths[s[i]-\\'a\\'];\\n                i++;\\n            }\\n            row+=1;\\n        }\\n        return {row,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035548,
                "title": "806-number-of-lines-to-write-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n\\n         int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n\\n         int tempSum = 0, lineCounter = 1;\\n        for (char c : s.toCharArray()) {\\n            int currCharLen = widths[c - \\'a\\'];\\n            if (tempSum + currCharLen <= 100) {\\n                tempSum += currCharLen;\\n            } else {\\n                lineCounter++;\\n                tempSum = currCharLen;\\n            }\\n        }\\n        return new int[]{lineCounter, tempSum};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029617,
                "title": "very-easy-simplw-for-beginners-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        x=0\\n        y=0\\n        a=[]\\n        b=[]\\n        for i in range(len(s)):\\n            z=widths[(ord(s[i])-ord(\\'a\\'))]\\n            if x+z>100:\\n                y+=1\\n                a.append(x)\\n                x=0\\n            x=x+z\\n        a.append(x)\\n        y+=1\\n        b.append(y)\\n        b.append(a[len(a)-1])\\n        return b\\n\\n        \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        x=0\\n        y=0\\n        a=[]\\n        b=[]\\n        for i in range(len(s)):\\n            z=widths[(ord(s[i])-ord(\\'a\\'))]\\n            if x+z>100:\\n                y+=1\\n                a.append(x)\\n                x=0\\n            x=x+z\\n        a.append(x)\\n        y+=1\\n        b.append(y)\\n        b.append(a[len(a)-1])\\n        return b\\n\\n        \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018649,
                "title": "easy-c-solution-0ms-beats-100-00-of-users-with-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int>ans;\\n        int sum=0;\\n        int line=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int temp=int(s[i])-97;\\n            sum+=widths[temp];\\n            if(sum>100)\\n            {\\n                sum-=widths[temp];\\n                line++;\\n                sum=0;\\n                i--;\\n            }\\n        }\\n            ans.push_back(line+1);\\n            ans.push_back(sum);\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int>ans;\\n        int sum=0;\\n        int line=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int temp=int(s[i])-97;\\n            sum+=widths[temp];\\n            if(sum>100)\\n            {\\n                sum-=widths[temp];\\n                line++;\\n                sum=0;\\n                i--;\\n            }\\n        }\\n            ans.push_back(line+1);\\n            ans.push_back(sum);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014003,
                "title": "swift-solution-using-reduce-14-2-mb-2-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 14.2 MB\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 2 ms\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func numberOfLines(_ widths: [Int], _ s: String) -> [Int] {\\n        \\n        var numberOfLines = 0\\n        var lastLine = s.reduce(into: 0) {\\n            var ch = ((Character(extendedGraphemeClusterLiteral: $1).asciiValue ?? 0) - 97)\\n            $0 += widths[Int(ch)]\\n            if($0 > 100) {\\n                $0 = 0\\n                numberOfLines += 1\\n                $0 += widths[Int(ch)]\\n            }\\n        }\\n        if (lastLine != 0 ) {numberOfLines += 1}\\n        return [numberOfLines, lastLine]\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func numberOfLines(_ widths: [Int], _ s: String) -> [Int] {\\n        \\n        var numberOfLines = 0\\n        var lastLine = s.reduce(into: 0) {\\n            var ch = ((Character(extendedGraphemeClusterLiteral: $1).asciiValue ?? 0) - 97)\\n            $0 += widths[Int(ch)]\\n            if($0 > 100) {\\n                $0 = 0\\n                numberOfLines += 1\\n                $0 += widths[Int(ch)]\\n            }\\n        }\\n        if (lastLine != 0 ) {numberOfLines += 1}\\n        return [numberOfLines, lastLine]\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012905,
                "title": "accepted-solution-for-java-beats-100-online-submissions",
                "content": "![Screenshot 2023-09-07 at 12.23.06 PM.png](https://assets.leetcode.com/users/images/52fd9cf4-55a2-4e6b-a81a-bc7593efba28_1694069607.9465797.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] result = new int[2];\\n        int num_lines = 1;\\n        int width = 0;\\n        for(char c : s.toCharArray()){\\n            int char_width = widths[c - \\'a\\'];\\n            if(char_width + width > 100){\\n                num_lines ++;\\n                width = 0;\\n            }\\n            width += char_width;            \\n        }\\n        result[0] = num_lines;\\n        result[1] = width;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] result = new int[2];\\n        int num_lines = 1;\\n        int width = 0;\\n        for(char c : s.toCharArray()){\\n            int char_width = widths[c - \\'a\\'];\\n            if(char_width + width > 100){\\n                num_lines ++;\\n                width = 0;\\n            }\\n            width += char_width;            \\n        }\\n        result[0] = num_lines;\\n        result[1] = width;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010754,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int total=0;\\n        int count=0;\\n        String str=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            char a=s.charAt(i);\\n            int ele=widths[a-\\'a\\']; \\n            if(total+ele<=100){\\n               str+=Character.valueOf(a).toString();\\n               total=total+ele; \\n            }else{\\n                count++;\\n                str=Character.valueOf(a).toString();\\n                total=ele;\\n            }           \\n        }\\n         if(!str.equals(\"\")) count++;\\n         int[] array=new int[2];\\n         array[0]=count;\\n         array[1]=total;\\n         return array;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum0=0; // sum of all string widths \\n        int sum=0;\\n        int sum1=0; // count of each line\\n        int count=0; // count of lines\\n        vector<int>ans; // store final ans\\n        vector<int>v; // store each lines width\\n        for(char c : s){\\n            sum0 += widths[c-97]; // sum of all string widths\\n            sum += widths[c-97];\\n            if(sum>100){\\n                v.push_back(sum1);\\n                count++;\\n                sum=sum-sum1;\\n            }\\n            else if(sum<=100){\\n                sum1=sum;\\n            }\\n        }\\n        int last = sum0; \\n        for(int j=0;j<v.size();j++){\\n            last=last-v[j]; //last==last_line_pixel\\n        }\\n        if(last>0) count++;// if last>0, then their should be last line\\n        ans.push_back(count);\\n        ans.push_back(last);\\n\\n        return ans;\\n    }\\n}; // plz upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int total=0;\\n        int count=0;\\n        String str=\"\";\\n        for(int i=0; i<s.length(); i++){\\n            char a=s.charAt(i);\\n            int ele=widths[a-\\'a\\']; \\n            if(total+ele<=100){\\n               str+=Character.valueOf(a).toString();\\n               total=total+ele; \\n            }else{\\n                count++;\\n                str=Character.valueOf(a).toString();\\n                total=ele;\\n            }           \\n        }\\n         if(!str.equals(\"\")) count++;\\n         int[] array=new int[2];\\n         array[0]=count;\\n         array[1]=total;\\n         return array;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum0=0; // sum of all string widths \\n        int sum=0;\\n        int sum1=0; // count of each line\\n        int count=0; // count of lines\\n        vector<int>ans; // store final ans\\n        vector<int>v; // store each lines width\\n        for(char c : s){\\n            sum0 += widths[c-97]; // sum of all string widths\\n            sum += widths[c-97];\\n            if(sum>100){\\n                v.push_back(sum1);\\n                count++;\\n                sum=sum-sum1;\\n            }\\n            else if(sum<=100){\\n                sum1=sum;\\n            }\\n        }\\n        int last = sum0; \\n        for(int j=0;j<v.size();j++){\\n            last=last-v[j]; //last==last_line_pixel\\n        }\\n        if(last>0) count++;// if last>0, then their should be last line\\n        ans.push_back(count);\\n        ans.push_back(last);\\n\\n        return ans;\\n    }\\n}; // plz upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003861,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, width = 1, 0\\n        for char in s:\\n            c = widths[ord(char)-97]\\n            if width + c <= 100:\\n                width += c\\n            else:\\n                lines += 1\\n                width = c\\n        return [lines, width]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        lines, width = 1, 0\\n        for char in s:\\n            c = widths[ord(char)-97]\\n            if width + c <= 100:\\n                width += c\\n            else:\\n                lines += 1\\n                width = c\\n        return [lines, width]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991225,
                "title": "simple-solution-with-explanation-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. We have a class called Solution with a method called NumberOfLines that takes two parameters: an array called widths and a string called s.\\n2. We create an integer array result with two elements, initialized to 0. This array will store the number of lines used and the remaining width.\\n3. We initialize a variable count to keep track of the current line\\'s width.\\n4. We loop through each character in the input string s.\\n5. For each character, we calculate its width based on its ASCII value using the widths array. If the character is \\'a\\', we add widths[0] to the current count.\\n6. If the current line width exceeds 100, we start a new line by resetting count to the width of the current character and incrementing the first element of the result array, which represents the number of lines used.\\n7. After processing all characters in s, if there is any remaining width, we increment the number of lines used and store the remaining width in the second element of the result array.\\n8. Finally, we return the result array, which contains the number of lines used and the remaining width. This code helps determine how many lines are needed to print the string s on a display where each character has a specific width as defined in the widths array.\\n\\n# Code\\n```\\nppublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        int[] result = new int[2];  // Create an integer array to store the result, initialized with two zeros.\\n        int count = 0;  // Initialize a variable \\'count\\' to keep track of the current line width.\\n\\n        // Loop through each character in the input string \\'s\\'.\\n        for(int i = 0; i < s.Length; i++){\\n            // Calculate the width of the current character by using its ASCII value.\\n            // Subtracting 97 from the ASCII value of the character maps it to the \\'widths\\' array.\\n            // For example, \\'a\\' (ASCII 97) corresponds to widths[0], \\'b\\' (ASCII 98) corresponds to widths[1], and so on.\\n            count += widths[s[i] - 97];\\n\\n            // If the current line width exceeds 100, it means we need to start a new line.\\n            if(count > 100){\\n                // Reset the \\'count\\' to the width of the current character.\\n                count = widths[s[i] - 97];\\n                // Increment the first element of the \\'result\\' array, which represents the number of lines used so far.\\n                result[0]++;\\n            }\\n        }\\n\\n        // If there is any remaining width left after processing all characters in \\'s\\',\\n        // it means we need to count one more line and store the remaining width in the second element of the \\'result\\' array.\\n        if(count > 0){\\n            result[0]++;  // Increment the number of lines.\\n            result[1] = count;  // Store the remaining width.\\n        }\\n\\n        // Return the \\'result\\' array, which contains the number of lines used and the remaining width.\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nppublic class Solution {\\n    public int[] NumberOfLines(int[] widths, string s) {\\n        int[] result = new int[2];  // Create an integer array to store the result, initialized with two zeros.\\n        int count = 0;  // Initialize a variable \\'count\\' to keep track of the current line width.\\n\\n        // Loop through each character in the input string \\'s\\'.\\n        for(int i = 0; i < s.Length; i++){\\n            // Calculate the width of the current character by using its ASCII value.\\n            // Subtracting 97 from the ASCII value of the character maps it to the \\'widths\\' array.\\n            // For example, \\'a\\' (ASCII 97) corresponds to widths[0], \\'b\\' (ASCII 98) corresponds to widths[1], and so on.\\n            count += widths[s[i] - 97];\\n\\n            // If the current line width exceeds 100, it means we need to start a new line.\\n            if(count > 100){\\n                // Reset the \\'count\\' to the width of the current character.\\n                count = widths[s[i] - 97];\\n                // Increment the first element of the \\'result\\' array, which represents the number of lines used so far.\\n                result[0]++;\\n            }\\n        }\\n\\n        // If there is any remaining width left after processing all characters in \\'s\\',\\n        // it means we need to count one more line and store the remaining width in the second element of the \\'result\\' array.\\n        if(count > 0){\\n            result[0]++;  // Increment the number of lines.\\n            result[1] = count;  // Store the remaining width.\\n        }\\n\\n        // Return the \\'result\\' array, which contains the number of lines used and the remaining width.\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987017,
                "title": "beats-100-at-time-better-than-half-at-space-complexity-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nint(s[i]) will convert char s[i] to a int, int(s[i])-97 will give it\\'s width in given array (97 is integer value of \\'a\\')\\n# \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& nums, string s) {\\n        vector<int> ans(2,0);\\n        int lines=1;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++){\\n            int id=int(s[i])-97;\\n            if(nums[id]+sum<=100)    sum+=nums[id];\\n            else{\\n                lines++;\\n                sum=0;\\n                sum+=nums[id];\\n            }\\n        }\\n        ans[0]=lines;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& nums, string s) {\\n        vector<int> ans(2,0);\\n        int lines=1;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++){\\n            int id=int(s[i])-97;\\n            if(nums[id]+sum<=100)    sum+=nums[id];\\n            else{\\n                lines++;\\n                sum=0;\\n                sum+=nums[id];\\n            }\\n        }\\n        ans[0]=lines;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968560,
                "title": "simple-and-efficient-approach-for-beginners-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nWe can solve this code in many ways. In this case, we solved the problem in a simple way. First keep \\'sum\\' variable equal to \\'Zero(0)\\'. Then keep \\'lines\\' variable as \\'One(1)\\'. Now iterate over the string \\'s\\' and update the \\'sum\\' with respect to the widths array. When \\'sum\\' gets the value greater than \\'100\\', we need to increment the \\'lines\\' variable by one time because each line should contain a maximum value of \\'100\\' only. And at the same time we need to update the \\'sum\\' variable as it gets over \\'100\\'. At last  we need to return a vector containing \\'number of lines\\' and \\'sum in the last line\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        int lines=1;\\n        for(int i=0;i<s.size();i++){\\n            sum=sum+widths[s[i]-\\'a\\'];\\n            if(sum>100){\\n                lines++;\\n                sum=widths[s[i]-\\'a\\'];\\n            }\\n            \\n            \\n        }\\n        vector <int> res;\\n        res.push_back(lines);\\n        res.push_back(sum);\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        int lines=1;\\n        for(int i=0;i<s.size();i++){\\n            sum=sum+widths[s[i]-\\'a\\'];\\n            if(sum>100){\\n                lines++;\\n                sum=widths[s[i]-\\'a\\'];\\n            }\\n            \\n            \\n        }\\n        vector <int> res;\\n        res.push_back(lines);\\n        res.push_back(sum);\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960355,
                "title": "beats-100-solution-for-beginner-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum0=0; // sum of all string widths \\n        int sum=0;\\n        int sum1=0; // count of each line\\n        int count=0; // count of lines\\n        vector<int>ans; // store final ans\\n        vector<int>v; // store each lines width\\n        for(char c : s){\\n            sum0 += widths[c-97]; // sum of all string widths\\n            sum += widths[c-97];\\n            if(sum>100){\\n                v.push_back(sum1);\\n                count++;\\n                sum=sum-sum1;\\n            }\\n            else if(sum<=100){\\n                sum1=sum;\\n            }\\n        }\\n        int last = sum0; \\n        for(int j=0;j<v.size();j++){\\n            last=last-v[j]; //last==last_line_pixel\\n        }\\n        if(last>0) count++;// if last>0, then their should be last line\\n        ans.push_back(count);\\n        ans.push_back(last);\\n\\n        return ans;\\n    }\\n}; // plz upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum0=0; // sum of all string widths \\n        int sum=0;\\n        int sum1=0; // count of each line\\n        int count=0; // count of lines\\n        vector<int>ans; // store final ans\\n        vector<int>v; // store each lines width\\n        for(char c : s){\\n            sum0 += widths[c-97]; // sum of all string widths\\n            sum += widths[c-97];\\n            if(sum>100){\\n                v.push_back(sum1);\\n                count++;\\n                sum=sum-sum1;\\n            }\\n            else if(sum<=100){\\n                sum1=sum;\\n            }\\n        }\\n        int last = sum0; \\n        for(int j=0;j<v.size();j++){\\n            last=last-v[j]; //last==last_line_pixel\\n        }\\n        if(last>0) count++;// if last>0, then their should be last line\\n        ans.push_back(count);\\n        ans.push_back(last);\\n\\n        return ans;\\n    }\\n}; // plz upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954528,
                "title": "c-best-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> v(2);\\n        int last_width = 0;\\n        int total_width = 0;\\n        int total_line = 0;\\n        for(int i = 0;i<s.size();i++){\\n            bool flag = 0;\\n            char c= s[i];\\n            if(total_width > 100 || flag){\\n                if(total_width > 100){\\n                    total_width = total_width - widths[s[i-1] - 97];\\n                    --i;\\n                }\\n                last_width = total_width;\\n                total_line++;\\n                total_width = 0;\\n            }\\n            else{\\n                total_width = total_width + widths[c-97];\\n                if(total_width > 100){\\n                    --i;\\n                    flag = 1;\\n                }\\n            }\\n        }\\n        if(total_width >0){\\n            total_line++;\\n            last_width = total_width;\\n        }\\n        v[0] = total_line;\\n        v[1] = last_width;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> v(2);\\n        int last_width = 0;\\n        int total_width = 0;\\n        int total_line = 0;\\n        for(int i = 0;i<s.size();i++){\\n            bool flag = 0;\\n            char c= s[i];\\n            if(total_width > 100 || flag){\\n                if(total_width > 100){\\n                    total_width = total_width - widths[s[i-1] - 97];\\n                    --i;\\n                }\\n                last_width = total_width;\\n                total_line++;\\n                total_width = 0;\\n            }\\n            else{\\n                total_width = total_width + widths[c-97];\\n                if(total_width > 100){\\n                    --i;\\n                    flag = 1;\\n                }\\n            }\\n        }\\n        if(total_width >0){\\n            total_line++;\\n            last_width = total_width;\\n        }\\n        v[0] = total_line;\\n        v[1] = last_width;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950571,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        ref = ord(\\'a\\')\\n\\n        i,line,count = 0,0,0\\n\\n        while i < len(s):\\n            line += 1\\n            count = 0\\n            while count <= 100 and i < len(s):\\n                count += widths[ord(s[i]) - ref]\\n                i += 1\\n            \\n            if count > 100:\\n                i -= 1\\n                count -= widths[ord(s[i]) - ref]\\n\\n        return [line, count]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        ref = ord(\\'a\\')\\n\\n        i,line,count = 0,0,0\\n\\n        while i < len(s):\\n            line += 1\\n            count = 0\\n            while count <= 100 and i < len(s):\\n                count += widths[ord(s[i]) - ref]\\n                i += 1\\n            \\n            if count > 100:\\n                i -= 1\\n                count -= widths[ord(s[i]) - ref]\\n\\n        return [line, count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950157,
                "title": "easy-c-solution-beginner-s-friendly",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n    int sum=0;\\n    int count=0;\\n    for(int i=0;i<s.size();i++){\\n        int value=widths[s[i]+\\'0\\'-145];\\n        if(sum+value<=100){\\n            sum=sum+value;\\n        }\\n        else{\\n            count++;\\n            sum=0;\\n            sum=sum+value;\\n        }\\n    }\\n    vector<int> result;\\n    result.push_back(count+1);\\n    result.push_back(sum);\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n    int sum=0;\\n    int count=0;\\n    for(int i=0;i<s.size();i++){\\n        int value=widths[s[i]+\\'0\\'-145];\\n        if(sum+value<=100){\\n            sum=sum+value;\\n        }\\n        else{\\n            count++;\\n            sum=0;\\n            sum=sum+value;\\n        }\\n    }\\n    vector<int> result;\\n    result.push_back(count+1);\\n    result.push_back(sum);\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943646,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] result = new int[2];\\n        int count = 0, lines  = 0;\\n\\n        for(char c : s.toCharArray()){\\n            count += widths[c -\\'a\\'];\\n\\n            if(count > 100){\\n                lines++;\\n                count = widths[c-\\'a\\'];\\n            }\\n        }\\n\\n        result[0] = lines+1;\\n        result[1] = count;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int[] result = new int[2];\\n        int count = 0, lines  = 0;\\n\\n        for(char c : s.toCharArray()){\\n            count += widths[c -\\'a\\'];\\n\\n            if(count > 100){\\n                lines++;\\n                count = widths[c-\\'a\\'];\\n            }\\n        }\\n\\n        result[0] = lines+1;\\n        result[1] = count;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939955,
                "title": "the-native-solution-is-explained-100-check-it-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code defines a C++ class Solution with a member function numberOfLines. This function takes two parameters: a vector of integers widths representing the widths of lowercase English letters, and a string s containing lowercase English letters. The goal is to determine how many lines it takes to write the string s using the given widths for each character, and the total width of the last line.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize total to 0 to keep track of the current line\\'s total width and lines to 1 to represent the first line.\\n2.Loop through each character in the string s.\\n3.For each character in s, calculate the index by subtracting \\'a\\' from its ASCII value. This index corresponds to the width of that character in the widths vector.\\n4.Add the width of the character to the total.\\n5.Check if the total exceeds 100, which represents the maximum line width allowed.\\n    If it does, increment the lines counter to represent a new line and reset the total to the width of the current character.\\n6Continue this process until all characters in the string s have been processed.\\n7.Finally, return a vector containing two values: lines, which represents the total number of lines required to write the string, and total, which represents the width of the last line.\\n# Complexity\\n- Time complexity: O(n  )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input string s. This is because the code iterates through each character in the string once and performs constant time operations for each character.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) because it uses a constant amount of extra space to store the total and lines variables, regardless of the input size. The returned vector also has a constant size (always two elements). The widths vector is provided as input and is not counted towards the space complexity of the function.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        \\n        int total = 0, lines = 1;\\n        for(int i = 0; i < s.length(); ++i){\\n            int index = (s[i] - \\'a\\');\\n\\n            total += widths[index];\\n\\n            if(total > 100){\\n                ++lines;\\n                total = widths[index];\\n            }\\n        }\\n\\n        return {lines, total};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        \\n        int total = 0, lines = 1;\\n        for(int i = 0; i < s.length(); ++i){\\n            int index = (s[i] - \\'a\\');\\n\\n            total += widths[index];\\n\\n            if(total > 100){\\n                ++lines;\\n                total = widths[index];\\n            }\\n        }\\n\\n        return {lines, total};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939324,
                "title": "806-number-of-lines-to-write-string",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n-time complexity here,  O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         int lines = 1; // Initialize with at least one line\\n        int currentWidth = 0; // Width of current line\\n        \\n        for (char c : s.toCharArray()) {\\n            int charWidth = widths[c - \\'a\\'];\\n            \\n            if (currentWidth + charWidth > 100) {\\n                lines++;\\n                currentWidth = 0;\\n            }\\n            \\n            currentWidth += charWidth;\\n        }\\n        \\n        return new int[] { lines, currentWidth };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         int lines = 1; // Initialize with at least one line\\n        int currentWidth = 0; // Width of current line\\n        \\n        for (char c : s.toCharArray()) {\\n            int charWidth = widths[c - \\'a\\'];\\n            \\n            if (currentWidth + charWidth > 100) {\\n                lines++;\\n                currentWidth = 0;\\n            }\\n            \\n            currentWidth += charWidth;\\n        }\\n        \\n        return new int[] { lines, currentWidth };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938006,
                "title": "c-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        vector<int>ans;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++){\\n            int c=s[i]-97;\\n            sum=sum+widths[c];\\n         \\n            if(sum>100){\\n                flag++;\\n                sum=0;\\n                i--;\\n\\n            }\\n            if(sum==100){\\n                 flag++;\\n                sum=0;\\n             \\n\\n            }\\n        }\\n        if(sum==0){\\n            sum=100;\\n            flag--;\\n        }\\n        ans.push_back(flag+1);\\n        ans.push_back(sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum=0;\\n        vector<int>ans;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++){\\n            int c=s[i]-97;\\n            sum=sum+widths[c];\\n         \\n            if(sum>100){\\n                flag++;\\n                sum=0;\\n                i--;\\n\\n            }\\n            if(sum==100){\\n                 flag++;\\n                sum=0;\\n             \\n\\n            }\\n        }\\n        if(sum==0){\\n            sum=100;\\n            flag--;\\n        }\\n        ans.push_back(flag+1);\\n        ans.push_back(sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937705,
                "title": "python-simple-solution-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        limit = 0\\n        classification = []\\n        chunk = \\'\\'\\n\\n        for char in s:\\n            test = limit + widths[ord(char) - ord(\\'a\\')]\\n            if test <= 100:\\n                chunk += char\\n                limit += widths[ord(char) - ord(\\'a\\')]\\n            else:\\n                classification.append(chunk)\\n                limit = widths[ord(char) - ord(\\'a\\')]\\n                chunk = char\\n\\n        classification.append(chunk)\\n        last_line_width = sum([widths[ord(char) - ord(\\'a\\')] for char in classification[-1]])\\n\\n        return [len(classification), last_line_width]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        limit = 0\\n        classification = []\\n        chunk = \\'\\'\\n\\n        for char in s:\\n            test = limit + widths[ord(char) - ord(\\'a\\')]\\n            if test <= 100:\\n                chunk += char\\n                limit += widths[ord(char) - ord(\\'a\\')]\\n            else:\\n                classification.append(chunk)\\n                limit = widths[ord(char) - ord(\\'a\\')]\\n                chunk = char\\n\\n        classification.append(chunk)\\n        last_line_width = sum([widths[ord(char) - ord(\\'a\\')] for char in classification[-1]])\\n\\n        return [len(classification), last_line_width]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931270,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/922fa01e-291e-43bb-bf94-dd6965dad015_1692449674.611826.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n       int noOfLines = 0, cnt=0;\\n       for(auto i : s){\\n           if(cnt + widths[i - \\'a\\'] > 100){\\n               noOfLines++;\\n               cnt = widths[i - \\'a\\'];\\n           }\\n           else cnt += widths[i - \\'a\\'];\\n       } \\n       return {noOfLines+1, cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n       int noOfLines = 0, cnt=0;\\n       for(auto i : s){\\n           if(cnt + widths[i - \\'a\\'] > 100){\\n               noOfLines++;\\n               cnt = widths[i - \\'a\\'];\\n           }\\n           else cnt += widths[i - \\'a\\'];\\n       } \\n       return {noOfLines+1, cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927013,
                "title": "number-of-lines-to-write-string-using-c",
                "content": "# Intuition \\uD83E\\uDD14\\nI\\'m thinking of solving this problem by iterating through each character in the given string and keeping track of the total width used. Whenever the width exceeds 100, I\\'ll start a new line and reset the width count.\\n\\n# Approach \\uD83D\\uDE80\\n1. Initialize variables: Create a vector v to store the result. Set sum to 0 to keep track of the current line\\'s width. Set line to 1 to count the number of lines used.\\n\\n2. Iterate through the string: For each character c in the string s:\\n\\n- Add the width of character c to the sum.\\n- If sum exceeds 100, reset sum to the width of character c and increment line.\\n3. Store the result: After iterating through the string, push the line count and the final sum to the vector v.\\n\\n4. Return the result vector v.\\n\\n# Complexity \\uD83D\\uDCCA\\n- Time complexity: The algorithm iterates through each character in the string once, resulting in a linear time complexity of O(n), where n is the length of the string.\\n\\n- Space complexity: The additional space used is for a few integer variables, resulting in constant space usage, i.e., O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> v;\\n        int n = widths.size();\\n        int m = s.size();\\n        int sum=0;\\n        int line = 1 ;\\n        for( int i=0;i<m;i++){\\n            sum += widths[s[i]-\\'a\\'];\\n            if(sum > 100){\\n                sum = widths[s[i]-\\'a\\'];\\n                line++;\\n            }\\n        }\\n        v.push_back(line);\\n        v.push_back(sum);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int> v;\\n        int n = widths.size();\\n        int m = s.size();\\n        int sum=0;\\n        int line = 1 ;\\n        for( int i=0;i<m;i++){\\n            sum += widths[s[i]-\\'a\\'];\\n            if(sum > 100){\\n                sum = widths[s[i]-\\'a\\'];\\n                line++;\\n            }\\n        }\\n        v.push_back(line);\\n        v.push_back(sum);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922263,
                "title": "beats-93",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        line=0\\n        pixel=0\\n        for i in range(len(s)):\\n            if pixel+widths[ord(s[i])-97]>100:\\n                line+=1\\n                pixel=widths[ord(s[i])-97]\\n            else:\\n                \\n                pixel+=widths[ord(s[i])-97]\\n                \\n        return [line+1,pixel]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        line=0\\n        pixel=0\\n        for i in range(len(s)):\\n            if pixel+widths[ord(s[i])-97]>100:\\n                line+=1\\n                pixel=widths[ord(s[i])-97]\\n            else:\\n                \\n                pixel+=widths[ord(s[i])-97]\\n                \\n        return [line+1,pixel]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913562,
                "title": "short-ans-well-explained",
                "content": "# Intuition\\nTwo variables are needed, one to count pixels and other to count line.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N), one for loop used\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) as new array is made.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         int line = 0;\\n        int pixelCount = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - \\'a\\';\\n            pixelCount += widths[index];\\n            \\n            if (pixelCount > 100) {\\n                i--; // if it exceeds 100\\n                line++;\\n                pixelCount = 0;\\n            }\\n        }\\n        // Last line\\n        if (pixelCount != 0) {\\n            line++;\\n        }\\n        \\n        // Making new array\\n        return new int[]{line, pixelCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n         int line = 0;\\n        int pixelCount = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - \\'a\\';\\n            pixelCount += widths[index];\\n            \\n            if (pixelCount > 100) {\\n                i--; // if it exceeds 100\\n                line++;\\n                pixelCount = 0;\\n            }\\n        }\\n        // Last line\\n        if (pixelCount != 0) {\\n            line++;\\n        }\\n        \\n        // Making new array\\n        return new int[]{line, pixelCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912149,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] w, String s) {\\n        int n=s.length(),sum=0,i=0,c=0;\\n        // sum=w[s.charAt(0)-\\'a\\'];\\n        int[] ans=new int[2];\\n        while(i<n){\\n            if(sum+w[s.charAt(i)-\\'a\\']<=100){\\n                sum+=w[s.charAt(i)-\\'a\\'];\\n                i++;\\n            }\\n            else{\\n                c++;\\n                sum=0;\\n                sum+=w[s.charAt(i)-\\'a\\'];\\n                i++;\\n            }\\n            // System.out.println(sum+\" \"+c);\\n        }\\n        ans[0]=c+1;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] w, String s) {\\n        int n=s.length(),sum=0,i=0,c=0;\\n        // sum=w[s.charAt(0)-\\'a\\'];\\n        int[] ans=new int[2];\\n        while(i<n){\\n            if(sum+w[s.charAt(i)-\\'a\\']<=100){\\n                sum+=w[s.charAt(i)-\\'a\\'];\\n                i++;\\n            }\\n            else{\\n                c++;\\n                sum=0;\\n                sum+=w[s.charAt(i)-\\'a\\'];\\n                i++;\\n            }\\n            // System.out.println(sum+\" \"+c);\\n        }\\n        ans[0]=c+1;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905776,
                "title": "c-easier-to-understand-beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nRun Time: Beats 100.00% of users with C++\\n\\nMemory: Beats 15.82%of users with C++\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line = 1 ; // The initial line is 1 \\n        int currWidth = 0 ;\\n\\n        for(char c : s ){\\n            int width = widths[c-\\'a\\'];\\n            if(currWidth + width  <= 100){\\n                currWidth += width;\\n            }\\n            else{\\n                ++line;\\n                currWidth = width;\\n            }\\n        }\\n        return {line, currWidth};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int line = 1 ; // The initial line is 1 \\n        int currWidth = 0 ;\\n\\n        for(char c : s ){\\n            int width = widths[c-\\'a\\'];\\n            if(currWidth + width  <= 100){\\n                currWidth += width;\\n            }\\n            else{\\n                ++line;\\n                currWidth = width;\\n            }\\n        }\\n        return {line, currWidth};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902324,
                "title": "beats-100-00-of-users-with-java",
                "content": "# Faster Solution\\nBeats 100.00% of users with Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        \\n    \\n        int currentLinePixel = 0;\\n        int noOfLines = 1;\\n        char[] charArray = s.toCharArray();\\n\\n        for(int i = 0 ; i<s.length() ; i ++) {\\n            char c = charArray[i];\\n            int charWidth = widths[c - \\'a\\'];\\n           if (currentLinePixel + charWidth > 100) {\\n            noOfLines++;\\n            currentLinePixel = charWidth;\\n        } else {\\n            currentLinePixel += charWidth;\\n        }\\n\\n\\n        }\\n \\n      return new int[] {noOfLines, currentLinePixel};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        \\n    \\n        int currentLinePixel = 0;\\n        int noOfLines = 1;\\n        char[] charArray = s.toCharArray();\\n\\n        for(int i = 0 ; i<s.length() ; i ++) {\\n            char c = charArray[i];\\n            int charWidth = widths[c - \\'a\\'];\\n           if (currentLinePixel + charWidth > 100) {\\n            noOfLines++;\\n            currentLinePixel = charWidth;\\n        } else {\\n            currentLinePixel += charWidth;\\n        }\\n\\n\\n        }\\n \\n      return new int[] {noOfLines, currentLinePixel};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898355,
                "title": "c-sol-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& width, string s) {\\n        int i,sum=0,line=1;\\n        for(i=0;i<s.size();i++){\\n            sum+=width[s[i]-\\'a\\'];\\n            if(sum>100){\\n                line++;\\n                sum=width[s[i]-\\'a\\'];\\n            }\\n        }\\n        return {line,sum};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& width, string s) {\\n        int i,sum=0,line=1;\\n        for(i=0;i<s.size();i++){\\n            sum+=width[s[i]-\\'a\\'];\\n            if(sum>100){\\n                line++;\\n                sum=width[s[i]-\\'a\\'];\\n            }\\n        }\\n        return {line,sum};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894857,
                "title": "easy-solutions-in-typescript-and-rust",
                "content": "# TypeScript\\n```\\nfunction numberOfLines(widths: number[], s: string): number[] {\\n    let lines = 1;\\n    let currLineWidth = 0;\\n\\n    for (const c of s) {\\n        const charWidth = widths[c.charCodeAt(0) -  \\'a\\'.charCodeAt(0)];\\n\\n        if (currLineWidth + charWidth > 100) {\\n            lines++;\\n            currLineWidth = 0;\\n        }\\n\\n        currLineWidth += charWidth;\\n    }\\n\\n    return [lines, currLineWidth];\\n};\\n```\\n\\n# Rust\\n```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        let mut lines = 1;\\n        let mut curr_line_width = 0;\\n\\n        for c in s.chars() {\\n            let char_width = widths[c as usize - \\'a\\' as usize];\\n\\n            if curr_line_width + char_width > 100 {\\n                lines += 1;\\n                curr_line_width = 0;\\n            }\\n\\n            curr_line_width += char_width;\\n        }\\n\\n        vec![lines, curr_line_width]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfunction numberOfLines(widths: number[], s: string): number[] {\\n    let lines = 1;\\n    let currLineWidth = 0;\\n\\n    for (const c of s) {\\n        const charWidth = widths[c.charCodeAt(0) -  \\'a\\'.charCodeAt(0)];\\n\\n        if (currLineWidth + charWidth > 100) {\\n            lines++;\\n            currLineWidth = 0;\\n        }\\n\\n        currLineWidth += charWidth;\\n    }\\n\\n    return [lines, currLineWidth];\\n};\\n```\n```\\nimpl Solution {\\n    pub fn number_of_lines(widths: Vec<i32>, s: String) -> Vec<i32> {\\n        let mut lines = 1;\\n        let mut curr_line_width = 0;\\n\\n        for c in s.chars() {\\n            let char_width = widths[c as usize - \\'a\\' as usize];\\n\\n            if curr_line_width + char_width > 100 {\\n                lines += 1;\\n                curr_line_width = 0;\\n            }\\n\\n            curr_line_width += char_width;\\n        }\\n\\n        vec![lines, curr_line_width]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892885,
                "title": "c-solution-3ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(sum + widths[s[i] - \\'a\\']<=100){\\n                sum = sum + widths[s[i] - \\'a\\'];\\n                i++;\\n            }\\n            else{\\n                count++;\\n                sum = 0;\\n            }\\n        }\\n        count++;\\n        vector<int> ans(2);\\n        ans[0] = count;\\n        ans[1] = sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int sum = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(sum + widths[s[i] - \\'a\\']<=100){\\n                sum = sum + widths[s[i] - \\'a\\'];\\n                i++;\\n            }\\n            else{\\n                count++;\\n                sum = 0;\\n            }\\n        }\\n        count++;\\n        vector<int> ans(2);\\n        ans[0] = count;\\n        ans[1] = sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892883,
                "title": "java-solution-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            int n = (int)(s.charAt(i)) - 97;\\n            if(sum + widths[n]<=100){\\n                sum = sum + widths[n];\\n                i++;\\n            }\\n            else{\\n                count++;\\n                sum = 0;\\n            }\\n        }\\n        count++;\\n        int ans[] = new int[2];\\n        ans[0] = count;\\n        ans[1] = sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int sum = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            int n = (int)(s.charAt(i)) - 97;\\n            if(sum + widths[n]<=100){\\n                sum = sum + widths[n];\\n                i++;\\n            }\\n            else{\\n                count++;\\n                sum = 0;\\n            }\\n        }\\n        count++;\\n        int ans[] = new int[2];\\n        ans[0] = count;\\n        ans[1] = sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859400,
                "title": "90-above-easy-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        d = dict()\\n        for i in range(0,26):\\n            d[chr(ord(\\'a\\')+i)]=widths[i]\\n\\n        s1,count = 0,1\\n        i=0\\n        while s1<100 and i<len(s):\\n            r = s[i]\\n            s1+=d[r]\\n            if s1==100:\\n                s1=0\\n                count+=1\\n            elif s1>100:\\n                s1=d[s[i]]\\n                count+=1\\n            i+=1\\n        l=[]\\n        if s1==0:\\n            s1=100\\n            count-=1\\n        l.append(count)\\n        l.append(s1)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\\n        d = dict()\\n        for i in range(0,26):\\n            d[chr(ord(\\'a\\')+i)]=widths[i]\\n\\n        s1,count = 0,1\\n        i=0\\n        while s1<100 and i<len(s):\\n            r = s[i]\\n            s1+=d[r]\\n            if s1==100:\\n                s1=0\\n                count+=1\\n            elif s1>100:\\n                s1=d[s[i]]\\n                count+=1\\n            i+=1\\n        l=[]\\n        if s1==0:\\n            s1=100\\n            count-=1\\n        l.append(count)\\n        l.append(s1)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855797,
                "title": "java-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int a[]= new int[2];\\n\\t\\tLinkedHashMap<String, Integer> map= new LinkedHashMap<>();\\n\\t\\tint sum=0;\\n\\t\\tint newline=1;\\n\\t\\tint codePoint=97;\\n\\t\\tint lastsumvalue=0;\\n\\t\\tfor (int i = 0; i<=widths.length-1; i++) {\\n\\t\\t\\t\\n\\t\\t\\tmap.put(Character.toString(codePoint), widths[i]);\\n\\t\\t\\tcodePoint++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<=s.length()-1;i++)\\n\\t\\t{\\n\\t\\tint value=\\tmap.get(String.valueOf(s.charAt(i)));\\n\\t\\tsum=sum+value;\\n\\t\\tif(sum>100)\\n\\t\\t{\\n\\t\\t\\tsum=0;\\n\\t\\t\\tnewline++;\\n\\t\\t\\t\\n\\t\\t\\tsum=sum+value;\\n\\t\\t}\\n\\t\\tlastsumvalue=sum;\\n\\t\\t}\\n\\t\\ta[0]=newline;\\n\\t\\ta[1]=lastsumvalue;\\nreturn a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        int a[]= new int[2];\\n\\t\\tLinkedHashMap<String, Integer> map= new LinkedHashMap<>();\\n\\t\\tint sum=0;\\n\\t\\tint newline=1;\\n\\t\\tint codePoint=97;\\n\\t\\tint lastsumvalue=0;\\n\\t\\tfor (int i = 0; i<=widths.length-1; i++) {\\n\\t\\t\\t\\n\\t\\t\\tmap.put(Character.toString(codePoint), widths[i]);\\n\\t\\t\\tcodePoint++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<=s.length()-1;i++)\\n\\t\\t{\\n\\t\\tint value=\\tmap.get(String.valueOf(s.charAt(i)));\\n\\t\\tsum=sum+value;\\n\\t\\tif(sum>100)\\n\\t\\t{\\n\\t\\t\\tsum=0;\\n\\t\\t\\tnewline++;\\n\\t\\t\\t\\n\\t\\t\\tsum=sum+value;\\n\\t\\t}\\n\\t\\tlastsumvalue=sum;\\n\\t\\t}\\n\\t\\ta[0]=newline;\\n\\t\\ta[1]=lastsumvalue;\\nreturn a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847258,
                "title": "best-runtime",
                "content": "\\n# Complexity\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n       int l=0,p=0;\\n       char a;\\n       for (int i=0;i<s.length();i++){\\n           a=s.charAt(i);\\n           p=p+widths[a-97];\\n           if(p>100){\\n               p=0;\\n               l++;\\n               i--;\\n           }\\n       }\\n       int i[]={++l,p};\\n       return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n       int l=0,p=0;\\n       char a;\\n       for (int i=0;i<s.length();i++){\\n           a=s.charAt(i);\\n           p=p+widths[a-97];\\n           if(p>100){\\n               p=0;\\n               l++;\\n               i--;\\n           }\\n       }\\n       int i[]={++l,p};\\n       return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845646,
                "title": "c-simple-and-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n) with 100% beat(0ms).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int>result;\\n        int count=0;  //vector<string>p;\\n        string q=\"\";\\n        int width=0;\\n        for(int i=0;i<s.length();i++){\\n            int index=s[i]-\\'a\\';\\n            q+=s[i];\\n            width+=widths[index];\\n            if(width>100){\\n                q.pop_back();\\n                i=i-1;\\n                count+=1;  //p.push_back(q);\\n                q=\"\";\\n                width=0;\\n            }\\n        }\\n        count+=1;    //p.push_back(q);\\n        int num1=count;   //p.size();\\n        int num2=width;\\n        result.push_back(num1);\\n        result.push_back(num2);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        vector<int>result;\\n        int count=0;  //vector<string>p;\\n        string q=\"\";\\n        int width=0;\\n        for(int i=0;i<s.length();i++){\\n            int index=s[i]-\\'a\\';\\n            q+=s[i];\\n            width+=widths[index];\\n            if(width>100){\\n                q.pop_back();\\n                i=i-1;\\n                count+=1;  //p.push_back(q);\\n                q=\"\";\\n                width=0;\\n            }\\n        }\\n        count+=1;    //p.push_back(q);\\n        int num1=count;   //p.size();\\n        int num2=width;\\n        result.push_back(num1);\\n        result.push_back(num2);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831468,
                "title": "number-of-lines-to-write-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        HashMap<Character,Integer> hm = new HashMap<Character,Integer>();\\n        for(int i=0;i<26;i++)\\n        {\\n            hm.put((char)(97+i),widths[i]);\\n        }\\n        int line = 1;\\n        int sum = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum=sum+hm.get(s.charAt(i));\\n            if(sum>100)\\n            {\\n                line++;\\n                sum = hm.get(s.charAt(i));\\n            }\\n            if(sum==100)\\n            {if(i!=s.length()-1)\\n            {sum=0;\\n            line++;}}\\n        }\\n        int[] arr = new int[2];\\n        arr[0] = line;\\n        arr[1] = sum;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] numberOfLines(int[] widths, String s) {\\n        HashMap<Character,Integer> hm = new HashMap<Character,Integer>();\\n        for(int i=0;i<26;i++)\\n        {\\n            hm.put((char)(97+i),widths[i]);\\n        }\\n        int line = 1;\\n        int sum = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum=sum+hm.get(s.charAt(i));\\n            if(sum>100)\\n            {\\n                line++;\\n                sum = hm.get(s.charAt(i));\\n            }\\n            if(sum==100)\\n            {if(i!=s.length()-1)\\n            {sum=0;\\n            line++;}}\\n        }\\n        int[] arr = new int[2];\\n        arr[0] = line;\\n        arr[1] = sum;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825192,
                "title": "beats-100-00-of-users-with-c-easy-approach-one-pass-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int cnt=0,curr_sum=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            curr_sum+=widths[s[i]-\\'a\\'];\\n            if(curr_sum>100)\\n            {\\n                curr_sum = widths[s[i]-\\'a\\'];\\n                cnt++;\\n            }\\n        }\\n        return {cnt + 1,curr_sum};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numberOfLines(vector<int>& widths, string s) {\\n        int cnt=0,curr_sum=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            curr_sum+=widths[s[i]-\\'a\\'];\\n            if(curr_sum>100)\\n            {\\n                curr_sum = widths[s[i]-\\'a\\'];\\n                cnt++;\\n            }\\n        }\\n        return {cnt + 1,curr_sum};\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564753,
                "content": [
                    {
                        "username": "georgemeng2001@gmail.com",
                        "content": "The description is so bad, it does not give a clear description, the example helps, but has to read multiple times to guess and guess.\\n"
                    },
                    {
                        "username": "sjw214",
                        "content": "No idea what\\'s even being asked."
                    },
                    {
                        "username": "kenumida",
                        "content": "as the subject"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "my face when I read description \\uD83D\\uDE28\\uD83D\\uDE28\\uD83D\\uDE28\\nmy face when I looked at example \\uD83D\\uDE30\\uD83D\\uDE30\\uD83D\\uDE31\\uD83D\\uDE31 "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is there something wrong with the testcase where s=\"mqblbtpvicqhbrejb\"? My solution works perfectly fine for all the other testcases (26/27) except this one. "
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "[@arshadsaifi](/arshadsaifi) yeah , thanks for the response even though i corrected it previously i forgot to delete my comment\\n"
                    },
                    {
                        "username": "arshadsaifi",
                        "content": "No, the question is fine. You might have missed the case where the length of a line can be 100px. And your code might be returning 0 for that case."
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "for that test case , the total sum comes out to be 100 , which means only 1 line will be required , and the last line will be 100 pixels wide because there is only one line.\\nYou will have to add another condition for this according to your code."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "All cases passed for me. How to get test case  #26 input in UI? Or please post it here."
                    }
                ]
            },
            {
                "id": 1566104,
                "content": [
                    {
                        "username": "georgemeng2001@gmail.com",
                        "content": "The description is so bad, it does not give a clear description, the example helps, but has to read multiple times to guess and guess.\\n"
                    },
                    {
                        "username": "sjw214",
                        "content": "No idea what\\'s even being asked."
                    },
                    {
                        "username": "kenumida",
                        "content": "as the subject"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "my face when I read description \\uD83D\\uDE28\\uD83D\\uDE28\\uD83D\\uDE28\\nmy face when I looked at example \\uD83D\\uDE30\\uD83D\\uDE30\\uD83D\\uDE31\\uD83D\\uDE31 "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is there something wrong with the testcase where s=\"mqblbtpvicqhbrejb\"? My solution works perfectly fine for all the other testcases (26/27) except this one. "
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "[@arshadsaifi](/arshadsaifi) yeah , thanks for the response even though i corrected it previously i forgot to delete my comment\\n"
                    },
                    {
                        "username": "arshadsaifi",
                        "content": "No, the question is fine. You might have missed the case where the length of a line can be 100px. And your code might be returning 0 for that case."
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "for that test case , the total sum comes out to be 100 , which means only 1 line will be required , and the last line will be 100 pixels wide because there is only one line.\\nYou will have to add another condition for this according to your code."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "All cases passed for me. How to get test case  #26 input in UI? Or please post it here."
                    }
                ]
            },
            {
                "id": 1566290,
                "content": [
                    {
                        "username": "georgemeng2001@gmail.com",
                        "content": "The description is so bad, it does not give a clear description, the example helps, but has to read multiple times to guess and guess.\\n"
                    },
                    {
                        "username": "sjw214",
                        "content": "No idea what\\'s even being asked."
                    },
                    {
                        "username": "kenumida",
                        "content": "as the subject"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "my face when I read description \\uD83D\\uDE28\\uD83D\\uDE28\\uD83D\\uDE28\\nmy face when I looked at example \\uD83D\\uDE30\\uD83D\\uDE30\\uD83D\\uDE31\\uD83D\\uDE31 "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is there something wrong with the testcase where s=\"mqblbtpvicqhbrejb\"? My solution works perfectly fine for all the other testcases (26/27) except this one. "
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "[@arshadsaifi](/arshadsaifi) yeah , thanks for the response even though i corrected it previously i forgot to delete my comment\\n"
                    },
                    {
                        "username": "arshadsaifi",
                        "content": "No, the question is fine. You might have missed the case where the length of a line can be 100px. And your code might be returning 0 for that case."
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "for that test case , the total sum comes out to be 100 , which means only 1 line will be required , and the last line will be 100 pixels wide because there is only one line.\\nYou will have to add another condition for this according to your code."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "All cases passed for me. How to get test case  #26 input in UI? Or please post it here."
                    }
                ]
            },
            {
                "id": 1876774,
                "content": [
                    {
                        "username": "georgemeng2001@gmail.com",
                        "content": "The description is so bad, it does not give a clear description, the example helps, but has to read multiple times to guess and guess.\\n"
                    },
                    {
                        "username": "sjw214",
                        "content": "No idea what\\'s even being asked."
                    },
                    {
                        "username": "kenumida",
                        "content": "as the subject"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "my face when I read description \\uD83D\\uDE28\\uD83D\\uDE28\\uD83D\\uDE28\\nmy face when I looked at example \\uD83D\\uDE30\\uD83D\\uDE30\\uD83D\\uDE31\\uD83D\\uDE31 "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is there something wrong with the testcase where s=\"mqblbtpvicqhbrejb\"? My solution works perfectly fine for all the other testcases (26/27) except this one. "
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "[@arshadsaifi](/arshadsaifi) yeah , thanks for the response even though i corrected it previously i forgot to delete my comment\\n"
                    },
                    {
                        "username": "arshadsaifi",
                        "content": "No, the question is fine. You might have missed the case where the length of a line can be 100px. And your code might be returning 0 for that case."
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "for that test case , the total sum comes out to be 100 , which means only 1 line will be required , and the last line will be 100 pixels wide because there is only one line.\\nYou will have to add another condition for this according to your code."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "All cases passed for me. How to get test case  #26 input in UI? Or please post it here."
                    }
                ]
            },
            {
                "id": 1783261,
                "content": [
                    {
                        "username": "georgemeng2001@gmail.com",
                        "content": "The description is so bad, it does not give a clear description, the example helps, but has to read multiple times to guess and guess.\\n"
                    },
                    {
                        "username": "sjw214",
                        "content": "No idea what\\'s even being asked."
                    },
                    {
                        "username": "kenumida",
                        "content": "as the subject"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "my face when I read description \\uD83D\\uDE28\\uD83D\\uDE28\\uD83D\\uDE28\\nmy face when I looked at example \\uD83D\\uDE30\\uD83D\\uDE30\\uD83D\\uDE31\\uD83D\\uDE31 "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Is there something wrong with the testcase where s=\"mqblbtpvicqhbrejb\"? My solution works perfectly fine for all the other testcases (26/27) except this one. "
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "[@arshadsaifi](/arshadsaifi) yeah , thanks for the response even though i corrected it previously i forgot to delete my comment\\n"
                    },
                    {
                        "username": "arshadsaifi",
                        "content": "No, the question is fine. You might have missed the case where the length of a line can be 100px. And your code might be returning 0 for that case."
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "for that test case , the total sum comes out to be 100 , which means only 1 line will be required , and the last line will be 100 pixels wide because there is only one line.\\nYou will have to add another condition for this according to your code."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "All cases passed for me. How to get test case  #26 input in UI? Or please post it here."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Words That Can Be Formed by Characters",
        "question_content": "<p>You are given an array of strings <code>words</code> and a string <code>chars</code>.</p>\n\n<p>A string is <strong>good</strong> if it can be formed by characters from chars (each character can only be used once).</p>\n\n<p>Return <em>the sum of lengths of all good strings in words</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>chars</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 360978,
                "title": "c-track-count",
                "content": "```\\nint countCharacters(vector<string>& words, string chars) {\\n  int cnt[26] = {}, res = 0;\\n  for (auto ch : chars) \\n      ++cnt[ch - \\'a\\'];\\n  for (auto &w : words) {\\n    int cnt1[26] = {}, match = true;\\n    for (auto ch : w)\\n      if (++cnt1[ch - \\'a\\'] > cnt[ch - \\'a\\']) {\\n        match = false;\\n        break;\\n      }\\n    if (match) \\n        res += w.size();\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countCharacters(vector<string>& words, string chars) {\\n  int cnt[26] = {}, res = 0;\\n  for (auto ch : chars) \\n      ++cnt[ch - \\'a\\'];\\n  for (auto &w : words) {\\n    int cnt1[26] = {}, match = true;\\n    for (auto ch : w)\\n      if (++cnt1[ch - \\'a\\'] > cnt[ch - \\'a\\']) {\\n        match = false;\\n        break;\\n      }\\n    if (match) \\n        res += w.size();\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360962,
                "title": "java-python-3-count-chars-in-each-word",
                "content": "Count the characters in `chars` in array `cnt`, then for each word in `words` check if `cnt` has enough to cover it.\\n```\\n    public int countCharacters(String[] words, String chars) {\\n        int cnt[] = new int[26], ans = 0;\\n        chars.chars().forEach(c -> ++cnt[c - \\'a\\']); // count chars.\\nouter: \\n        for (String w : words) {\\n            int[] count = cnt.clone();\\n            for (char c : w.toCharArray())\\n                if (--count[c - \\'a\\'] < 0) // not enough, continue next word in words.\\n                    continue outer;\\n            ans += w.length();\\n        }\\n        return ans;\\n    }\\n```\\n```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        sum, chars_counter = 0, collections.Counter(chars)\\n        for word in words:\\n            word_counter = collections.Counter(word)\\n            for c in word_counter:\\n                if word_counter[c] > chars_counter[c]:\\n                    break\\n            else:\\n                sum += len(word)\\n        return sum\\n```\\nSimilar version without using `for - else`.\\n```python\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        sum, ct = 0, collections.Counter\\n        chars_counter = ct(chars)\\n        for word in words:\\n            word_counter = ct(word)\\n            if all(word_counter[c] <= chars_counter[c] for c in word_counter):\\n                sum += len(word)\\n        return sum\\n```\\n**Analysis:**\\n\\nTime:: O(n), space: O(1), where n is total characters in `words` and `chars`",
                "solutionTags": [],
                "code": "```\\n    public int countCharacters(String[] words, String chars) {\\n        int cnt[] = new int[26], ans = 0;\\n        chars.chars().forEach(c -> ++cnt[c - \\'a\\']); // count chars.\\nouter: \\n        for (String w : words) {\\n            int[] count = cnt.clone();\\n            for (char c : w.toCharArray())\\n                if (--count[c - \\'a\\'] < 0) // not enough, continue next word in words.\\n                    continue outer;\\n            ans += w.length();\\n        }\\n        return ans;\\n    }\\n```\n```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        sum, chars_counter = 0, collections.Counter(chars)\\n        for word in words:\\n            word_counter = collections.Counter(word)\\n            for c in word_counter:\\n                if word_counter[c] > chars_counter[c]:\\n                    break\\n            else:\\n                sum += len(word)\\n        return sum\\n```\n```python\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        sum, ct = 0, collections.Counter\\n        chars_counter = ct(chars)\\n        for word in words:\\n            word_counter = ct(word)\\n            if all(word_counter[c] <= chars_counter[c] for c in word_counter):\\n                sum += len(word)\\n        return sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 361004,
                "title": "easy-explained-simple-java-check-all-char-count",
                "content": "```\\n\\n    public static int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        int[] seen = new int[26];\\n\\t\\t//Count char of Chars String\\n        for (char c : chars.toCharArray())\\n            seen[c - \\'a\\']++;\\n\\t\\t// Comparing each word in words\\n        for (String word : words) {\\n\\t\\t\\t// simple making copy of seen arr\\n            int[] tSeen = Arrays.copyOf(seen, seen.length); \\n            int Tcount = 0;\\n            for (char c : word.toCharArray()) {\\n                if (tSeen[c - \\'a\\'] > 0) {\\n                    tSeen[c - \\'a\\']--;\\n                    Tcount++;\\n                }\\n            }\\n            if (Tcount == word.length())\\n                count += Tcount;\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public static int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        int[] seen = new int[26];\\n\\t\\t//Count char of Chars String\\n        for (char c : chars.toCharArray())\\n            seen[c - \\'a\\']++;\\n\\t\\t// Comparing each word in words\\n        for (String word : words) {\\n\\t\\t\\t// simple making copy of seen arr\\n            int[] tSeen = Arrays.copyOf(seen, seen.length); \\n            int Tcount = 0;\\n            for (char c : word.toCharArray()) {\\n                if (tSeen[c - \\'a\\'] > 0) {\\n                    tSeen[c - \\'a\\']--;\\n                    Tcount++;\\n                }\\n            }\\n            if (Tcount == word.length())\\n                count += Tcount;\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 570313,
                "title": "c-hashmap-solution-commented-easy-to-read-and-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        // Create a map to store the occurences of each character in \"chars\"\\n        // Each character is mapped to their frequency <char, int>\\n        vector<int> chFreq(26, 0);\\n        // if a character is found, increment its frequency, e.g chFreq[\\'a\\']++\\n        for(auto ch : chars) chFreq[ch - \\'a\\']++;\\n        \\n        // Declare an integer to store sum of all the strings that are valid\\n        int count = 0;\\n        \\n        // Loop through the vector=\\n        for(auto str : words){\\n            // Create a flag to switch to false if the string can not be formed from \"chars\"\\n            bool flag = true;\\n            // Create a map to store the frequency of characters in current string\\n            vector<int> copyFreq(26, 0);\\n            // Loop through string and if the frequency of any character in the string\\n            // is greater than the frequency of the same character \\n            // in the \"chars\" string, make flag false and end loop (word is invalid)\\n            for(auto ch : str) {\\n                if(++copyFreq[ch - \\'a\\'] > chFreq[ch - \\'a\\']){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            // Append string\\'s length to \"count\" if the flag is still true(valid)\\n            if(flag) count += str.size();\\n        }\\n        \\n        // Return count\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        // Create a map to store the occurences of each character in \"chars\"\\n        // Each character is mapped to their frequency <char, int>\\n        vector<int> chFreq(26, 0);\\n        // if a character is found, increment its frequency, e.g chFreq[\\'a\\']++\\n        for(auto ch : chars) chFreq[ch - \\'a\\']++;\\n        \\n        // Declare an integer to store sum of all the strings that are valid\\n        int count = 0;\\n        \\n        // Loop through the vector=\\n        for(auto str : words){\\n            // Create a flag to switch to false if the string can not be formed from \"chars\"\\n            bool flag = true;\\n            // Create a map to store the frequency of characters in current string\\n            vector<int> copyFreq(26, 0);\\n            // Loop through string and if the frequency of any character in the string\\n            // is greater than the frequency of the same character \\n            // in the \"chars\" string, make flag false and end loop (word is invalid)\\n            for(auto ch : str) {\\n                if(++copyFreq[ch - \\'a\\'] > chFreq[ch - \\'a\\']){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            // Append string\\'s length to \"count\" if the flag is still true(valid)\\n            if(flag) count += str.size();\\n        }\\n        \\n        // Return count\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361377,
                "title": "python-concise-1-liner",
                "content": "```\\nfrom collections import Counter as cnt\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(not cnt(w) - cnt(chars) and len(w) for w in words)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter as cnt\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(not cnt(w) - cnt(chars) and len(w) for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362309,
                "title": "python-3-solution-without-using-counter-class-75-runtime",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter = 0\\n        for w in words:\\n            included = True\\n            charsList = [c for c in chars]\\n            for c in w:\\n                if c in charsList:\\n                    charsList.remove(c)\\n                else:\\n                    included = False\\n                    break\\n            if included: counter = counter+len(w)\\n        return counter",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter = 0\\n        for w in words:\\n            included = True\\n            charsList = [c for c in chars]\\n            for c in w:\\n                if c in charsList:\\n                    charsList.remove(c)\\n                else:\\n                    included = False\\n                    break\\n            if included: counter = counter+len(w)\\n        return counter",
                "codeTag": "Java"
            },
            {
                "id": 999413,
                "title": "map-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& v, string s) {\\n          map<char,int> m,p;\\n          int t=0;\\n        \\n          for(auto c: s)\\n               m[c]++;\\n           \\n          for(int i=0;i<v.size();i++)\\n          {   \\n              p=m;\\n              bool ok=1;\\n             \\n              for(int j=0;j<v[i].size();j++)\\n              {\\n                 p[v[i][j]]--; \\n                 if(p[v[i][j]]<0)\\n                 {\\n                     ok=0;\\n                     break;\\n                 }\\n              }\\n              if(ok)\\n                  t+=v[i].size();\\n          }\\n        return t;\\n    }\\n};\\n                         \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A Please do UPVOTE if my code helps you \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countCharacters(vector<string>& v, string s) {\\n          map<char,int> m,p;\\n          int t=0;\\n        \\n          for(auto c: s)\\n               m[c]++;\\n           \\n          for(int i=0;i<v.size();i++)\\n          {   \\n              p=m;\\n              bool ok=1;\\n             \\n              for(int j=0;j<v[i].size();j++)\\n              {\\n                 p[v[i][j]]--; \\n                 if(p[v[i][j]]<0)\\n                 {\\n                     ok=0;\\n                     break;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1019831,
                "title": "java-straightforward-explanation",
                "content": "**Time Complexity:**`O(C + N * S)`, where `C` = length of chars, `N` = number of words, and `S` = longest word in words\\n**Space Complexity:** `O(1)` [considering the constraint of having only lowercase English letters]\\n```\\nclass Solution {\\n    public int[] charFreq = new int[26];\\n    \\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        for(char c : chars.toCharArray()) ++charFreq[c - \\'a\\'];\\n        for(String word : words) if(isGood(word)) count += word.length();\\n\\t\\t\\n        return count;\\n    }\\n    \\n    public boolean isGood(String word) {\\n        int[] localCharFreq = new int[26];\\n        for(char c : word.toCharArray()) ++localCharFreq[c - \\'a\\'];\\n        for(int i = 0; i < 26; i++) if(localCharFreq[i] > charFreq[i]) return false;\\n\\t\\t\\n        return true;\\n    }\\n}\\n/*\\nConstraint:\\nLowercase English letters => an int[] array of size 26, holding frequency of each char respectively.\\n\\nBase Logic:\\n1. Compute the frequency of characters in chars and store in charFreq.\\n2. Go through each word => if the word is \"good\" => increment the counter to this word\\'s length.\\n\\nLogic for how a word is \"good\" (isGood()):\\n1. Compute the frequency of characters in this word and store in (local) int[] array of size 26 (localCharFreq)\\n2. Loop through localCharFreq and compare with (global) charFreq\\n\\t=> if any element in localCharFreq has value > value in charFreq => return false.\\n3. Else return true.\\n\\nThe \"greater than\" comparison also considers the situation where a character present in the word doesn\\'t exist in chars.\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] charFreq = new int[26];\\n    \\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        for(char c : chars.toCharArray()) ++charFreq[c - \\'a\\'];\\n        for(String word : words) if(isGood(word)) count += word.length();\\n\\t\\t\\n        return count;\\n    }\\n    \\n    public boolean isGood(String word) {\\n        int[] localCharFreq = new int[26];\\n        for(char c : word.toCharArray()) ++localCharFreq[c - \\'a\\'];\\n        for(int i = 0; i < 26; i++) if(localCharFreq[i] > charFreq[i]) return false;\\n\\t\\t\\n        return true;\\n    }\\n}\\n/*\\nConstraint:\\nLowercase English letters => an int[] array of size 26, holding frequency of each char respectively.\\n\\nBase Logic:\\n1. Compute the frequency of characters in chars and store in charFreq.\\n2. Go through each word => if the word is \"good\" => increment the counter to this word\\'s length.\\n\\nLogic for how a word is \"good\" (isGood()):\\n1. Compute the frequency of characters in this word and store in (local) int[] array of size 26 (localCharFreq)\\n2. Loop through localCharFreq and compare with (global) charFreq\\n\\t=> if any element in localCharFreq has value > value in charFreq => return false.\\n3. Else return true.\\n\\nThe \"greater than\" comparison also considers the situation where a character present in the word doesn\\'t exist in chars.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361463,
                "title": "python-using-dictionary",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        tot = 0\\n        for w in words:\\n            d = {}\\n            for c in chars:\\n                if c in d: d[c] += 1\\n                else: d[c] = 1\\n             \\n            temp = 0\\n            for l in w:\\n                if l in d and d[l] > 0:\\n                    d[l] -= 1 \\n                    temp += 1\\n                else:\\n                    temp = 0\\n                    break\\n                    \\n            tot += temp\\n            \\n        return tot\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        tot = 0\\n        for w in words:\\n            d = {}\\n            for c in chars:\\n                if c in d: d[c] += 1\\n                else: d[c] = 1\\n             \\n            temp = 0\\n            for l in w:\\n                if l in d and d[l] > 0:\\n                    d[l] -= 1 \\n                    temp += 1\\n                else:\\n                    temp = 0\\n                    break\\n                    \\n            tot += temp\\n            \\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538391,
                "title": "1160-javascript-almost-1-line-solution-using-reduce",
                "content": "> Runtime: **188 ms**, faster than *63.52%* of JavaScript online submissions_\\n> Memory Usage: **43.9 MB**, less than *100.00%* of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nconst countCharacters = (words, chars) =>\\n  words.reduce((cnt, word, idx) => {\\n    for (const c of [...chars]) word = word.replace(c, \\'\\');\\n    return cnt + (0 === word.length ? words[idx].length : 0);\\n  }, 0);\\n```\\n\\nAnd here is a terse and performant solution with comments.\\n\\n> Runtime: **128 ms**, faster than *80.66%* of JavaScript online submissions\\n> Memory Usage: **44.7 MB**, less than *99.40%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * Count all the instances of each lowercase character in the given string\\n * and return an array with those counts in an array with indices of the\\n * alphabetical index of that character i.e. 0-25 = a-z\\n *\\n * @param {string} str\\n * @return {number[]}\\n */\\nconst strToCntArr = str => {\\n  // Create the array of all the character counts\\n  const arr = new Array(26).fill(0);\\n  // Increment the count for each character in the string\\n  for (let i = 0; i < str.length; i++) arr[str.charCodeAt(i) - 97]++;\\n  // Return the array with all the counts\\n  return arr;\\n};\\n\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nconst countCharacters = (words, chars) => {\\n  // The sum of length of the valid words\\n  let sum = 0;\\n  // Get the array with the counts of the characters we have\\n  const have = strToCntArr(chars);\\n  // Loop through the words\\n  outer: for (const word of words) {\\n    // Continue if we need more more total characters than we have\\n    if (chars.length < word.length) continue;\\n    // Get the array with the counts of the characters we need\\n    const need = strToCntArr(word);\\n    // Continue the outer loop when we need more characters than we have\\n    for (let i = 0; i < 26; i++) if (have[i] < need[i]) continue outer;\\n    // Any word that reaches this point is valid, so add the length to sum\\n    sum += word.length;\\n  }\\n  // Return the sum of the lengths of all the valid words\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nconst countCharacters = (words, chars) =>\\n  words.reduce((cnt, word, idx) => {\\n    for (const c of [...chars]) word = word.replace(c, \\'\\');\\n    return cnt + (0 === word.length ? words[idx].length : 0);\\n  }, 0);\\n```\n```javascript\\n/**\\n * Count all the instances of each lowercase character in the given string\\n * and return an array with those counts in an array with indices of the\\n * alphabetical index of that character i.e. 0-25 = a-z\\n *\\n * @param {string} str\\n * @return {number[]}\\n */\\nconst strToCntArr = str => {\\n  // Create the array of all the character counts\\n  const arr = new Array(26).fill(0);\\n  // Increment the count for each character in the string\\n  for (let i = 0; i < str.length; i++) arr[str.charCodeAt(i) - 97]++;\\n  // Return the array with all the counts\\n  return arr;\\n};\\n\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nconst countCharacters = (words, chars) => {\\n  // The sum of length of the valid words\\n  let sum = 0;\\n  // Get the array with the counts of the characters we have\\n  const have = strToCntArr(chars);\\n  // Loop through the words\\n  outer: for (const word of words) {\\n    // Continue if we need more more total characters than we have\\n    if (chars.length < word.length) continue;\\n    // Get the array with the counts of the characters we need\\n    const need = strToCntArr(word);\\n    // Continue the outer loop when we need more characters than we have\\n    for (let i = 0; i < 26; i++) if (have[i] < need[i]) continue outer;\\n    // Any word that reaches this point is valid, so add the length to sum\\n    sum += word.length;\\n  }\\n  // Return the sum of the lengths of all the valid words\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364795,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        res = 0\\n\\n        for word in words:\\n            indicator = True\\n            for i in word:\\n                if word.count(i) > chars.count(i):\\n                    indicator = False\\n                    break\\n            if indicator:\\n                res += len(word)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        res = 0\\n\\n        for word in words:\\n            indicator = True\\n            for i in word:\\n                if word.count(i) > chars.count(i):\\n                    indicator = False\\n                    break\\n            if indicator:\\n                res += len(word)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363513,
                "title": "java-solution-using-hashmap",
                "content": "```\\n    public int countCharacters(String[] words, String chars) {\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (char c : chars.toCharArray()) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        int res = 0;\\n        HashMap<Character, Integer> copyMap;\\n        for (String word : words) {\\n            copyMap = (HashMap<Character, Integer>) countMap.clone();\\n            boolean fail = false;\\n            for (char c : word.toCharArray()) {\\n                if (copyMap.get(c) == null || copyMap.get(c) <= 0) {\\n                    fail = true;\\n                    break;\\n                } else {\\n                    copyMap.put(c, copyMap.get(c) - 1);\\n                }\\n            }\\n            if (!fail) res += word.length();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countCharacters(String[] words, String chars) {\\n        HashMap<Character, Integer> countMap = new HashMap<>();\\n        for (char c : chars.toCharArray()) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        int res = 0;\\n        HashMap<Character, Integer> copyMap;\\n        for (String word : words) {\\n            copyMap = (HashMap<Character, Integer>) countMap.clone();\\n            boolean fail = false;\\n            for (char c : word.toCharArray()) {\\n                if (copyMap.get(c) == null || copyMap.get(c) <= 0) {\\n                    fail = true;\\n                    break;\\n                } else {\\n                    copyMap.put(c, copyMap.get(c) - 1);\\n                }\\n            }\\n            if (!fail) res += word.length();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374231,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    let total = 0;\\n    for (let word of words) {\\n        let map = createMap(chars);       \\n        if (isWordGood(word, map)) {\\n            total += word.length;  \\n        }        \\n    }\\n    \\n    return total;   \\n};\\n\\nvar createMap = function(chars) {\\n    let map = {};\\n    for(let i = 0; i < chars.length; i++) {\\n        if (!map[chars[i]]) {\\n            map[chars[i]] = 0;\\n        } \\n        map[chars[i]]++;        \\n    }\\n    \\n    return map;\\n}\\n\\nvar isWordGood = function(word, map) {\\n    for (let i = 0; i < word.length; i++) {\\n        if (!map[word[i]] || map[word[i]] == 0) {\\n            return false;\\n        }\\n        map[word[i]]--;\\n    }\\n    \\n    return true;\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    let total = 0;\\n    for (let word of words) {\\n        let map = createMap(chars);       \\n        if (isWordGood(word, map)) {\\n            total += word.length;  \\n        }        \\n    }\\n    \\n    return total;   \\n};\\n\\nvar createMap = function(chars) {\\n    let map = {};\\n    for(let i = 0; i < chars.length; i++) {\\n        if (!map[chars[i]]) {\\n            map[chars[i]] = 0;\\n        } \\n        map[chars[i]]++;        \\n    }\\n    \\n    return map;\\n}\\n\\nvar isWordGood = function(word, map) {\\n    for (let i = 0; i < word.length; i++) {\\n        if (!map[word[i]] || map[word[i]] == 0) {\\n            return false;\\n        }\\n        map[word[i]]--;\\n    }\\n    \\n    return true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 813520,
                "title": "java-hashmap-solution-with-commented-code-and-basic-explanation",
                "content": "I am writing this explanation because this one actually confused me at first, though it is actually remarkably simple.\\n\\nThe basic idea is to put each character in \\'chars\\' into a HashMap alongside the number of times it appears in \\'chars\\'. We treat this value as the number of remaining uses. Then, for each word in our array, we copy the map and then loop through each character in the word. Whenever there is a character in the word that exists as a key in the map copy, we decrement the value for that key. \\n\\nIf the word has any character that is not in the map copy, or if it uses a character more times than is allowed, we mark the word as not good and stop iterating over that word. If all goes well, we mark the word as good and add its length to our result. \\n\\nI hope that helps anyone who is confused.\\n\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n       \\n        HashMap<Character, Integer> map = new HashMap<>(); \\n        \\n        for(char ch: chars.toCharArray()){ //Create a hashmap where the value of each character key is the number of times it appears in \\'chars\\'. Think of it as the number of uses available. \\n            map.put(ch, map.getOrDefault(ch, 0) + 1); //if the key is not already in the map, add it and set the value to 1. If it is already in the map, add one to the value (number of uses)\\n        }\\n        \\n        //The above hashmap is only used as a template to make copies we can use when we check\\n        \\n        int result = 0; //initialize the result\\n        \\n        for(String word: words) { //For every string in words, we make a temp hashmap by copying the main hashmap. We default to being a \\'good\\' string. \\n            \\n            HashMap<Character, Integer> temp = new HashMap<>(map);\\n            boolean good = true;\\n            \\n            //Next, we iterate over the word. \\n            for(int i = 0; i < word.length(); i++){\\n                char ch = word.charAt(i); \\n                \\n                //If our temp map contains the character and the number of remaining uses of that character is greater than 0,\\n                if(temp.containsKey(ch) && temp.get(ch) > 0){\\n                    \\n                    temp.put(ch, temp.get(ch) -1); //Then decrement the number of remaining uses of ch in the hashmap. \\n                    \\n                } else {\\n                    \\n                    //if at any point we find a character in our word that is either not in the map, or has run out of uses, then this is not a good word. End the loop so we can return.\\n                    good = false;\\n                    break;\\n                    \\n                }\\n            }\\n            \\n            //When the loops have stopped running, see if the word is good. If it is, add its length to our result, and then check the next word.\\n            if(good) {\\n                result += word.length();\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n       \\n        HashMap<Character, Integer> map = new HashMap<>(); \\n        \\n        for(char ch: chars.toCharArray()){ //Create a hashmap where the value of each character key is the number of times it appears in \\'chars\\'. Think of it as the number of uses available. \\n            map.put(ch, map.getOrDefault(ch, 0) + 1); //if the key is not already in the map, add it and set the value to 1. If it is already in the map, add one to the value (number of uses)\\n        }\\n        \\n        //The above hashmap is only used as a template to make copies we can use when we check\\n        \\n        int result = 0; //initialize the result\\n        \\n        for(String word: words) { //For every string in words, we make a temp hashmap by copying the main hashmap. We default to being a \\'good\\' string. \\n            \\n            HashMap<Character, Integer> temp = new HashMap<>(map);\\n            boolean good = true;\\n            \\n            //Next, we iterate over the word. \\n            for(int i = 0; i < word.length(); i++){\\n                char ch = word.charAt(i); \\n                \\n                //If our temp map contains the character and the number of remaining uses of that character is greater than 0,\\n                if(temp.containsKey(ch) && temp.get(ch) > 0){\\n                    \\n                    temp.put(ch, temp.get(ch) -1); //Then decrement the number of remaining uses of ch in the hashmap. \\n                    \\n                } else {\\n                    \\n                    //if at any point we find a character in our word that is either not in the map, or has run out of uses, then this is not a good word. End the loop so we can return.\\n                    good = false;\\n                    break;\\n                    \\n                }\\n            }\\n            \\n            //When the loops have stopped running, see if the word is good. If it is, add its length to our result, and then check the next word.\\n            if(good) {\\n                result += word.length();\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930339,
                "title": "python-faster-than-99-86-d",
                "content": "# Code\\n###### **NOTE**: This code was changed because of @potatopie\\'s suggestion. (check comments)\\n\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length=[]\\n        for i in words:\\n            for j in i:\\n                if chars.count(j) < i.count(j): \\n                    break\\n            else:\\n                length.append(len(i))\\n        return sum(length)\\n```\\n\\n###### **NOTE**: This code was added as mentioned as a reply to @Coder-Haris\\'s comment. (check comments)\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length = []\\n        freq = collections.defaultdict(lambda: 0)\\n        for c in chars:\\n            freq[c] += 1\\n\\n        for i in words:\\n            for j in i:\\n                if freq[j] < i.count(j): \\n                    break\\n            else:\\n                length.append(len(i))\\n        return sum(length)\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/ee98e7d8-9fb7-4d8f-963e-a1407a6e5b5c_1671504290.1059043.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length=[]\\n        for i in words:\\n            for j in i:\\n                if chars.count(j) < i.count(j): \\n                    break\\n            else:\\n                length.append(len(i))\\n        return sum(length)\\n```\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length = []\\n        freq = collections.defaultdict(lambda: 0)\\n        for c in chars:\\n            freq[c] += 1\\n\\n        for i in words:\\n            for j in i:\\n                if freq[j] < i.count(j): \\n                    break\\n            else:\\n                length.append(len(i))\\n        return sum(length)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728800,
                "title": "easy-c-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        unordered_map<char,int> chFreq;\\n        for(auto ch : chars) chFreq[ch]++;\\n        bool flag = true;\\n        string count = \"\";\\n        for(auto str : words){\\n            flag = true;\\n            unordered_map<char,int> copyFreq;\\n            for(auto ch : str) copyFreq[ch]++;\\n            for(auto ch : str) if(copyFreq[ch] > chFreq[ch]) flag = false;\\n            if(flag) count += str;\\n        }\\n        return count.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        unordered_map<char,int> chFreq;\\n        for(auto ch : chars) chFreq[ch]++;\\n        bool flag = true;\\n        string count = \"\";\\n        for(auto str : words){\\n            flag = true;\\n            unordered_map<char,int> copyFreq;\\n            for(auto ch : str) copyFreq[ch]++;\\n            for(auto ch : str) if(copyFreq[ch] > chFreq[ch]) flag = false;\\n            if(flag) count += str;\\n        }\\n        return count.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920728,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\n        ans = 0\\n        for word in words:\\n            flag = 1\\n            for char in word:\\n                if chars.count(char) < word.count(char):\\n                    flag = 0\\n                    break\\n            if flag:\\n                ans += len(word)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\n        ans = 0\\n        for word in words:\\n            flag = 1\\n            for char in word:\\n                if chars.count(char) < word.count(char):\\n                    flag = 0\\n                    break\\n            if flag:\\n                ans += len(word)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 364805,
                "title": "python-solution-faster-than-100",
                "content": "```python\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ret = 0\\n\\n        for word in words:\\n            boolean = True\\n            for i in word:\\n                if word.count(i) > chars.count(i):\\n                    boolean = False\\n                    break\\n            if boolean:\\n                ret += len(word)\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ret = 0\\n\\n        for word in words:\\n            boolean = True\\n            for i in word:\\n                if word.count(i) > chars.count(i):\\n                    boolean = False\\n                    break\\n            if boolean:\\n                ret += len(word)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361877,
                "title": "javascript",
                "content": "```\\nvar countCharacters = function(words, chars) {\\n    \\n    let count = 0\\n    \\n    const makeHash = (word) => {\\n        let hash = {}\\n        for (let i = 0; i < word.length; i++){\\n            hash[word[i]] ? hash[word[i]]++ : hash[word[i]] = 1\\n        }\\n        return hash\\n    }\\n    \\n    let hash = makeHash(chars)\\n        \\n    for (let i = 0; i < words.length; i++){\\n        let bool = true\\n        let temp = makeHash(words[i])\\n        for(let key in temp){\\n            if (!hash[key] || hash[key] < temp[key]){\\n                bool = false\\n            }\\n        }\\n        bool && (count += words[i].length)\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    \\n    let count = 0\\n    \\n    const makeHash = (word) => {\\n        let hash = {}\\n        for (let i = 0; i < word.length; i++){\\n            hash[word[i]] ? hash[word[i]]++ : hash[word[i]] = 1\\n        }\\n        return hash\\n    }\\n    \\n    let hash = makeHash(chars)\\n        \\n    for (let i = 0; i < words.length; i++){\\n        let bool = true\\n        let temp = makeHash(words[i])\\n        for(let key in temp){\\n            if (!hash[key] || hash[key] < temp[key]){\\n                bool = false\\n            }\\n        }\\n        bool && (count += words[i].length)\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547774,
                "title": "java-array-ascii-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int arr1[] = new int[26];\\n        for(int i=0;i<chars.length();i++){\\n            int num = chars.charAt(i)-97;\\n            arr1[num]++;\\n        }\\n        int len=0;\\n        for(int i=0;i<words.length;i++){\\n            String str = words[i];\\n            int arr2[] = new int[26];\\n            for(int j=0;j<str.length();j++){\\n                int num = str.charAt(j)-97;\\n                arr2[num]++;\\n            }\\n            int flag=0;\\n            for(int k=0;k<26;k++){\\n                if(arr2[k]>arr1[k]){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                len=len+str.length();\\n        }\\n        return len;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int arr1[] = new int[26];\\n        for(int i=0;i<chars.length();i++){\\n            int num = chars.charAt(i)-97;\\n            arr1[num]++;\\n        }\\n        int len=0;\\n        for(int i=0;i<words.length;i++){\\n            String str = words[i];\\n            int arr2[] = new int[26];\\n            for(int j=0;j<str.length();j++){\\n                int num = str.charAt(j)-97;\\n                arr2[num]++;\\n            }\\n            int flag=0;\\n            for(int k=0;k<26;k++){\\n                if(arr2[k]>arr1[k]){\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                len=len+str.length();\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964311,
                "title": "c-count-stl-function-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) \\n    {\\n        int sum=0,c=0;\\n        for(auto &x: words)\\n        {\\n            for(auto &ch : x)\\n            {\\n                if(count(x.begin(),x.end(),ch)<=count(chars.begin(),chars.end(),ch))\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c=0;\\n                    break;\\n                }\\n            }\\n            sum=sum+c;\\n            c=0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) \\n    {\\n        int sum=0,c=0;\\n        for(auto &x: words)\\n        {\\n            for(auto &ch : x)\\n            {\\n                if(count(x.begin(),x.end(),ch)<=count(chars.begin(),chars.end(),ch))\\n                {\\n                    c++;\\n                }\\n                else\\n                {\\n                    c=0;\\n                    break;\\n                }\\n            }\\n            sum=sum+c;\\n            c=0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177578,
                "title": "python3-o-n-2-o-1-runtime-96ms-97-20-memory-14-5mb-84-92",
                "content": "```\\nclass Solution:\\n#     O(n^2) || O(1)\\n# Runtime: 96ms 97.20% Memory: 14.5mb 84.92%\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=0\\n        for word in words:\\n            for ch in word:\\n                if word.count(ch)>chars.count(ch):\\n                    break\\n            else:\\n                ans+=len(word)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n^2) || O(1)\\n# Runtime: 96ms 97.20% Memory: 14.5mb 84.92%\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=0\\n        for word in words:\\n            for ch in word:\\n                if word.count(ch)>chars.count(ch):\\n                    break\\n            else:\\n                ans+=len(word)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694903,
                "title": "javascript-solution",
                "content": "## Please upvote, if it helps you!\\n\\n```\\nvar countCharacters = function(words, chars) {\\n    function generateMap(string) {\\n        let map = {}\\n        for (let char of string) {\\n            map[char] = map[char] ? map[char] + 1 : 1\\n        }\\n        return map\\n    }\\n    \\n    let count = 0\\n    \\n    for (let word of words) {\\n        let map = generateMap(chars)\\n        let isValidWord = true\\n        for (let char of word) {            \\n            if (map[char] > 0) {\\n                map[char] -= 1\\n            } else {\\n                isValidWord = false\\n            }\\n        }\\n        if (isValidWord) {\\n            count += word.length\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    function generateMap(string) {\\n        let map = {}\\n        for (let char of string) {\\n            map[char] = map[char] ? map[char] + 1 : 1\\n        }\\n        return map\\n    }\\n    \\n    let count = 0\\n    \\n    for (let word of words) {\\n        let map = generateMap(chars)\\n        let isValidWord = true\\n        for (let char of word) {            \\n            if (map[char] > 0) {\\n                map[char] -= 1\\n            } else {\\n                isValidWord = false\\n            }\\n        }\\n        if (isValidWord) {\\n            count += word.length\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559328,
                "title": "java-count-in-array-explained",
                "content": "You can solve this in muplitple way, just alternative one for fun.\\nUse array of 26 to count freq of every char in \"chars\".\\nThen iterate over array of words and for each one start counting freq of chars in that word. Every time we count one char in a word compare if that char count is no more than a count of the same char in \"chars\". If greater - this word cannnot be count. Otherwise in the end add length of the word to result.\\n\\nO(NxM) time - need to check every char in every word in words. O(1) space (we use arrays of length 26)\\n\\n```\\n    public int countCharacters(String[] words, String chars) {\\n        if (chars == null || chars.isEmpty() || words == null || words.length == 0)\\n            return 0;\\n        \\n        int[] counts = new int[26];\\n        for (char ch : chars.toCharArray()) {\\n            ++counts[ch - \\'a\\'];    \\n        }\\n        \\n        int res = 0;\\n        for (String w : words) {\\n            int[] wordCounts = new int[26];\\n            boolean possible = true;\\n            for (char ch : w.toCharArray()) {\\n                int idx = ch - \\'a\\';\\n                ++wordCounts[idx];\\n                if (wordCounts[idx] > counts[idx]) {\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n    \\n            if (!possible)\\n                continue;\\n            \\n            res+=w.length();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\n    public int countCharacters(String[] words, String chars) {\\n        if (chars == null || chars.isEmpty() || words == null || words.length == 0)\\n            return 0;\\n        \\n        int[] counts = new int[26];\\n        for (char ch : chars.toCharArray()) {\\n            ++counts[ch - \\'a\\'];    \\n        }\\n        \\n        int res = 0;\\n        for (String w : words) {\\n            int[] wordCounts = new int[26];\\n            boolean possible = true;\\n            for (char ch : w.toCharArray()) {\\n                int idx = ch - \\'a\\';\\n                ++wordCounts[idx];\\n                if (wordCounts[idx] > counts[idx]) {\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n    \\n            if (!possible)\\n                continue;\\n            \\n            res+=w.length();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386685,
                "title": "python-3-one-liner-abomination",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum([len(w) if (False not in [False if (w.count(l) > chars.count(l)) else True for l in [chr(c) for c in range(97, 123)]]) else 0 for w in words])\\n```\\n\\t\\t\\nNice",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum([len(w) if (False not in [False if (w.count(l) > chars.count(l)) else True for l in [chr(c) for c in range(97, 123)]]) else 0 for w in words])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128433,
                "title": "simple-java-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nAlgorithm - \\n1. Initialize the count to 0. \\n2. Iterate through an array of strings. \\n    - Check if the string element at index, i is good with the string, chars. \\n        - If it is good, increment the count by the length of the string, words[i]. \\n3. Return the value of the count variable onto the main method. \\n\\nHelper Function isGood - \\n1. Create a hashmap to map the characters in string, chars to the occurrence by iterating through the string, chars. \\n2. Check the elements of hashmap and its occurrence before modification. \\n3. Iterate through the string word and check if the character, ch exists in the hashmap and its occurrence is greater than 0, \\nif it is then decrement the occurrence of that character by 1 and assign the new value to the key (i.e, character ch) onto the hashmap, hm. \\nElse, return false if the character is not present in the hashmap or the count of the character is equal to 0. \\n4. Verify the hashmap after modification for error checks/testing. \\n5. Return true onto the calling function if the string is good. \\n\\nComplexity Analysis - \\n1. Time Complexity = O(N ^ 2 + N * M) => O(N ^ 2)\\n2. Space Complexity = O(N)\\n\\n*/\\n\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isGood(words[i], chars)) {\\n                System.out.println(\"Good\");\\n                count += words[i].length();\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean isGood(String word, String chars) {\\n        Map<Character, Integer> hm = new HashMap<>();\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars.charAt(i);\\n            hm.put(ch, hm.getOrDefault(ch, 0) + 1);\\n        }\\n        System.out.println(\"Hashmap before modification  \" + hm);\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (hm.containsKey(ch) && hm.get(ch) > 0) {\\n                hm.put(ch, hm.get(ch) - 1);\\n            } else {\\n                return false;\\n            }\\n        }\\n        System.out.println(\"Hashmap after modification \" + hm);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nAlgorithm - \\n1. Initialize the count to 0. \\n2. Iterate through an array of strings. \\n    - Check if the string element at index, i is good with the string, chars. \\n        - If it is good, increment the count by the length of the string, words[i]. \\n3. Return the value of the count variable onto the main method. \\n\\nHelper Function isGood - \\n1. Create a hashmap to map the characters in string, chars to the occurrence by iterating through the string, chars. \\n2. Check the elements of hashmap and its occurrence before modification. \\n3. Iterate through the string word and check if the character, ch exists in the hashmap and its occurrence is greater than 0, \\nif it is then decrement the occurrence of that character by 1 and assign the new value to the key (i.e, character ch) onto the hashmap, hm. \\nElse, return false if the character is not present in the hashmap or the count of the character is equal to 0. \\n4. Verify the hashmap after modification for error checks/testing. \\n5. Return true onto the calling function if the string is good. \\n\\nComplexity Analysis - \\n1. Time Complexity = O(N ^ 2 + N * M) => O(N ^ 2)\\n2. Space Complexity = O(N)\\n\\n*/\\n\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isGood(words[i], chars)) {\\n                System.out.println(\"Good\");\\n                count += words[i].length();\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean isGood(String word, String chars) {\\n        Map<Character, Integer> hm = new HashMap<>();\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars.charAt(i);\\n            hm.put(ch, hm.getOrDefault(ch, 0) + 1);\\n        }\\n        System.out.println(\"Hashmap before modification  \" + hm);\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (hm.containsKey(ch) && hm.get(ch) > 0) {\\n                hm.put(ch, hm.get(ch) - 1);\\n            } else {\\n                return false;\\n            }\\n        }\\n        System.out.println(\"Hashmap after modification \" + hm);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924506,
                "title": "find-words-that-can-be-formed-by-characters-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countCharacters(String[] words, String chars) {\\n    int ans = 0;\\n    int[] count = new int[26];\\n\\n    for (final char c : chars.toCharArray())\\n      ++count[c - \\'a\\'];\\n\\n    for (final String word : words) {\\n      int[] tempCount = count.clone();\\n      for (final char c : word.toCharArray())\\n        if (--tempCount[c - \\'a\\'] < 0) {\\n          ans -= word.length();\\n          break;\\n        }\\n      ans += word.length();\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public int countCharacters(String[] words, String chars) {\\n    int ans = 0;\\n    int[] count = new int[26];\\n\\n    for (final char c : chars.toCharArray())\\n      ++count[c - \\'a\\'];\\n\\n    for (final String word : words) {\\n      int[] tempCount = count.clone();\\n      for (final char c : word.toCharArray())\\n        if (--tempCount[c - \\'a\\'] < 0) {\\n          ans -= word.length();\\n          break;\\n        }\\n      ans += word.length();\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188726,
                "title": "python-1-liner",
                "content": "In Python, you can comapre dictionaries.\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(len(word) if collections.Counter(word) <= collections.Counter(chars) else 0 for word in words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(len(word) if collections.Counter(word) <= collections.Counter(chars) else 0 for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147614,
                "title": "simple-java-solution-highly-readable-and-commented",
                "content": "```\\nclass Solution {\\n    private boolean ifWordFeasible(String word, int[] charsFreq) {\\n        for (char chr: word.toCharArray()) { \\n            --charsFreq[chr-\\'a\\']; //reduce frequency of characters in the word\\n            if (charsFreq[chr-\\'a\\'] < 0) return false; //Check if anywhere insufficient chars (i.e use characters from chars string) are there in that case return false\\n        }\\n        return true;\\n        \\n    }\\n    public int countCharacters(String[] words, String chars) {\\n        int result=0; // result variable to store the answer\\n        \\n        for (String word: words) { //iterate over words\\n            int[] charsFreq = new int[26]; //Maintain frequency of characters in chars\\n            for (char chr: chars.toCharArray()) ++charsFreq[chr-\\'a\\']; //Count frequency for all 26 alphabets\\n            if (ifWordFeasible(word, charsFreq))  result += word.length(); // check if word is feasible and add length if feasible\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean ifWordFeasible(String word, int[] charsFreq) {\\n        for (char chr: word.toCharArray()) { \\n            --charsFreq[chr-\\'a\\']; //reduce frequency of characters in the word\\n            if (charsFreq[chr-\\'a\\'] < 0) return false; //Check if anywhere insufficient chars (i.e use characters from chars string) are there in that case return false\\n        }\\n        return true;\\n        \\n    }\\n    public int countCharacters(String[] words, String chars) {\\n        int result=0; // result variable to store the answer\\n        \\n        for (String word: words) { //iterate over words\\n            int[] charsFreq = new int[26]; //Maintain frequency of characters in chars\\n            for (char chr: chars.toCharArray()) ++charsFreq[chr-\\'a\\']; //Count frequency for all 26 alphabets\\n            if (ifWordFeasible(word, charsFreq))  result += word.length(); // check if word is feasible and add length if feasible\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067968,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countCharacters(vector<string>& words, string chars) {\\t\\n\\t\\t\\tvector<int> charfrequency(26,0);\\n\\t\\t\\tbool canform = true;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(char &ch:chars) {\\n\\t\\t\\t\\tcharfrequency[ch - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &word:words){\\n\\t\\t\\t\\tvector<int> wordfrequency(26,0);\\n\\t\\t\\t\\tfor(auto &ch:word){\\n\\t\\t\\t\\t\\twordfrequency[ch - \\'a\\']++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i = 0;i<charfrequency.size();i++){\\n\\t\\t\\t\\t\\tif(wordfrequency[i] > charfrequency[i]){\\n\\t\\t\\t\\t\\t\\tcanform = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse canform = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(canform) count += word.length();\\n\\t\\t\\t}\\n\\t\\t\\treturn count;    \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countCharacters(vector<string>& words, string chars) {\\t\\n\\t\\t\\tvector<int> charfrequency(26,0);\\n\\t\\t\\tbool canform = true;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(char &ch:chars) {\\n\\t\\t\\t\\tcharfrequency[ch - \\'a\\']++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 694572,
                "title": "clean-js-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    let res = 0;\\n    for (let word of words) {\\n        if (word.length > chars.length) continue;\\n        if (isGoodString(word, chars)) res += word.length;\\n    }\\n    return res;\\n};\\n    \\nvar isGoodString = function(word, chars) {\\n    let arr = chars.split(\"\");\\n    for (let char of word) {\\n        let idx = arr.indexOf(char);\\n        if (idx === -1) return false;\\n        else arr[idx] = \"\";\\n    }      \\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    let res = 0;\\n    for (let word of words) {\\n        if (word.length > chars.length) continue;\\n        if (isGoodString(word, chars)) res += word.length;\\n    }\\n    return res;\\n};\\n    \\nvar isGoodString = function(word, chars) {\\n    let arr = chars.split(\"\");\\n    for (let char of word) {\\n        let idx = arr.indexOf(char);\\n        if (idx === -1) return false;\\n        else arr[idx] = \"\";\\n    }      \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454173,
                "title": "c-40-stl-includes",
                "content": "class Solution {\\npublic:\\n    int countCharacters(std::vector<std::string>& words, std::string chars) {\\n        \\n        int res = 0;\\n        \\n        std::sort(chars.begin(), chars.end());\\n        \\n        for(auto & el: words)\\n        {\\n            std::sort(el.begin(), el.end());\\n        }\\n        \\n        for(size_t i = 0; i < words.size(); i++)\\n        {\\n            if(std::includes(chars.begin(), chars.end(), words[i].begin(), words[i].end()))\\n            {\\n                res += words[i].size();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countCharacters(std::vector<std::string>& words, std::string chars) {\\n        \\n        int res = 0;\\n        \\n        std::sort(chars.begin(), chars.end());\\n        \\n        for(auto & el: words)\\n        {\\n            std::sort(el.begin(), el.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 365638,
                "title": "python-3-simple-solution",
                "content": "class Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c = 0\\n        for i in words:\\n            flag = True\\n            for j in i:\\n                if i.count(j)>chars.count(j):\\n                    flag = False\\n            if flag:\\n                c = c + len(i)\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c = 0\\n        for i in words:\\n            flag = True\\n            for j in i:\\n                if i.count(j)>chars.count(j):\\n                    flag = False\\n            if flag:\\n                c = c + len(i)\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 364223,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] dict = new int[256];\\n        for (char c : chars.toCharArray()) {\\n            dict[c]++;\\n        }\\n        int res = 0;\\n        for (String word : words) {\\n            int[] curDict = new int[256];\\n            boolean isValid = true;\\n            for (char c : word.toCharArray()) {\\n                curDict[c]++;\\n                if (curDict[c] > dict[c]) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            res += isValid ? word.length() : 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] dict = new int[256];\\n        for (char c : chars.toCharArray()) {\\n            dict[c]++;\\n        }\\n        int res = 0;\\n        for (String word : words) {\\n            int[] curDict = new int[256];\\n            boolean isValid = true;\\n            for (char c : word.toCharArray()) {\\n                curDict[c]++;\\n                if (curDict[c] > dict[c]) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            res += isValid ? word.length() : 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476433,
                "title": "simple-solution-with-go",
                "content": "```\\nfunc countCharacters(words []string, chars string) int {\\n    charSet := make([]int, 26)\\n    \\n    for i := 0; i < len(chars); i++ {\\n        charSet[int(chars[i] - \\'a\\')]++\\n    }\\n    \\n    sum := 0\\n    \\n    for _, word := range words {\\n        currentCharSet := make([]int, 26)\\n        copy(currentCharSet, charSet)\\n        \\n        isValid := true\\n        \\n        for i := 0; i < len(word); i++ {\\n            currentCharSet[int(word[i] - \\'a\\')]--\\n            \\n            if currentCharSet[int(word[i] - \\'a\\')] < 0 {\\n                isValid = false\\n                break\\n            }\\n        }\\n        \\n        if isValid {\\n            sum += len(word)\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countCharacters(words []string, chars string) int {\\n    charSet := make([]int, 26)\\n    \\n    for i := 0; i < len(chars); i++ {\\n        charSet[int(chars[i] - \\'a\\')]++\\n    }\\n    \\n    sum := 0\\n    \\n    for _, word := range words {\\n        currentCharSet := make([]int, 26)\\n        copy(currentCharSet, charSet)\\n        \\n        isValid := true\\n        \\n        for i := 0; i < len(word); i++ {\\n            currentCharSet[int(word[i] - \\'a\\')]--\\n            \\n            if currentCharSet[int(word[i] - \\'a\\')] < 0 {\\n                isValid = false\\n                break\\n            }\\n        }\\n        \\n        if isValid {\\n            sum += len(word)\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395219,
                "title": "python-using-set-and-list-comprehension",
                "content": "```\\nclass Solution(object):\\n    def countCharacters(self, words, chars):\\n        \"\"\"\\n        :type words: List[str]\\n        :type chars: str\\n        :rtype: int\\n        \"\"\"\\n        b = set(chars)\\n        anwser = 0\\n        for i in words:\\n            a = set(i)\\n            if a.issubset(b):\\n                test = [o for o in a if chars.count(o) < i.count(o)]\\n                if len(test) == 0:    \\n                    anwser += len(i)\\n        return anwser\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def countCharacters(self, words, chars):\\n        \"\"\"\\n        :type words: List[str]\\n        :type chars: str\\n        :rtype: int\\n        \"\"\"\\n        b = set(chars)\\n        anwser = 0\\n        for i in words:\\n            a = set(i)\\n            if a.issubset(b):\\n                test = [o for o in a if chars.count(o) < i.count(o)]\\n                if len(test) == 0:    \\n                    anwser += len(i)\\n        return anwser\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156172,
                "title": "java-solution",
                "content": "I personally don\\'t like this problem becasue the description is so vauge. \\n  \\n  ```\\n  class Solution \\n{\\n    public int countCharacters(String[] words, String chars)\\n    {\\n        HashMap<Character, Integer> myMap = new HashMap<>();\\n        int res = 0;\\n          \\n        for(char ch : chars.toCharArray())\\n            myMap.put(ch, myMap.getOrDefault(ch, 0) + 1);\\n        \\n        for(String word: words)\\n        {\\n            HashMap<Character, Integer> count = new HashMap<>();\\n            int i = 0;\\n            \\n            for(; i < word.length(); i++)\\n            {\\n                char ch = word.charAt(i);\\n                \\n                if(myMap.containsKey(ch)) \\n                {\\n                    if(count.containsKey(ch) && count.get(ch) + 1 > myMap.get(ch))\\n                        break;\\n                    count.put(ch, count.getOrDefault(ch, 0) + 1);\\n                } \\n                else\\n                    break;\\n            }\\n            if(i == word.length())\\n                res += word.length();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Solution \\n{\\n    public int countCharacters(String[] words, String chars)\\n    {\\n        HashMap<Character, Integer> myMap = new HashMap<>();\\n        int res = 0;\\n          \\n        for(char ch : chars.toCharArray())\\n            myMap.put(ch, myMap.getOrDefault(ch, 0) + 1);\\n        \\n        for(String word: words)\\n        {\\n            HashMap<Character, Integer> count = new HashMap<>();\\n            int i = 0;\\n            \\n            for(; i < word.length(); i++)\\n            {\\n                char ch = word.charAt(i);\\n                \\n                if(myMap.containsKey(ch)) \\n                {\\n                    if(count.containsKey(ch) && count.get(ch) + 1 > myMap.get(ch))\\n                        break;\\n                    count.put(ch, count.getOrDefault(ch, 0) + 1);\\n                } \\n                else\\n                    break;\\n            }\\n            if(i == word.length())\\n                res += word.length();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100869,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int count[] = new int[26];\\n        int word_count[][] = new int[words.length][26];\\n        int res = 0;\\n        \\n        for(int i=0; i<chars.length(); i++)\\n            count[(int)(chars.charAt(i) - 97)]++;\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                word_count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n        \\n        for(int i=0; i<word_count.length; i++)\\n        {\\n            int c = 0;\\n            for(int j=0; j<26; j++)\\n            {\\n                if(count[j] >= word_count[i][j])\\n                    c++;\\n            }\\n            if(c == 26)\\n                res += words[i].length();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int count[] = new int[26];\\n        int word_count[][] = new int[words.length][26];\\n        int res = 0;\\n        \\n        for(int i=0; i<chars.length(); i++)\\n            count[(int)(chars.charAt(i) - 97)]++;\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                word_count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n        \\n        for(int i=0; i<word_count.length; i++)\\n        {\\n            int c = 0;\\n            for(int j=0; j<26; j++)\\n            {\\n                if(count[j] >= word_count[i][j])\\n                    c++;\\n            }\\n            if(c == 26)\\n                res += words[i].length();\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099811,
                "title": "python-top-95-solution",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans = \\'\\'\\n        for word in words:\\n            for letter in word:\\n                if chars.count(letter) < word.count(letter):\\n                    break\\n            else:\\n                ans += word\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans = \\'\\'\\n        for word in words:\\n            for letter in word:\\n                if chars.count(letter) < word.count(letter):\\n                    break\\n            else:\\n                ans += word\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968112,
                "title": "c-hashmap-easy-understanding-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        unordered_map<char,int> map;\\n        for(char c:chars)\\n        {\\n            map[c]++;\\n        }\\n        int result = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            if(funcheck(map,words[i]))\\n            {\\n                result += words[i].size();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool funcheck(unordered_map<char,int> map,string word)\\n    {\\n        for(char c:word)\\n        {\\n            if(map.find(c) != map.end())\\n            {\\n                map[c]--;\\n                if(map[c] == 0)\\n                {\\n                    map.erase(c);\\n                }\\n            }\\n            \\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        unordered_map<char,int> map;\\n        for(char c:chars)\\n        {\\n            map[c]++;\\n        }\\n        int result = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            if(funcheck(map,words[i]))\\n            {\\n                result += words[i].size();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool funcheck(unordered_map<char,int> map,string word)\\n    {\\n        for(char c:word)\\n        {\\n            if(map.find(c) != map.end())\\n            {\\n                map[c]--;\\n                if(map[c] == 0)\\n                {\\n                    map.erase(c);\\n                }\\n            }\\n            \\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711673,
                "title": "java-hashing-explained",
                "content": "**Idea:** \\n* Find the frequency of each letter in `chars`\\n* For each word `w`, the frequency of each letter `l` must be less than or equal to its frequency in `chars` for `w` to be qualify as a good word\\n>**T/S:** O(m + n)/O(1), where m = size(chars), n = sum(size(words[i]))\\n```\\npublic int countCharacters(String[] words, String chars) {\\n\\tvar letterFrequency = getLetterFrequency(chars);\\n\\tvar count = 0;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tif (isGood(letterFrequency, getLetterFrequency(word)))\\n\\t\\t\\tcount += word.length();\\n\\t\\n\\treturn count;\\n}\\n\\nprivate Map<Character, Integer> getLetterFrequency(String chars) {\\n\\tvar letterFrequency = new HashMap<Character, Integer>();\\n\\tfor (var i = 0; i < chars.length(); i++)\\n\\t\\tletterFrequency.compute(chars.charAt(i), (k, v) -> v == null ? 1 : v + 1);\\n\\treturn letterFrequency;\\n}\\n\\nprivate boolean isGood(Map<Character, Integer> letterFrequency, Map<Character, Integer> wordMap) {\\n\\tfor (var letter : wordMap.keySet())\\n\\t\\tif (letterFrequency.getOrDefault(letter, 0) < wordMap.get(letter))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n\\n**Stream Variation:** 6 lines\\n```\\npublic int countCharacters(String[] words, String chars) {\\n\\tvar letterFrequency = getLetterFrequency(chars);\\n\\t\\n\\treturn Arrays.stream(words)\\n\\t\\t\\t\\t .filter(word -> isGood(letterFrequency, getLetterFrequency(word)))\\n\\t\\t\\t\\t .mapToInt(String::length)\\n\\t\\t\\t\\t .sum();\\n}\\n\\nprivate Map<Character, Integer> getLetterFrequency(String chars) {\\n\\tvar letterFrequency = new HashMap<Character, Integer>();\\n\\t\\n\\tIntStream.range(0, chars.length())\\n\\t\\t\\t .forEach(i -> letterFrequency.compute(chars.charAt(i), (k, v) -> v == null ? 1 : v + 1));\\n\\t\\t\\t \\n\\treturn letterFrequency;\\n}\\n\\nprivate boolean isGood(Map<Character, Integer> letterFrequency, Map<Character, Integer> wordMap) {\\n\\treturn wordMap.keySet()\\n\\t\\t\\t\\t  .stream()\\n\\t\\t\\t\\t  .noneMatch(letter -> letterFrequency.getOrDefault(letter, 0) < wordMap.get(letter));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countCharacters(String[] words, String chars) {\\n\\tvar letterFrequency = getLetterFrequency(chars);\\n\\tvar count = 0;\\n\\t\\n\\tfor (var word : words)\\n\\t\\tif (isGood(letterFrequency, getLetterFrequency(word)))\\n\\t\\t\\tcount += word.length();\\n\\t\\n\\treturn count;\\n}\\n\\nprivate Map<Character, Integer> getLetterFrequency(String chars) {\\n\\tvar letterFrequency = new HashMap<Character, Integer>();\\n\\tfor (var i = 0; i < chars.length(); i++)\\n\\t\\tletterFrequency.compute(chars.charAt(i), (k, v) -> v == null ? 1 : v + 1);\\n\\treturn letterFrequency;\\n}\\n\\nprivate boolean isGood(Map<Character, Integer> letterFrequency, Map<Character, Integer> wordMap) {\\n\\tfor (var letter : wordMap.keySet())\\n\\t\\tif (letterFrequency.getOrDefault(letter, 0) < wordMap.get(letter))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\n```\\npublic int countCharacters(String[] words, String chars) {\\n\\tvar letterFrequency = getLetterFrequency(chars);\\n\\t\\n\\treturn Arrays.stream(words)\\n\\t\\t\\t\\t .filter(word -> isGood(letterFrequency, getLetterFrequency(word)))\\n\\t\\t\\t\\t .mapToInt(String::length)\\n\\t\\t\\t\\t .sum();\\n}\\n\\nprivate Map<Character, Integer> getLetterFrequency(String chars) {\\n\\tvar letterFrequency = new HashMap<Character, Integer>();\\n\\t\\n\\tIntStream.range(0, chars.length())\\n\\t\\t\\t .forEach(i -> letterFrequency.compute(chars.charAt(i), (k, v) -> v == null ? 1 : v + 1));\\n\\t\\t\\t \\n\\treturn letterFrequency;\\n}\\n\\nprivate boolean isGood(Map<Character, Integer> letterFrequency, Map<Character, Integer> wordMap) {\\n\\treturn wordMap.keySet()\\n\\t\\t\\t\\t  .stream()\\n\\t\\t\\t\\t  .noneMatch(letter -> letterFrequency.getOrDefault(letter, 0) < wordMap.get(letter));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500546,
                "title": "simple-java-approach-no-cloning-no-extra-memory",
                "content": "```\\n    public int countCharacters(String[] words, String chars) {\\n        int[] charsArray = new int[26];\\n        for (char c : chars.toCharArray()) charsArray[c - \\'a\\']++;\\n        int sum = 0;\\n        MAIN_LOOP:\\n        for (String word : words) {\\n            int[] wordArray = new int[26];\\n            for (char c : word.toCharArray()) wordArray[c - \\'a\\']++;\\n            for (int i = 0; i < 26; i++) \\n                if (wordArray[i] > 0 && charsArray[i] < wordArray[i]) continue MAIN_LOOP;\\n            sum += word.length();\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int countCharacters(String[] words, String chars) {\\n        int[] charsArray = new int[26];\\n        for (char c : chars.toCharArray()) charsArray[c - \\'a\\']++;\\n        int sum = 0;\\n        MAIN_LOOP:\\n        for (String word : words) {\\n            int[] wordArray = new int[26];\\n            for (char c : word.toCharArray()) wordArray[c - \\'a\\']++;\\n            for (int i = 0; i < 26; i++) \\n                if (wordArray[i] > 0 && charsArray[i] < wordArray[i]) continue MAIN_LOOP;\\n            sum += word.length();\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389605,
                "title": "java-clean-and-easy-solution",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] commDict = new int[26];\\n        for(char c : chars.toCharArray()) {\\n            commDict[c - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String word : words) {\\n            int[] currDict = new int[26];\\n            for(char c : word.toCharArray()) {\\n                currDict[c - \\'a\\']++;\\n            }\\n            \\n            boolean notGood = false;\\n            for(int i = 0; i < 26; i++) {\\n                if(currDict[i] > commDict[i]) {\\n                    notGood = true;\\n                    break;\\n                }\\n            }\\n            if(!notGood) sb.append(word);\\n        }\\n        return sb.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] commDict = new int[26];\\n        for(char c : chars.toCharArray()) {\\n            commDict[c - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String word : words) {\\n            int[] currDict = new int[26];\\n            for(char c : word.toCharArray()) {\\n                currDict[c - \\'a\\']++;\\n            }\\n            \\n            boolean notGood = false;\\n            for(int i = 0; i < 26; i++) {\\n                if(currDict[i] > commDict[i]) {\\n                    notGood = true;\\n                    break;\\n                }\\n            }\\n            if(!notGood) sb.append(word);\\n        }\\n        return sb.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016016,
                "title": "javascript-solution",
                "content": "```\\nvar countCharacters = function (words, chars) {\\n  let counter = 0;\\n\\n  const isLegit = (word) => {\\n    let str = chars;\\n      \\n    for (let char of word) {\\n      if (str.includes(char)) {\\n        str = str.replace(char, \\'\\');\\n      } else {\\n        return false;\\n      }\\n    }\\n    return true;\\n  };\\n\\n  for (let word of words) {\\n    isLegit(word) ? (counter += word.length) : null;\\n  }\\n\\n  return counter;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function (words, chars) {\\n  let counter = 0;\\n\\n  const isLegit = (word) => {\\n    let str = chars;\\n      \\n    for (let char of word) {\\n      if (str.includes(char)) {\\n        str = str.replace(char, \\'\\');\\n      } else {\\n        return false;\\n      }\\n    }\\n    return true;\\n  };\\n\\n  for (let word of words) {\\n    isLegit(word) ? (counter += word.length) : null;\\n  }\\n\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806134,
                "title": "python-using-dictionaries-please-suggest-improvements",
                "content": "I\\'ve used 2 dictionaries. One containing the frequencies of characters in chars and the other containing the frequency of each word [ A dic is Overwriten for every word ] Any suggestions on how I can improve this code?\\n\\nIt runs faster than 35% and takes lesser memory than 87%\\n\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        from collections import Counter\\n        d = Counter(chars)\\n        ans=0\\n        for word in words:\\n            flag=0\\n            newD = Counter(word)\\n            for key in newD.keys():\\n                try:\\n                    if d[key]>=newD[key]:\\n                        flag=1\\n                    else:\\n                        flag=0\\n                        break\\n                except:\\n                    pass\\n            if flag:\\n                ans+=len(word)\\n            \\n            \\n        return(ans)\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        from collections import Counter\\n        d = Counter(chars)\\n        ans=0\\n        for word in words:\\n            flag=0\\n            newD = Counter(word)\\n            for key in newD.keys():\\n                try:\\n                    if d[key]>=newD[key]:\\n                        flag=1\\n                    else:\\n                        flag=0\\n                        break\\n                except:\\n                    pass\\n            if flag:\\n                ans+=len(word)\\n            \\n            \\n        return(ans)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 723170,
                "title": "simple-python-using-counter",
                "content": "Python counter supports &(Intersection) and |(Union) operation, which is very conveient for us to compare. \\n```\\n        # counter\\n        char = Counter(chars)\\n        res = 0\\n        for word in words:\\n            w = Counter(word)\\n            if w & char == w:\\n                res += len(word)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        # counter\\n        char = Counter(chars)\\n        res = 0\\n        for word in words:\\n            w = Counter(word)\\n            if w & char == w:\\n                res += len(word)\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 713515,
                "title": "javascript-es6-solution-with-reduce",
                "content": "```\\nvar countCharacters = function (words, chars) {\\n  return words.reduce((acc, cur) => {\\n    var char = [...chars];\\n    return [...cur].every((x) => {\\n      var idx = char.indexOf(x);\\n      if (idx > -1) {\\n        return (char[idx] = true);\\n      }\\n    })\\n      ? acc + cur.length\\n      : acc;\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function (words, chars) {\\n  return words.reduce((acc, cur) => {\\n    var char = [...chars];\\n    return [...cur].every((x) => {\\n      var idx = char.indexOf(x);\\n      if (idx > -1) {\\n        return (char[idx] = true);\\n      }\\n    })\\n      ? acc + cur.length\\n      : acc;\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627097,
                "title": "c-using-multiset",
                "content": "class Solution {\\npublic:\\n\\n    int countCharacters(vector<string>& words, string chars) {\\n    \\n        multiset<char> ch,temp;\\n        for (auto i:chars)\\n            ch.insert(i);\\n        temp=ch;\\n        \\n        int count=0;\\n        for (auto i:words)\\n        {\\n            string str=i;\\n            int mark=0;\\n            temp=ch;\\n            for(auto j:str)\\n            {\\n                if(temp.find(j)!=temp.end())\\n                {\\n                    temp.erase(temp.find(j));\\n                    continue;\\n                }\\n                else\\n                {\\n                    mark=1;\\n                    break;\\n                }\\n            }\\n            if(mark==0)\\n                count+=str.length();\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countCharacters(vector<string>& words, string chars) {\\n    \\n        multiset<char> ch,temp;\\n        for (auto i:chars)\\n            ch.insert(i);\\n        temp=ch;\\n        \\n        int count=0;\\n        for (auto i:words)\\n        {\\n            string str=i;\\n            int mark=0;\\n            temp=ch;\\n            for(auto j:str)\\n            {\\n                if(temp.find(j)!=temp.end())\\n                {\\n                    temp.erase(temp.find(j));\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 511527,
                "title": "python-solution-using-hashing",
                "content": "The [`collections.Counter()`](https://docs.python.org/3/library/collections.html#collections.Counter) creates a dictionary with counts of occurence as value and the character as key. First creating a dictionary `d` which contains words and frequency of those words in the `chars` string. Then, for every word in `words`, we need to creat a temporary dictionary (named `w_d`) and check if all of the characters in `word` occurs in `d` at least as many times it occurs in `w_d`.  \\n\\nThe `all()` method returns `True` when for all of the characters in `word` we will have `d.get(ch, 0) >= w_d[ch]`. We need `dict.get()` method because, a character in `word` may not be present in `d`, in that case `get()` will return `0`. If I have used `d[ch]` it will raise error if any character `ch` in `word` is not present in `d`. \\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        d = Counter(chars)\\n        ans = 0\\n        for word in words:\\n            w_d = Counter(word)\\n            if all(d.get(ch, 0) >= w_d[ch] for ch in word):\\n                ans += len(word)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        d = Counter(chars)\\n        ans = 0\\n        for word in words:\\n            w_d = Counter(word)\\n            if all(d.get(ch, 0) >= w_d[ch] for ch in word):\\n                ans += len(word)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461284,
                "title": "go-12ms-97",
                "content": "```go\\nfunc countCharacters(words []string, chars string) int {\\n\\tmagic := [26]int{}\\n\\tfor _, c := range chars {\\n\\t\\tmagic[c-\\'a\\']++\\n\\t}\\n\\tgood := func(word string, magic [26]int) bool {\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tmagic[c-\\'a\\']--\\n\\t\\t\\tif magic[c-\\'a\\'] < 0 {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\t\\n\\tgoodWord := 0\\n\\tfor _, word := range words {\\n\\t\\tif good(word, magic) {\\n            goodWord += len(word)\\n\\t\\t}\\n\\t}\\n\\treturn goodWord\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc countCharacters(words []string, chars string) int {\\n\\tmagic := [26]int{}\\n\\tfor _, c := range chars {\\n\\t\\tmagic[c-\\'a\\']++\\n\\t}\\n\\tgood := func(word string, magic [26]int) bool {\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tmagic[c-\\'a\\']--\\n\\t\\t\\tif magic[c-\\'a\\'] < 0 {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\t\\n\\tgoodWord := 0\\n\\tfor _, word := range words {\\n\\t\\tif good(word, magic) {\\n            goodWord += len(word)\\n\\t\\t}\\n\\t}\\n\\treturn goodWord\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453169,
                "title": "simple-and-efficient-java-solution",
                "content": "```\\npublic int countCharacters(String[] words, String chars) {\\n\\tint count = 0;\\n\\tint[] seen = new int[26];\\n\\tfor(char c: chars.toCharArray()) {\\n\\t\\tseen[c - \\'a\\']++;\\n\\t}\\n\\n\\tfor(String word: words) {\\n\\t\\t// copy the seen array so we don\\'t have to modify the original seen array\\n\\t\\tint[] seenCopy = Arrays.copyOf(seen, seen.length);\\n\\t\\tboolean isEarlyReturn = false;\\n\\t\\tfor(char c: word.toCharArray()) {                \\n\\t\\t\\tseenCopy[c - \\'a\\']--;\\n\\t\\t\\tif(seenCopy[c - \\'a\\'] < 0) {\\n\\t\\t\\t\\tisEarlyReturn = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!isEarlyReturn)\\n\\t\\t\\tcount = count + word.length();\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countCharacters(String[] words, String chars) {\\n\\tint count = 0;\\n\\tint[] seen = new int[26];\\n\\tfor(char c: chars.toCharArray()) {\\n\\t\\tseen[c - \\'a\\']++;\\n\\t}\\n\\n\\tfor(String word: words) {\\n\\t\\t// copy the seen array so we don\\'t have to modify the original seen array\\n\\t\\tint[] seenCopy = Arrays.copyOf(seen, seen.length);\\n\\t\\tboolean isEarlyReturn = false;\\n\\t\\tfor(char c: word.toCharArray()) {                \\n\\t\\t\\tseenCopy[c - \\'a\\']--;\\n\\t\\t\\tif(seenCopy[c - \\'a\\'] < 0) {\\n\\t\\t\\t\\tisEarlyReturn = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!isEarlyReturn)\\n\\t\\t\\tcount = count + word.length();\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436107,
                "title": "python3-one-liner-time-99-91-space-100",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum([len(word) for word in words if all(0 < word.count(x) <= chars.count(x) for x in word)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum([len(word) for word in words if all(0 < word.count(x) <= chars.count(x) for x in word)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384582,
                "title": "python-5-liner",
                "content": "```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length = 0\\n        for word in words:\\n            if not (Counter(word) - Counter(chars)):\\n                length += len(word)\\n        return length\\n```",
                "solutionTags": [],
                "code": "```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        length = 0\\n        for word in words:\\n            if not (Counter(word) - Counter(chars)):\\n                length += len(word)\\n        return length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 370649,
                "title": "cpp-100-memory-maps",
                "content": "```\\nint countCharacters(vector<string>& words, string chars) {\\n        if(words.size()==0)\\n            return 0;\\n        \\n        map<char,int> ma;\\n        map<char,int> co;\\n        for(int i=0;i<chars.size();i++)\\n            ma[chars[i]]++;\\n        \\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            co=ma;\\n            int flag=0;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                if(co[words[i][j]]!=0)\\n                    co[words[i][j]]--;\\n                else\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==0)\\n                count+=words[i].size();\\n            \\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint countCharacters(vector<string>& words, string chars) {\\n        if(words.size()==0)\\n            return 0;\\n        \\n        map<char,int> ma;\\n        map<char,int> co;\\n        for(int i=0;i<chars.size();i++)\\n            ma[chars[i]]++;\\n        \\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            co=ma;\\n            int flag=0;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                if(co[words[i][j]]!=0)\\n                    co[words[i][j]]--;\\n                else\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==0)\\n                count+=words[i].size();\\n            \\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362197,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    return words.filter(word => {\\n        let charsRemain = chars.split(\\'\\');\\n        let correctWord = true;\\n        \\n        word.split(\\'\\').forEach(letter => {\\n            if (!correctWord) return;\\n            if (charsRemain.includes(letter)) {\\n                charsRemain.splice(charsRemain.indexOf(letter), 1);\\n            } else {\\n                correctWord = false;\\n            }\\n        });\\n        \\n        return correctWord;\\n    }).join(\\'\\').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    return words.filter(word => {\\n        let charsRemain = chars.split(\\'\\');\\n        let correctWord = true;\\n        \\n        word.split(\\'\\').forEach(letter => {\\n            if (!correctWord) return;\\n            if (charsRemain.includes(letter)) {\\n                charsRemain.splice(charsRemain.indexOf(letter), 1);\\n            } else {\\n                correctWord = false;\\n            }\\n        });\\n        \\n        return correctWord;\\n    }).join(\\'\\').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361580,
                "title": "java-easy-simple",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] arr = new int[26];\\n        for (char c : chars.toCharArray()) {\\n            arr[c-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(String w : words) {\\n            int[] charArray = arr.clone();\\n            int count = 0;\\n            for (char c : w.toCharArray()) {\\n                if(charArray[c - \\'a\\'] > 0) {\\n                    charArray[c - \\'a\\']--;\\n                    count++;\\n                } else \\n                    break;                \\n            }\\n            if(count == w.length()) \\n                ans += w.length();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] arr = new int[26];\\n        for (char c : chars.toCharArray()) {\\n            arr[c-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(String w : words) {\\n            int[] charArray = arr.clone();\\n            int count = 0;\\n            for (char c : w.toCharArray()) {\\n                if(charArray[c - \\'a\\'] > 0) {\\n                    charArray[c - \\'a\\']--;\\n                    count++;\\n                } else \\n                    break;                \\n            }\\n            if(count == w.length()) \\n                ans += w.length();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361296,
                "title": "easy-to-understand-python-with-comments",
                "content": "**Explanation**\\n\\nBasically, if all the characters to form the _word_ is available in `chars` then it\\'s a good word. What we can do is to count the character counts of `chars` and then, for each _word_ we also count the character counts. If all the characters of the _word_ is in `chctr` and the count is also `<=` then we consider it a good _word_.\\n\\n```Python\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\t# count chars character counts\\n        chctr = collections.Counter(chars)\\n\\t\\t\\n        goodln = 0\\n        for word in words:\\n            wctr = collections.Counter(word)\\n            isgood = True\\n            for key in wctr:\\n\\t\\t\\t\\t# chech if the character (or key) is available &\\n\\t\\t\\t\\t# we have enough of it\\n                if key not in chctr or wctr[key] > chctr[key]:\\n                    isgood = False\\n                    break\\n            if isgood:\\n                goodln += len(word)\\n        return goodln\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\t# count chars character counts\\n        chctr = collections.Counter(chars)\\n\\t\\t\\n        goodln = 0\\n        for word in words:\\n            wctr = collections.Counter(word)\\n            isgood = True\\n            for key in wctr:\\n\\t\\t\\t\\t# chech if the character (or key) is available &\\n\\t\\t\\t\\t# we have enough of it\\n                if key not in chctr or wctr[key] > chctr[key]:\\n                    isgood = False\\n                    break\\n            if isgood:\\n                goodln += len(word)\\n        return goodln\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361099,
                "title": "ruby-solution-two-methods",
                "content": "This is the first passing solution I came up with. It\\'s readable, I suppose, but I\\'m not particularly pleased with it.\\n\\n```\\n\\ndef count_characters(words, chars)\\n    found_words = []\\n    words.each do |w|\\n        if word_chars_in_approve_list?(w, chars)\\n            found_words << w \\n        end\\n    end\\n    p found_words\\n    return found_words.join.length\\nend\\n\\ndef word_chars_in_approve_list?(word, chars)\\n    list = chars.split(\"\")\\n    word.split(\"\").each do |c|\\n        if list.include?(c)\\n            index = list.index(c)\\n            list.delete_at(index)\\n        else\\n            return false\\n        end\\n    end\\n    return true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n\\ndef count_characters(words, chars)\\n    found_words = []\\n    words.each do |w|\\n        if word_chars_in_approve_list?(w, chars)\\n            found_words << w \\n        end\\n    end\\n    p found_words\\n    return found_words.join.length\\nend\\n\\ndef word_chars_in_approve_list?(word, chars)\\n    list = chars.split(\"\")\\n    word.split(\"\").each do |c|\\n        if list.include?(c)\\n            index = list.index(c)\\n            list.delete_at(index)\\n        else\\n            return false\\n        end\\n    end\\n    return true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 361007,
                "title": "javascript-c-c-count-based",
                "content": "Javascript\\n```\\nvar countCharacters = function(words, chars) {\\n    const count = [];\\n    for(const ch of chars) { count[ch] = (count[ch] || 0) + 1 ; }\\n    let total = 0;\\n    for(const word of words) {\\n        const wordCount = [];\\n        let canConstruct = true;\\n        for(const ch of word) {\\n            wordCount[ch] = (wordCount[ch] || 0) + 1;\\n            if (!count[ch] || wordCount[ch] > count[ch]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        \\n        if (canConstruct) total += word.length;\\n    }\\n    return total;\\n};\\n```\\n\\nC#\\n```\\npublic int CountCharacters(string[] words, string chars) {\\n    var count = new int[26];\\n    foreach(var ch in chars) { count[ch - \\'a\\']++; }\\n    var total = 0;\\n    foreach(var word in words) {\\n        var wordCount = new int[26];\\n        var canConstruct = true;\\n        foreach(var ch in word) {\\n            var ind = ch - \\'a\\';\\n            if (++wordCount[ind] > count[ind]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        if (canConstruct) total += word.Length;\\n    }\\n    return total;\\n}\\n```\\n\\nC++\\n```\\nint countCharacters(vector<string>& words, string chars) {\\n    vector<int> count(26);\\n    int total = 0;\\n    for (auto ch : chars) ++count[ch - \\'a\\'];\\n\\n    for (auto& word : words) {\\n        vector<int> wCount(26);\\n        bool canConstruct = true;\\n        for (auto ch : word) {\\n            auto index = ch - \\'a\\';\\n            if (++wCount[index] > count[index]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        if (canConstruct) total += word.size();\\n    }\\n    return total;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    const count = [];\\n    for(const ch of chars) { count[ch] = (count[ch] || 0) + 1 ; }\\n    let total = 0;\\n    for(const word of words) {\\n        const wordCount = [];\\n        let canConstruct = true;\\n        for(const ch of word) {\\n            wordCount[ch] = (wordCount[ch] || 0) + 1;\\n            if (!count[ch] || wordCount[ch] > count[ch]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        \\n        if (canConstruct) total += word.length;\\n    }\\n    return total;\\n};\\n```\n```\\npublic int CountCharacters(string[] words, string chars) {\\n    var count = new int[26];\\n    foreach(var ch in chars) { count[ch - \\'a\\']++; }\\n    var total = 0;\\n    foreach(var word in words) {\\n        var wordCount = new int[26];\\n        var canConstruct = true;\\n        foreach(var ch in word) {\\n            var ind = ch - \\'a\\';\\n            if (++wordCount[ind] > count[ind]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        if (canConstruct) total += word.Length;\\n    }\\n    return total;\\n}\\n```\n```\\nint countCharacters(vector<string>& words, string chars) {\\n    vector<int> count(26);\\n    int total = 0;\\n    for (auto ch : chars) ++count[ch - \\'a\\'];\\n\\n    for (auto& word : words) {\\n        vector<int> wCount(26);\\n        bool canConstruct = true;\\n        for (auto ch : word) {\\n            auto index = ch - \\'a\\';\\n            if (++wCount[index] > count[index]) {\\n                canConstruct = false;\\n                break;\\n            }\\n        }\\n        if (canConstruct) total += word.size();\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979592,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans=0;\\n        unordered_map<char,int>ch;\\n        for(int i=0;i<chars.length();i++){\\n            ch[chars[i]]++;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            unordered_map<char,int>str;\\n            string s=words[i];\\n            for(int j=0;j<s.length();j++){\\n                str[s[j]]++;\\n            }\\n            bool flag=true;\\n            for(int k=0;k<s.length();k++){\\n                if(str[s[k]]>ch[s[k]]){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            ans+=s.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans=0;\\n        unordered_map<char,int>ch;\\n        for(int i=0;i<chars.length();i++){\\n            ch[chars[i]]++;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            unordered_map<char,int>str;\\n            string s=words[i];\\n            for(int j=0;j<s.length();j++){\\n                str[s[j]]++;\\n            }\\n            bool flag=true;\\n            for(int k=0;k<s.length();k++){\\n                if(str[s[k]]>ch[s[k]]){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            ans+=s.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877542,
                "title": "python-solution-using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822712,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> arr1 , vector<int> arr2){\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(arr1[i] < arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        \\n        vector<int> arr1(26,0);\\n        for(int i = 0 ; i < chars.size() ; i++)\\n            arr1[chars[i]-\\'a\\']++;\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            vector<int> arr2(26,0);\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                string m = words[i];\\n                arr2[m[j]-\\'a\\']++;\\n            }\\n            \\n            bool p = check(arr1 , arr2);\\n            if(p){\\n                sum = sum + words[i].size();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> arr1 , vector<int> arr2){\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(arr1[i] < arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        \\n        vector<int> arr1(26,0);\\n        for(int i = 0 ; i < chars.size() ; i++)\\n            arr1[chars[i]-\\'a\\']++;\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            vector<int> arr2(26,0);\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                string m = words[i];\\n                arr2[m[j]-\\'a\\']++;\\n            }\\n            \\n            bool p = check(arr1 , arr2);\\n            if(p){\\n                sum = sum + words[i].size();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726360,
                "title": "java-hash-solution",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    \\n    private static final BigInteger[] primes = new BigInteger[27];\\n    \\n    static {\\n        primes[0] = BigInteger.valueOf(2);\\n        primes[1] = BigInteger.valueOf(3);\\n        primes[2] = BigInteger.valueOf(5);\\n        primes[3] = BigInteger.valueOf(7);\\n        primes[4] = BigInteger.valueOf(11);\\n        primes[5] = BigInteger.valueOf(13);\\n        primes[6] = BigInteger.valueOf(17);\\n        primes[7] = BigInteger.valueOf(19);\\n        primes[8] = BigInteger.valueOf(23);\\n        primes[9] = BigInteger.valueOf(29);\\n        primes[10] = BigInteger.valueOf(31);\\n        primes[11] = BigInteger.valueOf(37);\\n        primes[12] = BigInteger.valueOf(41);\\n        primes[13] = BigInteger.valueOf(43);\\n        primes[14] = BigInteger.valueOf(47);\\n        primes[15] = BigInteger.valueOf(53);\\n        primes[16] = BigInteger.valueOf(59);\\n        primes[17] = BigInteger.valueOf(61);\\n        primes[18] = BigInteger.valueOf(67);\\n        primes[19] = BigInteger.valueOf(71);\\n        primes[20] = BigInteger.valueOf(73);\\n        primes[21] = BigInteger.valueOf(79);\\n        primes[22] = BigInteger.valueOf(83);\\n        primes[23] = BigInteger.valueOf(89);\\n        primes[24] = BigInteger.valueOf(97);\\n        primes[25] = BigInteger.valueOf(101);\\n        primes[26] = BigInteger.valueOf(103); \\n    }\\n    \\n    public int countCharacters(String[] words, String chars) {        \\n        int result = 0;\\n        BigInteger hash = BigInteger.ONE;\\n        for (char ch : chars.toCharArray()) {\\n            hash = hash.multiply(primes[ch - \\'a\\']);\\n        }\\n    \\n        for (String word : words) {\\n            BigInteger wordHash = BigInteger.ONE;\\n            for (char ch : word.toCharArray()) {\\n                wordHash = wordHash.multiply(primes[ch - \\'a\\']);\\n            }\\n            if (hash.remainder(wordHash) == BigInteger.ZERO) {\\n                result += word.length();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    \\n    private static final BigInteger[] primes = new BigInteger[27];\\n    \\n    static {\\n        primes[0] = BigInteger.valueOf(2);\\n        primes[1] = BigInteger.valueOf(3);\\n        primes[2] = BigInteger.valueOf(5);\\n        primes[3] = BigInteger.valueOf(7);\\n        primes[4] = BigInteger.valueOf(11);\\n        primes[5] = BigInteger.valueOf(13);\\n        primes[6] = BigInteger.valueOf(17);\\n        primes[7] = BigInteger.valueOf(19);\\n        primes[8] = BigInteger.valueOf(23);\\n        primes[9] = BigInteger.valueOf(29);\\n        primes[10] = BigInteger.valueOf(31);\\n        primes[11] = BigInteger.valueOf(37);\\n        primes[12] = BigInteger.valueOf(41);\\n        primes[13] = BigInteger.valueOf(43);\\n        primes[14] = BigInteger.valueOf(47);\\n        primes[15] = BigInteger.valueOf(53);\\n        primes[16] = BigInteger.valueOf(59);\\n        primes[17] = BigInteger.valueOf(61);\\n        primes[18] = BigInteger.valueOf(67);\\n        primes[19] = BigInteger.valueOf(71);\\n        primes[20] = BigInteger.valueOf(73);\\n        primes[21] = BigInteger.valueOf(79);\\n        primes[22] = BigInteger.valueOf(83);\\n        primes[23] = BigInteger.valueOf(89);\\n        primes[24] = BigInteger.valueOf(97);\\n        primes[25] = BigInteger.valueOf(101);\\n        primes[26] = BigInteger.valueOf(103); \\n    }\\n    \\n    public int countCharacters(String[] words, String chars) {        \\n        int result = 0;\\n        BigInteger hash = BigInteger.ONE;\\n        for (char ch : chars.toCharArray()) {\\n            hash = hash.multiply(primes[ch - \\'a\\']);\\n        }\\n    \\n        for (String word : words) {\\n            BigInteger wordHash = BigInteger.ONE;\\n            for (char ch : word.toCharArray()) {\\n                wordHash = wordHash.multiply(primes[ch - \\'a\\']);\\n            }\\n            if (hash.remainder(wordHash) == BigInteger.ZERO) {\\n                result += word.length();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553602,
                "title": "c-solution-find-words-that-can-be-formed-by-characters",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> arr1 , vector<int> arr2){\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(arr1[i] < arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        \\n        //find frequency of \\'chars\\'\\n        vector<int> arr1(26,0);\\n        for(int i = 0 ; i < chars.size() ; i++)\\n            arr1[chars[i]-\\'a\\']++;\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            //calculate the frequency of each word.\\n            vector<int> arr2(26,0);\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                string m = words[i];\\n                arr2[m[j]-\\'a\\']++;\\n            }\\n            \\n            bool p = check(arr1 , arr2);\\n            if(p){\\n                sum = sum + words[i].size();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> arr1 , vector<int> arr2){\\n        for(int i = 0 ; i < 26 ; i++){\\n            if(arr1[i] < arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        \\n        //find frequency of \\'chars\\'\\n        vector<int> arr1(26,0);\\n        for(int i = 0 ; i < chars.size() ; i++)\\n            arr1[chars[i]-\\'a\\']++;\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            //calculate the frequency of each word.\\n            vector<int> arr2(26,0);\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                string m = words[i];\\n                arr2[m[j]-\\'a\\']++;\\n            }\\n            \\n            bool p = check(arr1 , arr2);\\n            if(p){\\n                sum = sum + words[i].size();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161928,
                "title": "using-maps-easy",
                "content": "bool check(string str,string chars)\\n    {\\n        unordered_map<char,int>m;\\n        for(auto val:chars)\\n        {\\n            m[val]++;\\n        }\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(m[str[i]])\\n            {\\n                m[str[i]]--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        int ans=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(check(words[i],chars))\\n            {\\n                ans=ans+words[i].size();\\n            }\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "bool check(string str,string chars)\\n    {\\n        unordered_map<char,int>m;\\n        for(auto val:chars)\\n        {\\n            m[val]++;\\n        }\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(m[str[i]])\\n            {\\n                m[str[i]]--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        int ans=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(check(words[i],chars))\\n            {\\n                ans=ans+words[i].size();\\n            }\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2006949,
                "title": "easy-clean-python",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans = 0\\n        for word in words: \\n            for char in word: \\n                if word.count(char) > chars.count(char):  break\\n            else: ans += len(word)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans = 0\\n        for word in words: \\n            for char in word: \\n                if word.count(char) > chars.count(char):  break\\n            else: ans += len(word)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003908,
                "title": "python-easy",
                "content": "```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        hmap = Counter(chars)\\n        res = 0\\n        for word in words:\\n            if not Counter(word) - hmap:  # All the characters from word are in chars\\n                res += len(word)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        hmap = Counter(chars)\\n        res = 0\\n        for word in words:\\n            if not Counter(word) - hmap:  # All the characters from word are in chars\\n                res += len(word)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888459,
                "title": "c-simple-and-easy-to-understand-with-comments-hash-table",
                "content": "class Solution {\\npublic:\\n\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        // hash table of chars and their count.\\n        int charsCounts[26] = {0};\\n        for(int i = 0; i < chars.length(); i++){\\n            charsCounts[chars[i] - \\'a\\']++;\\n        }\\n        \\n        // For each word assume its valid and add its length to result.\\n        // Alternative is to use a flag.\\n        // For each word create its own hashtable of char count.\\n        // Add all letters from the word into a hash table.\\n        // After a letter is added check if it\\'s count exceeds the count\\n        // of the same letter in charsCount hash table.\\n        // If it does the assumption was wrong so substract the words length from result \\n        // and continue to the next word.\\n        int result = 0;\\n        for(int i = 0; i < words.size(); i++){\\n            result += words[i].length();\\n            int wordCharCount[26] = {0};\\n            for(int j = 0; j < words[i].length(); j++){\\n                int index = words[i][j] - \\'a\\';\\n                wordCharCount[index]++;\\n                if(wordCharCount[index] > charsCounts[index]){\\n                    result -= words[i].length();\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        // hash table of chars and their count.\\n        int charsCounts[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1875631,
                "title": "python-simple-approach-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        output = 0\\n        for i in words:\\n            count = 0\\n            for j in i:\\n                if chars.count(j) >= i.count(j):\\n                    count+=1\\n                else:\\n                    break\\n            if count == len(i):\\n                output+=count\\n        return output\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        output = 0\\n        for i in words:\\n            count = 0\\n            for j in i:\\n                if chars.count(j) >= i.count(j):\\n                    count+=1\\n                else:\\n                    break\\n            if count == len(i):\\n                output+=count\\n        return output\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664996,
                "title": "java-count-solution",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] dict = new int[26];\\n        int ans = 0;\\n        for(char c : chars.toCharArray()) dict[c - \\'a\\']++;\\n        \\n        for(String s : words) {\\n            int[] dictCopy = Arrays.copyOf(dict, 26);\\n            for(int i = 0; i<s.length(); i++) {\\n                if(--dictCopy[s.charAt(i) - \\'a\\'] <0 ) break;\\n                if(i == s.length() - 1) ans += s.length();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] dict = new int[26];\\n        int ans = 0;\\n        for(char c : chars.toCharArray()) dict[c - \\'a\\']++;\\n        \\n        for(String s : words) {\\n            int[] dictCopy = Arrays.copyOf(dict, 26);\\n            for(int i = 0; i<s.length(); i++) {\\n                if(--dictCopy[s.charAt(i) - \\'a\\'] <0 ) break;\\n                if(i == s.length() - 1) ans += s.length();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531417,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    int count[]=new int[256];\\n    \\n    \\n    void initialize(String chars){\\n        Arrays.fill(count,0);\\n        for(int i=0;i<chars.length();i++){\\n            count[chars.charAt(i)]++;\\n        }\\n    }\\n    \\n    public int countCharacters(String[] words, String chars) {\\n        boolean flag;\\n        int length=0;\\n        for(String temp:words){\\n            initialize(chars);\\n            flag=true;\\n            for(int i=0;i<temp.length();i++){\\n                if(count[temp.charAt(i)]<=0)\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n                else\\n                count[temp.charAt(i)]--;\\n            }\\n            if(flag){\\n                length+=temp.length();\\n            }\\n        }\\n        return length ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count[]=new int[256];\\n    \\n    \\n    void initialize(String chars){\\n        Arrays.fill(count,0);\\n        for(int i=0;i<chars.length();i++){\\n            count[chars.charAt(i)]++;\\n        }\\n    }\\n    \\n    public int countCharacters(String[] words, String chars) {\\n        boolean flag;\\n        int length=0;\\n        for(String temp:words){\\n            initialize(chars);\\n            flag=true;\\n            for(int i=0;i<temp.length();i++){\\n                if(count[temp.charAt(i)]<=0)\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n                else\\n                count[temp.charAt(i)]--;\\n            }\\n            if(flag){\\n                length+=temp.length();\\n            }\\n        }\\n        return length ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525526,
                "title": "c-solution-no-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int countCharacters(vector<string> &words, string chars)\\n    {\\n        int count = 0;\\n        for (const auto &i : words)\\n        {\\n            string charcompare = chars;\\n            int var = 0;\\n            for (const auto &j : i)\\n            {\\n                int finding = charcompare.find(j);\\n                if (finding != string::npos)\\n                {\\n                    charcompare.erase(finding, 1);\\n                    var = i.size();\\n                }\\n                else\\n                {\\n                    var = 0;\\n                    break;\\n                }\\n            }\\n            count += var;\\n            var = 0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int countCharacters(vector<string> &words, string chars)\\n    {\\n        int count = 0;\\n        for (const auto &i : words)\\n        {\\n            string charcompare = chars;\\n            int var = 0;\\n            for (const auto &j : i)\\n            {\\n                int finding = charcompare.find(j);\\n                if (finding != string::npos)\\n                {\\n                    charcompare.erase(finding, 1);\\n                    var = i.size();\\n                }\\n                else\\n                {\\n                    var = 0;\\n                    break;\\n                }\\n            }\\n            count += var;\\n            var = 0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353416,
                "title": "easy-python-solution",
                "content": "output = 0\\n        count = 0\\n                \\n        for i in words:\\n            count = 0\\n            chars_dup = list(chars)\\n            for j,value in enumerate(i):\\n                if value not in chars_dup:\\n                    break\\n                else:    \\n                    chars_dup.pop(chars_dup.index(value))\\n                    count = count + 1\\n                  \\n            if count == len(i):\\n                output = output + len(i)\\n                chars_dup.clear()\\n                \\n        return output",
                "solutionTags": [],
                "code": "output = 0\\n        count = 0\\n                \\n        for i in words:\\n            count = 0\\n            chars_dup = list(chars)\\n            for j,value in enumerate(i):\\n                if value not in chars_dup:\\n                    break\\n                else:    \\n                    chars_dup.pop(chars_dup.index(value))\\n                    count = count + 1\\n                  \\n            if count == len(i):\\n                output = output + len(i)\\n                chars_dup.clear()\\n                \\n        return output",
                "codeTag": "Unknown"
            },
            {
                "id": 1346239,
                "title": "c-time-94-space-95",
                "content": "```\\n int countCharacters(vector<string>& words, string chars) {\\n        int hash[26]={0},ans=0,j;\\n        for(int i=0;i<chars.size();i++)hash[chars[i]-\\'a\\']++;\\n        for(int i=0;i<words.size();i++){\\n            int flag=1;\\n            for(j=0;j<words[i].size();j++){\\n                if(hash[words[i][j]-\\'a\\'])hash[words[i][j]-\\'a\\']--;\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)ans+=j;\\n            j--;\\n            for(;j>=0;j--)hash[words[i][j]-\\'a\\']++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int countCharacters(vector<string>& words, string chars) {\\n        int hash[26]={0},ans=0,j;\\n        for(int i=0;i<chars.size();i++)hash[chars[i]-\\'a\\']++;\\n        for(int i=0;i<words.size();i++){\\n            int flag=1;\\n            for(j=0;j<words[i].size();j++){\\n                if(hash[words[i][j]-\\'a\\'])hash[words[i][j]-\\'a\\']--;\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag)ans+=j;\\n            j--;\\n            for(;j>=0;j--)hash[words[i][j]-\\'a\\']++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1269238,
                "title": "python-solution-using-counter",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter_chars = Counter(chars)\\n        sum = 0\\n        for word in words:\\n            counter_word = Counter(word)\\n            if counter_word & counter_chars == counter_word:\\n                sum += len(word)\\n        return sum\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter_chars = Counter(chars)\\n        sum = 0\\n        for word in words:\\n            counter_word = Counter(word)\\n            if counter_word & counter_chars == counter_word:\\n                sum += len(word)\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192917,
                "title": "simple-python-99-fast-solution",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res = 0\\n        for word in words:\\n            for w in word:\\n                if word.count(w) > chars.count(w):\\n                    break\\n            else:\\n                res += len(word) \\n        return res\\n```\\n**If you find it useful, then please upvote**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res = 0\\n        for word in words:\\n            for w in word:\\n                if word.count(w) > chars.count(w):\\n                    break\\n            else:\\n                res += len(word) \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177800,
                "title": "c-easy-solution-using-unordered-map",
                "content": "***Do upvote if you found it helpful to keep me motivated to post more*** \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n       unordered_map<char,int> u;\\n        int count = 0 , flag = 1 , i;\\n        for(i=0 ; i < chars.length() ; i++)\\n        { \\n\\t\\t   u[chars[i]]++;\\n\\t\\t}\\n        for(i=0 ; i < words.size(); i++)\\n        {\\n            unordered_map<char,int> v;\\n            flag = 1;\\n          for(j = 0 ; j < words[i].size() ; j++)\\n          {\\n             v[words[i][j]]++;\\n          }\\n            for(auto x: words[i])\\n            {\\n              if(v[x] > u[x])\\n                flag = 0;\\n            }\\n            if(flag == 1)\\n                count += words[i].size();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n       unordered_map<char,int> u;\\n        int count = 0 , flag = 1 , i;\\n        for(i=0 ; i < chars.length() ; i++)\\n        { \\n\\t\\t   u[chars[i]]++;\\n\\t\\t}\\n        for(i=0 ; i < words.size(); i++)\\n        {\\n            unordered_map<char,int> v;\\n            flag = 1;\\n          for(j = 0 ; j < words[i].size() ; j++)\\n          {\\n             v[words[i][j]]++;\\n          }\\n            for(auto x: words[i])\\n            {\\n              if(v[x] > u[x])\\n                flag = 0;\\n            }\\n            if(flag == 1)\\n                count += words[i].size();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147528,
                "title": "simple-c-solution-with-using-vectors-for-tracking-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        vector<int> letters(26,0);\\n        // compute occurances of each letter in the string chars\\n        for(auto ch: chars) {\\n            letters[ch-\\'a\\']++;\\n        }\\n        int sum = 0;\\n        // for every word check if the word can be formed using the letetrs in chars string and add the length to the result if the word can be formed;\\n        for(auto word: words) {\\n            int i = 0;\\n            vector<int> freq = letters;\\n            /* This is equivalent to \\n                while(i < word.size()) {\\n                    freq[word[i]-\\'a\\']--;\\n                    i++\\n                }\\n            */\\n            for(;i < word.size() && freq[word[i]-\\'a\\']-- > 0; i++);\\n            /* This is equivalent to \\n                if(i == word.size() )\\n                    sum += word.size()\\n            */\\n            sum += word.size() * (i == word.size() );\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        vector<int> letters(26,0);\\n        // compute occurances of each letter in the string chars\\n        for(auto ch: chars) {\\n            letters[ch-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 899431,
                "title": "life-made-easy-by-collections-counter",
                "content": "![image](https://assets.leetcode.com/users/images/1e79684d-7fc0-46c1-9596-d57ae518066c_1602992697.1196833.png)\\n\\nA little known fact about Counter objects are that you can peform set operations on them. Here also, we subttact the obtained word counter with our pre compiled counter, and if it\\'s null, then we add its length to the result.\\t\\n\\t\\n\\tfrom collections import Counter\\n\\tclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        pre_compiled_counter = Counter(chars)\\n        output = 0 \\n        for word in words : \\n            if Counter(word) - pre_compiled_counter == Counter() :\\n                output = output + len(word)\\n        return output\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/1e79684d-7fc0-46c1-9596-d57ae518066c_1602992697.1196833.png)\\n\\nA little known fact about Counter objects are that you can peform set operations on them. Here also, we subttact the obtained word counter with our pre compiled counter, and if it\\'s null, then we add its length to the result.\\t\\n\\t\\n\\tfrom collections import Counter\\n\\tclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        pre_compiled_counter = Counter(chars)\\n        output = 0 \\n        for word in words : \\n            if Counter(word) - pre_compiled_counter == Counter() :\\n                output = output + len(word)\\n        return output\\n",
                "codeTag": "Java"
            },
            {
                "id": 856426,
                "title": "swift-2-solutions",
                "content": "**With a dictionary**\\nTime: O(n + m), Space: O(n + m) where n is words.count, m is chars.count\\n```\\nfunc countCharacters(_ words: [String], _ chars: String) -> Int {\\n\\tvar charToFreq = [Character: Int]()\\n\\tvar result = 0\\n\\n\\tfor char in chars {\\n\\t\\tcharToFreq[char, default: 0] += 1\\n\\t}\\n\\n\\tfor word in words {\\n\\t\\tvar curCharToFreq = [Character: Int]()\\n\\n\\t\\tfor char in word {\\n\\t\\t\\tcurCharToFreq[char, default: 0] += 1\\n\\t\\t}\\n\\n\\t\\tvar canBeFormed = true\\n\\t\\tfor (char, freq) in curCharToFreq {\\n\\t\\t\\tif charToFreq[char] == nil || charToFreq[char]! < freq { \\n\\t\\t\\t\\tcanBeFormed = false\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif canBeFormed {\\n\\t\\t\\tresult += word.count\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n**With an array, 3 times faster suprisingly**\\nTime: O(n + m), Space: O(n)\\n```\\nfunc countCharacters(_ words: [String], _ chars: String) -> Int {\\n\\tvar freqs = Array(repeating: 0, count: 26)\\n\\tvar result = 0\\n\\n\\tfor char in chars {\\n\\t\\tfreqs[charToInt(char)] += 1\\n\\t}\\n\\n\\tfor word in words {\\n\\t\\tvar curFreqs = freqs\\n\\n\\n\\t\\tvar canBeFormed = true\\n\\t\\tfor char in word {\\n\\t\\t\\tlet index = charToInt(char)\\n\\t\\t\\tif curFreqs[index] <= 0 { \\n\\t\\t\\t\\tcanBeFormed = false\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t\\tcurFreqs[index] -= 1\\n\\t\\t}\\n\\n\\t\\tif canBeFormed {\\n\\t\\t\\tresult += word.count\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc charToInt(_ char: Character) -> Int {\\n\\treturn Int(char.asciiValue! - Character(\"a\").asciiValue!)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc countCharacters(_ words: [String], _ chars: String) -> Int {\\n\\tvar charToFreq = [Character: Int]()\\n\\tvar result = 0\\n\\n\\tfor char in chars {\\n\\t\\tcharToFreq[char, default: 0] += 1\\n\\t}\\n\\n\\tfor word in words {\\n\\t\\tvar curCharToFreq = [Character: Int]()\\n\\n\\t\\tfor char in word {\\n\\t\\t\\tcurCharToFreq[char, default: 0] += 1\\n\\t\\t}\\n\\n\\t\\tvar canBeFormed = true\\n\\t\\tfor (char, freq) in curCharToFreq {\\n\\t\\t\\tif charToFreq[char] == nil || charToFreq[char]! < freq { \\n\\t\\t\\t\\tcanBeFormed = false\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif canBeFormed {\\n\\t\\t\\tresult += word.count\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc countCharacters(_ words: [String], _ chars: String) -> Int {\\n\\tvar freqs = Array(repeating: 0, count: 26)\\n\\tvar result = 0\\n\\n\\tfor char in chars {\\n\\t\\tfreqs[charToInt(char)] += 1\\n\\t}\\n\\n\\tfor word in words {\\n\\t\\tvar curFreqs = freqs\\n\\n\\n\\t\\tvar canBeFormed = true\\n\\t\\tfor char in word {\\n\\t\\t\\tlet index = charToInt(char)\\n\\t\\t\\tif curFreqs[index] <= 0 { \\n\\t\\t\\t\\tcanBeFormed = false\\n\\t\\t\\t\\tbreak \\n\\t\\t\\t}\\n\\t\\t\\tcurFreqs[index] -= 1\\n\\t\\t}\\n\\n\\t\\tif canBeFormed {\\n\\t\\t\\tresult += word.count\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc charToInt(_ char: Character) -> Int {\\n\\treturn Int(char.asciiValue! - Character(\"a\").asciiValue!)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609574,
                "title": "java-modular-code-with-comments-and-using-int-60-time-and-100-memory",
                "content": "Inspired by https://www.youtube.com/watch?v=3MwRGPPB4tw&list=PLI1t_8YX-Apv-UiRlnZwqqrRT8D1RhriX&index=13&t=0s\\n\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int sum = 0;\\n        \\n\\t\\t//26 size array because all inputs are lowercase english letters\\n\\t\\t//prepare char count array using the private method\\n        int[] charsCount = getCountArray(chars);\\n        \\n        for (String word : words) {\\n\\t\\t//prepare char count array for each word in the words list\\n            int[] wordCount = getCountArray(word);\\n\\t\\t\\t\\n\\t\\t\\t//check if the word can be formed by characters in the given \"chars\" string\\n            if(isWordPossible(charsCount,wordCount)) {\\n\\t\\t\\t//if yes, add the current word\\'s length to the sum\\n                sum += word.length();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private static int[] getCountArray(String w) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i < w.length(); i++) {\\n            counts[w.charAt(i) - \\'a\\']++;\\n        }\\n        return counts;\\n    }\\n    \\n    private boolean isWordPossible(int[] cCount, int[] wCount) {\\n        for(int i = 0; i < cCount.length; i++) {\\n            if(cCount[i] - wCount[i] < 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int sum = 0;\\n        \\n\\t\\t//26 size array because all inputs are lowercase english letters\\n\\t\\t//prepare char count array using the private method\\n        int[] charsCount = getCountArray(chars);\\n        \\n        for (String word : words) {\\n\\t\\t//prepare char count array for each word in the words list\\n            int[] wordCount = getCountArray(word);\\n\\t\\t\\t\\n\\t\\t\\t//check if the word can be formed by characters in the given \"chars\" string\\n            if(isWordPossible(charsCount,wordCount)) {\\n\\t\\t\\t//if yes, add the current word\\'s length to the sum\\n                sum += word.length();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private static int[] getCountArray(String w) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i < w.length(); i++) {\\n            counts[w.charAt(i) - \\'a\\']++;\\n        }\\n        return counts;\\n    }\\n    \\n    private boolean isWordPossible(int[] cCount, int[] wCount) {\\n        for(int i = 0; i < cCount.length; i++) {\\n            if(cCount[i] - wCount[i] < 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602578,
                "title": "python-3-simple-use-for-else-control-loop-99-100",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res = 0\\n        for w in words:\\n            for l in w:\\n                if l not in chars or w.count(l) > chars.count(l):\\n                    break\\n            else: res += len(w)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res = 0\\n        for w in words:\\n            for l in w:\\n                if l not in chars or w.count(l) > chars.count(l):\\n                    break\\n            else: res += len(w)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 533699,
                "title": "ruby-iterating-with-hash",
                "content": "```rb\\ndef count_characters(words, chars)\\n    value = 0\\n    chars_counts = Hash.new(0)\\n    chars.chars.each { |char| chars_counts[char] += 1 }\\n   \\n    words.each do |word| \\n        word_chars = word.chars\\n        available_chars = chars_counts.dup\\n        value += word_chars.size if can_form_word?(word_chars,available_chars)\\n    end\\n    \\n    value\\nend\\n\\ndef can_form_word?(word_chars, available_chars)\\n    word_chars.each do |char|\\n        available_chars[char] -= 1  \\n        return false unless available_chars[char] >= 0\\n    end\\n    true\\nend\\n```",
                "solutionTags": [],
                "code": "```rb\\ndef count_characters(words, chars)\\n    value = 0\\n    chars_counts = Hash.new(0)\\n    chars.chars.each { |char| chars_counts[char] += 1 }\\n   \\n    words.each do |word| \\n        word_chars = word.chars\\n        available_chars = chars_counts.dup\\n        value += word_chars.size if can_form_word?(word_chars,available_chars)\\n    end\\n    \\n    value\\nend\\n\\ndef can_form_word?(word_chars, available_chars)\\n    word_chars.each do |char|\\n        available_chars[char] -= 1  \\n        return false unless available_chars[char] >= 0\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 520416,
                "title": "javascript-using-hashmap-reduce-human-readable",
                "content": "```\\nvar countCharacters = function(words, chars) {\\n    const dict = new Map();\\n    chars.split(\\'\\').forEach(c => {\\n        if(dict.has(c)) {\\n            dict.set(c, dict.get(c) + 1);\\n        } else {\\n            dict.set(c, 1);\\n        }\\n    })\\n    const reducer = (acc, curr) => {\\n        const reference = new Map(dict);\\n        for(let i = 0; i< curr.length; i++) {\\n            if(reference.has(curr[i]) && reference.get(curr[i]) > 0) {\\n                if(i === curr.length - 1) acc += curr.length;\\n                reference.set(curr[i], reference.get(curr[i]) - 1);\\n            } else {\\n                break;\\n            }\\n        }\\n        return acc;   \\n    }\\n    return words.reduce(reducer, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    const dict = new Map();\\n    chars.split(\\'\\').forEach(c => {\\n        if(dict.has(c)) {\\n            dict.set(c, dict.get(c) + 1);\\n        } else {\\n            dict.set(c, 1);\\n        }\\n    })\\n    const reducer = (acc, curr) => {\\n        const reference = new Map(dict);\\n        for(let i = 0; i< curr.length; i++) {\\n            if(reference.has(curr[i]) && reference.get(curr[i]) > 0) {\\n                if(i === curr.length - 1) acc += curr.length;\\n                reference.set(curr[i], reference.get(curr[i]) - 1);\\n            } else {\\n                break;\\n            }\\n        }\\n        return acc;   \\n    }\\n    return words.reduce(reducer, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489177,
                "title": "c-44ms-98-in-speed-and-100-in-space-proper-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        // make a vector of size 26 in which each index represents a character \\n        // from \\'a\\' to \\'z\\'\\n        vector<char> m(26),temp(26);\\n        \\n        auto count = 0;\\n        \\n        // keep track of frequency of each character of chars in vector m \\n        for(auto i:chars)\\n            m[i-\\'a\\']++;\\n        \\n        // saving frequency of each char of chars in temp \\n        // so that when i make changes in the \"m\"(frequency of each char),\\n        // i will not loose my original \"m\"(frequency of each character of chars)\\n        temp = m;\\n        \\n        \\n        for(auto i:words)\\n        {\\n            bool flag = true;\\n            m = temp; \\n            for(auto j:i)\\n            {\\n                if(m[j-\\'a\\']==0)\\n                {\\n                    // situation meets and you enter this if block\\n                    // means there is some character required to make the string                        \\n\\t\\t\\t\\t\\t//on which we are currently iterating over is not in the                           \\n\\t\\t\\t\\t\\t//chars ... so we will break the inner loop and will move to                        \\n\\t\\t\\t\\t\\t//the next word in the words array\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                    m[j-\\'a\\']--;\\n            }\\n            if(flag)\\n                count+=i.length();\\n        }\\n        return count;\\n    }\\n    Solution(){\\n        // few lines of code to boost up the I/O of our program and hence execution time \\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        // make a vector of size 26 in which each index represents a character \\n        // from \\'a\\' to \\'z\\'\\n        vector<char> m(26),temp(26);\\n        \\n        auto count = 0;\\n        \\n        // keep track of frequency of each character of chars in vector m \\n        for(auto i:chars)\\n            m[i-\\'a\\']++;\\n        \\n        // saving frequency of each char of chars in temp \\n        // so that when i make changes in the \"m\"(frequency of each char),\\n        // i will not loose my original \"m\"(frequency of each character of chars)\\n        temp = m;\\n        \\n        \\n        for(auto i:words)\\n        {\\n            bool flag = true;\\n            m = temp; \\n            for(auto j:i)\\n            {\\n                if(m[j-\\'a\\']==0)\\n                {\\n                    // situation meets and you enter this if block\\n                    // means there is some character required to make the string                        \\n\\t\\t\\t\\t\\t//on which we are currently iterating over is not in the                           \\n\\t\\t\\t\\t\\t//chars ... so we will break the inner loop and will move to                        \\n\\t\\t\\t\\t\\t//the next word in the words array\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                    m[j-\\'a\\']--;\\n            }\\n            if(flag)\\n                count+=i.length();\\n        }\\n        return count;\\n    }\\n    Solution(){\\n        // few lines of code to boost up the I/O of our program and hence execution time \\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 475915,
                "title": "python-iterative-sol-based-on-count-of-string-95-with-explanation",
                "content": "Python iterative sol. based on count() of string\\n\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n          \\n        list_of_success = []\\n        \\n        # visit each word\\n        for word in words:\\n            \\n            # check each character\\n            for character in word:\\n                \\n                if word.count( character ) > chars.count( character ):\\n                    # miss:\\n                    # chars has no enough characters to make the word\\n                    break\\n                    \\n            else:\\n                # hit:\\n                # add the word into list of success\\n                list_of_success.append( word )\\n                \\n                \\n        return len ( \\'\\'.join( list_of_success) )\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n          \\n        list_of_success = []\\n        \\n        # visit each word\\n        for word in words:\\n            \\n            # check each character\\n            for character in word:\\n                \\n                if word.count( character ) > chars.count( character ):\\n                    # miss:\\n                    # chars has no enough characters to make the word\\n                    break\\n                    \\n            else:\\n                # hit:\\n                # add the word into list of success\\n                list_of_success.append( word )\\n                \\n                \\n        return len ( \\'\\'.join( list_of_success) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429603,
                "title": "java-4-ms-91-86-37-8-mb-100",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int result = 0;\\n        int[] charSet = new int[26];\\n        for(int i=0; i<chars.length(); i++){\\n            charSet[chars.charAt(i) - \\'a\\'] ++;\\n        }\\n        \\n        for(String word : words){\\n           int[] copySet = charSet.clone();\\n           if(wordExist(word, copySet))\\n               result += word.length(); \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean wordExist(String word, int[] copySet){\\n        for(int i=0; i<word.length(); i++){\\n               if(copySet[(word.charAt(i) - \\'a\\')] == 0  )\\n                   return false;\\n                else {\\n                    copySet[(word.charAt(i) - \\'a\\')] --;\\n                }\\n           }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int result = 0;\\n        int[] charSet = new int[26];\\n        for(int i=0; i<chars.length(); i++){\\n            charSet[chars.charAt(i) - \\'a\\'] ++;\\n        }\\n        \\n        for(String word : words){\\n           int[] copySet = charSet.clone();\\n           if(wordExist(word, copySet))\\n               result += word.length(); \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean wordExist(String word, int[] copySet){\\n        for(int i=0; i<word.length(); i++){\\n               if(copySet[(word.charAt(i) - \\'a\\')] == 0  )\\n                   return false;\\n                else {\\n                    copySet[(word.charAt(i) - \\'a\\')] --;\\n                }\\n           }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395266,
                "title": "python-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        c = Counter(chars)\\n        res = 0\\n        for w in words:\\n            cw = Counter(w)\\n            if cw == cw & c :\\n                res += len(w)\\n        return res",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        c = Counter(chars)\\n        res = 0\\n        for w in words:\\n            cw = Counter(w)\\n            if cw == cw & c :\\n                res += len(w)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 391495,
                "title": "java-solution-using-hashmap-no-copy-map",
                "content": "```\\npublic int countCharacters(String[] words, String chars) {\\n        if (chars == null || chars.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Map<Character, Integer> charCount = new HashMap<>();\\n        for (char c : chars.toCharArray()) {\\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        int totalLen = 0;\\n        \\n        for (String word : words) {\\n            boolean isFound = true;\\n            Map<Character, Integer> map = new HashMap<>();\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (map.getOrDefault(c, 0) >= charCount.getOrDefault(c, 0)) {\\n                    isFound = false;\\n                    break;\\n                }\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n            if (isFound) {\\n                totalLen += word.length();\\n            }\\n        }\\n        return totalLen;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic int countCharacters(String[] words, String chars) {\\n        if (chars == null || chars.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Map<Character, Integer> charCount = new HashMap<>();\\n        for (char c : chars.toCharArray()) {\\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        int totalLen = 0;\\n        \\n        for (String word : words) {\\n            boolean isFound = true;\\n            Map<Character, Integer> map = new HashMap<>();\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (map.getOrDefault(c, 0) >= charCount.getOrDefault(c, 0)) {\\n                    isFound = false;\\n                    break;\\n                }\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n            if (isFound) {\\n                totalLen += word.length();\\n            }\\n        }\\n        return totalLen;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 386073,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def countCharacters(self, words, chars):\\n        \"\"\"\\n        :type words: List[str]\\n        :type chars: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([len(word) for word in words if (collections.Counter(word) & collections.Counter(chars) == collections.Counter(word))])\\n```\\n\\nDoes it return early if the count of a letter isn\\'t in \"chars\"? No, but life is short and one-liners are fun.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countCharacters(self, words, chars):\\n        \"\"\"\\n        :type words: List[str]\\n        :type chars: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([len(word) for word in words if (collections.Counter(word) & collections.Counter(chars) == collections.Counter(word))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361187,
                "title": "java-clean-beats-100",
                "content": "We count the number of characters in initial String. Then for each word we create a copy of the array with counts and decrement number. If after that the number is < 0 - word cannot be formed. Otherwise - add it\\'s length to result.\\nTime - O(max(len(chars), L x len(words)) - we do 2 iterations - for for the len of chars to count characters, then L x len(words) - for each word we check every character, L is average length of word. \\nSpace - O(1) - constant space for number of characters, there will be always constant number of characters.\\n\\n```\\n    public int countCharacters(String[] words, String chars) {\\n        int[] c = new int[128];\\n        //count the num of each character\\n        for (char ch : chars.toCharArray()) {\\n            c[ch]++;\\n        }\\n        \\n        int res = 0;\\n        for (String s : words) {\\n            //create copy of count array for this word\\n            int[] c2 = Arrays.copyOf(c, 128);\\n            boolean valid = true;\\n            for (char ch : s.toCharArray()) {\\n                c2[ch]--;\\n                //if we don\\'t ave enough count of character\\n                if (c2[ch] < 0) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            //if we can form the word - add it\\'s length to the result\\n            if (valid) {\\n                res+= s.length();\\n            } \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int countCharacters(String[] words, String chars) {\\n        int[] c = new int[128];\\n        //count the num of each character\\n        for (char ch : chars.toCharArray()) {\\n            c[ch]++;\\n        }\\n        \\n        int res = 0;\\n        for (String s : words) {\\n            //create copy of count array for this word\\n            int[] c2 = Arrays.copyOf(c, 128);\\n            boolean valid = true;\\n            for (char ch : s.toCharArray()) {\\n                c2[ch]--;\\n                //if we don\\'t ave enough count of character\\n                if (c2[ch] < 0) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            //if we can form the word - add it\\'s length to the result\\n            if (valid) {\\n                res+= s.length();\\n            } \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3723315,
                "title": "easy-and-optimized-solution-in-java-97-beats-fully-explained",
                "content": "# Approach\\nThe provided solution aims to find the sum of the lengths of all \"good\" strings in an array of words, where a string is considered \"good\" if it can be formed using characters from a given `chars` string. Here\\'s a detailed explanation of the approach:\\n\\n1. Initialize a variable `lenSum` to keep track of the sum of lengths of all \"good\" strings.\\n\\n2. Count the occurrences of each character in the `chars` string by calling the `countCharacters` method. This method takes a string as input and returns an array `charCounts` of size 26 (representing the 26 lowercase English letters). Each index of `charCounts` corresponds to a letter, and the value at that index represents the count of that letter in the string. For example, `charCounts[0]` represents the count of \\'a\\', `charCounts[1]` represents the count of \\'b\\', and so on.\\n\\n3. Iterate over each word in the `words` array.\\n\\n4. For each word, count the occurrences of each character by calling the `countCharacters` method again. This time, the method returns an array `wordCounts` representing the character counts for the current word.\\n\\n5. Check if the current word can be formed using the available characters in `chars`. This is done by calling the `canFormWord` method, which takes `wordCounts` and `charCounts` as inputs. It compares the counts of each character in `wordCounts` with the corresponding counts in `charCounts`. If any character count in `wordCounts` exceeds the count in `charCounts`, it means the word cannot be formed, so the method returns `false`. Otherwise, if all character counts in `wordCounts` are less than or equal to the counts in `charCounts`, the word can be formed, and the method returns `true`.\\n\\n6. If the current word is \"good\" (i.e., it can be formed using the available characters), add its length to `lenSum`.\\n\\n7. Repeat steps 4-6 for each word in the `words` array.\\n\\n8. Finally, return the value of `lenSum`, which represents the sum of the lengths of all \"good\" strings.\\n\\nIn summary, the solution counts the occurrences of characters in both the `chars` string and each word separately. It then compares these counts to determine if each word can be formed using the available characters. By counting the characters beforehand and comparing the counts, the solution achieves an improved time complexity of O(n), where n is the total number of characters in `chars` and all words combined.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int lenSum = 0;\\n        int[] charCounts = countCharacters(chars); // Count characters in \\'chars\\'\\n\\n        for (String word : words) {\\n            int[] wordCounts = countCharacters(word); // Count characters in current word\\n            \\n            if (canFormWord(wordCounts, charCounts)) {\\n                lenSum += word.length();\\n            }\\n        }\\n\\n        return lenSum;\\n    }\\n\\n    private int[] countCharacters(String word) {\\n        int[] charCounts = new int[26];\\n        for (char c : word.toCharArray()) {\\n            charCounts[c - \\'a\\']++;\\n        }\\n        return charCounts;\\n    }\\n\\n    private boolean canFormWord(int[] wordCounts, int[] charCounts) {\\n        for (int i = 0; i < 26; i++) {\\n            if (wordCounts[i] > charCounts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int lenSum = 0;\\n        int[] charCounts = countCharacters(chars); // Count characters in \\'chars\\'\\n\\n        for (String word : words) {\\n            int[] wordCounts = countCharacters(word); // Count characters in current word\\n            \\n            if (canFormWord(wordCounts, charCounts)) {\\n                lenSum += word.length();\\n            }\\n        }\\n\\n        return lenSum;\\n    }\\n\\n    private int[] countCharacters(String word) {\\n        int[] charCounts = new int[26];\\n        for (char c : word.toCharArray()) {\\n            charCounts[c - \\'a\\']++;\\n        }\\n        return charCounts;\\n    }\\n\\n    private boolean canFormWord(int[] wordCounts, int[] charCounts) {\\n        for (int i = 0; i < 26; i++) {\\n            if (wordCounts[i] > charCounts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454322,
                "title": "c-solution-faster-than-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int CountCharacters(string[] words, string chars) {\\n        int[] freq = new int[26];\\n        for(int i = 0; i < chars.Length;i++) freq[chars[i] - \\'a\\']++;\\n        int len = 0;\\n        foreach(var word in words){\\n            int[] freqWord = new int[26];\\n            len+= word.Length;\\n            for(int i = 0; i < word.Length;i++){\\n                int idx = word[i] - \\'a\\';\\n                freqWord[idx]++;\\n                if(freqWord[idx] > freq[idx]){\\n                    len-=word.Length;\\n                    break;\\n                }\\n            } \\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCharacters(string[] words, string chars) {\\n        int[] freq = new int[26];\\n        for(int i = 0; i < chars.Length;i++) freq[chars[i] - \\'a\\']++;\\n        int len = 0;\\n        foreach(var word in words){\\n            int[] freqWord = new int[26];\\n            len+= word.Length;\\n            for(int i = 0; i < word.Length;i++){\\n                int idx = word[i] - \\'a\\';\\n                freqWord[idx]++;\\n                if(freqWord[idx] > freq[idx]){\\n                    len-=word.Length;\\n                    break;\\n                }\\n            } \\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452868,
                "title": "minimum-memory-solution-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        Map<Character, Integer> list = new HashMap<>();\\n\\n        for(int a = 0; a < chars.length(); a++){\\n            char val = chars.charAt(a);\\n\\n            if(list.containsKey(val)) list.put(val, list.get(val)+1);\\n            else list.put(val, 1);\\n        }\\n        for(String word: words){\\n            Map<Character, Integer> temp = new HashMap<>();\\n\\n            for(int a = 0; a < word.length(); a++){\\n                char val = word.charAt(a);\\n\\n                if(temp.containsKey(val)) temp.put(val, temp.get(val)+1);\\n                else temp.put(val, 1);\\n            }\\n            boolean isTrue = true;\\n            for(Map.Entry<Character, Integer> entry: temp.entrySet()){\\n                char val = entry.getKey();\\n                int  con = entry.getValue();\\n                if(!list.containsKey(val) || list.get(val)<con) isTrue = false;\\n            }\\n            if(isTrue) count += word.length();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n        Map<Character, Integer> list = new HashMap<>();\\n\\n        for(int a = 0; a < chars.length(); a++){\\n            char val = chars.charAt(a);\\n\\n            if(list.containsKey(val)) list.put(val, list.get(val)+1);\\n            else list.put(val, 1);\\n        }\\n        for(String word: words){\\n            Map<Character, Integer> temp = new HashMap<>();\\n\\n            for(int a = 0; a < word.length(); a++){\\n                char val = word.charAt(a);\\n\\n                if(temp.containsKey(val)) temp.put(val, temp.get(val)+1);\\n                else temp.put(val, 1);\\n            }\\n            boolean isTrue = true;\\n            for(Map.Entry<Character, Integer> entry: temp.entrySet()){\\n                char val = entry.getKey();\\n                int  con = entry.getValue();\\n                if(!list.containsKey(val) || list.get(val)<con) isTrue = false;\\n            }\\n            if(isTrue) count += word.length();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345877,
                "title": "beginner-friendly-99-19-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    // Create a counter array hashmap\\n    let arr = new Array(26).fill(0);\\n    for (let i = 0; i < chars.length; i++) {\\n        let index = chars.charCodeAt(i) - \\'a\\'.charCodeAt(0);\\n        arr[index]++;\\n    }\\n    // Compare each word to a new copy of the counter array, and sum up the good string words\\n    let sum = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i];\\n        let copyArr = [...arr];\\n        if(isGoodString(copyArr,word)) {\\n            sum += word.length;\\n        }\\n    }\\n    return sum;\\n};\\n// Helper function to check is the char exist the array hashmap\\nvar isGoodString = function(arr, str) {\\n    for (let j = 0; j < str.length; j++) {\\n        if (arr[str.charCodeAt(j) - \\'a\\'.charCodeAt(0)] > 0) {\\n            arr[str.charCodeAt(j) - \\'a\\'.charCodeAt(0)]--;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} chars\\n * @return {number}\\n */\\nvar countCharacters = function(words, chars) {\\n    // Create a counter array hashmap\\n    let arr = new Array(26).fill(0);\\n    for (let i = 0; i < chars.length; i++) {\\n        let index = chars.charCodeAt(i) - \\'a\\'.charCodeAt(0);\\n        arr[index]++;\\n    }\\n    // Compare each word to a new copy of the counter array, and sum up the good string words\\n    let sum = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i];\\n        let copyArr = [...arr];\\n        if(isGoodString(copyArr,word)) {\\n            sum += word.length;\\n        }\\n    }\\n    return sum;\\n};\\n// Helper function to check is the char exist the array hashmap\\nvar isGoodString = function(arr, str) {\\n    for (let j = 0; j < str.length; j++) {\\n        if (arr[str.charCodeAt(j) - \\'a\\'.charCodeAt(0)] > 0) {\\n            arr[str.charCodeAt(j) - \\'a\\'.charCodeAt(0)]--;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3340562,
                "title": "find-words-that-can-be-formed-by-characters-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int i, j, k, flag=0, flag2=0, sum_len=0;\\n        string str;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            str = chars;\\n            flag=0;\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                flag2=0;\\n                for(k=0 ; k<str.length() ; k++)\\n                {\\n                    if(words[i][j]==str[k])\\n                    {\\n                        str.erase(str.begin()+k);\\n                        flag2=1;\\n                        break;\\n                    }\\n                }\\n                if(flag2==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                sum_len += words[i].length();\\n            }\\n        }\\n        return sum_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int i, j, k, flag=0, flag2=0, sum_len=0;\\n        string str;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            str = chars;\\n            flag=0;\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                flag2=0;\\n                for(k=0 ; k<str.length() ; k++)\\n                {\\n                    if(words[i][j]==str[k])\\n                    {\\n                        str.erase(str.begin()+k);\\n                        flag2=1;\\n                        break;\\n                    }\\n                }\\n                if(flag2==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                sum_len += words[i].length();\\n            }\\n        }\\n        return sum_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281353,
                "title": "c-easy-but-slowly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int result=0;\\n        map<char,int> mp1;\\n        for(const auto&it:chars) mp1[it]++;\\n        \\n        for(const auto&it:words){\\n            bool flag=1;\\n            map<char,int> mp2;\\n            for(const auto&itr:it) mp2[itr]++;\\n\\n            if(mp2.size()>mp1.size()){\\n                continue;\\n                mp2.clear();\\n            }\\n            for(const auto&it:mp2){\\n\\n                if(mp1[it.first] < it.second) {\\n                    flag=0;\\n                }\\n            }\\n            if(flag) result+=it.size();\\n            mp2.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int result=0;\\n        map<char,int> mp1;\\n        for(const auto&it:chars) mp1[it]++;\\n        \\n        for(const auto&it:words){\\n            bool flag=1;\\n            map<char,int> mp2;\\n            for(const auto&itr:it) mp2[itr]++;\\n\\n            if(mp2.size()>mp1.size()){\\n                continue;\\n                mp2.clear();\\n            }\\n            for(const auto&it:mp2){\\n\\n                if(mp1[it.first] < it.second) {\\n                    flag=0;\\n                }\\n            }\\n            if(flag) result+=it.size();\\n            mp2.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173629,
                "title": "js-javascript-solution-using-map",
                "content": "# Code\\n```\\nconst countCharacters = (words, chars) => {\\n    let result = 0;\\n    const charsMap = new Map();\\n    for (const char of chars) {\\n        charsMap.has(char) ? charsMap.set(char, charsMap.get(char) + 1) : charsMap.set(char, 1);\\n    }\\n    for (const word of words) {\\n        const wordMap = new Map();\\n        for (const char of word) {\\n            wordMap.has(char) ? wordMap.set(char, wordMap.get(char) + 1) : wordMap.set(char, 1);\\n        }\\n        for (let i = 0; i < word.length; i++) {\\n            if (charsMap.has(word[i])) {\\n                if (wordMap.get(word[i]) > charsMap.get(word[i])) {\\n                    break;\\n                }\\n            } else {\\n                break;\\n            }\\n            if (i === word.length - 1) result += word.length;\\n        }\\n    }\\n    return result;\\n};\\n```\\n* Runtime: 164 ms (Beats 72.3%)\\n* Memory: 50.9 MB (Beats 42.15%)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst countCharacters = (words, chars) => {\\n    let result = 0;\\n    const charsMap = new Map();\\n    for (const char of chars) {\\n        charsMap.has(char) ? charsMap.set(char, charsMap.get(char) + 1) : charsMap.set(char, 1);\\n    }\\n    for (const word of words) {\\n        const wordMap = new Map();\\n        for (const char of word) {\\n            wordMap.has(char) ? wordMap.set(char, wordMap.get(char) + 1) : wordMap.set(char, 1);\\n        }\\n        for (let i = 0; i < word.length; i++) {\\n            if (charsMap.has(word[i])) {\\n                if (wordMap.get(word[i]) > charsMap.get(word[i])) {\\n                    break;\\n                }\\n            } else {\\n                break;\\n            }\\n            if (i === word.length - 1) result += word.length;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106048,
                "title": "javascript-solution",
                "content": "```\\nvar countCharacters = function(words, chars) {\\n    const array = []\\n    let count = 0\\n    \\n    for (let word of words) {\\n        const map = new Map()\\n        for (let char of chars) {\\n            map.set(char, map.get(char) + 1 || 1)\\n        }\\n        \\n        for (let i = 0; i < word.length; i++){\\n            if (!map.get(word[i])) break\\n            map.set(word[i], map.get(word[i]) - 1)\\n            if (i === word.length - 1) array.push(word)\\n        }\\n    }\\n    \\n    for (let word of array) {\\n        count += word.length\\n    }\\n    return count\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    const array = []\\n    let count = 0\\n    \\n    for (let word of words) {\\n        const map = new Map()\\n        for (let char of chars) {\\n            map.set(char, map.get(char) + 1 || 1)\\n        }\\n        \\n        for (let i = 0; i < word.length; i++){\\n            if (!map.get(word[i])) break\\n            map.set(word[i], map.get(word[i]) - 1)\\n            if (i === word.length - 1) array.push(word)\\n        }\\n    }\\n    \\n    for (let word of array) {\\n        count += word.length\\n    }\\n    return count\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3102362,
                "title": "java-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i=0;i<chars.length();i++) {\\n            char c = chars.charAt(i);\\n            if(hm.containsKey(c)) {\\n                hm.put(c,hm.get(c)+1);\\n            } else {\\n                hm.put(c,1);\\n            }\\n        }\\n\\n        for(int i=0;i<words.length;i++) {\\n            HashMap<Character,Integer> tempMap = new HashMap<>();\\n                for(int j =0;j<words[i].length();j++) {\\n                    char c = words[i].charAt(j);\\n                    if(tempMap.containsKey(c)) {\\n                    tempMap.put(c,tempMap.get(c)+1);\\n                } else {\\n                    tempMap.put(c,1);\\n                }\\n             }\\n             boolean flag = true;\\n             for(Character ch : tempMap.keySet()) {\\n                 if(hm.containsKey(ch) && hm.get(ch) >= tempMap.get(ch)) {\\n                     continue;\\n                 } else {\\n                     flag = false;\\n                     break;\\n                 }\\n             }\\n             if(flag) {\\n                 count += words[i].length();\\n             }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count = 0;\\n\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i=0;i<chars.length();i++) {\\n            char c = chars.charAt(i);\\n            if(hm.containsKey(c)) {\\n                hm.put(c,hm.get(c)+1);\\n            } else {\\n                hm.put(c,1);\\n            }\\n        }\\n\\n        for(int i=0;i<words.length;i++) {\\n            HashMap<Character,Integer> tempMap = new HashMap<>();\\n                for(int j =0;j<words[i].length();j++) {\\n                    char c = words[i].charAt(j);\\n                    if(tempMap.containsKey(c)) {\\n                    tempMap.put(c,tempMap.get(c)+1);\\n                } else {\\n                    tempMap.put(c,1);\\n                }\\n             }\\n             boolean flag = true;\\n             for(Character ch : tempMap.keySet()) {\\n                 if(hm.containsKey(ch) && hm.get(ch) >= tempMap.get(ch)) {\\n                     continue;\\n                 } else {\\n                     flag = false;\\n                     break;\\n                 }\\n             }\\n             if(flag) {\\n                 count += words[i].length();\\n             }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097302,
                "title": "array-string-only-used-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] char_map;\\n    public int countCharacters(String[] words, String chars) {\\n        char_map=new int[26];\\n       int ans=0;\\n       for(char c : chars.toCharArray()){\\n           char_map[c-\\'a\\']++;\\n       }\\n\\n       for(String word: words){\\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\\n           int count =0;\\n           for(char c: word.toCharArray()){\\n               if(dummyArray[c-\\'a\\']>0){\\n                   count++;\\n                   dummyArray[c-\\'a\\']--;\\n               }\\n           }\\n           if(count==word.length()){\\n               ans+=word.length();\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] char_map;\\n    public int countCharacters(String[] words, String chars) {\\n        char_map=new int[26];\\n       int ans=0;\\n       for(char c : chars.toCharArray()){\\n           char_map[c-\\'a\\']++;\\n       }\\n\\n       for(String word: words){\\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\\n           int count =0;\\n           for(char c: word.toCharArray()){\\n               if(dummyArray[c-\\'a\\']>0){\\n                   count++;\\n                   dummyArray[c-\\'a\\']--;\\n               }\\n           }\\n           if(count==word.length()){\\n               ans+=word.length();\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088497,
                "title": "easy-approach-using-hash-table-o-nk-time-o-26-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n       vector<int>hash(26,0);\\n        int ans=0;\\n        for(int i=0;i<chars.length();i++){\\n            hash[chars[i]-97]++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            bool canMake=true;\\n            vector<int>org(hash);\\n            for(int j=0;j<temp.length();j++){\\n                if(hash[temp[j]-97]<=0){\\n                    canMake=false;\\n                    break;\\n                }else{\\n                    hash[temp[j]-97]--;\\n                }\\n            }\\n            hash=org;\\n            if(canMake){\\n                ans+=temp.length();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n       vector<int>hash(26,0);\\n        int ans=0;\\n        for(int i=0;i<chars.length();i++){\\n            hash[chars[i]-97]++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            bool canMake=true;\\n            vector<int>org(hash);\\n            for(int j=0;j<temp.length();j++){\\n                if(hash[temp[j]-97]<=0){\\n                    canMake=false;\\n                    break;\\n                }else{\\n                    hash[temp[j]-97]--;\\n                }\\n            }\\n            hash=org;\\n            if(canMake){\\n                ans+=temp.length();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069735,
                "title": "java-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n       int arr[] = new int[26];\\n       for(int i=0;i<chars.length();i++){\\n           arr[chars.charAt(i)-\\'a\\']++;\\n       }\\n       boolean c =false;\\n       int sum = 0;\\n       for(int i=0;i<words.length;i++){\\n           String temp = words[i];\\n           HashMap<Character,Integer>map = new HashMap();\\n           for(int j=0;j<temp.length();j++){\\n               map.put(temp.charAt(j),map.getOrDefault(temp.charAt(j),0)+1);\\n           }\\n           for(int k=0;k<temp.length();k++){\\n               if(!(arr[temp.charAt(k)-\\'a\\']>=map.get(temp.charAt(k)))){\\n                   c = true;\\n                   break;\\n               }\\n           }\\n            if(!c){\\n                sum+=temp.length();\\n            }\\n            c = false;\\n       }\\n       return sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n       int arr[] = new int[26];\\n       for(int i=0;i<chars.length();i++){\\n           arr[chars.charAt(i)-\\'a\\']++;\\n       }\\n       boolean c =false;\\n       int sum = 0;\\n       for(int i=0;i<words.length;i++){\\n           String temp = words[i];\\n           HashMap<Character,Integer>map = new HashMap();\\n           for(int j=0;j<temp.length();j++){\\n               map.put(temp.charAt(j),map.getOrDefault(temp.charAt(j),0)+1);\\n           }\\n           for(int k=0;k<temp.length();k++){\\n               if(!(arr[temp.charAt(k)-\\'a\\']>=map.get(temp.charAt(k)))){\\n                   c = true;\\n                   break;\\n               }\\n           }\\n            if(!c){\\n                sum+=temp.length();\\n            }\\n            c = false;\\n       }\\n       return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886813,
                "title": "beginner-friendly-java-solution",
                "content": "# Complexity\\n- Time complexity:\\n**O(m*n)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int ch[] = new int[26];\\n        for(char c: chars.toCharArray())  ch[c - \\'a\\']++;\\n        int count = 0;\\n        for(String word : words){\\n            int tmp[] = ch.clone();\\n            count += word.length();\\n            for(char c : word.toCharArray()){\\n                tmp[c - \\'a\\']--;\\n                if(tmp[c - \\'a\\'] < 0){\\n                    count -= word.length();\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int ch[] = new int[26];\\n        for(char c: chars.toCharArray())  ch[c - \\'a\\']++;\\n        int count = 0;\\n        for(String word : words){\\n            int tmp[] = ch.clone();\\n            count += word.length();\\n            for(char c : word.toCharArray()){\\n                tmp[c - \\'a\\']--;\\n                if(tmp[c - \\'a\\'] < 0){\\n                    count -= word.length();\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666173,
                "title": "hashmap-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        unordered_map<char,int> l,b;\\n        for(auto i: chars)\\n        {\\n            l[i]+=1;\\n        }\\n        \\n        b = l;\\n        \\n        int res = 0;\\n        for(auto i: words)\\n        {\\n           l=b; \\n           for(int j=0;j<i.length();j++)\\n           {\\n               if(l[i[j]] == 0)\\n                   break;\\n               l[i[j]]-=1;\\n               if(j==i.length()-1)\\n                   res+=i.length();\\n           }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        unordered_map<char,int> l,b;\\n        for(auto i: chars)\\n        {\\n            l[i]+=1;\\n        }\\n        \\n        b = l;\\n        \\n        int res = 0;\\n        for(auto i: words)\\n        {\\n           l=b; \\n           for(int j=0;j<i.length();j++)\\n           {\\n               if(l[i[j]] == 0)\\n                   break;\\n               l[i[j]]-=1;\\n               if(j==i.length()-1)\\n                   res+=i.length();\\n           }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484327,
                "title": "c-using-mapping",
                "content": "\\n\\n\\'\\'\\'\\n bool check( string s ,  unordered_map< char , int >mp  )\\n    {\\n        unordered_map< char , int >mp1 ;\\n        \\n        for( auto i : s) mp1[i]++ ;\\n        \\n        for( auto i : mp1 )\\n        {\\n            if(mp[i.first] < mp1[i.first])\\n            {\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n      \\n        \\n         unordered_map< char , int >mp ;\\n        \\n        for( auto i : chars ) mp[i]++ ;\\n        \\n        int count = 0 ;\\n        \\n        for( int i = 0 ; i < words.size() ; i++ )\\n        {\\n            if( check( words[i] , mp )) \\n            {\\n                count += words[i].size() ;\\n            }\\n        }\\n        \\n      return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\n\\'\\'\\'\\n bool check( string s ,  unordered_map< char , int >mp  )\\n    {\\n        unordered_map< char , int >mp1 ;\\n        \\n        for( auto i : s) mp1[i]++ ;\\n        \\n        for( auto i : mp1 )\\n        {\\n            if(mp[i.first] < mp1[i.first])\\n            {\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n      \\n        \\n         unordered_map< char , int >mp ;\\n        \\n        for( auto i : chars ) mp[i]++ ;\\n        \\n        int count = 0 ;\\n        \\n        for( int i = 0 ; i < words.size() ; i++ )\\n        {\\n            if( check( words[i] , mp )) \\n            {\\n                count += words[i].size() ;\\n            }\\n        }\\n        \\n      return count ;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2436747,
                "title": "python-faster-solution-and-easy",
                "content": "```\\ndef countCharacters(self, words: List[str], chars: str) -> int:\\n        char=set(chars)\\n        count=0\\n        for i in words:\\n            for j in i:\\n                if(chars.count(j)<i.count(j)):\\n                    break\\n            else:\\n                count+=len(i)\\n        return count\\n    \\n    \\n```",
                "solutionTags": [],
                "code": "```\\ndef countCharacters(self, words: List[str], chars: str) -> int:\\n        char=set(chars)\\n        count=0\\n        for i in words:\\n            for j in i:\\n                if(chars.count(j)<i.count(j)):\\n                    break\\n            else:\\n                count+=len(i)\\n        return count\\n    \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2425817,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int[] freq = new int[26];\\n        int res=0;\\n        List<String> ans = new ArrayList<>();\\n        \\n        for(char c : chars.toCharArray())\\n            freq[c-\\'a\\']++;\\n        \\n        for(String s : words){\\n            int[] count = new int[26];\\n            boolean flag = true;\\n            for(char c : s.toCharArray()){\\n                count[c-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(freq[i]<count[i]){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n                ans.add(s);\\n        }\\n        \\n        System.out.print(ans);\\n        \\n        for(int i=0; i<ans.size(); i++){\\n            res += ans.get(i).length();\\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int[] freq = new int[26];\\n        int res=0;\\n        List<String> ans = new ArrayList<>();\\n        \\n        for(char c : chars.toCharArray())\\n            freq[c-\\'a\\']++;\\n        \\n        for(String s : words){\\n            int[] count = new int[26];\\n            boolean flag = true;\\n            for(char c : s.toCharArray()){\\n                count[c-\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2358392,
                "title": "java-faster-than-98-simple-explaination",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] freq = new int[26];\\n        for (int i = 0; i < chars.length(); i++) {\\n            // char - char is a kind of clever way to get the position of\\n            // the character in the alphabet. \\'a\\' - \\'a\\' would give you 0.\\n            // \\'b\\' - \\'a\\' would give you 1. \\'c\\' - \\'a\\' would give you 2, and so on.\\n            freq[chars.charAt(i) - \\'a\\'] ++;\\n        }\\n        \\n        int result = 0;\\n        for (String word : words) {\\n            int[] copy = Arrays.copyOf(freq, freq.length);\\n            boolean pass = true;\\n            for (int j = 0; j < word.length(); j++) {\\n\\t\\t\\t\\t// decrement the frequency of this char in array for using\\n\\t\\t\\t\\t// if there are less than 1 chance for using this character, invalid, \\n\\t\\t\\t\\t// move to next word in words\\n                if (-- copy[word.charAt(j) - \\'a\\'] < 0) {\\n                    pass = false;\\n                    break;\\n                }\\n            }\\n            if (pass) {\\n                result += word.length();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int[] freq = new int[26];\\n        for (int i = 0; i < chars.length(); i++) {\\n            // char - char is a kind of clever way to get the position of\\n            // the character in the alphabet. \\'a\\' - \\'a\\' would give you 0.\\n            // \\'b\\' - \\'a\\' would give you 1. \\'c\\' - \\'a\\' would give you 2, and so on.\\n            freq[chars.charAt(i) - \\'a\\'] ++;\\n        }\\n        \\n        int result = 0;\\n        for (String word : words) {\\n            int[] copy = Arrays.copyOf(freq, freq.length);\\n            boolean pass = true;\\n            for (int j = 0; j < word.length(); j++) {\\n\\t\\t\\t\\t// decrement the frequency of this char in array for using\\n\\t\\t\\t\\t// if there are less than 1 chance for using this character, invalid, \\n\\t\\t\\t\\t// move to next word in words\\n                if (-- copy[word.charAt(j) - \\'a\\'] < 0) {\\n                    pass = false;\\n                    break;\\n                }\\n            }\\n            if (pass) {\\n                result += word.length();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277268,
                "title": "python-counter-easy-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter = Counter(chars)\\n        res = 0\\n        for word in words:\\n            word_counter = Counter(word)\\n            if all(word_counter[c] <= counter[c] for c in word_counter):\\n                res += len(word)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        counter = Counter(chars)\\n        res = 0\\n        for word in words:\\n            word_counter = Counter(word)\\n            if all(word_counter[c] <= counter[c] for c in word_counter):\\n                res += len(word)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2247203,
                "title": "c-solution-with-frequencies-of-letters",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        vector<int> freq1(150, 0);\\n        \\n        for(char c:chars)\\n            freq1[(int)c]++;\\n        \\n        int res = 0;\\n        for(string word:words)\\n        {\\n            bool good = true;\\n            vector<int> freq2(150, 0);\\n            for(char c:word)\\n            {\\n                freq2[(int)c]++;\\n                if(freq2[(int)c] > freq1[(int)c])\\n                {\\n                    good = false;\\n                    break;\\n                }\\n            }\\n                          \\n            if (good)\\n                res += word.size();\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        vector<int> freq1(150, 0);\\n        \\n        for(char c:chars)\\n            freq1[(int)c]++;\\n        \\n        int res = 0;\\n        for(string word:words)\\n        {\\n            bool good = true;\\n            vector<int> freq2(150, 0);\\n            for(char c:word)\\n            {\\n                freq2[(int)c]++;\\n                if(freq2[(int)c] > freq1[(int)c])\\n                {\\n                    good = false;\\n                    break;\\n                }\\n            }\\n                          \\n            if (good)\\n                res += word.size();\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242483,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        fre = Counter(chars)\\n        count = 0\\n        for i in words:\\n            if Counter(i) <= fre:\\n                count += len(i)\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        fre = Counter(chars)\\n        count = 0\\n        for i in words:\\n            if Counter(i) <= fre:\\n                count += len(i)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242192,
                "title": "slowest-python-solution",
                "content": "```\\ndef countCharacters(self, words, chars):\\n        length = 0\\n        for word in words:\\n            if not Counter(word) - Counter(chars):\\n                length += len(word)\\n        return length\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countCharacters(self, words, chars):\\n        length = 0\\n        for word in words:\\n            if not Counter(word) - Counter(chars):\\n                length += len(word)\\n        return length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2214288,
                "title": "python-multisets",
                "content": "```\\nfrom collections import Counter as multiset\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        chars = multiset(chars)\\n        res = 0\\n        for w in words:\\n            msw = multiset(w)\\n            if msw & chars == msw:\\n                res += len(w)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as multiset\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        chars = multiset(chars)\\n        res = 0\\n        for w in words:\\n            msw = multiset(w)\\n            if msw & chars == msw:\\n                res += len(w)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211365,
                "title": "c-multiset-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/e418416d-136b-4508-a150-59228b582a5b_1656450547.0913696.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countCharacters(vector<string>& w, string c) {\\n\\t\\t\\tmultiset<char>s,t;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<c.size();i++)s.insert(c[i]);\\n\\t\\t\\tfor(int i=0;i<w.size();i++){\\n\\t\\t\\t\\tt=s;\\n\\t\\t\\t\\tbool f=true;\\n\\t\\t\\t\\tfor(int j=0;j<w[i].size();j++){\\n\\t\\t\\t\\t\\tauto it=t.find(w[i][j]);\\n\\t\\t\\t\\t\\tif(it==t.end()){\\n\\t\\t\\t\\t\\t\\tf=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tt.erase(it);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(f) ans+=w[i].size();\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countCharacters(vector<string>& w, string c) {\\n\\t\\t\\tmultiset<char>s,t;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<c.size();i++)s.insert(c[i]);\\n\\t\\t\\tfor(int i=0;i<w.size();i++){\\n\\t\\t\\t\\tt=s;\\n\\t\\t\\t\\tbool f=true;\\n\\t\\t\\t\\tfor(int j=0;j<w[i].size();j++){\\n\\t\\t\\t\\t\\tauto it=t.find(w[i][j]);\\n\\t\\t\\t\\t\\tif(it==t.end()){\\n\\t\\t\\t\\t\\t\\tf=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2200781,
                "title": "python3-simple",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        charCounts = Counter(chars)\\n        \\n        def canBeFormed(word: str) -> int:\\n            for k, v in Counter(word).items():\\n                if v > charCounts[k]:\\n                    return 0\\n            return len(word)\\n        \\n        res = 0   \\n        for word in words:\\n            res += canBeFormed(word)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        charCounts = Counter(chars)\\n        \\n        def canBeFormed(word: str) -> int:\\n            for k, v in Counter(word).items():\\n                if v > charCounts[k]:\\n                    return 0\\n            return len(word)\\n        \\n        res = 0   \\n        for word in words:\\n            res += canBeFormed(word)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094684,
                "title": "java-easy-to-understand",
                "content": "```\\npublic int countCharacters(String[] words, String chars) {\\n        int [] temp=new int[26];\\n        int ans=0;\\n        HashSet<Character>st=new HashSet<>();\\n        for(char c:chars.toCharArray()){\\n            temp[c-\\'a\\']++;\\n        }\\n        System.out.print(st);\\n        for(String s:words){\\n            if(ismatch(s,temp)){\\n\\n                ans+=s.length();\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    boolean ismatch(String s,int[] temp){\\n        int []temp1=Arrays.copyOf(temp, temp.length);\\n        for(char str:s.toCharArray()){\\n            if(temp1[str-\\'a\\']==0) return false;\\n            else temp1[str-\\'a\\']--;\\n\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countCharacters(String[] words, String chars) {\\n        int [] temp=new int[26];\\n        int ans=0;\\n        HashSet<Character>st=new HashSet<>();\\n        for(char c:chars.toCharArray()){\\n            temp[c-\\'a\\']++;\\n        }\\n        System.out.print(st);\\n        for(String s:words){\\n            if(ismatch(s,temp)){\\n\\n                ans+=s.length();\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    boolean ismatch(String s,int[] temp){\\n        int []temp1=Arrays.copyOf(temp, temp.length);\\n        for(char str:s.toCharArray()){\\n            if(temp1[str-\\'a\\']==0) return false;\\n            else temp1[str-\\'a\\']--;\\n\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086449,
                "title": "find-words-that-can-be-formed-by-characters-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_map<char,int> freqCount(string &s)\\n    {\\n        unordered_map<char,int> freq;\\n        \\n        for(auto ch: s)\\n        {\\n            freq[ch]++;\\n        }\\n        \\n        return freq;\\n    }\\n    \\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        unordered_map<char,int> chFreq;\\n        \\n        unordered_map<char,int> wordFreq;\\n        \\n        chFreq= freqCount(chars);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            string currString= words[i];\\n            \\n            wordFreq= freqCount(currString);\\n            \\n            int flag=0;\\n            \\n            for(auto ch: currString)\\n            {\\n                if(chFreq[ch]<wordFreq[ch])\\n                    flag=1;\\n                    \\n            }\\n            \\n            if(flag!=1)\\n                sum+= currString.length();  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_map<char,int> freqCount(string &s)\\n    {\\n        unordered_map<char,int> freq;\\n        \\n        for(auto ch: s)\\n        {\\n            freq[ch]++;\\n        }\\n        \\n        return freq;\\n    }\\n    \\n    int countCharacters(vector<string>& words, string chars) {\\n        \\n        unordered_map<char,int> chFreq;\\n        \\n        unordered_map<char,int> wordFreq;\\n        \\n        chFreq= freqCount(chars);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            string currString= words[i];\\n            \\n            wordFreq= freqCount(currString);\\n            \\n            int flag=0;\\n            \\n            for(auto ch: currString)\\n            {\\n                if(chFreq[ch]<wordFreq[ch])\\n                    flag=1;\\n                    \\n            }\\n            \\n            if(flag!=1)\\n                sum+= currString.length();  \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055758,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar countCharacters = function(words, chars) {\\n    const hash = chars.split(\\'\\').reduce((res, c) => {\\n        if (!res[c]) {\\n            res[c] = 0;\\n        }\\n        \\n        res[c]++;\\n        \\n        return res;\\n    }, {});\\n    \\n    const useChar = (hash, c) => {\\n        if (!hash[c]) {\\n            return false;\\n        }\\n    \\n        hash[c]--;\\n        \\n        if (hash[c] === 0) {\\n            delete hash[c];\\n        }\\n        \\n        return true;\\n    };\\n    \\n    return words\\n        .filter((word) => {\\n            let i = 0;\\n            const map = {...hash};\\n        \\n            while (useChar(map, word[i]) && i < word.length) {\\n                i++;\\n            }\\n        \\n            return i === word.length;\\n        })\\n        .reduce((res, word) => res + word.length, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    const hash = chars.split(\\'\\').reduce((res, c) => {\\n        if (!res[c]) {\\n            res[c] = 0;\\n        }\\n        \\n        res[c]++;\\n        \\n        return res;\\n    }, {});\\n    \\n    const useChar = (hash, c) => {\\n        if (!hash[c]) {\\n            return false;\\n        }\\n    \\n        hash[c]--;\\n        \\n        if (hash[c] === 0) {\\n            delete hash[c];\\n        }\\n        \\n        return true;\\n    };\\n    \\n    return words\\n        .filter((word) => {\\n            let i = 0;\\n            const map = {...hash};\\n        \\n            while (useChar(map, word[i]) && i < word.length) {\\n                i++;\\n            }\\n        \\n            return i === word.length;\\n        })\\n        .reduce((res, word) => res + word.length, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039597,
                "title": "no-inbuilt-function-used-and-easy-to-understand",
                "content": "```\\ndef countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\tmatch = myCounter(chars)\\n\\t\\tres = 0\\n\\t\\tfor word in words:\\n\\t\\t\\ttemp = match.copy()\\n\\t\\t\\tpresent = True\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tif ch in temp and temp[ch] > 0:\\n\\t\\t\\t\\t\\ttemp[ch] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpresent = False\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif present:\\n\\t\\t\\t\\tres += len(word)\\n\\t\\treturn res      \\n\\ndef myCounter(string):\\n\\td = {}\\n\\tfor ch in string:\\n\\t\\tif ch in d: d[ch]+=1\\n\\t\\telse: d[ch] = 1\\n\\treturn d\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countCharacters(self, words: List[str], chars: str) -> int:\\n\\t\\tmatch = myCounter(chars)\\n\\t\\tres = 0\\n\\t\\tfor word in words:\\n\\t\\t\\ttemp = match.copy()\\n\\t\\t\\tpresent = True\\n\\t\\t\\tfor ch in word:\\n\\t\\t\\t\\tif ch in temp and temp[ch] > 0:\\n\\t\\t\\t\\t\\ttemp[ch] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpresent = False\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif present:\\n\\t\\t\\t\\tres += len(word)\\n\\t\\treturn res      \\n\\ndef myCounter(string):\\n\\td = {}\\n\\tfor ch in string:\\n\\t\\tif ch in d: d[ch]+=1\\n\\t\\telse: d[ch] = 1\\n\\treturn d\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2027599,
                "title": "java-solution-using-a-hashmap",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: chars.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        \\n        int ans = 0;\\n        for(String s: words) {\\n            Map<Character, Integer> count = new HashMap<>();\\n            int i = 0;\\n            for(; i<s.length(); i++) {\\n                char c = s.charAt(i);\\n                if(map.containsKey(c)) {\\n                    if(count.containsKey(c) && count.get(c) + 1 > map.get(c))\\n                        break;\\n                    count.put(c, count.getOrDefault(c, 0) + 1);\\n                } else\\n                    break;\\n            }\\n            if(i == s.length())\\n                ans += s.length();\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: chars.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        \\n        int ans = 0;\\n        for(String s: words) {\\n            Map<Character, Integer> count = new HashMap<>();\\n            int i = 0;\\n            for(; i<s.length(); i++) {\\n                char c = s.charAt(i);\\n                if(map.containsKey(c)) {\\n                    if(count.containsKey(c) && count.get(c) + 1 > map.get(c))\\n                        break;\\n                    count.put(c, count.getOrDefault(c, 0) + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1964580,
                "title": "6-ms-faster-than-93-57-of-java-online-submissions",
                "content": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int allowedFreqChar[] = getFreq(chars);\\n        int count =0 ;\\n        for(String str : words){\\n            int freqChar[] = getFreq(str);\\n            if(isAllowed(allowedFreqChar, freqChar)) {\\n                count+= str.length();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isAllowed(int allowedFreqChar[], int freqChar[]){\\n        for(int i=0;i<allowedFreqChar.length;i++){\\n            if(allowedFreqChar[i] - freqChar[i] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int[] getFreq(String chars){\\n        int freq[] = new int[26];\\n        for(char c : chars.toCharArray()){\\n            freq[c - \\'a\\']++;\\n        }\\n        return freq;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        \\n        int allowedFreqChar[] = getFreq(chars);\\n        int count =0 ;\\n        for(String str : words){\\n            int freqChar[] = getFreq(str);\\n            if(isAllowed(allowedFreqChar, freqChar)) {\\n                count+= str.length();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1951603,
                "title": "python-beats-90-using-dictionary",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res=0\\n        dic=defaultdict(int)\\n        for c in chars:\\n            dic[c]+=1\\n        for w in words:\\n            if all(w.count(c)<=dic[c] for c in w):\\n                res+=len(w)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        res=0\\n        dic=defaultdict(int)\\n        for c in chars:\\n            dic[c]+=1\\n        for w in words:\\n            if all(w.count(c)<=dic[c] for c in w):\\n                res+=len(w)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943305,
                "title": "java-faster-than-94-7-frequency-array-easier-to-code-than-map-in-java",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int len = 0;\\n        \\n        // freq\\n        int[] f = new int[26];\\n        for(int i = 0; i < chars.length(); i++){\\n            f[chars.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // check each word\\n        for(String word : words){\\n            if(check(word, f)) len += word.length();\\n        }\\n        return len;\\n    }\\n    \\n    private boolean check(String word, int[] f){\\n        int[] w = new int[26];\\n        for(int i = 0; i < word.length(); i++){\\n            w[word.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(f[i] - w[i] < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int len = 0;\\n        \\n        // freq\\n        int[] f = new int[26];\\n        for(int i = 0; i < chars.length(); i++){\\n            f[chars.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        // check each word\\n        for(String word : words){\\n            if(check(word, f)) len += word.length();\\n        }\\n        return len;\\n    }\\n    \\n    private boolean check(String word, int[] f){\\n        int[] w = new int[26];\\n        for(int i = 0; i < word.length(); i++){\\n            w[word.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(f[i] - w[i] < 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940107,
                "title": "easiest-hashmap-solution-using-java",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) \\n    {\\n        int count=0;\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char i:chars.toCharArray())\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        for(String str:words)\\n        {\\n            int flag=0;\\n            HashMap<Character,Integer> hmap2=new HashMap<>(hmap);\\n            for(char ch:str.toCharArray())\\n            {\\n                hmap2.put(ch,hmap2.getOrDefault(ch,0)-1);\\n                if(!chars.contains(\"\"+ch) || hmap2.get(ch)==-1)\\n                {\\n                    flag=-1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                count+=str.length();\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) \\n    {\\n        int count=0;\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char i:chars.toCharArray())\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        for(String str:words)\\n        {\\n            int flag=0;\\n            HashMap<Character,Integer> hmap2=new HashMap<>(hmap);\\n            for(char ch:str.toCharArray())\\n            {\\n                hmap2.put(ch,hmap2.getOrDefault(ch,0)-1);\\n                if(!chars.contains(\"\"+ch) || hmap2.get(ch)==-1)\\n                {\\n                    flag=-1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1925256,
                "title": "simple-java-solution-using-map",
                "content": "\\n```\\n  Map<Character,Integer> mapMain= new HashMap<>();\\n\\n        int result=0;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char  ch=chars.charAt(i);\\n            int count=mapMain.getOrDefault(ch,0);\\n            mapMain.put(ch,++count);\\n        }\\n        for (String wo:words){\\n            Map<Character,Integer> map= new HashMap<>(mapMain);\\n            boolean possible=true;\\n            for (int i = 0; i < wo.length(); i++) {\\n                char ch=wo.charAt(i);\\n                int count=map.getOrDefault(ch,0);\\n                if (count>0) {\\n                    map.put(ch, --count);\\n                }else\\n                {\\n                    System.out.println(\"This word cant be formed \"+wo);\\n                    possible=false;\\n                    break;\\n                }\\n            }\\n            if (possible) result+=wo.length();\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  Map<Character,Integer> mapMain= new HashMap<>();\\n\\n        int result=0;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char  ch=chars.charAt(i);\\n            int count=mapMain.getOrDefault(ch,0);\\n            mapMain.put(ch,++count);\\n        }\\n        for (String wo:words){\\n            Map<Character,Integer> map= new HashMap<>(mapMain);\\n            boolean possible=true;\\n            for (int i = 0; i < wo.length(); i++) {\\n                char ch=wo.charAt(i);\\n                int count=map.getOrDefault(ch,0);\\n                if (count>0) {\\n                    map.put(ch, --count);\\n                }else\\n                {\\n                    System.out.println(\"This word cant be formed \"+wo);\\n                    possible=false;\\n                    break;\\n                }\\n            }\\n            if (possible) result+=wo.length();\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918471,
                "title": "python-one-liner-counter",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def countCharacters(self, words, chars):\\n        d, total = Counter(chars), 0\\n        for w in words: total += self.helper(w, d.copy())\\n        return total\\n    \\n    def helper(self, w, d):\\n        for c in w:\\n            if c not in d or d[c] == 0: return 0\\n            else: d[c]-=1\\n        return len(w)\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def countCharacters(self, words, chars):\\n        return (lambda c:sum(len(x) for x in words if Counter(x) < c))(Counter(chars))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words, chars):\\n        d, total = Counter(chars), 0\\n        for w in words: total += self.helper(w, d.copy())\\n        return total\\n    \\n    def helper(self, w, d):\\n        for c in w:\\n            if c not in d or d[c] == 0: return 0\\n            else: d[c]-=1\\n        return len(w)\\n```\n```\\nclass Solution:\\n    def countCharacters(self, words, chars):\\n        return (lambda c:sum(len(x) for x in words if Counter(x) < c))(Counter(chars))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900441,
                "title": "python-idk-what-to-even-calls-this",
                "content": "First I made a helper function that would just check if word had the same characters as chars. Then I did for loop checking.\\nIf anyone knows how to make my helper function better, PLEASE, let me know.\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def isinchars(self, word, chars):\\n        word = collections.Counter(word)\\n        chars = collections.Counter(chars)\\n        for letter in word:\\n            try:\\n                if word.get(letter) > chars.get(letter):\\n                    return False\\n            except:\\n                return False\\n        return True\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        count = 0\\n        for word in words:\\n            if self.isinchars(word, chars):\\n                count += len(word)\\n        \\n        return count\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def isinchars(self, word, chars):\\n        word = collections.Counter(word)\\n        chars = collections.Counter(chars)\\n        for letter in word:\\n            try:\\n                if word.get(letter) > chars.get(letter):\\n                    return False\\n            except:\\n                return False\\n        return True\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        count = 0\\n        for word in words:\\n            if self.isinchars(word, chars):\\n                count += len(word)\\n        \\n        return count\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863466,
                "title": "c-2-hashing-solutions-hashmaps-and-char-vector",
                "content": "**Solution 1: Using char vector**\\n```\\nclass Solution {\\npublic:\\n    bool func(string s, vector<int>mp){\\n        for(char x: s){\\n            if(mp[x-\\'a\\']!=0){\\n                mp[x-\\'a\\']--;\\n            }\\n            \\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans = 0;\\n        vector<int>mp(26,0);\\n        for(char x: chars){\\n            mp[x-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            if(func(words[i], mp)){\\n                ans+=(words[i].size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2: Using Hashmaps**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool func(string word, unordered_map<char,int>mp){\\n        for(char x: word){\\n            if(mp.find(x) != mp.end()){\\n                mp[x]--;\\n                if(mp[x] == 0){\\n                    mp.erase(x);\\n                }\\n            }\\n            \\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(char x: chars){\\n            mp[x]++;\\n        }\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            if(func(words[i], mp)){\\n                ans+=(words[i].size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(string s, vector<int>mp){\\n        for(char x: s){\\n            if(mp[x-\\'a\\']!=0){\\n                mp[x-\\'a\\']--;\\n            }\\n            \\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans = 0;\\n        vector<int>mp(26,0);\\n        for(char x: chars){\\n            mp[x-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            if(func(words[i], mp)){\\n                ans+=(words[i].size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool func(string word, unordered_map<char,int>mp){\\n        for(char x: word){\\n            if(mp.find(x) != mp.end()){\\n                mp[x]--;\\n                if(mp[x] == 0){\\n                    mp.erase(x);\\n                }\\n            }\\n            \\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int countCharacters(vector<string>& words, string chars) {\\n        int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(char x: chars){\\n            mp[x]++;\\n        }\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            if(func(words[i], mp)){\\n                ans+=(words[i].size());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855350,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int freq[]=new int[26];\\n        int totalLength=0;\\n        for(char ch:chars.toCharArray())\\n        {\\n            freq[ch-\\'a\\']++;\\n        }\\n        for(String word:words)\\n        {\\n            int freq1[]=new int[26];\\n            int flag=1;\\n            for(char ch: word.toCharArray())\\n            {\\n                freq1[ch-\\'a\\']++;\\n                if(freq1[ch-\\'a\\']>freq[ch-\\'a\\'])\\n                {\\n                    flag=0;\\n                }\\n            }\\n            if(flag==1)\\n                totalLength+=word.length();\\n        }\\n        return totalLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int freq[]=new int[26];\\n        int totalLength=0;\\n        for(char ch:chars.toCharArray())\\n        {\\n            freq[ch-\\'a\\']++;\\n        }\\n        for(String word:words)\\n        {\\n            int freq1[]=new int[26];\\n            int flag=1;\\n            for(char ch: word.toCharArray())\\n            {\\n                freq1[ch-\\'a\\']++;\\n                if(freq1[ch-\\'a\\']>freq[ch-\\'a\\'])\\n                {\\n                    flag=0;\\n                }\\n            }\\n            if(flag==1)\\n                totalLength+=word.length();\\n        }\\n        return totalLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806893,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c = list(chars)\\n        l,ans = 0,0\\n        for i in words:\\n            for j in list(i):\\n                if j in c:\\n                    l += 1\\n                    c.remove(j)\\n            if l == len(i):\\n                ans += len(i)\\n            c = list(chars)\\n            l = 0\\n        return (ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c = list(chars)\\n        l,ans = 0,0\\n        for i in words:\\n            for j in list(i):\\n                if j in c:\\n                    l += 1\\n                    c.remove(j)\\n            if l == len(i):\\n                ans += len(i)\\n            c = list(chars)\\n            l = 0\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791465,
                "title": "java-easy-to-understand-code-o-n-with-explanation",
                "content": "1. First of all we have to store the occurance of every char of the given array .\\n2. Second we have to store each and every char count of all string given as array .\\n3. Now as we have both count we can start comparing.\\n4. If any case we find we have greater count for the string arr[] than the string given; we will not include its length, else we will include the length of its.\\n5. return the total length.\\n\\n```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count[]=new int[27];\\n        for(int i=0;i<chars.length();i++)\\n            count[chars.charAt(i) - 96]++;\\n        int arr[]=new int[27];\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            Arrays.fill(arr,0);\\n            for(int j=0;j<words[i].length();j++){\\n                arr[words[i].charAt(j)-96]++;\\n            }\\n            boolean add=true;\\n            for(int k=1;k<27;k++){\\n                if(arr[k]>0 && arr[k]>count[k]){\\n                    add=false;\\n                    break;\\n                }\\n            }\\n            if(add)ans+=words[i].length();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int count[]=new int[27];\\n        for(int i=0;i<chars.length();i++)\\n            count[chars.charAt(i) - 96]++;\\n        int arr[]=new int[27];\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            Arrays.fill(arr,0);\\n            for(int j=0;j<words[i].length();j++){\\n                arr[words[i].charAt(j)-96]++;\\n            }\\n            boolean add=true;\\n            for(int k=1;k<27;k++){\\n                if(arr[k]>0 && arr[k]>count[k]){\\n                    add=false;\\n                    break;\\n                }\\n            }\\n            if(add)ans+=words[i].length();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763598,
                "title": "java-solution-using-two-pointer-without-using-hash-map",
                "content": "```\\nclass Solution{\\n    public int countCharacters(String[] words, String chars) {\\n        char ch []=chars.toCharArray();\\n        Arrays.sort(ch);\\n        int ans = 0;\\n       for(int i=0;i<=words.length-1;i++) \\n       {\\n            char ch1[]=words[i].toCharArray();\\n           Arrays.sort(ch1);\\n           int l1=0;\\n           int l=0;\\n\\n           while(l < ch.length && l1 < ch1.length)\\n           {\\n                \\n               if(ch1[l1] == ch[l]){\\n                   l++;\\n                   l1++;\\n               }\\n               else\\n               {\\n                   l++;                   \\n               }\\n                            \\n           }\\n           \\n           if(l1 == ch1.length)\\n                ans += l1;\\n       }\\n        \\n        return ans;\\n        \\n  }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution{\\n    public int countCharacters(String[] words, String chars) {\\n        char ch []=chars.toCharArray();\\n        Arrays.sort(ch);\\n        int ans = 0;\\n       for(int i=0;i<=words.length-1;i++) \\n       {\\n            char ch1[]=words[i].toCharArray();\\n           Arrays.sort(ch1);\\n           int l1=0;\\n           int l=0;\\n\\n           while(l < ch.length && l1 < ch1.length)\\n           {\\n                \\n               if(ch1[l1] == ch[l]){\\n                   l++;\\n                   l1++;\\n               }\\n               else\\n               {\\n                   l++;                   \\n               }\\n                            \\n           }\\n           \\n           if(l1 == ch1.length)\\n                ans += l1;\\n       }\\n        \\n        return ans;\\n        \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737569,
                "title": "very-simple-python-solution",
                "content": "We need to solve the problem for each string in words independently and check how many times each character occurs in string chars.\\nThis can be coded as below:\\n\\nclass Solution:\\n\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c=0\\n        res=0\\n        char1=chars\\n        \\n        for ele in words:\\n            c=0\\n            char1=chars\\n            \\n            for i in ele:\\n                if i in char1:\\n                    c+=1\\n                    char1=char1.replace(i,\" \",1)\\n                \\n            if c==len(ele):\\n                res+=len(ele)\\n        return res\\n\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "We need to solve the problem for each string in words independently and check how many times each character occurs in string chars.\\nThis can be coded as below:\\n\\nclass Solution:\\n\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        c=0\\n        res=0\\n        char1=chars\\n        \\n        for ele in words:\\n            c=0\\n            char1=chars\\n            \\n            for i in ele:\\n                if i in char1:\\n                    c+=1\\n                    char1=char1.replace(i,\" \",1)\\n                \\n            if c==len(ele):\\n                res+=len(ele)\\n        return res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1723724,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        int length=0;\\n        for(int i=0;i<chars.length();i++)\\n            hmap.put(chars.charAt(i),hmap.getOrDefault(chars.charAt(i),0)+1);\\n        for(int j=0;j<words.length;j++){\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            String ele=words[j];\\n            for(int k=0;k<ele.length();k++)\\n                map.put(ele.charAt(k),map.getOrDefault(ele.charAt(k),0)+1);\\n            for(int l=0;l<ele.length();l++){\\n                char ch=ele.charAt(l);\\n                    if(hmap.containsKey(ch) && hmap.get(ch)>=map.get(ch))\\n                        count++;\\n            }\\n            if(count==ele.length()){\\n                length += ele.length();\\n            }\\n        }\\n        return length;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        int length=0;\\n        for(int i=0;i<chars.length();i++)\\n            hmap.put(chars.charAt(i),hmap.getOrDefault(chars.charAt(i),0)+1);\\n        for(int j=0;j<words.length;j++){\\n            int count=0;\\n            HashMap<Character,Integer> map=new HashMap<>();\\n            String ele=words[j];\\n            for(int k=0;k<ele.length();k++)\\n                map.put(ele.charAt(k),map.getOrDefault(ele.charAt(k),0)+1);\\n            for(int l=0;l<ele.length();l++){\\n                char ch=ele.charAt(l);\\n                    if(hmap.containsKey(ch) && hmap.get(ch)>=map.get(ch))\\n                        count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1645215,
                "title": "python-simple-solution-by-counting-characters-beats-68-run-time",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        count = 0\\n        chars = list(chars)\\n        \\n        for word in words:\\n            temp = []\\n            chars_pool = chars[:]\\n            for char in word:\\n                if char not in chars_pool:\\n                    break\\n                else:\\n                    temp.append(char)\\n                    chars_pool.remove(char)\\n            temp = \\'\\'.join(temp)\\n            if temp == word:\\n                count += len(word)\\n                    \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        count = 0\\n        chars = list(chars)\\n        \\n        for word in words:\\n            temp = []\\n            chars_pool = chars[:]\\n            for char in word:\\n                if char not in chars_pool:\\n                    break\\n                else:\\n                    temp.append(char)\\n                    chars_pool.remove(char)\\n            temp = \\'\\'.join(temp)\\n            if temp == word:\\n                count += len(word)\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618538,
                "title": "my-java-solution-using-arrays",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        if(words.length == 0)\\n            return 0;\\n        \\n        int res = 0;\\n        // Store the count of all character occurence in chCount array\\n        int[] chCount = new int[26];\\n        \\n        for(char ch : chars.toCharArray())\\n            chCount[ch - \\'a\\']++;\\n\\n        \\n        for(String word : words){\\n            //Create a clone array to be used in each word check\\n            int[] tempCount = chCount.clone();\\n            boolean isValid = true;\\n            for(char ch : word.toCharArray()){\\n                tempCount[ch - \\'a\\']--;\\n                if(tempCount[ch - \\'a\\'] < 0){\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            if(isValid)\\n                res+=word.length();\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        if(words.length == 0)\\n            return 0;\\n        \\n        int res = 0;\\n        // Store the count of all character occurence in chCount array\\n        int[] chCount = new int[26];\\n        \\n        for(char ch : chars.toCharArray())\\n            chCount[ch - \\'a\\']++;\\n\\n        \\n        for(String word : words){\\n            //Create a clone array to be used in each word check\\n            int[] tempCount = chCount.clone();\\n            boolean isValid = true;\\n            for(char ch : word.toCharArray()){\\n                tempCount[ch - \\'a\\']--;\\n                if(tempCount[ch - \\'a\\'] < 0){\\n                    isValid = false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1587765,
                "title": "java-track-count-no-hashmap",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int map[] = new int[26], res = 0;\\n        for (char c: chars.toCharArray())   map[c - \\'a\\']++;\\n        for (String word: words) {\\n            int[] lmap = map.clone();\\n            boolean flag = true;\\n            for (char ch: word.toCharArray()) {\\n                if (lmap[ch -\\'a\\'] == 0) {\\n                    flag = false;\\n                    break;\\n                } else  lmap[ch -\\'a\\']--;\\n            }\\n            if (flag) res+=word.length();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int map[] = new int[26], res = 0;\\n        for (char c: chars.toCharArray())   map[c - \\'a\\']++;\\n        for (String word: words) {\\n            int[] lmap = map.clone();\\n            boolean flag = true;\\n            for (char ch: word.toCharArray()) {\\n                if (lmap[ch -\\'a\\'] == 0) {\\n                    flag = false;\\n                    break;\\n                } else  lmap[ch -\\'a\\']--;\\n            }\\n            if (flag) res+=word.length();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537935,
                "title": "java-easy-iterative-98-faster",
                "content": "please upvote if solution helps.\\n\\n````\\n/** we would be using a map to store character count in chars,\\nand then comparing that count with each individual string in array.**/\\n\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int []letters = new int[26];\\n        for(int i=0;i<chars.length();i++){\\n            letters[chars.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        int length=0;\\n        for(String s:words){\\n            int []current= new int[26];\\n            int i=0;\\n            for(i=0;i<s.length();i++){\\n                int cur=s.charAt(i)-\\'a\\';\\n                current[cur]++;\\n                if(current[cur]>letters[cur])\\n                    break;\\n        }\\n            if(i==s.length())\\n                length+=i;\\n        }\\n        return length;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        int []letters = new int[26];\\n        for(int i=0;i<chars.length();i++){\\n            letters[chars.charAt(i)-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1523413,
                "title": "java-without-hashmap-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(String word: words){\\n            int alpha[]= new int [26];\\n            for(int i=0; i<chars.length(); i++){\\n                alpha[chars.charAt(i)-\\'a\\']++;\\n            }\\n            \\n            boolean state=true;\\n            \\n            for(int i=0; i<word.length(); i++){\\n                alpha[word.charAt(i)-\\'a\\']--;\\n                if(alpha[word.charAt(i)-\\'a\\']<0){\\n                    state=false;\\n                    break;\\n                }\\n            }\\n            \\n            if(state){\\n                res.append(word);\\n            }\\n        }\\n        return res.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCharacters(String[] words, String chars) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(String word: words){\\n            int alpha[]= new int [26];\\n            for(int i=0; i<chars.length(); i++){\\n                alpha[chars.charAt(i)-\\'a\\']++;\\n            }\\n            \\n            boolean state=true;\\n            \\n            for(int i=0; i<word.length(); i++){\\n                alpha[word.charAt(i)-\\'a\\']--;\\n                if(alpha[word.charAt(i)-\\'a\\']<0){\\n                    state=false;\\n                    break;\\n                }\\n            }\\n            \\n            if(state){\\n                res.append(word);\\n            }\\n        }\\n        return res.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522599,
                "title": "c-hashmap-runtime-81-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n\\t// map to store frequencies of each charater in chars, unordered map because they take less time.\\n        unordered_map<char, int> mp;\\n        for(auto c:chars) mp[c]++;\\n\\t\\t// auxillary map because we need to maintain the orginal count of character while manipulating according to the need of the string in words.\\n        unordered_map<char, int> mp1=mp;\\n\\t\\t// flag variable to keep track if we have considered all the element of a particular string in words or not\\n        int ans=0, flag=0;\\n        for(auto s:words){\\n            for(int i=0; i<s.size(); i++){\\n                if(mp1.find(s[i])!=mp1.end() && mp1[s[i]]!=0){\\n                    mp1[s[i]]--;\\n                }\\n                else{\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) {\\n                ans+=s.size();\\n            }\\n            else flag=0;\\n            mp1=mp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n\\t// map to store frequencies of each charater in chars, unordered map because they take less time.\\n        unordered_map<char, int> mp;\\n        for(auto c:chars) mp[c]++;\\n\\t\\t// auxillary map because we need to maintain the orginal count of character while manipulating according to the need of the string in words.\\n        unordered_map<char, int> mp1=mp;\\n\\t\\t// flag variable to keep track if we have considered all the element of a particular string in words or not\\n        int ans=0, flag=0;\\n        for(auto s:words){\\n            for(int i=0; i<s.size(); i++){\\n                if(mp1.find(s[i])!=mp1.end() && mp1[s[i]]!=0){\\n                    mp1[s[i]]--;\\n                }\\n                else{\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) {\\n                ans+=s.size();\\n            }\\n            else flag=0;\\n            mp1=mp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488071,
                "title": "javascript-fast-solution-with-comments-90ms-run-time",
                "content": "```\\nvar countCharacters = function(words, chars) {\\n    // make a map of the characters and their count\\n    var available = new Map()\\n    var total = 0\\n    // populate the available characters map \\n    for(var i = 0; i < chars.length; ++i){\\n        if (!available.has(chars[i])){\\n            available.set(chars[i], 1)\\n        } else {\\n            available.set(chars[i], available.get(chars[i])+1)\\n        }\\n    }\\n    // iterrate through all the words \\n    for(var word of words){\\n        // if the length of the word is greater then char length then skip\\n      if (word.length > chars.length) continue\\n        // create a map of the current word and a flag to let us know if we should \\n        // commit that to the total \\n        var used = new Map()\\n        var shouldCommit = false\\n        // iterate through every character and add it to the used map \\n        for (var char of word){\\n            // if available has it then add it to used \\n            if (available.has(char) && !used.has(char)){\\n                used.set(char, 1)\\n                shouldCommit = true\\n            } \\n            // if both have it make sure we dont go over the ammount\\n            else if (available.has(char) && used.has(char)){\\n                if (used.get(char) < available.get(char)){\\n                     used.set(char,used.get(char)+1)\\n                    shouldCommit = true\\n            // if we are going over the ammount available then break and dont commit\\n                }else if (used.get(char) >= available.get(char)){\\n                    shouldCommit = false\\n                    break\\n                }\\n           \\n            } \\n            // if available does not have it then break early and dont commit \\n            else {\\n                shouldCommit = false\\n               break\\n            }  \\n\\n        }\\n        // commit because the word can be made\\n        if (shouldCommit == true) total+= word.length\\n    \\n    }\\n    // return the total \\n    return total\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar countCharacters = function(words, chars) {\\n    // make a map of the characters and their count\\n    var available = new Map()\\n    var total = 0\\n    // populate the available characters map \\n    for(var i = 0; i < chars.length; ++i){\\n        if (!available.has(chars[i])){\\n            available.set(chars[i], 1)\\n        } else {\\n            available.set(chars[i], available.get(chars[i])+1)\\n        }\\n    }\\n    // iterrate through all the words \\n    for(var word of words){\\n        // if the length of the word is greater then char length then skip\\n      if (word.length > chars.length) continue\\n        // create a map of the current word and a flag to let us know if we should \\n        // commit that to the total \\n        var used = new Map()\\n        var shouldCommit = false\\n        // iterate through every character and add it to the used map \\n        for (var char of word){\\n            // if available has it then add it to used \\n            if (available.has(char) && !used.has(char)){\\n                used.set(char, 1)\\n                shouldCommit = true\\n            } \\n            // if both have it make sure we dont go over the ammount\\n            else if (available.has(char) && used.has(char)){\\n                if (used.get(char) < available.get(char)){\\n                     used.set(char,used.get(char)+1)\\n                    shouldCommit = true\\n            // if we are going over the ammount available then break and dont commit\\n                }else if (used.get(char) >= available.get(char)){\\n                    shouldCommit = false\\n                    break\\n                }\\n           \\n            } \\n            // if available does not have it then break early and dont commit \\n            else {\\n                shouldCommit = false\\n               break\\n            }  \\n\\n        }\\n        // commit because the word can be made\\n        if (shouldCommit == true) total+= word.length\\n    \\n    }\\n    // return the total \\n    return total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466100,
                "title": "simple-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        arr=[list(x) for x in words] #making the string into an array to remove elements \\n        sum_array=[] #to store the final length of all the substrings formed\\n        for i in arr:\\n            count=0\\n            f=[char for char in chars]\\n            for j in i:\\n                if j in f:\\n                    f.remove(j)\\n                    count+=1\\n            if count==len(i):\\n                sum_array.append(len(i))\\n        return sum(sum_array)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        arr=[list(x) for x in words] #making the string into an array to remove elements \\n        sum_array=[] #to store the final length of all the substrings formed\\n        for i in arr:\\n            count=0\\n            f=[char for char in chars]\\n            for j in i:\\n                if j in f:\\n                    f.remove(j)\\n                    count+=1\\n            if count==len(i):\\n                sum_array.append(len(i))\\n        return sum(sum_array)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447254,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        char arr[26] {};\\n        for (const auto c: chars)\\n            ++arr[c - \\'a\\'];\\n        for (const auto &word: words) {\\n            bool can_form = true;\\n            char temp[26] {};\\n            for (auto c: word) {\\n                ++temp[c - \\'a\\'];\\n                if (temp[c - \\'a\\'] > arr[c - \\'a\\']) {\\n                    can_form = false;\\n                    break;\\n                }\\n            }\\n            if (can_form) \\n                sum += word.size();\\n        }\\n        return sum;    \\n    }\\n};\\n```\\nO(n) space and time",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCharacters(vector<string>& words, string chars) {\\n        int sum = 0;\\n        char arr[26] {};\\n        for (const auto c: chars)\\n            ++arr[c - \\'a\\'];\\n        for (const auto &word: words) {\\n            bool can_form = true;\\n            char temp[26] {};\\n            for (auto c: word) {\\n                ++temp[c - \\'a\\'];\\n                if (temp[c - \\'a\\'] > arr[c - \\'a\\']) {\\n                    can_form = false;\\n                    break;\\n                }\\n            }\\n            if (can_form) \\n                sum += word.size();\\n        }\\n        return sum;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444762,
                "title": "python-count-char-one-liner",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(map(len, filter(lambda w: Counter(w) & Counter(chars) == Counter(w), words)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        return sum(map(len, filter(lambda w: Counter(w) & Counter(chars) == Counter(w), words)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414168,
                "title": "java-2ms-top-1-explanations",
                "content": "```\\nclass Solution {\\n\\t/**\\n\\t* 1. Parse chars and count how many a,b,c are and store them in an array [26] (a-z)\\n\\t* 2. For each word initialize an empty int[26] and count one letter at a time, storing the result in the new int[].\\n\\t*    If the stored result it > than the chars array for that char, return 0 immediately;\\n\\t*    If each loop runs till the end, return the word length\\n\\t*/\\n    public int countCharacters(String[] words, String chars) {\\n\\t\\tint countWords = 0;\\n        int[] charCount = getCharCount(chars);\\n        for(String word : words) {\\n            countWords += getValidWordLength(word, charCount);\\n        }\\n        return countWords;\\n    }\\n    \\n    private int[] getCharCount(String chars) {\\n        int[] charCount = new int[\\'z\\' - \\'a\\' + 1];\\n        for (int i = 0; i < chars.length(); i++) {\\n            charCount[chars.charAt(i)- \\'a\\']++;\\n        }\\n        return charCount;\\n    }\\n    \\n    private int getValidWordLength(String word, int[] charCount) {\\n        int[] wordChars =  new int[26];\\n        int currentChar;\\n        for (int i = 0; i < word.length(); i++) {\\n            currentChar = word.charAt(i) - \\'a\\';\\n            wordChars[currentChar]++;\\n            // if current word has more letters [i] than the charCount/given dictionary, return 0 immediately\\n\\t\\t\\tif (wordChars[currentChar] > charCount[currentChar]) {\\n                return 0;\\n            }\\n        }\\n        return word.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t/**\\n\\t* 1. Parse chars and count how many a,b,c are and store them in an array [26] (a-z)\\n\\t* 2. For each word initialize an empty int[26] and count one letter at a time, storing the result in the new int[].\\n\\t*    If the stored result it > than the chars array for that char, return 0 immediately;\\n\\t*    If each loop runs till the end, return the word length\\n\\t*/\\n    public int countCharacters(String[] words, String chars) {\\n\\t\\tint countWords = 0;\\n        int[] charCount = getCharCount(chars);\\n        for(String word : words) {\\n            countWords += getValidWordLength(word, charCount);\\n        }\\n        return countWords;\\n    }\\n    \\n    private int[] getCharCount(String chars) {\\n        int[] charCount = new int[\\'z\\' - \\'a\\' + 1];\\n        for (int i = 0; i < chars.length(); i++) {\\n            charCount[chars.charAt(i)- \\'a\\']++;\\n        }\\n        return charCount;\\n    }\\n    \\n    private int getValidWordLength(String word, int[] charCount) {\\n        int[] wordChars =  new int[26];\\n        int currentChar;\\n        for (int i = 0; i < word.length(); i++) {\\n            currentChar = word.charAt(i) - \\'a\\';\\n            wordChars[currentChar]++;\\n            // if current word has more letters [i] than the charCount/given dictionary, return 0 immediately\\n\\t\\t\\tif (wordChars[currentChar] > charCount[currentChar]) {\\n                return 0;\\n            }\\n        }\\n        return word.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386031,
                "title": "python3-faster-than-99-94-memory-less-than-79-96",
                "content": "![image](https://assets.leetcode.com/users/images/46eca55e-4222-45ea-bb93-dc76f754e415_1628202673.2343316.png)\\n\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        from collections import Counter\\n\\n        c = Counter(chars)\\n\\n        cnt = 0\\n\\n        for word in words:\\n            good = True\\n            for letter in word:\\n\\n                if word.count(letter) > c[letter]:\\n                    good = False\\n                    break\\n\\n            if good:\\n                cnt += len(word)\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        \\n        from collections import Counter\\n\\n        c = Counter(chars)\\n\\n        cnt = 0\\n\\n        for word in words:\\n            good = True\\n            for letter in word:\\n\\n                if word.count(letter) > c[letter]:\\n                    good = False\\n                    break\\n\\n            if good:\\n                cnt += len(word)\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378933,
                "title": "python3-another-simple-solution",
                "content": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        temp_chars=chars\\n        answer=0\\n        num=0\\n        for i in words:\\n            for j in i:\\n                if j in temp_chars:\\n                    num+=1\\n                    temp_chars=temp_chars.replace(j,\\'\\',1) #delete first char in chars\\n            if num==len(i): #chech num of matching is same as length of the target\\n                answer+=num\\n            num=0      \\n            temp_chars=chars\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        temp_chars=chars\\n        answer=0\\n        num=0\\n        for i in words:\\n            for j in i:\\n                if j in temp_chars:\\n                    num+=1\\n                    temp_chars=temp_chars.replace(j,\\'\\',1) #delete first char in chars\\n            if num==len(i): #chech num of matching is same as length of the target\\n                answer+=num\\n            num=0      \\n            temp_chars=chars\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348096,
                "title": "java-solution-3ms-faster-than-98",
                "content": "```\\npublic int countCharacters(String[] words, String chars) {\\n        int count=0;\\n        int a[]=new int[27];\\n        Arrays.fill(a,0);\\n        for(char i:chars.toCharArray())\\n        {\\n            a[i-\\'a\\']++;\\n        }\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].length()>chars.length())\\n                continue;\\n            int b[]=new int[27];int flag=1;\\n            for(char s:words[i].toCharArray())\\n            {\\n                b[s-\\'a\\']++;\\n                if(b[s-\\'a\\']>a[s-\\'a\\'])\\n                {flag=0; break;}\\n            }\\n            if(flag==1)\\n                count+=words[i].length(); \\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countCharacters(String[] words, String chars) {\\n        int count=0;\\n        int a[]=new int[27];\\n        Arrays.fill(a,0);\\n        for(char i:chars.toCharArray())\\n        {\\n            a[i-\\'a\\']++;\\n        }\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].length()>chars.length())\\n                continue;\\n            int b[]=new int[27];int flag=1;\\n            for(char s:words[i].toCharArray())\\n            {\\n                b[s-\\'a\\']++;\\n                if(b[s-\\'a\\']>a[s-\\'a\\'])\\n                {flag=0; break;}\\n            }\\n            if(flag==1)\\n                count+=words[i].length(); \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1330008,
                "title": "python-solution-with-memory-usage-92-better",
                "content": "```\\nimport copy\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        chars_freq = {}\\n        for char in chars:\\n            if (char not in chars_freq):\\n                chars_freq.update({char:0})\\n            chars_freq.update({char:chars_freq.get(char)+1})\\n        length = 0\\n        for word in words:\\n            temp_freq_map = copy.deepcopy(chars_freq)\\n            goodString = True\\n            for char in word:\\n                if (temp_freq_map.get(char) == None or temp_freq_map.get(char) == 0):\\n                    goodString = False\\n                    break\\n                temp_freq_map.update({char:temp_freq_map.get(char) - 1})\\n            if (goodString):\\n                length += len(word)\\n        return length",
                "solutionTags": [],
                "code": "class Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        chars_freq = {}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568234,
                "content": [
                    {
                        "username": "yoo_hoo",
                        "content": "In explaination is mentioned: \"A string is good if it can be formed by characters from chars (each character can only be used once).\"\\n\\nBut in first example we got output 6 because \"cat\" and \"hat\" can be formed. How  you can form those words from chars \"atach\" if each character can be used only once?"
                    },
                    {
                        "username": "wcchuo",
                        "content": "This problem means that each character in `chars` can only be used once for each word in the `words` array, not once for the entire `words` array. At least it didn't mention it.\n\nIn other words, you should consider `chars` as a pool of letters that gets refilled after forming each word, rather than a pool that needs to last for all the words.\n\nSo, in your example, `chars = \"atach\"` can be used to form the word `\"cat\"` because it has one `'c'`, one `'a'`, and one `'t'`. After this, the `chars` string is \"refilled\", so it can be used again to form the word `\"hat\"` because it also has one `'h'`, one `'a'`, and one `'t'`. This is why the total length is `3 + 3 = 6`. \n\nThe key is that the characters are reused for each word in the `words` array, not across all the words.\n\nThe problem description should be edited \"... (each character can only be used once in each `words` iteration)\""
                    },
                    {
                        "username": "quppiehy",
                        "content": "I\\'m also confused by this"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "facing the same problem here?"
                    },
                    {
                        "username": "Md_Saif",
                        "content": "In this test case   [\\n    \\'dyiclysmffuhibgfvapygkorkqllqlvokosagyelotobicwcmebnpznjbirzrzsrtzjxhsfpiwyfhzyonmuabtlwin\\',\\n    \\'ndqeyhhcquplmznwslewjzuyfgklssvkqxmqjpwhrshycmvrb\\',\\n    \\'ulrrbpspyudncdlbkxkrqpivfftrggemkpyjl\\',\\n    \\'boygirdlggnh\\',\\n    \\'xmqohbyqwagkjzpyawsydmdaattthmuvjbzwpyopyafphx\\',\\n    \\'nulvimegcsiwvhwuiyednoxpugfeimnnyeoczuzxgxbqjvegcxeqnjbwnbvowastqhojepisusvsidhqmszbrnynkyop\\',\\n    \\'hiefuovybkpgzygprmndrkyspoiyapdwkxebgsmodhzpx\\',\\n    \\'juldqdzeskpffaoqcyyxiqqowsalqumddcufhouhrskozhlmobiwzxnhdkidr\\',\\n    \\'lnnvsdcrvzfmrvurucrzlfyigcycffpiuoo\\',\\n    \\'oxgaskztzroxuntiwlfyufddl\\',\\n    \\'tfspedteabxatkaypitjfkhkkigdwdkctqbczcugripkgcyfezpuklfqfcsccboarbfbjfrkxp\\',\\n    \\'qnagrpfzlyrouolqquytwnwnsqnmuzphne\\',\\n    \\'eeilfdaookieawrrbvtnqfzcricvhpiv\\',\\n    \\'sisvsjzyrbdsjcwwygdnxcjhzhsxhpceqz\\',\\n    \\'yhouqhjevqxtecomahbwoptzlkyvjexhzcbccusbjjdgcfzlkoqwiwue\\',\\n    \\'hwxxighzvceaplsycajkhynkhzkwkouszwaiuzqcleyflqrxgjsvlegvupzqijbornbfwpefhxekgpuvgiyeudhncv\\',\\n    \\'cpwcjwgbcquirnsazumgjjcltitmeyfaudbnbqhflvecjsupjmgwfbjo\\',\\n    \\'teyygdmmyadppuopvqdodaczob\\',\\n    \\'qaeowuwqsqffvibrtxnjnzvzuuonrkwpysyxvkijemmpdmtnqxwekbpfzs\\',\\n    \\'qqxpxpmemkldghbmbyxpkwgkaykaerhmwwjonrhcsubchs\\',\\n  ],\\n\\nI am getting 47 here on leetcode but when i run my program in local i am getting 0 which is correct so why this is happening here any guesses ??"
                    },
                    {
                        "username": "Teddy-Lin",
                        "content": "return sum([len(word) for word in words if all(word.count(i) <= chars.count(i) for i in word)])"
                    },
                    {
                        "username": "RyanAura",
                        "content": "Whats the point of putting the solution in the discussion."
                    },
                    {
                        "username": "Rushab11",
                        "content": "\n        \n        int len=0;\n        for(int i=0;i<words.size();i++)\n        {\n           string str=words[i];\n           int c=0;\n           for(int k=0;k<str.length();k++)\n           {\n             if(count(chars.begin(),chars.end(),str[k]))\n             {\n                 c++;\n             }\n           }\n           if(c==str.length())\n           {\n               len+=c;\n              \n           }\n           \n\n        }\n        return len;\n    \n\nWhat's Wrong with this Approach ?? Only 10 Test Case Passed"
                    },
                    {
                        "username": "user6808zB",
                        "content": "The below code works for the test cases but fails on the Final Submission when there is the chars of 50 characters and 70 words more than 40 chars each,. Can anyone please give me a suggestion what to modify in the below code: \n\ndef countCharacters(self, words: List[str], chars: str) -> int:\n\n        cnt=0                                                  #variable to count the total number of characters                               \n\n        for word in words:\n            res=[]                                                    #temp array to track the number of characters for the word\n            for i in range(len(word)): \n                if word[i] in chars:\n                    res.append(word[i])\n            if len(res)==len(word): \n                cnt+=len(res) \n        return cnt"
                    },
                    {
                        "username": "guruhegde777",
                        "content": "You are checking if word[ i ] exists in chars without checking the count.\\nFor example if a word has \\'a\\' 3 times but in chars single \\'a\\' is present, then you can\\'t construct a word which has 3 \\'a\\'s with only one \\'a\\'. Hope you understood.  "
                    }
                ]
            },
            {
                "id": 2009030,
                "content": [
                    {
                        "username": "yoo_hoo",
                        "content": "In explaination is mentioned: \"A string is good if it can be formed by characters from chars (each character can only be used once).\"\\n\\nBut in first example we got output 6 because \"cat\" and \"hat\" can be formed. How  you can form those words from chars \"atach\" if each character can be used only once?"
                    },
                    {
                        "username": "wcchuo",
                        "content": "This problem means that each character in `chars` can only be used once for each word in the `words` array, not once for the entire `words` array. At least it didn't mention it.\n\nIn other words, you should consider `chars` as a pool of letters that gets refilled after forming each word, rather than a pool that needs to last for all the words.\n\nSo, in your example, `chars = \"atach\"` can be used to form the word `\"cat\"` because it has one `'c'`, one `'a'`, and one `'t'`. After this, the `chars` string is \"refilled\", so it can be used again to form the word `\"hat\"` because it also has one `'h'`, one `'a'`, and one `'t'`. This is why the total length is `3 + 3 = 6`. \n\nThe key is that the characters are reused for each word in the `words` array, not across all the words.\n\nThe problem description should be edited \"... (each character can only be used once in each `words` iteration)\""
                    },
                    {
                        "username": "quppiehy",
                        "content": "I\\'m also confused by this"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "facing the same problem here?"
                    },
                    {
                        "username": "Md_Saif",
                        "content": "In this test case   [\\n    \\'dyiclysmffuhibgfvapygkorkqllqlvokosagyelotobicwcmebnpznjbirzrzsrtzjxhsfpiwyfhzyonmuabtlwin\\',\\n    \\'ndqeyhhcquplmznwslewjzuyfgklssvkqxmqjpwhrshycmvrb\\',\\n    \\'ulrrbpspyudncdlbkxkrqpivfftrggemkpyjl\\',\\n    \\'boygirdlggnh\\',\\n    \\'xmqohbyqwagkjzpyawsydmdaattthmuvjbzwpyopyafphx\\',\\n    \\'nulvimegcsiwvhwuiyednoxpugfeimnnyeoczuzxgxbqjvegcxeqnjbwnbvowastqhojepisusvsidhqmszbrnynkyop\\',\\n    \\'hiefuovybkpgzygprmndrkyspoiyapdwkxebgsmodhzpx\\',\\n    \\'juldqdzeskpffaoqcyyxiqqowsalqumddcufhouhrskozhlmobiwzxnhdkidr\\',\\n    \\'lnnvsdcrvzfmrvurucrzlfyigcycffpiuoo\\',\\n    \\'oxgaskztzroxuntiwlfyufddl\\',\\n    \\'tfspedteabxatkaypitjfkhkkigdwdkctqbczcugripkgcyfezpuklfqfcsccboarbfbjfrkxp\\',\\n    \\'qnagrpfzlyrouolqquytwnwnsqnmuzphne\\',\\n    \\'eeilfdaookieawrrbvtnqfzcricvhpiv\\',\\n    \\'sisvsjzyrbdsjcwwygdnxcjhzhsxhpceqz\\',\\n    \\'yhouqhjevqxtecomahbwoptzlkyvjexhzcbccusbjjdgcfzlkoqwiwue\\',\\n    \\'hwxxighzvceaplsycajkhynkhzkwkouszwaiuzqcleyflqrxgjsvlegvupzqijbornbfwpefhxekgpuvgiyeudhncv\\',\\n    \\'cpwcjwgbcquirnsazumgjjcltitmeyfaudbnbqhflvecjsupjmgwfbjo\\',\\n    \\'teyygdmmyadppuopvqdodaczob\\',\\n    \\'qaeowuwqsqffvibrtxnjnzvzuuonrkwpysyxvkijemmpdmtnqxwekbpfzs\\',\\n    \\'qqxpxpmemkldghbmbyxpkwgkaykaerhmwwjonrhcsubchs\\',\\n  ],\\n\\nI am getting 47 here on leetcode but when i run my program in local i am getting 0 which is correct so why this is happening here any guesses ??"
                    },
                    {
                        "username": "Teddy-Lin",
                        "content": "return sum([len(word) for word in words if all(word.count(i) <= chars.count(i) for i in word)])"
                    },
                    {
                        "username": "RyanAura",
                        "content": "Whats the point of putting the solution in the discussion."
                    },
                    {
                        "username": "Rushab11",
                        "content": "\n        \n        int len=0;\n        for(int i=0;i<words.size();i++)\n        {\n           string str=words[i];\n           int c=0;\n           for(int k=0;k<str.length();k++)\n           {\n             if(count(chars.begin(),chars.end(),str[k]))\n             {\n                 c++;\n             }\n           }\n           if(c==str.length())\n           {\n               len+=c;\n              \n           }\n           \n\n        }\n        return len;\n    \n\nWhat's Wrong with this Approach ?? Only 10 Test Case Passed"
                    },
                    {
                        "username": "user6808zB",
                        "content": "The below code works for the test cases but fails on the Final Submission when there is the chars of 50 characters and 70 words more than 40 chars each,. Can anyone please give me a suggestion what to modify in the below code: \n\ndef countCharacters(self, words: List[str], chars: str) -> int:\n\n        cnt=0                                                  #variable to count the total number of characters                               \n\n        for word in words:\n            res=[]                                                    #temp array to track the number of characters for the word\n            for i in range(len(word)): \n                if word[i] in chars:\n                    res.append(word[i])\n            if len(res)==len(word): \n                cnt+=len(res) \n        return cnt"
                    },
                    {
                        "username": "guruhegde777",
                        "content": "You are checking if word[ i ] exists in chars without checking the count.\\nFor example if a word has \\'a\\' 3 times but in chars single \\'a\\' is present, then you can\\'t construct a word which has 3 \\'a\\'s with only one \\'a\\'. Hope you understood.  "
                    }
                ]
            },
            {
                "id": 1574699,
                "content": [
                    {
                        "username": "yoo_hoo",
                        "content": "In explaination is mentioned: \"A string is good if it can be formed by characters from chars (each character can only be used once).\"\\n\\nBut in first example we got output 6 because \"cat\" and \"hat\" can be formed. How  you can form those words from chars \"atach\" if each character can be used only once?"
                    },
                    {
                        "username": "wcchuo",
                        "content": "This problem means that each character in `chars` can only be used once for each word in the `words` array, not once for the entire `words` array. At least it didn't mention it.\n\nIn other words, you should consider `chars` as a pool of letters that gets refilled after forming each word, rather than a pool that needs to last for all the words.\n\nSo, in your example, `chars = \"atach\"` can be used to form the word `\"cat\"` because it has one `'c'`, one `'a'`, and one `'t'`. After this, the `chars` string is \"refilled\", so it can be used again to form the word `\"hat\"` because it also has one `'h'`, one `'a'`, and one `'t'`. This is why the total length is `3 + 3 = 6`. \n\nThe key is that the characters are reused for each word in the `words` array, not across all the words.\n\nThe problem description should be edited \"... (each character can only be used once in each `words` iteration)\""
                    },
                    {
                        "username": "quppiehy",
                        "content": "I\\'m also confused by this"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "facing the same problem here?"
                    },
                    {
                        "username": "Md_Saif",
                        "content": "In this test case   [\\n    \\'dyiclysmffuhibgfvapygkorkqllqlvokosagyelotobicwcmebnpznjbirzrzsrtzjxhsfpiwyfhzyonmuabtlwin\\',\\n    \\'ndqeyhhcquplmznwslewjzuyfgklssvkqxmqjpwhrshycmvrb\\',\\n    \\'ulrrbpspyudncdlbkxkrqpivfftrggemkpyjl\\',\\n    \\'boygirdlggnh\\',\\n    \\'xmqohbyqwagkjzpyawsydmdaattthmuvjbzwpyopyafphx\\',\\n    \\'nulvimegcsiwvhwuiyednoxpugfeimnnyeoczuzxgxbqjvegcxeqnjbwnbvowastqhojepisusvsidhqmszbrnynkyop\\',\\n    \\'hiefuovybkpgzygprmndrkyspoiyapdwkxebgsmodhzpx\\',\\n    \\'juldqdzeskpffaoqcyyxiqqowsalqumddcufhouhrskozhlmobiwzxnhdkidr\\',\\n    \\'lnnvsdcrvzfmrvurucrzlfyigcycffpiuoo\\',\\n    \\'oxgaskztzroxuntiwlfyufddl\\',\\n    \\'tfspedteabxatkaypitjfkhkkigdwdkctqbczcugripkgcyfezpuklfqfcsccboarbfbjfrkxp\\',\\n    \\'qnagrpfzlyrouolqquytwnwnsqnmuzphne\\',\\n    \\'eeilfdaookieawrrbvtnqfzcricvhpiv\\',\\n    \\'sisvsjzyrbdsjcwwygdnxcjhzhsxhpceqz\\',\\n    \\'yhouqhjevqxtecomahbwoptzlkyvjexhzcbccusbjjdgcfzlkoqwiwue\\',\\n    \\'hwxxighzvceaplsycajkhynkhzkwkouszwaiuzqcleyflqrxgjsvlegvupzqijbornbfwpefhxekgpuvgiyeudhncv\\',\\n    \\'cpwcjwgbcquirnsazumgjjcltitmeyfaudbnbqhflvecjsupjmgwfbjo\\',\\n    \\'teyygdmmyadppuopvqdodaczob\\',\\n    \\'qaeowuwqsqffvibrtxnjnzvzuuonrkwpysyxvkijemmpdmtnqxwekbpfzs\\',\\n    \\'qqxpxpmemkldghbmbyxpkwgkaykaerhmwwjonrhcsubchs\\',\\n  ],\\n\\nI am getting 47 here on leetcode but when i run my program in local i am getting 0 which is correct so why this is happening here any guesses ??"
                    },
                    {
                        "username": "Teddy-Lin",
                        "content": "return sum([len(word) for word in words if all(word.count(i) <= chars.count(i) for i in word)])"
                    },
                    {
                        "username": "RyanAura",
                        "content": "Whats the point of putting the solution in the discussion."
                    },
                    {
                        "username": "Rushab11",
                        "content": "\n        \n        int len=0;\n        for(int i=0;i<words.size();i++)\n        {\n           string str=words[i];\n           int c=0;\n           for(int k=0;k<str.length();k++)\n           {\n             if(count(chars.begin(),chars.end(),str[k]))\n             {\n                 c++;\n             }\n           }\n           if(c==str.length())\n           {\n               len+=c;\n              \n           }\n           \n\n        }\n        return len;\n    \n\nWhat's Wrong with this Approach ?? Only 10 Test Case Passed"
                    },
                    {
                        "username": "user6808zB",
                        "content": "The below code works for the test cases but fails on the Final Submission when there is the chars of 50 characters and 70 words more than 40 chars each,. Can anyone please give me a suggestion what to modify in the below code: \n\ndef countCharacters(self, words: List[str], chars: str) -> int:\n\n        cnt=0                                                  #variable to count the total number of characters                               \n\n        for word in words:\n            res=[]                                                    #temp array to track the number of characters for the word\n            for i in range(len(word)): \n                if word[i] in chars:\n                    res.append(word[i])\n            if len(res)==len(word): \n                cnt+=len(res) \n        return cnt"
                    },
                    {
                        "username": "guruhegde777",
                        "content": "You are checking if word[ i ] exists in chars without checking the count.\\nFor example if a word has \\'a\\' 3 times but in chars single \\'a\\' is present, then you can\\'t construct a word which has 3 \\'a\\'s with only one \\'a\\'. Hope you understood.  "
                    }
                ]
            },
            {
                "id": 1983369,
                "content": [
                    {
                        "username": "yoo_hoo",
                        "content": "In explaination is mentioned: \"A string is good if it can be formed by characters from chars (each character can only be used once).\"\\n\\nBut in first example we got output 6 because \"cat\" and \"hat\" can be formed. How  you can form those words from chars \"atach\" if each character can be used only once?"
                    },
                    {
                        "username": "wcchuo",
                        "content": "This problem means that each character in `chars` can only be used once for each word in the `words` array, not once for the entire `words` array. At least it didn't mention it.\n\nIn other words, you should consider `chars` as a pool of letters that gets refilled after forming each word, rather than a pool that needs to last for all the words.\n\nSo, in your example, `chars = \"atach\"` can be used to form the word `\"cat\"` because it has one `'c'`, one `'a'`, and one `'t'`. After this, the `chars` string is \"refilled\", so it can be used again to form the word `\"hat\"` because it also has one `'h'`, one `'a'`, and one `'t'`. This is why the total length is `3 + 3 = 6`. \n\nThe key is that the characters are reused for each word in the `words` array, not across all the words.\n\nThe problem description should be edited \"... (each character can only be used once in each `words` iteration)\""
                    },
                    {
                        "username": "quppiehy",
                        "content": "I\\'m also confused by this"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "facing the same problem here?"
                    },
                    {
                        "username": "Md_Saif",
                        "content": "In this test case   [\\n    \\'dyiclysmffuhibgfvapygkorkqllqlvokosagyelotobicwcmebnpznjbirzrzsrtzjxhsfpiwyfhzyonmuabtlwin\\',\\n    \\'ndqeyhhcquplmznwslewjzuyfgklssvkqxmqjpwhrshycmvrb\\',\\n    \\'ulrrbpspyudncdlbkxkrqpivfftrggemkpyjl\\',\\n    \\'boygirdlggnh\\',\\n    \\'xmqohbyqwagkjzpyawsydmdaattthmuvjbzwpyopyafphx\\',\\n    \\'nulvimegcsiwvhwuiyednoxpugfeimnnyeoczuzxgxbqjvegcxeqnjbwnbvowastqhojepisusvsidhqmszbrnynkyop\\',\\n    \\'hiefuovybkpgzygprmndrkyspoiyapdwkxebgsmodhzpx\\',\\n    \\'juldqdzeskpffaoqcyyxiqqowsalqumddcufhouhrskozhlmobiwzxnhdkidr\\',\\n    \\'lnnvsdcrvzfmrvurucrzlfyigcycffpiuoo\\',\\n    \\'oxgaskztzroxuntiwlfyufddl\\',\\n    \\'tfspedteabxatkaypitjfkhkkigdwdkctqbczcugripkgcyfezpuklfqfcsccboarbfbjfrkxp\\',\\n    \\'qnagrpfzlyrouolqquytwnwnsqnmuzphne\\',\\n    \\'eeilfdaookieawrrbvtnqfzcricvhpiv\\',\\n    \\'sisvsjzyrbdsjcwwygdnxcjhzhsxhpceqz\\',\\n    \\'yhouqhjevqxtecomahbwoptzlkyvjexhzcbccusbjjdgcfzlkoqwiwue\\',\\n    \\'hwxxighzvceaplsycajkhynkhzkwkouszwaiuzqcleyflqrxgjsvlegvupzqijbornbfwpefhxekgpuvgiyeudhncv\\',\\n    \\'cpwcjwgbcquirnsazumgjjcltitmeyfaudbnbqhflvecjsupjmgwfbjo\\',\\n    \\'teyygdmmyadppuopvqdodaczob\\',\\n    \\'qaeowuwqsqffvibrtxnjnzvzuuonrkwpysyxvkijemmpdmtnqxwekbpfzs\\',\\n    \\'qqxpxpmemkldghbmbyxpkwgkaykaerhmwwjonrhcsubchs\\',\\n  ],\\n\\nI am getting 47 here on leetcode but when i run my program in local i am getting 0 which is correct so why this is happening here any guesses ??"
                    },
                    {
                        "username": "Teddy-Lin",
                        "content": "return sum([len(word) for word in words if all(word.count(i) <= chars.count(i) for i in word)])"
                    },
                    {
                        "username": "RyanAura",
                        "content": "Whats the point of putting the solution in the discussion."
                    },
                    {
                        "username": "Rushab11",
                        "content": "\n        \n        int len=0;\n        for(int i=0;i<words.size();i++)\n        {\n           string str=words[i];\n           int c=0;\n           for(int k=0;k<str.length();k++)\n           {\n             if(count(chars.begin(),chars.end(),str[k]))\n             {\n                 c++;\n             }\n           }\n           if(c==str.length())\n           {\n               len+=c;\n              \n           }\n           \n\n        }\n        return len;\n    \n\nWhat's Wrong with this Approach ?? Only 10 Test Case Passed"
                    },
                    {
                        "username": "user6808zB",
                        "content": "The below code works for the test cases but fails on the Final Submission when there is the chars of 50 characters and 70 words more than 40 chars each,. Can anyone please give me a suggestion what to modify in the below code: \n\ndef countCharacters(self, words: List[str], chars: str) -> int:\n\n        cnt=0                                                  #variable to count the total number of characters                               \n\n        for word in words:\n            res=[]                                                    #temp array to track the number of characters for the word\n            for i in range(len(word)): \n                if word[i] in chars:\n                    res.append(word[i])\n            if len(res)==len(word): \n                cnt+=len(res) \n        return cnt"
                    },
                    {
                        "username": "guruhegde777",
                        "content": "You are checking if word[ i ] exists in chars without checking the count.\\nFor example if a word has \\'a\\' 3 times but in chars single \\'a\\' is present, then you can\\'t construct a word which has 3 \\'a\\'s with only one \\'a\\'. Hope you understood.  "
                    }
                ]
            },
            {
                "id": 1747924,
                "content": [
                    {
                        "username": "yoo_hoo",
                        "content": "In explaination is mentioned: \"A string is good if it can be formed by characters from chars (each character can only be used once).\"\\n\\nBut in first example we got output 6 because \"cat\" and \"hat\" can be formed. How  you can form those words from chars \"atach\" if each character can be used only once?"
                    },
                    {
                        "username": "wcchuo",
                        "content": "This problem means that each character in `chars` can only be used once for each word in the `words` array, not once for the entire `words` array. At least it didn't mention it.\n\nIn other words, you should consider `chars` as a pool of letters that gets refilled after forming each word, rather than a pool that needs to last for all the words.\n\nSo, in your example, `chars = \"atach\"` can be used to form the word `\"cat\"` because it has one `'c'`, one `'a'`, and one `'t'`. After this, the `chars` string is \"refilled\", so it can be used again to form the word `\"hat\"` because it also has one `'h'`, one `'a'`, and one `'t'`. This is why the total length is `3 + 3 = 6`. \n\nThe key is that the characters are reused for each word in the `words` array, not across all the words.\n\nThe problem description should be edited \"... (each character can only be used once in each `words` iteration)\""
                    },
                    {
                        "username": "quppiehy",
                        "content": "I\\'m also confused by this"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "facing the same problem here?"
                    },
                    {
                        "username": "Md_Saif",
                        "content": "In this test case   [\\n    \\'dyiclysmffuhibgfvapygkorkqllqlvokosagyelotobicwcmebnpznjbirzrzsrtzjxhsfpiwyfhzyonmuabtlwin\\',\\n    \\'ndqeyhhcquplmznwslewjzuyfgklssvkqxmqjpwhrshycmvrb\\',\\n    \\'ulrrbpspyudncdlbkxkrqpivfftrggemkpyjl\\',\\n    \\'boygirdlggnh\\',\\n    \\'xmqohbyqwagkjzpyawsydmdaattthmuvjbzwpyopyafphx\\',\\n    \\'nulvimegcsiwvhwuiyednoxpugfeimnnyeoczuzxgxbqjvegcxeqnjbwnbvowastqhojepisusvsidhqmszbrnynkyop\\',\\n    \\'hiefuovybkpgzygprmndrkyspoiyapdwkxebgsmodhzpx\\',\\n    \\'juldqdzeskpffaoqcyyxiqqowsalqumddcufhouhrskozhlmobiwzxnhdkidr\\',\\n    \\'lnnvsdcrvzfmrvurucrzlfyigcycffpiuoo\\',\\n    \\'oxgaskztzroxuntiwlfyufddl\\',\\n    \\'tfspedteabxatkaypitjfkhkkigdwdkctqbczcugripkgcyfezpuklfqfcsccboarbfbjfrkxp\\',\\n    \\'qnagrpfzlyrouolqquytwnwnsqnmuzphne\\',\\n    \\'eeilfdaookieawrrbvtnqfzcricvhpiv\\',\\n    \\'sisvsjzyrbdsjcwwygdnxcjhzhsxhpceqz\\',\\n    \\'yhouqhjevqxtecomahbwoptzlkyvjexhzcbccusbjjdgcfzlkoqwiwue\\',\\n    \\'hwxxighzvceaplsycajkhynkhzkwkouszwaiuzqcleyflqrxgjsvlegvupzqijbornbfwpefhxekgpuvgiyeudhncv\\',\\n    \\'cpwcjwgbcquirnsazumgjjcltitmeyfaudbnbqhflvecjsupjmgwfbjo\\',\\n    \\'teyygdmmyadppuopvqdodaczob\\',\\n    \\'qaeowuwqsqffvibrtxnjnzvzuuonrkwpysyxvkijemmpdmtnqxwekbpfzs\\',\\n    \\'qqxpxpmemkldghbmbyxpkwgkaykaerhmwwjonrhcsubchs\\',\\n  ],\\n\\nI am getting 47 here on leetcode but when i run my program in local i am getting 0 which is correct so why this is happening here any guesses ??"
                    },
                    {
                        "username": "Teddy-Lin",
                        "content": "return sum([len(word) for word in words if all(word.count(i) <= chars.count(i) for i in word)])"
                    },
                    {
                        "username": "RyanAura",
                        "content": "Whats the point of putting the solution in the discussion."
                    },
                    {
                        "username": "Rushab11",
                        "content": "\n        \n        int len=0;\n        for(int i=0;i<words.size();i++)\n        {\n           string str=words[i];\n           int c=0;\n           for(int k=0;k<str.length();k++)\n           {\n             if(count(chars.begin(),chars.end(),str[k]))\n             {\n                 c++;\n             }\n           }\n           if(c==str.length())\n           {\n               len+=c;\n              \n           }\n           \n\n        }\n        return len;\n    \n\nWhat's Wrong with this Approach ?? Only 10 Test Case Passed"
                    },
                    {
                        "username": "user6808zB",
                        "content": "The below code works for the test cases but fails on the Final Submission when there is the chars of 50 characters and 70 words more than 40 chars each,. Can anyone please give me a suggestion what to modify in the below code: \n\ndef countCharacters(self, words: List[str], chars: str) -> int:\n\n        cnt=0                                                  #variable to count the total number of characters                               \n\n        for word in words:\n            res=[]                                                    #temp array to track the number of characters for the word\n            for i in range(len(word)): \n                if word[i] in chars:\n                    res.append(word[i])\n            if len(res)==len(word): \n                cnt+=len(res) \n        return cnt"
                    },
                    {
                        "username": "guruhegde777",
                        "content": "You are checking if word[ i ] exists in chars without checking the count.\\nFor example if a word has \\'a\\' 3 times but in chars single \\'a\\' is present, then you can\\'t construct a word which has 3 \\'a\\'s with only one \\'a\\'. Hope you understood.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Form a Target String Given a Dictionary",
        "question_content": "<p>You are given a list of strings of the <strong>same length</strong> <code>words</code> and a string <code>target</code>.</p>\n\n<p>Your task is to form <code>target</code> using the given <code>words</code> under the following rules:</p>\n\n<ul>\n\t<li><code>target</code> should be formed from left to right.</li>\n\t<li>To form the <code>i<sup>th</sup></code> character (<strong>0-indexed</strong>) of <code>target</code>, you can choose the <code>k<sup>th</sup></code> character of the <code>j<sup>th</sup></code> string in <code>words</code> if <code>target[i] = words[j][k]</code>.</li>\n\t<li>Once you use the <code>k<sup>th</sup></code> character of the <code>j<sup>th</sup></code> string of <code>words</code>, you <strong>can no longer</strong> use the <code>x<sup>th</sup></code> character of any string in <code>words</code> where <code>x &lt;= k</code>. In other words, all characters to the left of or at index <code>k</code> become unusuable for every string.</li>\n\t<li>Repeat the process until you form the string <code>target</code>.</li>\n</ul>\n\n<p><strong>Notice</strong> that you can use <strong>multiple characters</strong> from the <strong>same string</strong> in <code>words</code> provided the conditions above are met.</p>\n\n<p>Return <em>the number of ways to form <code>target</code> from <code>words</code></em>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;acca&quot;,&quot;bbbb&quot;,&quot;caca&quot;], target = &quot;aba&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> There are 6 ways to form target.\n&quot;aba&quot; -&gt; index 0 (&quot;<u>a</u>cca&quot;), index 1 (&quot;b<u>b</u>bb&quot;), index 3 (&quot;cac<u>a</u>&quot;)\n&quot;aba&quot; -&gt; index 0 (&quot;<u>a</u>cca&quot;), index 2 (&quot;bb<u>b</u>b&quot;), index 3 (&quot;cac<u>a</u>&quot;)\n&quot;aba&quot; -&gt; index 0 (&quot;<u>a</u>cca&quot;), index 1 (&quot;b<u>b</u>bb&quot;), index 3 (&quot;acc<u>a</u>&quot;)\n&quot;aba&quot; -&gt; index 0 (&quot;<u>a</u>cca&quot;), index 2 (&quot;bb<u>b</u>b&quot;), index 3 (&quot;acc<u>a</u>&quot;)\n&quot;aba&quot; -&gt; index 1 (&quot;c<u>a</u>ca&quot;), index 2 (&quot;bb<u>b</u>b&quot;), index 3 (&quot;acc<u>a</u>&quot;)\n&quot;aba&quot; -&gt; index 1 (&quot;c<u>a</u>ca&quot;), index 2 (&quot;bb<u>b</u>b&quot;), index 3 (&quot;cac<u>a</u>&quot;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abba&quot;,&quot;baab&quot;], target = &quot;bab&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 ways to form target.\n&quot;bab&quot; -&gt; index 0 (&quot;<u>b</u>aab&quot;), index 1 (&quot;b<u>a</u>ab&quot;), index 2 (&quot;ab<u>b</u>a&quot;)\n&quot;bab&quot; -&gt; index 0 (&quot;<u>b</u>aab&quot;), index 1 (&quot;b<u>a</u>ab&quot;), index 3 (&quot;baa<u>b</u>&quot;)\n&quot;bab&quot; -&gt; index 0 (&quot;<u>b</u>aab&quot;), index 2 (&quot;ba<u>a</u>b&quot;), index 3 (&quot;baa<u>b</u>&quot;)\n&quot;bab&quot; -&gt; index 1 (&quot;a<u>b</u>ba&quot;), index 2 (&quot;ba<u>a</u>b&quot;), index 3 (&quot;baa<u>b</u>&quot;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li>All strings in <code>words</code> have the same length.</li>\n\t<li><code>1 &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> and <code>target</code> contain only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 917779,
                "title": "java-c-python-space-o-n",
                "content": "# **Explanation**\\n`res[j]` means the number of ways to form target `j` first characters.\\n<br>\\n\\n# **Complexity**\\nTime `O(S(W + N))`,\\nSpace `O(N + S)`\\nwhere `N = target.length`,\\n`S = words[i].length`,\\n`W = words.length`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numWays(String[] words, String target) {\\n        int n = target.length();\\n        long mod = (long)1e9 + 7, res[] = new long[n + 1];\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            int[] count = new int[26];\\n            for (String w : words)\\n                count[w.charAt(i) - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target.charAt(j) - \\'a\\'] % mod;\\n            }\\n        }\\n        return (int)(res[n] % mod);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numWays(vector<string>& words, string target) {\\n        int n = target.length(), mod = 1e9 + 7;\\n        vector<long> res(n + 1);\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            vector<int> count(26);\\n            for (auto& w : words)\\n                count[w[i] - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target[j] - \\'a\\'] % mod;\\n            }\\n        }\\n        return res[n] % mod;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numWays(self, words, target):\\n        n, mod = len(target), 10**9 + 7\\n        res = [1] + [0] * n\\n        for i in xrange(len(words[0])):\\n            count = collections.Counter(w[i] for w in words)\\n            for j in xrange(n - 1, -1, -1):\\n                res[j + 1] += res[j] * count[target[j]] % mod\\n        return res[n] % mod\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numWays(String[] words, String target) {\\n        int n = target.length();\\n        long mod = (long)1e9 + 7, res[] = new long[n + 1];\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            int[] count = new int[26];\\n            for (String w : words)\\n                count[w.charAt(i) - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target.charAt(j) - \\'a\\'] % mod;\\n            }\\n        }\\n        return (int)(res[n] % mod);\\n    }\\n```\n```cpp\\n    int numWays(vector<string>& words, string target) {\\n        int n = target.length(), mod = 1e9 + 7;\\n        vector<long> res(n + 1);\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            vector<int> count(26);\\n            for (auto& w : words)\\n                count[w[i] - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target[j] - \\'a\\'] % mod;\\n            }\\n        }\\n        return res[n] % mod;\\n    }\\n```\n```py\\n    def numWays(self, words, target):\\n        n, mod = len(target), 10**9 + 7\\n        res = [1] + [0] * n\\n        for i in xrange(len(words[0])):\\n            count = collections.Counter(w[i] for w in words)\\n            for j in xrange(n - 1, -1, -1):\\n                res[j + 1] += res[j] * count[target[j]] % mod\\n        return res[n] % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2234922,
                "title": "c-recursion-memoization-optimization-step-by-step-solution",
                "content": "```\\n//Recursion\\nclass Solution {\\n    long getWords(vector<string>&words,string &target,int i,int j){\\n        if(j == target.size())return 1;\\n        if(i== words[0].size() || words[0].size() - i < target.size() - j)return 0;\\n   \\n        long count = 0;\\n        for(int idx = 0; idx < words.size(); idx++){\\n            if(words[idx][i] == target[j]){\\n                count += getWords(words, target, i + 1, j + 1)%1000000007;\\n            }\\n        }\\n        count += getWords(words, target, i + 1, j)%1000000007;\\n        return count%1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        return getWords(words, target, 0, 0);\\n    }\\n};\\n\\n//memoization but still (85/89)\\nclass Solution {\\n    vector<vector<int>>dp;\\n    \\n    long getWords(vector<string>&words,string &target,int i,int j){\\n        if(j == target.size())return 1;\\n        if(i== words[0].size() || words[0].size() - i < target.size() - j)return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        for(int idx = 0; idx < words.size(); idx++){\\n            if(words[idx][i] == target[j]){\\n                count += getWords(words, target, i + 1, j + 1)%1000000007;\\n            }\\n        }\\n        count += getWords(words, target, i + 1, j)%1000000007;\\n        return dp[i][j] = count%1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        \\n        return getWords(words, target, 0, 0);\\n    }\\n};\\n\\n// memoization + optimization (by pre calculating frequency) \\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recursion\\nclass Solution {\\n    long getWords(vector<string>&words,string &target,int i,int j){\\n        if(j == target.size())return 1;\\n        if(i== words[0].size() || words[0].size() - i < target.size() - j)return 0;\\n   \\n        long count = 0;\\n        for(int idx = 0; idx < words.size(); idx++){\\n            if(words[idx][i] == target[j]){\\n                count += getWords(words, target, i + 1, j + 1)%1000000007;\\n            }\\n        }\\n        count += getWords(words, target, i + 1, j)%1000000007;\\n        return count%1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        return getWords(words, target, 0, 0);\\n    }\\n};\\n\\n//memoization but still (85/89)\\nclass Solution {\\n    vector<vector<int>>dp;\\n    \\n    long getWords(vector<string>&words,string &target,int i,int j){\\n        if(j == target.size())return 1;\\n        if(i== words[0].size() || words[0].size() - i < target.size() - j)return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        for(int idx = 0; idx < words.size(); idx++){\\n            if(words[idx][i] == target[j]){\\n                count += getWords(words, target, i + 1, j + 1)%1000000007;\\n            }\\n        }\\n        count += getWords(words, target, i + 1, j)%1000000007;\\n        return dp[i][j] = count%1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        \\n        return getWords(words, target, 0, 0);\\n    }\\n};\\n\\n// memoization + optimization (by pre calculating frequency) \\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917694,
                "title": "java-python-top-down-dp-clean-concise-o-m-n",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        m, n = len(words[0]), len(target)\\n        charAtIndexCnt = [[0] * m for _ in range(128)]\\n        for word in words:\\n            for i, c in enumerate(word):\\n                charAtIndexCnt[ord(c)][i] += 1  # Count the number of character `c` at index `i` of all words\\n\\n        @lru_cache(None)\\n        def dp(k, i):\\n            if i == n:  # Formed a valid target\\n                return 1\\n            if k == m:  # Reached to length of words[x] but don\\'t found any result\\n                return 0\\n            c = target[i]\\n            ans = dp(k + 1, i)  # Skip k_th index of words\\n            if charAtIndexCnt[ord(c)][k] > 0: # Take k_th index of words if found character `c` at index k_th\\n                ans += dp(k + 1, i + 1) * charAtIndexCnt[ord(c)][k]\\n                ans %= MOD\\n            return ans\\n\\n        return dp(0, 0)\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    String[] words;\\n    String target;\\n    Integer[][] memo;\\n    int m, n;\\n    int[][] charAtIndexCnt;\\n    public int numWays(String[] words, String target) {\\n        this.words = words; this.target = target;\\n        m = words[0].length(); n = target.length();\\n        memo = new Integer[m][n];\\n        charAtIndexCnt = new int[128][m];\\n        \\n        for (String word : words)\\n            for (int i = 0; i < word.length(); i++)\\n                charAtIndexCnt[word.charAt(i)][i] += 1; // Count the number of character `c` at index `i` of all words\\n        return dp(0, 0);\\n    }\\n    \\n    int dp(int k, int i) {\\n        if (i == n)  // Formed a valid target\\n            return 1;\\n        if (k == m)  // Reached to length of words[x] but don\\'t found any result\\n            return 0;\\n        if (memo[k][i] != null) return memo[k][i];\\n        char c = target.charAt(i);\\n        long ans = dp(k + 1, i);  // Skip k_th index of words\\n        if (charAtIndexCnt[c][k] > 0) { // Take k_th index of words if found character `c` at index k_th\\n            ans += (long) dp(k + 1, i + 1) * charAtIndexCnt[c][k];\\n            ans %= 1_000_000_007;\\n        }\\n        return memo[k][i] = (int) ans;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time & Space: `O(m*n)`, where `m` is `words[i].length` and `n` is`target.length`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        m, n = len(words[0]), len(target)\\n        charAtIndexCnt = [[0] * m for _ in range(128)]\\n        for word in words:\\n            for i, c in enumerate(word):\\n                charAtIndexCnt[ord(c)][i] += 1  # Count the number of character `c` at index `i` of all words\\n\\n        @lru_cache(None)\\n        def dp(k, i):\\n            if i == n:  # Formed a valid target\\n                return 1\\n            if k == m:  # Reached to length of words[x] but don\\'t found any result\\n                return 0\\n            c = target[i]\\n            ans = dp(k + 1, i)  # Skip k_th index of words\\n            if charAtIndexCnt[ord(c)][k] > 0: # Take k_th index of words if found character `c` at index k_th\\n                ans += dp(k + 1, i + 1) * charAtIndexCnt[ord(c)][k]\\n                ans %= MOD\\n            return ans\\n\\n        return dp(0, 0)\\n```\n```java\\nclass Solution {\\n    String[] words;\\n    String target;\\n    Integer[][] memo;\\n    int m, n;\\n    int[][] charAtIndexCnt;\\n    public int numWays(String[] words, String target) {\\n        this.words = words; this.target = target;\\n        m = words[0].length(); n = target.length();\\n        memo = new Integer[m][n];\\n        charAtIndexCnt = new int[128][m];\\n        \\n        for (String word : words)\\n            for (int i = 0; i < word.length(); i++)\\n                charAtIndexCnt[word.charAt(i)][i] += 1; // Count the number of character `c` at index `i` of all words\\n        return dp(0, 0);\\n    }\\n    \\n    int dp(int k, int i) {\\n        if (i == n)  // Formed a valid target\\n            return 1;\\n        if (k == m)  // Reached to length of words[x] but don\\'t found any result\\n            return 0;\\n        if (memo[k][i] != null) return memo[k][i];\\n        char c = target.charAt(i);\\n        long ans = dp(k + 1, i);  // Skip k_th index of words\\n        if (charAtIndexCnt[c][k] > 0) { // Take k_th index of words if found character `c` at index k_th\\n            ans += (long) dp(k + 1, i + 1) * charAtIndexCnt[c][k];\\n            ans %= 1_000_000_007;\\n        }\\n        return memo[k][i] = (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421540,
                "title": "image-explanation-dp-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Number of Ways to Form a Target String Given a Dictionary` by `Aryan Mittal`\\n![Google5.png](https://assets.leetcode.com/users/images/7619722e-0d28-4ab7-8b63-6f3f84e9bc2c_1681621146.8390808.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/44cac326-71d0-442b-8152-8bb49a2eab2e_1681611732.607299.png)\\n![image.png](https://assets.leetcode.com/users/images/2c16f158-7238-4cea-8d6d-4c228f376da6_1681611746.2214.png)\\n![image.png](https://assets.leetcode.com/users/images/9508ca82-c57b-4006-a3dc-1172d3b75409_1681611756.5372636.png)\\n![image.png](https://assets.leetcode.com/users/images/ba51587d-885c-4a2b-ad5e-4104fcc042ff_1681611765.9728422.png)\\n![image.png](https://assets.leetcode.com/users/images/52ca8930-c552-4f5e-90d1-20a62a52f3db_1681611783.6557567.png)\\n![image.png](https://assets.leetcode.com/users/images/6823d369-d2cb-41d6-bf0b-261bee7efa32_1681611790.43094.png)\\n![image.png](https://assets.leetcode.com/users/images/a1fc6962-1e63-407c-92c1-77e39967bdaf_1681612135.3716147.png)\\n![image.png](https://assets.leetcode.com/users/images/e0ad8250-18eb-42a1-8ccd-d6a09a2692cf_1681611819.9767623.png)\\n![image.png](https://assets.leetcode.com/users/images/0aeecf1d-29b4-4f9c-9530-9cd381cb0381_1681611828.9015882.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size();\\n        int m = target.size();\\n        int mod = 1000000007;\\n        vector<int> dp(m+1, 0);\\n        dp[0] = 1;\\n        \\n        vector<vector<int>> count(n, vector<int>(26, 0));\\n        for (const string& word : words) {\\n            for (int i = 0; i < n; i++) {\\n                count[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                dp[j+1] += (int)((long)dp[j] * count[i][target[j] - \\'a\\'] % mod);\\n                dp[j+1] %= mod;\\n            }\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int n = words[0].length();\\n        int m = target.length();\\n        int mod = 1000000007;\\n        int[] dp = new int[m+1];\\n        dp[0] = 1;\\n        \\n        int[][] count = new int[n][26];\\n        for (String word : words) {\\n            for (int i = 0; i < n; i++) {\\n                count[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                dp[j+1] += (int)((long)dp[j] * count[i][target.charAt(j) - \\'a\\'] % mod);\\n                dp[j+1] %= mod;\\n            }\\n        }\\n        \\n        return dp[m];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n = len(words[0])\\n        m = len(target)\\n        mod = 10**9 + 7\\n        dp = [0] * (m+1)\\n        dp[0] = 1\\n        \\n        count = [[0] * 26 for _ in range(n)]\\n        for i in range(n):\\n            for word in words:\\n                count[i][ord(word[i]) - ord(\\'a\\')] += 1\\n        \\n        for i in range(n):\\n            for j in range(m-1, -1, -1):\\n                dp[j+1] += dp[j] * count[i][ord(target[j]) - ord(\\'a\\')]\\n                dp[j+1] %= mod\\n        \\n        return dp[m]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size();\\n        int m = target.size();\\n        int mod = 1000000007;\\n        vector<int> dp(m+1, 0);\\n        dp[0] = 1;\\n        \\n        vector<vector<int>> count(n, vector<int>(26, 0));\\n        for (const string& word : words) {\\n            for (int i = 0; i < n; i++) {\\n                count[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                dp[j+1] += (int)((long)dp[j] * count[i][target[j] - \\'a\\'] % mod);\\n                dp[j+1] %= mod;\\n            }\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int n = words[0].length();\\n        int m = target.length();\\n        int mod = 1000000007;\\n        int[] dp = new int[m+1];\\n        dp[0] = 1;\\n        \\n        int[][] count = new int[n][26];\\n        for (String word : words) {\\n            for (int i = 0; i < n; i++) {\\n                count[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = m-1; j >= 0; j--) {\\n                dp[j+1] += (int)((long)dp[j] * count[i][target.charAt(j) - \\'a\\'] % mod);\\n                dp[j+1] %= mod;\\n            }\\n        }\\n        \\n        return dp[m];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n = len(words[0])\\n        m = len(target)\\n        mod = 10**9 + 7\\n        dp = [0] * (m+1)\\n        dp[0] = 1\\n        \\n        count = [[0] * 26 for _ in range(n)]\\n        for i in range(n):\\n            for word in words:\\n                count[i][ord(word[i]) - ord(\\'a\\')] += 1\\n        \\n        for i in range(n):\\n            for j in range(m-1, -1, -1):\\n                dp[j+1] += dp[j] * count[i][ord(target[j]) - ord(\\'a\\')]\\n                dp[j+1] %= mod\\n        \\n        return dp[m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421602,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n >The idea is to use dynamic programming to calculate the number of ways to form the target string using the frequency of each character in each column of the matrix. We can keep track of the frequency of each character in each column of the matrix and then use a dp array to store the number of ways to form the prefix of target with the characters in the first i columns of the matrix. At each step, we can use the frequency array to calculate the number of ways to add the next character of the target to the prefix using the ith column of the matrix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. Calculate the frequency of each character in each column of the matrix using a 2D frequency array.\\n\\n> 2. Initialize a 2D dp array with dp[i][j] = number of ways to form the prefix of target with length j using the first i columns of the matrix.\\n\\n> 3. Initialize dp[0][0] = 1 to account for the empty prefix.\\n \\n> 4. Use a nested loop to iterate over the columns and characters of the matrix and target string respectively.\\n \\n> 5. Calculate the number of times the current character of the target appears in the current column of the matrix using the frequency array.\\n \\n> 6. Update the dp array at each step using the recurrence relation dp[i][j] = dp[i-1][j] + charCount * dp[i-1][j-1], where charCount is the number of times the current character appears in the current column.\\n \\n> 7. Return dp[n][target.length()], where n is the number of columns in the matrix.\\n\\n# Complexity\\n>- Time complexity:\\n >$$O(nm|target|)$$, where n is the number of columns in the matrix, m is the length of each word in the matrix, and |target| is the length of the target string.\\n\\n\\n\\n\\n> - Space complexity:\\n>Space complexity: $$O(n*|target|)$$, for the dp array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int mod = 1000000007;\\n        int n = words[0].length();\\n        int[][] freq = new int[n][26]; // freq[i][j] = frequency of j+\\'a\\' in the ith column of the matrix\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < n; j++) {\\n                freq[j][words[i].charAt(j) - \\'a\\']++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n+1][target.length()+1]; // dp[i][j] = number of ways to form the prefix of target with length j using the first i columns of the matrix\\n        \\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target.length(); j++) {\\n                int charCount = freq[i-1][target.charAt(j-1) - \\'a\\'];\\n                dp[i][j] = (dp[i-1][j] + (int)((long)charCount * dp[i-1][j-1] % mod)) % mod;\\n            }\\n        }\\n        \\n        return dp[n][target.length()];\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9 + 7\\n        m, n = len(words), len(words[0])\\n        \\n        # frequency array for each character in each column\\n        freq = [[0] * 26 for _ in range(n)]\\n        for j in range(n):\\n            for i in range(m):\\n                freq[j][ord(words[i][j]) - ord(\\'a\\')] += 1\\n        \\n        # dp array to store the number of ways to form the prefix of target\\n        dp = [1] + [0] * len(target)\\n        \\n        # fill dp array from left to right\\n        for j in range(n):\\n            for i in range(len(target), 0, -1):\\n                dp[i] += dp[i-1] * freq[j][ord(target[i-1]) - ord(\\'a\\')]\\n                dp[i] %= mod\\n                \\n        return dp[len(target)]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int mod = 1e9 + 7;\\n        int m = words.size(), n = words[0].size();\\n        \\n        // frequency array for each character in each column\\n        vector<vector<int>> freq(n, vector<int>(26, 0));\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                freq[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        \\n        // dp array to store the number of ways to form the prefix of target\\n        vector<long long> dp(target.size() + 1, 0);\\n        dp[0] = 1;\\n        \\n        // fill dp array from left to right\\n        for (int j = 0; j < n; j++) {\\n            for (int i = target.size(); i > 0; i--) {\\n                dp[i] = (dp[i] + dp[i-1] * freq[j][target[i-1] - \\'a\\']) % mod;\\n            }\\n        }\\n        \\n        return dp[target.size()];\\n    }\\n};\\n```\\n\\n```JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n    const mod = 1e9 + 7;\\n    const m = words.length;\\n    const n = words[0].length;\\n    \\n    // frequency array for each character in each column\\n    const freq = Array.from({ length: n }, () => Array(26).fill(0));\\n    for (let j = 0; j < n; j++) {\\n        for (let i = 0; i < m; i++) {\\n            freq[j][words[i].charCodeAt(j) - 97]++;\\n        }\\n    }\\n    \\n    // dp array to store the number of ways to form the prefix of target\\n    const dp = Array(target.length + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    // fill dp array from left to right\\n    for (let j = 0; j < n; j++) {\\n        for (let i = target.length; i > 0; i--) {\\n            dp[i] += dp[i-1] * freq[j][target.charCodeAt(i-1) - 97];\\n            dp[i] %= mod;\\n        }\\n    }\\n    \\n    return dp[target.length];\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int mod = 1000000007;\\n        int n = words[0].length();\\n        int[][] freq = new int[n][26]; // freq[i][j] = frequency of j+\\'a\\' in the ith column of the matrix\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < n; j++) {\\n                freq[j][words[i].charAt(j) - \\'a\\']++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n+1][target.length()+1]; // dp[i][j] = number of ways to form the prefix of target with length j using the first i columns of the matrix\\n        \\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= target.length(); j++) {\\n                int charCount = freq[i-1][target.charAt(j-1) - \\'a\\'];\\n                dp[i][j] = (dp[i-1][j] + (int)((long)charCount * dp[i-1][j-1] % mod)) % mod;\\n            }\\n        }\\n        \\n        return dp[n][target.length()];\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9 + 7\\n        m, n = len(words), len(words[0])\\n        \\n        # frequency array for each character in each column\\n        freq = [[0] * 26 for _ in range(n)]\\n        for j in range(n):\\n            for i in range(m):\\n                freq[j][ord(words[i][j]) - ord(\\'a\\')] += 1\\n        \\n        # dp array to store the number of ways to form the prefix of target\\n        dp = [1] + [0] * len(target)\\n        \\n        # fill dp array from left to right\\n        for j in range(n):\\n            for i in range(len(target), 0, -1):\\n                dp[i] += dp[i-1] * freq[j][ord(target[i-1]) - ord(\\'a\\')]\\n                dp[i] %= mod\\n                \\n        return dp[len(target)]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int mod = 1e9 + 7;\\n        int m = words.size(), n = words[0].size();\\n        \\n        // frequency array for each character in each column\\n        vector<vector<int>> freq(n, vector<int>(26, 0));\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                freq[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        \\n        // dp array to store the number of ways to form the prefix of target\\n        vector<long long> dp(target.size() + 1, 0);\\n        dp[0] = 1;\\n        \\n        // fill dp array from left to right\\n        for (int j = 0; j < n; j++) {\\n            for (int i = target.size(); i > 0; i--) {\\n                dp[i] = (dp[i] + dp[i-1] * freq[j][target[i-1] - \\'a\\']) % mod;\\n            }\\n        }\\n        \\n        return dp[target.size()];\\n    }\\n};\\n```\n```JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n    const mod = 1e9 + 7;\\n    const m = words.length;\\n    const n = words[0].length;\\n    \\n    // frequency array for each character in each column\\n    const freq = Array.from({ length: n }, () => Array(26).fill(0));\\n    for (let j = 0; j < n; j++) {\\n        for (let i = 0; i < m; i++) {\\n            freq[j][words[i].charCodeAt(j) - 97]++;\\n        }\\n    }\\n    \\n    // dp array to store the number of ways to form the prefix of target\\n    const dp = Array(target.length + 1).fill(0);\\n    dp[0] = 1;\\n    \\n    // fill dp array from left to right\\n    for (let j = 0; j < n; j++) {\\n        for (let i = target.length; i > 0; i--) {\\n            dp[i] += dp[i-1] * freq[j][target.charCodeAt(i-1) - 97];\\n            dp[i] %= mod;\\n        }\\n    }\\n    \\n    return dp[target.length];\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421437,
                "title": "recursion-top-down-bottom-up-easy-to-understand",
                "content": "## RECURSION\\n```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int solve(vector<vector<int>>&freq, string& target, int colIdx, int targetIdx)\\n    {\\n        //if target is complete, then irrespective of colIdx the formation is \\'VALID\\'\\n        if (targetIdx == target.size()) return 1; \\n        if (colIdx == freq.size()) //will come here only when (targetIdx != target.size())\\n            return 0;  //means target is not complete and still the string choices are over\\n                       //so \\'INVALID\\'\\n\\n        char targetCh = target[targetIdx];\\n        int notPickWays = solve(freq, target, colIdx + 1, targetIdx);\\n        //===================================================================\\n        int pickWays = 0;\\n        if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n        {\\n            int currWays = freq[colIdx][targetCh - \\'a\\'];\\n            int nextWays = solve(freq, target, colIdx + 1, targetIdx + 1);\\n            pickWays = (currWays * (long long)nextWays) % MOD;\\n        }\\n        //====================================================================\\n        return ((pickWays + (long long)notPickWays) % MOD);\\n        \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        int ans = solve(freq, target, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n//=======================================================================================================================\\n## TOP DOWN, MEMOIZATION [Accepted]\\n```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int solve(vector<vector<int>>&freq, string& target, vector<vector<int>>& dp, int colIdx, int targetIdx)\\n    {\\n        //if target is complete, then irrespective of colIdx the formation is \\'VALID\\'\\n        if (targetIdx == target.size()) return 1; \\n        if (colIdx == freq.size()) //will come here only when (targetIdx != target.size())\\n            return 0;  //means target is not complete and still the string choices are over\\n                       //so \\'INVALID\\'\\n\\n        if (dp[colIdx][targetIdx] != -1) return dp[colIdx][targetIdx];\\n        char targetCh = target[targetIdx];\\n        int notPickWays = solve(freq, target, dp, colIdx + 1, targetIdx);\\n        //===================================================================\\n        int pickWays = 0;\\n        if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n        {\\n            int currWays = freq[colIdx][targetCh - \\'a\\'];\\n            int nextWays = solve(freq, target, dp, colIdx + 1, targetIdx + 1);\\n            pickWays = (currWays * (long long)nextWays) % MOD;\\n        }\\n        //====================================================================\\n        return dp[colIdx][targetIdx] = ((pickWays + (long long)notPickWays) % MOD);\\n        \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        vector<vector<int>>dp(n, vector<int>(target.size(), -1));\\n        int ans = solve(freq, target, dp, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n//=======================================================================================================================\\n## BOTTOM UP [Accepted]\\n```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        //===================================================================================================\\n         //TOP DOWN => \\n        //  1)[colIdx = j], we expected results for [colIdx = j + 1]\\n        //  2)[targetIdx = k], we expected results for [targetIdx = k + 1]\\n        //BOTTOM UP => \\n        //  1) We calculate [col = j + 1] results first\\n        //     Then use them in [colIdx = j] :)\\n        //  2) We calculate [targetIdx = k + 1] results first\\n        //     Then use them in [targetIdx = k] :)\\n        \\n        int targetSize = target.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(targetSize + 1, 0));\\n        for (int colIdx = n; colIdx >= 0; colIdx--)\\n        {\\n            for (int targetIdx = targetSize; targetIdx >= 0; targetIdx--)\\n            {\\n                //SAME BASE CONDITIONS AS IN TOP DOWN\\n                if (targetIdx == targetSize) { dp[colIdx][targetIdx] = 1; continue; }\\n                if (colIdx == n) { dp[colIdx][targetIdx] = 0; continue; }\\n                \\n                char targetCh = target[targetIdx];\\n                int notPickWays = dp[colIdx + 1][targetIdx];\\n                //===================================================================\\n                int pickWays = 0;\\n                if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n                {\\n                    int currWays = freq[colIdx][targetCh - \\'a\\'];\\n                    int nextWays = dp[colIdx + 1][targetIdx + 1];\\n                    pickWays = (currWays * (long long)nextWays) % MOD;\\n                }\\n                //====================================================================\\n                dp[colIdx][targetIdx] = ((pickWays + (long long)notPickWays) % MOD);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int solve(vector<vector<int>>&freq, string& target, int colIdx, int targetIdx)\\n    {\\n        //if target is complete, then irrespective of colIdx the formation is \\'VALID\\'\\n        if (targetIdx == target.size()) return 1; \\n        if (colIdx == freq.size()) //will come here only when (targetIdx != target.size())\\n            return 0;  //means target is not complete and still the string choices are over\\n                       //so \\'INVALID\\'\\n\\n        char targetCh = target[targetIdx];\\n        int notPickWays = solve(freq, target, colIdx + 1, targetIdx);\\n        //===================================================================\\n        int pickWays = 0;\\n        if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n        {\\n            int currWays = freq[colIdx][targetCh - \\'a\\'];\\n            int nextWays = solve(freq, target, colIdx + 1, targetIdx + 1);\\n            pickWays = (currWays * (long long)nextWays) % MOD;\\n        }\\n        //====================================================================\\n        return ((pickWays + (long long)notPickWays) % MOD);\\n        \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        int ans = solve(freq, target, 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int solve(vector<vector<int>>&freq, string& target, vector<vector<int>>& dp, int colIdx, int targetIdx)\\n    {\\n        //if target is complete, then irrespective of colIdx the formation is \\'VALID\\'\\n        if (targetIdx == target.size()) return 1; \\n        if (colIdx == freq.size()) //will come here only when (targetIdx != target.size())\\n            return 0;  //means target is not complete and still the string choices are over\\n                       //so \\'INVALID\\'\\n\\n        if (dp[colIdx][targetIdx] != -1) return dp[colIdx][targetIdx];\\n        char targetCh = target[targetIdx];\\n        int notPickWays = solve(freq, target, dp, colIdx + 1, targetIdx);\\n        //===================================================================\\n        int pickWays = 0;\\n        if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n        {\\n            int currWays = freq[colIdx][targetCh - \\'a\\'];\\n            int nextWays = solve(freq, target, dp, colIdx + 1, targetIdx + 1);\\n            pickWays = (currWays * (long long)nextWays) % MOD;\\n        }\\n        //====================================================================\\n        return dp[colIdx][targetIdx] = ((pickWays + (long long)notPickWays) % MOD);\\n        \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        vector<vector<int>>dp(n, vector<int>(target.size(), -1));\\n        int ans = solve(freq, target, dp, 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long MOD = 1000000007;\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>>freq(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                char ch = words[i][j];\\n                freq[j][ch - \\'a\\']++; //freq of \\'ch\\' in jth col\\n            }\\n        }\\n        //===================================================================================================\\n         //TOP DOWN => \\n        //  1)[colIdx = j], we expected results for [colIdx = j + 1]\\n        //  2)[targetIdx = k], we expected results for [targetIdx = k + 1]\\n        //BOTTOM UP => \\n        //  1) We calculate [col = j + 1] results first\\n        //     Then use them in [colIdx = j] :)\\n        //  2) We calculate [targetIdx = k + 1] results first\\n        //     Then use them in [targetIdx = k] :)\\n        \\n        int targetSize = target.size();\\n        vector<vector<int>>dp(n + 1, vector<int>(targetSize + 1, 0));\\n        for (int colIdx = n; colIdx >= 0; colIdx--)\\n        {\\n            for (int targetIdx = targetSize; targetIdx >= 0; targetIdx--)\\n            {\\n                //SAME BASE CONDITIONS AS IN TOP DOWN\\n                if (targetIdx == targetSize) { dp[colIdx][targetIdx] = 1; continue; }\\n                if (colIdx == n) { dp[colIdx][targetIdx] = 0; continue; }\\n                \\n                char targetCh = target[targetIdx];\\n                int notPickWays = dp[colIdx + 1][targetIdx];\\n                //===================================================================\\n                int pickWays = 0;\\n                if (freq[colIdx][targetCh - \\'a\\'] != 0)\\n                {\\n                    int currWays = freq[colIdx][targetCh - \\'a\\'];\\n                    int nextWays = dp[colIdx + 1][targetIdx + 1];\\n                    pickWays = (currWays * (long long)nextWays) % MOD;\\n                }\\n                //====================================================================\\n                dp[colIdx][targetIdx] = ((pickWays + (long long)notPickWays) % MOD);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917693,
                "title": "python-short-o-mn-dp-solution-explained",
                "content": "Let us denote by `dp[i][j]` number of solutions, such that the last symbol we take was from `i`-th column and also we create exactly `j` symbold of our `target`. Let also `sp[i][j]` be cumulative sum of `dp` on first index, that is `sp[i][j] = sp[i-1][j] + ... + sp[0][j]`.\\n\\nNow, the question is how we an evaluate `dp[i][j]`. By definition, the last symbol we take is from `i`-th column. So, first, we need to understand how many options we have to take this symbol: for quick acces we use `Q[i][j]` array, how many times we have symbol `j` in `i`-th column. We need to multiply this number by `sp[i-1][j-1] = dp[0][j-1] + ... + dp[i-1][j-1]`, because previous taken symbol can be from any of previous columns. For example, it can happen, that `Q[i][ord(target[j]) - ord(\"a\")] = 0`, it means that `dp[i][j] = 0` immedietly. Also we need to consider one more corner case: if `j = 0`, it means, we just start to build our `target` string, so in this case we do not need to multiply by `sp[i-1][j-1]`. Finally, we update our `sp` and do not forget to use modulo `N`.\\n\\n**Complexity**: space complexity is `O(26n + nk)` to keep our `Q`, `dp` and `sp` tables. Time complexity is `O(nm + nk)` to form `Q` table and to update `dp` and `sp` tables.\\n\\n\\n```\\nclass Solution:\\n    def numWays(self, words, target):\\n        m, n, k, N = len(words), len(words[0]), len(target), 10**9 + 7\\n        Q  = [[0] * 26 for _ in range(n)]\\n        dp = [[0] * k for _ in range(n)]\\n        sp = [[0] * k for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                Q[i][ord(words[j][i]) - ord(\"a\")] += 1\\n\\n        dp[0][0] = sp[0][0] = Q[0][ord(target[0]) - ord(\"a\")]\\n        \\n        for i in range(1, n):\\n            for j in range(k):\\n                if j > 0: dp[i][j] = Q[i][ord(target[j]) - ord(\"a\")] * sp[i-1][j-1]\\n                else: dp[i][j] = Q[i][ord(target[j]) - ord(\"a\")]\\n                sp[i][j] = (sp[i-1][j] + dp[i][j]) % N\\n\\n        return sp[-1][-1] % N\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words, target):\\n        m, n, k, N = len(words), len(words[0]), len(target), 10**9 + 7\\n        Q  = [[0] * 26 for _ in range(n)]\\n        dp = [[0] * k for _ in range(n)]\\n        sp = [[0] * k for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                Q[i][ord(words[j][i]) - ord(\"a\")] += 1\\n\\n        dp[0][0] = sp[0][0] = Q[0][ord(target[0]) - ord(\"a\")]\\n        \\n        for i in range(1, n):\\n            for j in range(k):\\n                if j > 0: dp[i][j] = Q[i][ord(target[j]) - ord(\"a\")] * sp[i-1][j-1]\\n                else: dp[i][j] = Q[i][ord(target[j]) - ord(\"a\")]\\n                sp[i][j] = (sp[i-1][j] + dp[i][j]) % N\\n\\n        return sp[-1][-1] % N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917672,
                "title": "c-dp-bottom-up-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nIntuition: we can think of flattening the `words` array into a string where each place has multiple character options. And we use this spacial string to match `target`.\\n\\nWe first do the flattening using a `cnt` array, where `cnt[i]` stores the frequencies of characters at position `i` in `words`.\\n\\nLet `dp[i+1][j+1]` be the number of ways to match `target[0..j]` using `cnt[0..i]`.\\n\\nWhen `j == 0`, we have only `target[0]` to match, we have two options:\\n1. Use `cnt[i]` to match. There are `cnt[i][target[j] - \\'a\\']` ways.\\n2. Reuse `dp[i][j + 1]` which covers the cases where we use `cnt[j], j < i` to match `target[0]`.\\n\\nSo `dp[i + 1][j + 1] = cnt[i][target[j] - \\'a\\'] + dp[i][j + 1]` when `j == 0`.\\n\\nWhen `j > 0`, we have two options:\\n1. Use `cnt[i]` to match `target[j]`. There are `cnt[i][target[j] - \\'a\\']` ways to match the last character, and for the leading part there are `dp[i][j]` ways. So in total there are `cnt[i][target[j] - \\'a\\'] * dp[i][j]` ways.\\n2. Reuse the `dp[i][j + 1]` which covers the cases where we use `cnt[j], j < i` to match `target[j]`. \\n\\nSo `dp[i + 1][j + 1] = cnt[i][target[j] - \\'a\\'] * dp[i][j] + dp[i][j + 1]` when `j > 0`.\\n\\nWe can merge these two cases by treating `dp[i][j] = 1` if `j == 0`:\\n\\n```\\ndp[i + 1][j + 1] = cnt[i][target[j] - \\'a\\'] * dp[i][j] + dp[i][j + 1] where 0 <= i < L, 0 <= j < N\\n\\ndp[i][0] = 1\\n\\ndp[i + 1][j + 1] = 0 if i < j\\n```\\n\\nThe answer is `dp[L][N]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-38/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/\\n// Author: github.com/lzl124631x\\n// Time: O(LM + LN)\\n// Space: O(LN)\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& A, string target) {\\n        long mod = 1e9+7, M = A.size(), L = A[0].size(), N = target.size();\\n        if (L < N) return 0;\\n        vector<array<long, 26>> cnt(L, array<long, 26>());\\n        for (int i = 0; i < L; ++i) {\\n            for (int j = 0; j < M; ++j) cnt[i][A[j][i] - \\'a\\']++;\\n        }\\n        vector<vector<int>> dp(L + 1, vector<int>(N + 1));\\n        for (int i = 0; i < L; ++i) {\\n            dp[i][0] = 1;\\n            for (int j = 0; j <= i && j < N; ++j) {\\n                dp[i + 1][j + 1] = ((cnt[i][target[j] - \\'a\\'] * dp[i][j]) % mod + dp[i][j + 1]) % mod;\\n            }\\n        }\\n        return dp[L][N];\\n    }\\n};\\n```\\n\\n## Solution 2. DP with Space Optimization\\n\\nSince `dp[i + 1][j + 1]` only depends on `dp[i][j]` and `dp[i][j + 1]`, we can flatten the `dp` array from `L * N` to `1 * N`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/\\n// Author: github.com/lzl124631x\\n// Time: O(LM + LN)\\n// Space: O(L + N)\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& A, string target) {\\n        long mod = 1e9+7, M = A.size(), L = A[0].size(), N = target.size();\\n        if (L < N) return 0;\\n        vector<array<long, 26>> cnt(L, array<long, 26>());\\n        for (int i = 0; i < L; ++i) {\\n            for (int j = 0; j < M; ++j) {\\n                cnt[i][A[j][i] - \\'a\\']++;\\n            }\\n        }\\n        vector<long> dp(N + 1);\\n        for (int i = 0; i < L; ++i) {\\n            int prev = 1;\\n            for (int j = 0; j <= i && j < N; ++j) {\\n                int cur = dp[j + 1];\\n                dp[j + 1] = ((cnt[i][target[j] - \\'a\\'] * prev) % mod + dp[j + 1]) % mod;\\n                prev = cur;\\n            }\\n        }\\n        return dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i + 1][j + 1] = cnt[i][target[j] - \\'a\\'] * dp[i][j] + dp[i][j + 1] where 0 <= i < L, 0 <= j < N\\n\\ndp[i][0] = 1\\n\\ndp[i + 1][j + 1] = 0 if i < j\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-38/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/\\n// Author: github.com/lzl124631x\\n// Time: O(LM + LN)\\n// Space: O(LN)\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& A, string target) {\\n        long mod = 1e9+7, M = A.size(), L = A[0].size(), N = target.size();\\n        if (L < N) return 0;\\n        vector<array<long, 26>> cnt(L, array<long, 26>());\\n        for (int i = 0; i < L; ++i) {\\n            for (int j = 0; j < M; ++j) cnt[i][A[j][i] - \\'a\\']++;\\n        }\\n        vector<vector<int>> dp(L + 1, vector<int>(N + 1));\\n        for (int i = 0; i < L; ++i) {\\n            dp[i][0] = 1;\\n            for (int j = 0; j <= i && j < N; ++j) {\\n                dp[i + 1][j + 1] = ((cnt[i][target[j] - \\'a\\'] * dp[i][j]) % mod + dp[i][j + 1]) % mod;\\n            }\\n        }\\n        return dp[L][N];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/\\n// Author: github.com/lzl124631x\\n// Time: O(LM + LN)\\n// Space: O(L + N)\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& A, string target) {\\n        long mod = 1e9+7, M = A.size(), L = A[0].size(), N = target.size();\\n        if (L < N) return 0;\\n        vector<array<long, 26>> cnt(L, array<long, 26>());\\n        for (int i = 0; i < L; ++i) {\\n            for (int j = 0; j < M; ++j) {\\n                cnt[i][A[j][i] - \\'a\\']++;\\n            }\\n        }\\n        vector<long> dp(N + 1);\\n        for (int i = 0; i < L; ++i) {\\n            int prev = 1;\\n            for (int j = 0; j <= i && j < N; ++j) {\\n                int cur = dp[j + 1];\\n                dp[j + 1] = ((cnt[i][target[j] - \\'a\\'] * prev) % mod + dp[j + 1]) % mod;\\n                prev = cur;\\n            }\\n        }\\n        return dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917696,
                "title": "c-recursion-with-memoization-clean-with-detailed-explanation",
                "content": "* Store a frequency table of characters by position. So for eg., in position 0, count the number of a\\u2019s, b\\u2019s, c\\u2019s, etc. across index 0 of all words\\n* Run a dfs that takes two inputs - the current position in word (int w), and the current position in target (int t)\\n* Refer code comments for details\\n \\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    const ll MOD = 1e9 + 7; // Using long long for MOD to avoid overflows\\n    \\n    int n;  // Length of word\\n    vector<vector<ll>> freq, mem;\\n    string target;\\n    \\n    // DFS : Takes in current index of word and target\\n    int go(int w, int t) {\\n        \\n        // If we exceed target\\'s length, we\\'ve matched everything in target\\n        if(t >= target.size()) \\n            return 1;\\n        \\n        // Else if we exceed word\\'s length, we haven\\'t matched target\\n        if(w >= n) \\n            return 0;\\n        \\n        // If we\\'ve processed this before, return the value from the memoization table\\n        ll &ans = mem[w][t];\\n        if(ans > -1) \\n            return ans;\\n        \\n        int cur = target[t] - \\'a\\';\\n        \\n        // Else return the sum of :\\n        //   1) Don\\'t match the current character of target to current index of word (go(w + 1, t))\\n        //   2) Match the current character of target to word (freq[w][cur] * go(w + 1, t + 1))\\n        // Note: There are freq[w][cur] options to choose the current letter, hence the multiplier \\n        // Note: MOD\\'s are needed to avoid overflows - apply MOD after every operation        \\n        return ans = (go(w + 1, t) + ((freq[w][cur] * go(w + 1, t + 1)) % MOD)) % MOD;\\n    }\\n    int numWays(vector<string>& words, string _target) {\\n        target = _target;\\n        int i, j, m = words.size();\\n        n = words[0].size();\\n        freq.resize(n, vector<ll>(26, 0));\\n        mem.resize(n + 1, vector<ll>(target.size() + 1, -1));\\n        \\n        // Build a frequency table indexed by word position\\n        for(i=0; i<m; i++)\\n            for(j=0; j<n; j++)\\n                freq[j][words[i][j] - \\'a\\']++;\\n        \\n        return go(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    const ll MOD = 1e9 + 7; // Using long long for MOD to avoid overflows\\n    \\n    int n;  // Length of word\\n    vector<vector<ll>> freq, mem;\\n    string target;\\n    \\n    // DFS : Takes in current index of word and target\\n    int go(int w, int t) {\\n        \\n        // If we exceed target\\'s length, we\\'ve matched everything in target\\n        if(t >= target.size()) \\n            return 1;\\n        \\n        // Else if we exceed word\\'s length, we haven\\'t matched target\\n        if(w >= n) \\n            return 0;\\n        \\n        // If we\\'ve processed this before, return the value from the memoization table\\n        ll &ans = mem[w][t];\\n        if(ans > -1) \\n            return ans;\\n        \\n        int cur = target[t] - \\'a\\';\\n        \\n        // Else return the sum of :\\n        //   1) Don\\'t match the current character of target to current index of word (go(w + 1, t))\\n        //   2) Match the current character of target to word (freq[w][cur] * go(w + 1, t + 1))\\n        // Note: There are freq[w][cur] options to choose the current letter, hence the multiplier \\n        // Note: MOD\\'s are needed to avoid overflows - apply MOD after every operation        \\n        return ans = (go(w + 1, t) + ((freq[w][cur] * go(w + 1, t + 1)) % MOD)) % MOD;\\n    }\\n    int numWays(vector<string>& words, string _target) {\\n        target = _target;\\n        int i, j, m = words.size();\\n        n = words[0].size();\\n        freq.resize(n, vector<ll>(26, 0));\\n        mem.resize(n + 1, vector<ll>(target.size() + 1, -1));\\n        \\n        // Build a frequency table indexed by word position\\n        for(i=0; i<m; i++)\\n            for(j=0; j<n; j++)\\n                freq[j][words[i][j] - \\'a\\']++;\\n        \\n        return go(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917708,
                "title": "c-python3-top-down-and-bottom-up",
                "content": "#### Top-Down\\nThe trick is to pre-process words so we know the count `cnt` of each character in each position.\\n\\nThen, we can efficiently look for a match; if there are more than one word we can use (`cnt[k][char] > 1`), we multiply the result by that count.\\n\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint dfs(vector<vector<int>> &cnt, string &t, int i, int j) {\\n    if (j >= t.size())\\n        return 1;\\n    if (dp[i][j] == 0) {\\n        dp[i][j] = 1;\\n        for (int k = i; k + (t.size() - j) <= cnt.size(); ++k)\\n            if (cnt[k][t[j] - \\'a\\'])\\n                dp[i][j]  = ((long)cnt[k][t[j] - \\'a\\'] * dfs(cnt, t, k + 1, j + 1) + dp[i][j]) % 1000000007;\\n    }\\n    return dp[i][j] - 1;\\n}\\nint numWays(vector<string>& words, string target) {\\n    vector<vector<int>> cnt(words[0].size(), vector<int>(26));\\n    for (auto &w : words)\\n        for (auto i = 0; i < w.size(); ++i)\\n            ++cnt[i][w[i] - \\'a\\'];\\n    return dfs(cnt, target, 0, 0);\\n}\\n```\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def numWays(self, words: List[str], t: str) -> int:\\n        @lru_cache(None)\\n        def dfs(i: int, j: int) -> int:\\n            if j >= len(t):\\n                return 1\\n            k = len(cnt) - len(t) + j + 1\\n            return sum(cnt[k][t[j]] * dfs(k + 1, j + 1) for k in range(i, k)) % 1000000007\\n        cnt = [collections.Counter(w[i] for w in words) for i in range(len(words[0]))]\\n        return dfs(0, 0)\\n```\\n#### Bottom-Up\\nWe can convert the memoisation solution into bottom-up tabulation, and reduce the required memory to O(n). With help by [mayank12559](https://leetcode.com/mayank12559/) - see the Java solution in his comment below.\\n\\n**C++**\\n```cpp\\nint numWays(vector<string>& words, string target) {\\n    int dp[10001] = { 1 };\\n    for (int i = 0; i < words[0].size(); ++i) {\\n        int cnt[26] = {};\\n        for (auto &w : words)\\n            ++cnt[w[i] - \\'a\\'];\\n        for (int j = min(i + 1, (int)target.size()); j > 0; --j) {\\n            dp[j] = ((long)cnt[target[j - 1] - \\'a\\'] * dp[j - 1] + dp[j]) % 1000000007;\\n        }\\n    }\\n    return dp[target.size()];\\n}\\n```\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        res = [1] + [0] * len(target)\\n        for i in range(len(words[0])):\\n            cnt = collections.Counter(w[i] for w in words)\\n            for j in range(min(i + 1, len(target)), 0, -1):\\n                res[j] = (res[j] + res[j - 1] * cnt[target[j - 1]]) % 1000000007\\n        return res[len(target)]\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001][1001] = {};\\nint dfs(vector<vector<int>> &cnt, string &t, int i, int j) {\\n    if (j >= t.size())\\n        return 1;\\n    if (dp[i][j] == 0) {\\n        dp[i][j] = 1;\\n        for (int k = i; k + (t.size() - j) <= cnt.size(); ++k)\\n            if (cnt[k][t[j] - \\'a\\'])\\n                dp[i][j]  = ((long)cnt[k][t[j] - \\'a\\'] * dfs(cnt, t, k + 1, j + 1) + dp[i][j]) % 1000000007;\\n    }\\n    return dp[i][j] - 1;\\n}\\nint numWays(vector<string>& words, string target) {\\n    vector<vector<int>> cnt(words[0].size(), vector<int>(26));\\n    for (auto &w : words)\\n        for (auto i = 0; i < w.size(); ++i)\\n            ++cnt[i][w[i] - \\'a\\'];\\n    return dfs(cnt, target, 0, 0);\\n}\\n```\n```python\\nclass Solution:\\n    def numWays(self, words: List[str], t: str) -> int:\\n        @lru_cache(None)\\n        def dfs(i: int, j: int) -> int:\\n            if j >= len(t):\\n                return 1\\n            k = len(cnt) - len(t) + j + 1\\n            return sum(cnt[k][t[j]] * dfs(k + 1, j + 1) for k in range(i, k)) % 1000000007\\n        cnt = [collections.Counter(w[i] for w in words) for i in range(len(words[0]))]\\n        return dfs(0, 0)\\n```\n```cpp\\nint numWays(vector<string>& words, string target) {\\n    int dp[10001] = { 1 };\\n    for (int i = 0; i < words[0].size(); ++i) {\\n        int cnt[26] = {};\\n        for (auto &w : words)\\n            ++cnt[w[i] - \\'a\\'];\\n        for (int j = min(i + 1, (int)target.size()); j > 0; --j) {\\n            dp[j] = ((long)cnt[target[j - 1] - \\'a\\'] * dp[j - 1] + dp[j]) % 1000000007;\\n        }\\n    }\\n    return dp[target.size()];\\n}\\n```\n```python\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        res = [1] + [0] * len(target)\\n        for i in range(len(words[0])):\\n            cnt = collections.Counter(w[i] for w in words)\\n            for j in range(min(i + 1, len(target)), 0, -1):\\n                res[j] = (res[j] + res[j - 1] * cnt[target[j - 1]]) % 1000000007\\n        return res[len(target)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424358,
                "title": "easy-to-understand-full-explanation-brute-force-to-optimal-step-by-step-c-o-n-2-solution",
                "content": "# Observations\\nOn analyisis of constraints :\\n    1) `Each word` in the word list is of the `same length`.\\n    2) The `maximum number of words` in the list is `1000`.\\n    3) `Each word` can have a `max length` of `1000`.\\n    4) The `target` length can also be a maximum of `1000`.\\n    5) Since, after the computation for answer of an index `i` the previous indices `before i` become invalid, the answers have to computed sequentially from `0-> word[0].size()-1`\\n\\n# Intuition\\nCome up with a `N^2` or `N^2LOG(N)` solution to solve the problem.\\n\\n# Approach\\n1) Identify the `changing variables`.\\n2) Break the problem into subproblems in terms of the changing variables.\\n3) Changing variables: \\n    a) `i`: denotes the index of each word in the word list which can be used to make target string.\\n    b) `j`: denotes the current index in the target string with which i is matched to make a decision.\\n\\n    Neccessarily, the subproblem becomes `recur(i,j)` which means find the number of ways to make the jth character of the target string from the ith index of each word in words.\\n\\n4) Now for every `ith` index there exists two options\\n    a) if there exists target[j] at the ith index of every word, use it to make the target string and `recur(i+1, j+1)`.\\n    b) dont take the ith character and find out ways skipping the ith index altogether, `recur(i+1,j)`.\\n\\n5) The total number of ways would be the sum of both the possibilities.\\n\\n6) Base cases:\\n    a) If we are able to reach the end of target string `(j==target.size()) return 1` (which means this way of making the target is one possible way).\\n    b) If we exhaust our possible indices `i` to choose characters to make target then `return 0.`\\nNOTE: These cases are written sequentially to handle the true case of i== word[0].size() && j== target.size()\\n \\n# Brute Force \\n```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n        \\n        long long ways=0;\\n        \\n        for(auto word: words)\\n        {\\n            if(target[j]== word[i])\\n            {\\n                ways+= recur(words,target,i+1,j+1); // take case\\n                ways%=mod;\\n            }\\n        }\\n        \\n        ways+= recur(words,target,i+1,j); // not take case\\n        ways%= mod;\\n        \\n        return ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        return recur(words,target,0,0);\\n    }\\n};\\n```\\n\\n# Brute Force (Memoised)\\nThe goal here is to tackle overlapping subproblems using memoisation and dynamic programming.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j, vector<vetor<int>>& dp)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long ways=0;\\n        \\n        for(auto word: words) //O(N)\\n        {\\n            if(target[j]== word[i])\\n            {\\n                ways+= recur(words,target,i+1,j+1, dp); //Take case\\n                ways%=mod;\\n            }\\n        }\\n        \\n        ways+= recur(words,target,i+1,j,dp); //Not take case\\n        ways%= mod;\\n        \\n        return dp[i][j]= ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        return recur(words,target,0,0,dp);\\n    }\\n};\\n```\\n\\n# Optimal solution\\n\\nIt is true that the memoised solution is a better solution than the first one. However it does not pass the given constraints.\\n\\nNotice that across all N^2 states, O(N) work is being done in the block of code below: \\n\\n```\\nfor(auto word: words) //O(N)\\n{\\n    if(target[j]== word[i])\\n    {\\n        ways+= recur(words,target,i+1,j+1);\\n        ways%=mod;\\n    }\\n}\\n```\\n\\nFor our solution to pass we would have to eliminate this extra work.\\n\\nObservation : If we are able to figure out the ways possible by using the character present at `i` we can just can simply multiply it by the number of times the same character occurs at the same index `i`.\\n\\nTo implement this, we precompute the frequency of a character at a particular index using a `map<pair<char,int>, int>` and use this map to eliminate the loop above.\\n\\nUsing this map we can simply check if the target[j] is present in the map by `map[target[j],i] > 0` (For the character to be present, its freq must be greater than 0).\\n\\nIf the character is present, calculate the number of ways using this character and multiply the frequency.\\n\\nThe map will have a maximum of 26*N key values.\\n\\nNOTE: Using a different word for the same index `i` is a new way to make the target word. However since it is at the same index `i` but in a different word, the calculation is repetitive and can be just computed using number of times it has to be calculated (frequency).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j, vector<vector<int>> &dp, map<pair<char,int>, int>& charatidxfreq)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long ways=0;\\n        \\n        if(charatidxfreq[{target[j],i}]!=0) // Now this operation becomes O(1)\\n        {\\n            ways+= recur(words,target,i+1,j+1,dp, charatidxfreq);\\n            ways%= mod;\\n            ways*= (charatidxfreq[{target[j],i}]%mod); //find ways and the multiply by frequency\\n            ways%= mod;\\n        }\\n        \\n        ways+= recur(words,target,i+1,j,dp, charatidxfreq);\\n        ways%= mod;\\n        \\n        return dp[i][j]= ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        unordered_map<int, set<char>> idxTochar;\\n        \\n        map<pair<char,int>, int> charatidxfreq;\\n        \\n        for(auto word: words)\\n        {\\n            for(int i=0;i<word.size();i++)\\n            {   \\n                charatidxfreq[{word[i],i}]++;\\n            }\\n        }\\n        \\n        return recur(words,target,0,0, dp, charatidxfreq);\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity :\\n    Brute Force Solution : O(2^ N^2)* N \\n    Brute Force Solution memoised: O(N^3);\\n    Optimal Solution: N^2 + (26*N)LOG(26N) = O(N^2)\\nwhere N is the number of characters in a word.\\n\\n- Space complexity:\\n    Brute Force: Auxillary Stack Space O(N)\\n    Brute Force Memoised : O(N^2)+ Auxillary Stack Space O(N)= O(N^2)\\n    Optimal Solution : N^2(dp)+ 26*N(freq map) + Auxillary Stack Space = O(N^2)\\nwhere N is the number of characters in a word.\\n\\nThe auxillary stack space can be eliminated using tabulation.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n        \\n        long long ways=0;\\n        \\n        for(auto word: words)\\n        {\\n            if(target[j]== word[i])\\n            {\\n                ways+= recur(words,target,i+1,j+1); // take case\\n                ways%=mod;\\n            }\\n        }\\n        \\n        ways+= recur(words,target,i+1,j); // not take case\\n        ways%= mod;\\n        \\n        return ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        return recur(words,target,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j, vector<vetor<int>>& dp)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long ways=0;\\n        \\n        for(auto word: words) //O(N)\\n        {\\n            if(target[j]== word[i])\\n            {\\n                ways+= recur(words,target,i+1,j+1, dp); //Take case\\n                ways%=mod;\\n            }\\n        }\\n        \\n        ways+= recur(words,target,i+1,j,dp); //Not take case\\n        ways%= mod;\\n        \\n        return dp[i][j]= ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        return recur(words,target,0,0,dp);\\n    }\\n};\\n```\n```\\nfor(auto word: words) //O(N)\\n{\\n    if(target[j]== word[i])\\n    {\\n        ways+= recur(words,target,i+1,j+1);\\n        ways%=mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int mod= 1e9+7;\\n    \\n    int recur(vector<string>& words, string& target, int i, int j, vector<vector<int>> &dp, map<pair<char,int>, int>& charatidxfreq)\\n    {\\n        if(j== target.size()) return 1;\\n        \\n        if(i== words[0].size()) return 0; //Base cases\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        long long ways=0;\\n        \\n        if(charatidxfreq[{target[j],i}]!=0) // Now this operation becomes O(1)\\n        {\\n            ways+= recur(words,target,i+1,j+1,dp, charatidxfreq);\\n            ways%= mod;\\n            ways*= (charatidxfreq[{target[j],i}]%mod); //find ways and the multiply by frequency\\n            ways%= mod;\\n        }\\n        \\n        ways+= recur(words,target,i+1,j,dp, charatidxfreq);\\n        ways%= mod;\\n        \\n        return dp[i][j]= ways%mod;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        int n= words[0].size();\\n        int m= target.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        unordered_map<int, set<char>> idxTochar;\\n        \\n        map<pair<char,int>, int> charatidxfreq;\\n        \\n        for(auto word: words)\\n        {\\n            for(int i=0;i<word.size();i++)\\n            {   \\n                charatidxfreq[{word[i],i}]++;\\n            }\\n        }\\n        \\n        return recur(words,target,0,0, dp, charatidxfreq);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421400,
                "title": "bottom-up-dynamic-programming-go-c",
                "content": "\\n# Complexity\\n- Time complexity: $$O((n + m) * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc numWays(words []string, target string) int {\\n    alphabet := 26\\n    mod := 1000000007\\n    m := len(target)\\n    k := len(words[0])\\n    cnt := make([][]int, alphabet)\\n    for i := range cnt {\\n        cnt[i] = make([]int, k)\\n    }\\n    for j := 0; j < k; j++ {\\n        for _, word := range words {\\n            cnt[word[j]-\\'a\\'][j]++\\n        }\\n    }\\n    dp := make([][]int64, m+1)\\n    for i := range dp {\\n        dp[i] = make([]int64, k+1)\\n    }\\n    dp[0][0] = 1\\n    for i := 0; i <= m; i++ {\\n        for j := 0; j < k; j++ {\\n            if i < m {\\n                dp[i+1][j+1] += int64(cnt[target[i]-\\'a\\'][j]) * dp[i][j] % int64(mod)\\n                dp[i+1][j+1] %= int64(mod)\\n            }\\n            dp[i][j+1] += dp[i][j]\\n            dp[i][j+1] %= int64(mod)\\n        }\\n    }\\n    return int(dp[m][k])\\n}\\n\\n```\\nC#\\n```\\npublic class Solution {\\n    public int NumWays(string[] words, string target) {\\n        int alphabet = 26;\\n        int mod = 1000000007;\\n        int m = target.Length, k = words[0].Length;\\n        int[,] cnt = new int[alphabet, k];\\n        for (int j = 0; j < k; j++) {\\n            foreach (string word in words) {\\n                cnt[word[j] - \\'a\\', j]++;\\n            }\\n        }\\n        long[,] dp = new long[m + 1, k + 1];\\n        dp[0, 0] = 1;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j < k; j++) {\\n                if (i < m) {\\n                    dp[i + 1, j + 1] += cnt[target[i] - \\'a\\', j] * dp[i, j];\\n                    dp[i + 1, j + 1] %= mod;\\n                }\\n                dp[i, j + 1] += dp[i, j];\\n                dp[i, j + 1] %= mod;\\n            }\\n        }\\n        return (int)dp[m, k];\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc numWays(words []string, target string) int {\\n    alphabet := 26\\n    mod := 1000000007\\n    m := len(target)\\n    k := len(words[0])\\n    cnt := make([][]int, alphabet)\\n    for i := range cnt {\\n        cnt[i] = make([]int, k)\\n    }\\n    for j := 0; j < k; j++ {\\n        for _, word := range words {\\n            cnt[word[j]-\\'a\\'][j]++\\n        }\\n    }\\n    dp := make([][]int64, m+1)\\n    for i := range dp {\\n        dp[i] = make([]int64, k+1)\\n    }\\n    dp[0][0] = 1\\n    for i := 0; i <= m; i++ {\\n        for j := 0; j < k; j++ {\\n            if i < m {\\n                dp[i+1][j+1] += int64(cnt[target[i]-\\'a\\'][j]) * dp[i][j] % int64(mod)\\n                dp[i+1][j+1] %= int64(mod)\\n            }\\n            dp[i][j+1] += dp[i][j]\\n            dp[i][j+1] %= int64(mod)\\n        }\\n    }\\n    return int(dp[m][k])\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int NumWays(string[] words, string target) {\\n        int alphabet = 26;\\n        int mod = 1000000007;\\n        int m = target.Length, k = words[0].Length;\\n        int[,] cnt = new int[alphabet, k];\\n        for (int j = 0; j < k; j++) {\\n            foreach (string word in words) {\\n                cnt[word[j] - \\'a\\', j]++;\\n            }\\n        }\\n        long[,] dp = new long[m + 1, k + 1];\\n        dp[0, 0] = 1;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j < k; j++) {\\n                if (i < m) {\\n                    dp[i + 1, j + 1] += cnt[target[i] - \\'a\\', j] * dp[i, j];\\n                    dp[i + 1, j + 1] %= mod;\\n                }\\n                dp[i, j + 1] += dp[i, j];\\n                dp[i, j + 1] %= mod;\\n            }\\n        }\\n        return (int)dp[m, k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421410,
                "title": "easy-solution-of-java-python-c-dp",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int N = words.length;\\n        int W = words[0].length(); \\n        int T = target.length();\\n        int[][] freq = new int[W][26];\\n        for (int i = 0; i < W; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int let = words[j].charAt(i) - \\'a\\';\\n                freq[i][let]++;\\n            }\\n        }\\n        long[][] dp = new long[T + 1][W + 1];\\n        for (int i = 0; i <= W; i++) {\\n            dp[0][i] = 1;\\n        }\\n        // for (int i = 0; i <= T; i++) {\\n        //     dp[i][0] = 1;\\n        // }\\n        for (int i = 0; i < T; i++) {\\n            char tar = target.charAt(i);\\n            for (int j = 0; j < W; j++) {\\n                int num = freq[j][tar - \\'a\\'];\\n                dp[i + 1][j + 1] = (dp[i + 1][j] + (dp[i][j] * num) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return (int)dp[T][W];\\n    }\\n}\\n```\\nPYTHON\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        freq = [[0]*26 for i in range(W)]\\n        for i in range(W):\\n            for j in range(N):\\n                let = ord(words[j][i]) - ord(\\'a\\')\\n                freq[i][let] += 1\\n        dp = [[0]*(W+1) for i in range(T+1)]\\n        for i in range(W+1):\\n            dp[0][i] = 1\\n        for i in range(T):\\n            tar = ord(target[i]) - ord(\\'a\\')\\n            for j in range(W):\\n                num = freq[j][tar]\\n                dp[i+1][j+1] = (dp[i+1][j] + (dp[i][j]*num) % 1000000007) % 1000000007\\n        return int(dp[T][W])\\n\\n```\\nC++\\n```\\n\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int N = words.size();\\n        int W = words[0].size();\\n        int T = target.size();\\n        vector<vector<int>> freq(W, vector<int>(26, 0));\\n        for (int i = 0; i < W; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int let = words[j][i] - \\'a\\';\\n                freq[i][let] += 1;\\n            }\\n        }\\n        vector<vector<long long>> dp(T+1, vector<long long>(W+1, 0));\\n        for (int i = 0; i <= W; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < T; i++) {\\n            int tar = target[i] - \\'a\\';\\n            for (int j = 0; j < W; j++) {\\n                int num = freq[j][tar];\\n                dp[i+1][j+1] = (dp[i+1][j] + (dp[i][j]*num) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return (int)dp[T][W];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int N = words.length;\\n        int W = words[0].length(); \\n        int T = target.length();\\n        int[][] freq = new int[W][26];\\n        for (int i = 0; i < W; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int let = words[j].charAt(i) - \\'a\\';\\n                freq[i][let]++;\\n            }\\n        }\\n        long[][] dp = new long[T + 1][W + 1];\\n        for (int i = 0; i <= W; i++) {\\n            dp[0][i] = 1;\\n        }\\n        // for (int i = 0; i <= T; i++) {\\n        //     dp[i][0] = 1;\\n        // }\\n        for (int i = 0; i < T; i++) {\\n            char tar = target.charAt(i);\\n            for (int j = 0; j < W; j++) {\\n                int num = freq[j][tar - \\'a\\'];\\n                dp[i + 1][j + 1] = (dp[i + 1][j] + (dp[i][j] * num) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return (int)dp[T][W];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        freq = [[0]*26 for i in range(W)]\\n        for i in range(W):\\n            for j in range(N):\\n                let = ord(words[j][i]) - ord(\\'a\\')\\n                freq[i][let] += 1\\n        dp = [[0]*(W+1) for i in range(T+1)]\\n        for i in range(W+1):\\n            dp[0][i] = 1\\n        for i in range(T):\\n            tar = ord(target[i]) - ord(\\'a\\')\\n            for j in range(W):\\n                num = freq[j][tar]\\n                dp[i+1][j+1] = (dp[i+1][j] + (dp[i][j]*num) % 1000000007) % 1000000007\\n        return int(dp[T][W])\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int N = words.size();\\n        int W = words[0].size();\\n        int T = target.size();\\n        vector<vector<int>> freq(W, vector<int>(26, 0));\\n        for (int i = 0; i < W; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int let = words[j][i] - \\'a\\';\\n                freq[i][let] += 1;\\n            }\\n        }\\n        vector<vector<long long>> dp(T+1, vector<long long>(W+1, 0));\\n        for (int i = 0; i <= W; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < T; i++) {\\n            int tar = target[i] - \\'a\\';\\n            for (int j = 0; j < W; j++) {\\n                int num = freq[j][tar];\\n                dp[i+1][j+1] = (dp[i+1][j] + (dp[i][j]*num) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return (int)dp[T][W];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421613,
                "title": "python-top-down-2d-bu-1d-bu-dp",
                "content": "If you\\'ve done it this way, you\\'re almost there!\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        @cache\\n        def dfs(i, k):\\n            if i == T: # ran out of chars in target\\n                return 1 # 1 way\\n            if k == W: # ran out of chars in word[j]\\n                return 0\\n            \\n            ways = 0\\n            for j in range(N): # loop over words\\n                for x in range(k, W): # loop over chars in words\\n                    if words[j][x] == target[i]:\\n                        ways += dfs(i + 1, x + 1)\\n            return ways\\n         \\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        return dfs(0, 0) % (10 ** 9 + 7)\\n```\\nThis obviously will TLE.\\nWe need to replace N\\\\*W loop with something O(1) or O(logn).\\nInstead of Running N\\\\*W again and again we can precompute `char count @ pos in words` and then\\n`dfs(i + 1, k + 1) * char_count_@_pos`.\\n```\\nchar_pos_count = [[0] * W for _ in range(26)]\\nfor w in words:\\n    for pos,c in enumerate(w):\\n        char_pos_count[ord(c) - 97][pos] += 1\\n```\\nThis way we get O(1) for the same 2 loops.\\n\\n---\\nThere was a quesiton: *How does it work?*\\nAnswer:\\nAn example:\\ntarget:\\n`abc`\\ninput words:\\n1.`a...`\\n2.`a...`\\n3.`a...`\\n4.`a...`\\n...\\n100.`a...`\\n\\nNow imagine you need to calculate how many ways you can form `a` from input words.\\nIn brute force you will first find that you have target[0] = `a`. Next you need to find all `a` in the words. How will you do it? Loop over word[j][0] and count all found `a`s.\\nThis loop can be replaced with O(1) instead of O(#num_of_words) if we precalculate those `a` for each column in advance.\\n\\n---\\nSource code for Top-Down -> 2D BU -> 1D BU:\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        ### top-down\\n        @cache\\n        def dfs(i, k):\\n            if i == T:\\n                return 1\\n            if k == W:\\n                return 0\\n            \\n            char_idx = ord(target[i]) - 97\\n            ways = dfs(i, k + 1) # skip k-th idx in words\\n            if char_pos_count[char_idx][k]:\\n                ways += dfs(i + 1, k + 1) * char_pos_count[char_idx][k]\\n            return ways\\n         \\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        \\n        char_pos_count = [[0] * W for _ in range(26)]\\n        for w in words:\\n            for pos,c in enumerate(w):\\n                char_pos_count[ord(c) - 97][pos] += 1\\n        \\n        return dfs(0, 0) % (10 ** 9 + 7)\\n\\n        # bottom-up 2d\\n        # precomputation copy + paste from top-down\\n        dp = [[0] * (W + 1) for _ in range(T + 1)]\\n        dp[T][W] = 1\\n\\n        for k in reversed(range(W)):\\n            dp[T][k] = 1\\n            for i in reversed(range(T)):\\n                char_idx = ord(target[i]) - 97\\n                dp[i][k] = dp[i][k + 1] # skip k-th idx in words\\n                if char_pos_count[char_idx][k]:\\n                    dp[i][k] += dp[i + 1][k + 1] * char_pos_count[char_idx][k]\\n\\n        return dp[0][0] % (10 ** 9 + 7)\\n\\n        # bottom-up 1d\\n        # precomputation copy + paste from top-down\\n        dp = [0] * (T + 1)\\n        dp[T] = 1\\n\\n        for k in reversed(range(W)):\\n            for i in range(T):\\n                dp[i] += dp[i + 1] * char_pos_count[ord(target[i]) - 97][k]\\n\\n        return dp[0] % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        @cache\\n        def dfs(i, k):\\n            if i == T: # ran out of chars in target\\n                return 1 # 1 way\\n            if k == W: # ran out of chars in word[j]\\n                return 0\\n            \\n            ways = 0\\n            for j in range(N): # loop over words\\n                for x in range(k, W): # loop over chars in words\\n                    if words[j][x] == target[i]:\\n                        ways += dfs(i + 1, x + 1)\\n            return ways\\n         \\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        return dfs(0, 0) % (10 ** 9 + 7)\\n```\n```\\nchar_pos_count = [[0] * W for _ in range(26)]\\nfor w in words:\\n    for pos,c in enumerate(w):\\n        char_pos_count[ord(c) - 97][pos] += 1\\n```\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        ### top-down\\n        @cache\\n        def dfs(i, k):\\n            if i == T:\\n                return 1\\n            if k == W:\\n                return 0\\n            \\n            char_idx = ord(target[i]) - 97\\n            ways = dfs(i, k + 1) # skip k-th idx in words\\n            if char_pos_count[char_idx][k]:\\n                ways += dfs(i + 1, k + 1) * char_pos_count[char_idx][k]\\n            return ways\\n         \\n        N = len(words)\\n        W = len(words[0])\\n        T = len(target)\\n        \\n        char_pos_count = [[0] * W for _ in range(26)]\\n        for w in words:\\n            for pos,c in enumerate(w):\\n                char_pos_count[ord(c) - 97][pos] += 1\\n        \\n        return dfs(0, 0) % (10 ** 9 + 7)\\n\\n        # bottom-up 2d\\n        # precomputation copy + paste from top-down\\n        dp = [[0] * (W + 1) for _ in range(T + 1)]\\n        dp[T][W] = 1\\n\\n        for k in reversed(range(W)):\\n            dp[T][k] = 1\\n            for i in reversed(range(T)):\\n                char_idx = ord(target[i]) - 97\\n                dp[i][k] = dp[i][k + 1] # skip k-th idx in words\\n                if char_pos_count[char_idx][k]:\\n                    dp[i][k] += dp[i + 1][k + 1] * char_pos_count[char_idx][k]\\n\\n        return dp[0][0] % (10 ** 9 + 7)\\n\\n        # bottom-up 1d\\n        # precomputation copy + paste from top-down\\n        dp = [0] * (T + 1)\\n        dp[T] = 1\\n\\n        for k in reversed(range(W)):\\n            for i in range(T):\\n                dp[i] += dp[i + 1] * char_pos_count[ord(target[i]) - 97][k]\\n\\n        return dp[0] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421537,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int M = 1e9 + 7, n = words[0].size(), m = target.size();\\n        vector<vector<long long>> dp(n, vector<long long>(m, -1));\\n        vector<vector<long long>> cnt(n, vector<long long>(26));\\n        // count character frequency for each j-th column\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        function<int(int,int)> dfs = [&](int i, int j) {\\n            // reach end of target\\n            if (j == m) return 1;\\n            // reach end of words\\n            if (i == n) return 0;\\n            if (dp[i][j] != -1) return (int) dp[i][j];\\n            // skip i-th character\\n            int res = dfs(i + 1, j), c = target[j] - \\'a\\';\\n            if (cnt[i][c]) res = (res + cnt[i][c] * dfs(i + 1, j + 1)) % M;\\n            // memoize the result\\n            return (int) (dp[i][j] = res);\\n        };\\n        return dfs(0, 0);\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        M = 10 ** 9 + 7\\n        n, m = len(words[0]), len(target)\\n        cnt = [[0] * 26 for _ in range(n)]\\n        # count character frequency for each j-th column\\n        for i in range(len(words)):\\n            for j in range(n):\\n                cnt[j][ord(words[i][j]) - ord(\\'a\\')] += 1\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            # reach target\\n            if j == m:\\n                return 1\\n            # reach the end of the word\\n            if i == n:\\n                return 0\\n            # not take\\n            res = dfs(i + 1, j)\\n            # take\\n            c = ord(target[j]) - ord(\\'a\\')\\n            if cnt[i][c] > 0:\\n                res += cnt[i][c] * dfs(i + 1, j + 1)\\n            return res % M\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int M = 1e9 + 7, n = words[0].size(), m = target.size();\\n        vector<vector<long long>> dp(n, vector<long long>(m, -1));\\n        vector<vector<long long>> cnt(n, vector<long long>(26));\\n        // count character frequency for each j-th column\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        function<int(int,int)> dfs = [&](int i, int j) {\\n            // reach end of target\\n            if (j == m) return 1;\\n            // reach end of words\\n            if (i == n) return 0;\\n            if (dp[i][j] != -1) return (int) dp[i][j];\\n            // skip i-th character\\n            int res = dfs(i + 1, j), c = target[j] - \\'a\\';\\n            if (cnt[i][c]) res = (res + cnt[i][c] * dfs(i + 1, j + 1)) % M;\\n            // memoize the result\\n            return (int) (dp[i][j] = res);\\n        };\\n        return dfs(0, 0);\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        M = 10 ** 9 + 7\\n        n, m = len(words[0]), len(target)\\n        cnt = [[0] * 26 for _ in range(n)]\\n        # count character frequency for each j-th column\\n        for i in range(len(words)):\\n            for j in range(n):\\n                cnt[j][ord(words[i][j]) - ord(\\'a\\')] += 1\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            # reach target\\n            if j == m:\\n                return 1\\n            # reach the end of the word\\n            if i == n:\\n                return 0\\n            # not take\\n            res = dfs(i + 1, j)\\n            # take\\n            c = ord(target[j]) - ord(\\'a\\')\\n            if cnt[i][c] > 0:\\n                res += cnt[i][c] * dfs(i + 1, j + 1)\\n            return res % M\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421516,
                "title": "short-python-code-with-detailed-explanation-top-down-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        W = zip(*words)\\n        # Count the occurrences of characters in each word using Counter\\n        word_counts = [Counter(word) for word in W]\\n        \\n        # number of ways to form target from words starting at index i and j\\n        @cache\\n        def dp(i, j):\\n            # if i reaches to end of target, return 1 as valid\\n            # if j reaches to end of words[0], return 0 as no more characters can be made\\n            if i == len(target):\\n                return 1\\n            elif j == len(words[0]):\\n                return 0\\n            \\n            else:\\n                # number of ways to form the target without using current character in words[j]\\n                without_cur = dp(i, j + 1)\\n                \\n                # number of ways to form the target with using current character in words[j]\\n                with_cur = dp(i + 1, j + 1) * word_counts[j][target[i]]\\n                \\n                return (without_cur + with_cur) % int(1e9 + 7)\\n        \\n        return dp(0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        W = zip(*words)\\n        # Count the occurrences of characters in each word using Counter\\n        word_counts = [Counter(word) for word in W]\\n        \\n        # number of ways to form target from words starting at index i and j\\n        @cache\\n        def dp(i, j):\\n            # if i reaches to end of target, return 1 as valid\\n            # if j reaches to end of words[0], return 0 as no more characters can be made\\n            if i == len(target):\\n                return 1\\n            elif j == len(words[0]):\\n                return 0\\n            \\n            else:\\n                # number of ways to form the target without using current character in words[j]\\n                without_cur = dp(i, j + 1)\\n                \\n                # number of ways to form the target with using current character in words[j]\\n                with_cur = dp(i + 1, j + 1) * word_counts[j][target[i]]\\n                \\n                return (without_cur + with_cur) % int(1e9 + 7)\\n        \\n        return dp(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918233,
                "title": "python3-easy-top-down-dp",
                "content": "Maintain a ```counter``` for every column index. ```counter``` is number of times characters occur at column ```idx``` in input ```words```\\n\\n\\tself.counter = [collections.Counter() for _ in range(self.cols)] # a counter for every column\\n\\tfor word in words: #counter hash\\n\\t\\tfor idx, char in enumerate(word):\\n\\t\\t\\tself.counter[idx][char] += 1  # Count the number of character `char` at index `idx`\\n\\n\\nNext, the problem reduces to suffix dp. ```dp(i,j)``` is number of ways to create ```target[j:]``` using columns ```cols[i:]```. Final goal is is ```dp(0,0)```\\nTo get ```dp(i,j)```\\n1. Skip the column i and try to create ```target[j:]``` using ```cols[i+1:]``` -> ```dp (i+1,j)```\\n2. If target[j] exists in cols[i], just need to find target[j+1:] in cols[i+1:]; and multiply by number of times target[j] occurs in cols[i] -> ```dp (i+1,j+1) * counter[i][j]```\\n```dp(i,j) = dp(i+1,j)+dp(i+1,j+1)*counter[i][j]```\\n\\n\\n```\\nclass Solution:\\n    def dp(self,col, idxTarget):\\n        if (col, idxTarget) in self.memo:\\n            return self.memo[(col, idxTarget)]\\n        if idxTarget == self.lenTarget:  # Formed a valid target\\n            return 1\\n        if col == self.cols:  # Explored all columns but didnt create target\\n            return 0\\n        char = self.target[idxTarget]\\n        ans=0\\n        ans += self.dp(col + 1, idxTarget + 1) * self.counter[col][char] if self.counter[col][char] > 0 else 0 # If cound char at col, build rest of Target starting char+1 using remaining cols col+1\\n        ans += self.dp(col + 1, idxTarget)  # Skip col_th column and try to make Target using columns col + 1 to end\\n        ans %= self.MOD\\n        self.memo[(col, idxTarget)]=ans\\n        return ans\\n    def numWays(self, words: List[str], target: str) -> int:\\n        self.memo=dict()\\n        self.target=target\\n        self.MOD = 10 ** 9 + 7\\n        self.cols, self.lenTarget = len(words[0]), len(target)\\n        self.counter = [collections.Counter() for _ in range(self.cols)] # a counter for every column\\n        for word in words: #counter hash\\n            for idx, char in enumerate(word):\\n                self.counter[idx][char] += 1  # Count the number of character `char` at index `idx`\\n        return self.dp(0, 0)\\n```",
                "solutionTags": [],
                "code": "```counter```\n```counter```\n```idx```\n```words```\n```dp(i,j)```\n```target[j:]```\n```cols[i:]```\n```dp(0,0)```\n```dp(i,j)```\n```target[j:]```\n```cols[i+1:]```\n```dp (i+1,j)```\n```dp (i+1,j+1) * counter[i][j]```\n```dp(i,j) = dp(i+1,j)+dp(i+1,j+1)*counter[i][j]```\n```\\nclass Solution:\\n    def dp(self,col, idxTarget):\\n        if (col, idxTarget) in self.memo:\\n            return self.memo[(col, idxTarget)]\\n        if idxTarget == self.lenTarget:  # Formed a valid target\\n            return 1\\n        if col == self.cols:  # Explored all columns but didnt create target\\n            return 0\\n        char = self.target[idxTarget]\\n        ans=0\\n        ans += self.dp(col + 1, idxTarget + 1) * self.counter[col][char] if self.counter[col][char] > 0 else 0 # If cound char at col, build rest of Target starting char+1 using remaining cols col+1\\n        ans += self.dp(col + 1, idxTarget)  # Skip col_th column and try to make Target using columns col + 1 to end\\n        ans %= self.MOD\\n        self.memo[(col, idxTarget)]=ans\\n        return ans\\n    def numWays(self, words: List[str], target: str) -> int:\\n        self.memo=dict()\\n        self.target=target\\n        self.MOD = 10 ** 9 + 7\\n        self.cols, self.lenTarget = len(words[0]), len(target)\\n        self.counter = [collections.Counter() for _ in range(self.cols)] # a counter for every column\\n        for word in words: #counter hash\\n            for idx, char in enumerate(word):\\n                self.counter[idx][char] += 1  # Count the number of character `char` at index `idx`\\n        return self.dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422398,
                "title": "dp-solution-with-o-n-w-m-mem-and-o-n-w-time",
                "content": "A Sunday morning with a hard problem :(\\n# Intuition\\nminIndex: the minimum of index of word that can be chosen to form the target string\\n\\nFrom beginning to end of the target string, for each character, find its position in words that greater than minIndex and update minIndex\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI had to do this problem many times to pass all the test cases! This is my thinking process to solve the problem. You can skip this and go directly to the **Final Code** part to see the solution code.\\n\\nFirst, I wrote a function that has 3 parameters targetIndex, minIndex, wordsIndex (wordsIndex is the position of current word in words array). With each wordsIndex and targetIndex, we have 2 options: \\n- Don\\'t use words[wordsIndex] to form the target[targetIndex]\\n- Use if it includes target[targetIndex] and its index >= minIndex\\n\\n\\n# Complexity\\n- Time complexity: $$O(N*M*W)$$\\nN: target length\\nM: words length\\nW: word length\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n\\n  const dp = (targetIndex, wordsIndex, minIndex) => {\\n    if (targetIndex === targetLength) {\\n      return 1;\\n    }\\n    if (wordsIndex === wordsLength) return 0;\\n    let res = 0;\\n    res += dp(targetIndex, wordsIndex + 1, minIndex);\\n    for (let j = minIndex; j < wordLength; j++) {\\n      if (words[wordsIndex][j] === target[targetIndex]) {\\n        res += dp(targetIndex + 1, 0, j + 1);\\n      }\\n    }\\n    return res % (1e9 +7);\\n  }\\n\\n  return dp(0, 0, 0);\\n};\\n```\\n\\nOf course, it only pass 20/89 testcases. And I try to use cache mem[targetIndex][wordsIndex][minIndex] (3 dimensional array). But for the last testcases (pass 79/89 testcases), it\\'s out of memory (1000 * 1000 * 1000 = 10^9)\\n\\nSo I think, I can only use 2 dimensional array!!!\\nAnd it seems I don\\'t need to use wordsIndex, because I can use for loop for all words to find the target character!\\n\\n# Complexity\\n- Time complexity: $$O(N*M*W)$$\\n- Space complexity: $$O(N*W)$$\\nN: target length\\nM: words length\\nW: word length\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n  const mem = Array(targetLength).fill(0).map(() => Array(targetLength));\\n\\n  const dp = (targetIndex, minIndex) => {\\n    if (targetIndex === targetLength) return 1;\\n    if (wordLength - minIndex < targetLength - targetIndex) return 0;\\n    if (mem[targetIndex][minIndex] !== undefined) \\n      return mem[targetIndex][minIndex];\\n    mem[targetIndex][minIndex] = 0;\\n    for (let i = 0; i < wordsLength; i++) {\\n      for (let j = minIndex; j < wordLength; j++) {\\n        if (\\n          words[i][j] === target[targetIndex] \\n          && wordLength - j >= targetLength - targetIndex\\n        ) {\\n          mem[targetIndex][minIndex] += dp(targetIndex + 1, j + 1);\\n        }\\n      }\\n    }\\n    mem[targetIndex][minIndex] %= (1e9 + 7);\\n    return mem[targetIndex][minIndex];\\n  }\\n\\n  return dp(0, 0);\\n};\\n```\\nI was very confident that this way would pass the test cases. But, it\\'s not. It just passed 1 more testcase than the previous way. You see,  this way has the same time complexity.\\n\\nI finally realized that I don\\'t need to know which word is chosen to form the target character, I just need to know their index and update the minIndex value.\\nSo I count all characters (a-z) that grouped by index and save it into an array $$count$$. For example: \\nwords = [\"acca\",\"bbbb\",\"caca\"]\\n=> Character \"a\": index 0 = 1, index 1 = 1, index 3 = 2\\n   Character \"b\": index 0 = 1, index 1 = 1, index 2 = 1, index 3 = 1\\n   Character \"c\": index 0 = 1, index 1 = 1, index 2 = 2\\n\\n# Complexity\\n- Time complexity: $$O(N*W)$$\\n- Space complexity: $$O(N*W+M)$$\\nN: target length\\nM: words length\\nW: word length\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Final Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n  const mem = Array(targetLength).fill(0).map(() => Array(targetLength));\\n\\n  const count = Array(26).fill(0).map(() => ({}));\\n  for (let i = 0; i < wordsLength; i++) {\\n    for (let j = 0; j < wordLength; j++) {\\n      if (!count[words[i].charCodeAt(j) - 97][j]) {\\n        count[words[i].charCodeAt(j) - 97][j] = 0;\\n      }\\n      count[words[i].charCodeAt(j) - 97][j]++;\\n    }\\n  }\\n\\n  const dp = (targetIndex, minIndex) => {\\n    if (targetIndex === targetLength) {\\n      return 1;\\n    }\\n    if (wordLength - minIndex < targetLength - targetIndex) return 0;\\n    if (mem[targetIndex][minIndex] !== undefined) \\n      return mem[targetIndex][minIndex];\\n    let res = 0;\\n    \\n    for (let i = minIndex; i < wordLength; i++) {\\n      if (count[target.charCodeAt(targetIndex) - 97][i]) {\\n        res += Number(count[target.charCodeAt(targetIndex) - 97][i])\\n          * dp(targetIndex + 1, i + 1);\\n      }\\n    }\\n\\n    res %= (1e9 + 7);\\n    mem[targetIndex][minIndex] = res;\\n    return res;\\n  }\\n\\n  return dp(0, 0);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n\\n  const dp = (targetIndex, wordsIndex, minIndex) => {\\n    if (targetIndex === targetLength) {\\n      return 1;\\n    }\\n    if (wordsIndex === wordsLength) return 0;\\n    let res = 0;\\n    res += dp(targetIndex, wordsIndex + 1, minIndex);\\n    for (let j = minIndex; j < wordLength; j++) {\\n      if (words[wordsIndex][j] === target[targetIndex]) {\\n        res += dp(targetIndex + 1, 0, j + 1);\\n      }\\n    }\\n    return res % (1e9 +7);\\n  }\\n\\n  return dp(0, 0, 0);\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n  const mem = Array(targetLength).fill(0).map(() => Array(targetLength));\\n\\n  const dp = (targetIndex, minIndex) => {\\n    if (targetIndex === targetLength) return 1;\\n    if (wordLength - minIndex < targetLength - targetIndex) return 0;\\n    if (mem[targetIndex][minIndex] !== undefined) \\n      return mem[targetIndex][minIndex];\\n    mem[targetIndex][minIndex] = 0;\\n    for (let i = 0; i < wordsLength; i++) {\\n      for (let j = minIndex; j < wordLength; j++) {\\n        if (\\n          words[i][j] === target[targetIndex] \\n          && wordLength - j >= targetLength - targetIndex\\n        ) {\\n          mem[targetIndex][minIndex] += dp(targetIndex + 1, j + 1);\\n        }\\n      }\\n    }\\n    mem[targetIndex][minIndex] %= (1e9 + 7);\\n    return mem[targetIndex][minIndex];\\n  }\\n\\n  return dp(0, 0);\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  const targetLength = target.length;\\n  const wordsLength = words.length;\\n  const wordLength = words[0].length;\\n  const mem = Array(targetLength).fill(0).map(() => Array(targetLength));\\n\\n  const count = Array(26).fill(0).map(() => ({}));\\n  for (let i = 0; i < wordsLength; i++) {\\n    for (let j = 0; j < wordLength; j++) {\\n      if (!count[words[i].charCodeAt(j) - 97][j]) {\\n        count[words[i].charCodeAt(j) - 97][j] = 0;\\n      }\\n      count[words[i].charCodeAt(j) - 97][j]++;\\n    }\\n  }\\n\\n  const dp = (targetIndex, minIndex) => {\\n    if (targetIndex === targetLength) {\\n      return 1;\\n    }\\n    if (wordLength - minIndex < targetLength - targetIndex) return 0;\\n    if (mem[targetIndex][minIndex] !== undefined) \\n      return mem[targetIndex][minIndex];\\n    let res = 0;\\n    \\n    for (let i = minIndex; i < wordLength; i++) {\\n      if (count[target.charCodeAt(targetIndex) - 97][i]) {\\n        res += Number(count[target.charCodeAt(targetIndex) - 97][i])\\n          * dp(targetIndex + 1, i + 1);\\n      }\\n    }\\n\\n    res %= (1e9 + 7);\\n    mem[targetIndex][minIndex] = res;\\n    return res;\\n  }\\n\\n  return dp(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421979,
                "title": "c-recursive-memoized-dp-clean-code-great-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt was pretty obvious that it was a dynamic programming problem, as we needed to `find the ways to do something`. So I came up with a recursive-memoized DP solution.\\n\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we use the i<sup>th</sup> character of any string in `words`, we cannot use any other character less than or equal to it again. So, we need to iterate over these characters in order to find answer.\\n\\nTo do calculate the ways efficiently, we pre-calculate the frequency of each character at each index of the strings.\\n\\nNow, our problem becomes relatively easier. We need to find the ways to make `target`, we have a list of frequencies of each character at each position. This can be done by DP easily.\\n\\n**DP state:** \\n> `dp[posWord][posTarget]`\\nThis denotes that answer for strings in `words` with characters at index `j` i.e. j<sup>th</sup> column in `words`, where `j >= posWord` and target is `target[posTarget : ]`\\n\\n**DP Transition:**\\n> Option 1: `target[posTarget]` exists in `posWord`th column of words. Here we will find answer for `posWord + 1` and `posTarget + 1` and multiply it by current frequency of `target[posTarget]` in `posWord`th column of words.\\n>> `dp[posWord][posTarget] = freq[posWord][posTarget] * dp[posWord + 1][posTarget + 1]`\\n\\n> Option 2: Skip the `posWord` column and try to form `target[posTarget : ]` from `columns[posWord : ]`\\n>> `dp[posWord][posTarget] = dp[posWord + 1][posTarget]`\\n\\n**Base Case:**\\n> When we reach the end of `target`, we simply return 1\\n> When we reach the end of columns, we cannot make target, so we return 0\\n\\nOur required answer will be stored in `dp[0][0]`\\n\\nUpvotes and feedback are appreciated :)\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(s * t)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere `s` is length of the string in `words` and `t` is length of `target`.\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# Code\\n```\\nconst int mod = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int nt = (int) target.size();\\n        int ns = (int) words[0].size();\\n\\n        vector<vector<int>> f(ns, vector<int>(26, 0));\\n        for (auto s : words) {\\n            for (int i = 0; i < ns; i++)\\n                f[i][s[i] - \\'a\\']++;\\n        }\\n\\n        vector<vector<long long>> dp(ns, vector<long long>(nt, -1));\\n\\n        function<long long(int, int)> helper = [&] (int posWord, int posTarget) {\\n            if (posTarget == nt) return 1ll;\\n            if (posWord == ns) return 0ll;\\n            if (dp[posWord][posTarget] != -1) return dp[posWord][posTarget];\\n            \\n            int p = target[posTarget] - \\'a\\';\\n            long long res = 0;\\n            \\n            // take (posTarget)th character from (posWord)th character of strings in words\\n            res += (f[posWord][p] * helper(posWord + 1, posTarget + 1));\\n            res %= mod;\\n\\n            // not take any character from (posWord)th character of strings in words\\n            res += (helper(posWord + 1, posTarget));\\n            res %= mod;\\n\\n            dp[posWord][posTarget] = res % mod;\\n            return res;\\n        };\\n\\n        return (int) helper(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nconst int mod = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int nt = (int) target.size();\\n        int ns = (int) words[0].size();\\n\\n        vector<vector<int>> f(ns, vector<int>(26, 0));\\n        for (auto s : words) {\\n            for (int i = 0; i < ns; i++)\\n                f[i][s[i] - \\'a\\']++;\\n        }\\n\\n        vector<vector<long long>> dp(ns, vector<long long>(nt, -1));\\n\\n        function<long long(int, int)> helper = [&] (int posWord, int posTarget) {\\n            if (posTarget == nt) return 1ll;\\n            if (posWord == ns) return 0ll;\\n            if (dp[posWord][posTarget] != -1) return dp[posWord][posTarget];\\n            \\n            int p = target[posTarget] - \\'a\\';\\n            long long res = 0;\\n            \\n            // take (posTarget)th character from (posWord)th character of strings in words\\n            res += (f[posWord][p] * helper(posWord + 1, posTarget + 1));\\n            res %= mod;\\n\\n            // not take any character from (posWord)th character of strings in words\\n            res += (helper(posWord + 1, posTarget));\\n            res %= mod;\\n\\n            dp[posWord][posTarget] = res % mod;\\n            return res;\\n        };\\n\\n        return (int) helper(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423465,
                "title": "c-dp-recursive-memoization",
                "content": "# Intuition \\nThe idea is to use dynamic programming to calculate the number of ways to form the target string using the frequency of each character in each column of the matrix.\\n# Approach \\nCalculate the frequency of each character in each column of the matrix using a 2D frequency array, then we\\'ll pass the starting index of target srtring and index of column.\\nThen the conditions for base cases - \\n1. if index of string is greater than string size means the whole target string is finished and we got our solution (return 1 means we got our solution).\\n2. if column index is more than column size means we are out of reach return 0 in this case.\\n\\nNow we\\'ll calculate our answer as \\n1. we are taking the frequency of target string\\'s char\\n2. and we are not taking the frequency then we will not move our target string\\'s index\\n\\nIn this recursive solution the target string\\'s and column\\'s index are changing (only these two) we\\'ll memoize accordingly\\n\\n\\n![photo_2023-04-16_17-50-14.jpg](https://assets.leetcode.com/users/images/99b091e9-e483-4dc7-a3fd-4a8408fea6e9_1681647626.5430667.jpeg)\\n\\n# Complexity\\n- Time complexity: **O(n*m)**\\n- Here n is target string size & m is word\\'s column size.\\n# Code\\n```\\nclass Solution {\\n    long long mod=1e9+7;\\npublic:\\n    int c(vector<string>&w, string &s,int i,int j,vector<vector<int>>&dp,vector<vector<int>>&pre){\\n        if(i>=s.size())return 1;\\n        if(j>=w[0].size())return 0;\\n        int ans=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int t=0;\\n        t=pre[j][s[i]-\\'a\\'];\\n        ans = (c(w,s,i,j+1,dp,pre)%mod + ((t%mod)*(c(w,s,i+1,j+1,dp,pre)%mod))%mod)%mod;\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int numWays(vector<string>& w, string s) {\\n        int n=s.size(),m=w[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        vector<vector<int>>pre(m,vector<int>(26,0));\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<w.size();i++){\\n                pre[j][w[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return c(w,s,0,0,dp,pre);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/47d8d7d0-a30c-49dc-8097-59c9d115a075_1681646863.1812792.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long mod=1e9+7;\\npublic:\\n    int c(vector<string>&w, string &s,int i,int j,vector<vector<int>>&dp,vector<vector<int>>&pre){\\n        if(i>=s.size())return 1;\\n        if(j>=w[0].size())return 0;\\n        int ans=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int t=0;\\n        t=pre[j][s[i]-\\'a\\'];\\n        ans = (c(w,s,i,j+1,dp,pre)%mod + ((t%mod)*(c(w,s,i+1,j+1,dp,pre)%mod))%mod)%mod;\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int numWays(vector<string>& w, string s) {\\n        int n=s.size(),m=w[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        vector<vector<int>>pre(m,vector<int>(26,0));\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<w.size();i++){\\n                pre[j][w[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return c(w,s,0,0,dp,pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917823,
                "title": "java-bottom-up-dp-80",
                "content": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        //strategy: Bottom Up DP\\n        long mod = 1000000007;\\n        long[] dp = new long[target.length()];\\n        //first for loop deals with the current letter in words\\n        for (int i = 0; i < words[0].length(); i++) {\\n            //set up frequency array to keep track of the frequence at the ith position\\n            int[] frequency = new int[26];\\n            //update the letter frequency \\n            for (int j = 0; j < words.length; j++) {\\n                frequency[words[j].charAt(i) - \\'a\\']++;\\n            }\\n            //start from back so previous calculated won\\'t affect current\\n            //third for loop deals with the current position in target\\n            for (int j = Math.min(i, target.length() - 1); j >= 0; j--) {\\n                //see if have any letters that correspond with the jth position in target\\n                if (frequency[target.charAt(j) - \\'a\\'] > 0) {\\n                    //two possibilities: \\n                    //first position will always just be the frequency because there is no previous to work with since it would be out of bounds\\n                    //other positions is a combination of previous jth position in target and current frequency\\n                    dp[j] += (j == 0) ? frequency[target.charAt(j) - \\'a\\'] : dp[j - 1] * frequency[target.charAt(j) - \\'a\\'];\\n                    dp[j] %= mod;\\n                }\\n            }\\n        }\\n        return (int) dp[target.length() - 1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numWays(String[] words, String target) {\\n        //strategy: Bottom Up DP\\n        long mod = 1000000007;\\n        long[] dp = new long[target.length()];\\n        //first for loop deals with the current letter in words\\n        for (int i = 0; i < words[0].length(); i++) {\\n            //set up frequency array to keep track of the frequence at the ith position\\n            int[] frequency = new int[26];\\n            //update the letter frequency \\n            for (int j = 0; j < words.length; j++) {\\n                frequency[words[j].charAt(i) - \\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 917739,
                "title": "java-recursion-with-memo",
                "content": "The idea is to build the counts array, which will show how many of each character we have on each position in our vocabulary.\\nWhen we have it, go recursively through all positions in the target word and check how many ways we have to get the needed character from the vocabulary.\\n\\n1. Build counts array, where `counts[i][c] ` shows how many characters `c` are at position `i` in the vocabulary words.\\n2. Go to first character in target word (i=0): \\n\\ta. See how many words give us it as a first character(j=0), then recursively go to the second character(i=1) in target work and do the same(j=1), etc.\\n\\tb. Add the number of ways when we skip the current character from words and go to the next one(j=1, i=0 still) - like in example (t=`cac`, w=`[caaac]`) we can replace `a` in target with `a` from the vocabulary word on position `1`, or we can skip it and try to replace it with `a` on position `2`, or then `3`.\\n\\n```java\\nclass Solution {\\n    static int MOD = 1_000_000_000 + 7;\\n    Integer[][] memo;\\n    long[][] counts;\\n    int maxLength = 0;\\n    public int numWays(String[] w, String target) {\\n        counts = new long[1000][26];\\n        // build the counts array\\n\\t\\t// it shows how many same characters we have on each position among all words\\n        for (String q : w) {\\n            maxLength = Math.max(maxLength, q.length());\\n            for (int i = 0; i < q.length(); i++) {\\n                counts[i][q.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        memo = new Integer[maxLength][target.length()];\\n        return f(target, 0, 0);\\n    }\\n    \\n    int f(String target, int j, int i) {\\n\\t    // we built the word\\n        if (i == target.length()) return 1;\\n\\t\\t// we reached the end of all words, but haven\\'t built the word\\n        if (j == maxLength) return 0;\\n        if (memo[j][i] != null) return memo[j][i];\\n        int f = target.charAt(i) -  \\'a\\';\\n        int res = 0;\\n        // no need to enter the recursion otherwise\\n        if (counts[j][f] > 0) {\\n            // substitute the character in i position from j position in words\\n\\t\\t\\t// we can choose it from counts[j][f] words, it would be different solutions, so we multiply\\n            res = (int) ((counts[j][f] * f(target, j + 1, i + 1)) % MOD);\\n        }\\n        // do not substitute character in i position from j position in words\\n        res += f(target, j + 1, i);\\n        res %= MOD;\\n        \\n        return memo[j][i] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    static int MOD = 1_000_000_000 + 7;\\n    Integer[][] memo;\\n    long[][] counts;\\n    int maxLength = 0;\\n    public int numWays(String[] w, String target) {\\n        counts = new long[1000][26];\\n        // build the counts array\\n\\t\\t// it shows how many same characters we have on each position among all words\\n        for (String q : w) {\\n            maxLength = Math.max(maxLength, q.length());\\n            for (int i = 0; i < q.length(); i++) {\\n                counts[i][q.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        memo = new Integer[maxLength][target.length()];\\n        return f(target, 0, 0);\\n    }\\n    \\n    int f(String target, int j, int i) {\\n\\t    // we built the word\\n        if (i == target.length()) return 1;\\n\\t\\t// we reached the end of all words, but haven\\'t built the word\\n        if (j == maxLength) return 0;\\n        if (memo[j][i] != null) return memo[j][i];\\n        int f = target.charAt(i) -  \\'a\\';\\n        int res = 0;\\n        // no need to enter the recursion otherwise\\n        if (counts[j][f] > 0) {\\n            // substitute the character in i position from j position in words\\n\\t\\t\\t// we can choose it from counts[j][f] words, it would be different solutions, so we multiply\\n            res = (int) ((counts[j][f] * f(target, j + 1, i + 1)) % MOD);\\n        }\\n        // do not substitute character in i position from j position in words\\n        res += f(target, j + 1, i);\\n        res %= MOD;\\n        \\n        return memo[j][i] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422219,
                "title": "ruby-3-liner",
                "content": "```\\ndef num_ways(words, target) =\\n\\n  words.map(&:chars).transpose.map(&:tally).then &ways = -> a,i=0,j=0,m=[]{\\n    target[a.size-j+i] ? 0 : !target[i] ? 1 : m[i*a.size+j] ||=\\n    (ways[a,i,j+1,m] + a[j][target[i]].to_i * ways[a,i+1,j+1,m]) % 1000000007 }\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_ways(words, target) =\\n\\n  words.map(&:chars).transpose.map(&:tally).then &ways = -> a,i=0,j=0,m=[]{\\n    target[a.size-j+i] ? 0 : !target[i] ? 1 : m[i*a.size+j] ||=\\n    (ways[a,i,j+1,m] + a[j][target[i]].to_i * ways[a,i+1,j+1,m]) % 1000000007 }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2108454,
                "title": "python-top-down-with-memoization-o-m-n",
                "content": "dfs(i,j): the number ways to make target[j:] using word in words from index i\\n```\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        M = 10**9 + 7\\n        dt = defaultdict(int)\\n        m, n = len(words[-1]), len(target)\\n        for word in words:\\n            for i, c in enumerate(word):\\n                dt[i,c] += 1\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if j == n: return 1\\n            if i == m: return 0\\n            res = 0\\n            if dt[i,target[j]]:\\n                res = (res + dt[i,target[j]]*dfs(i+1,j+1))%M\\n            res = (res + dfs(i+1,j))%M\\n            return res\\n        return dfs(0,0)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "dfs(i,j): the number ways to make target[j:] using word in words from index i\\n```\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        M = 10**9 + 7\\n        dt = defaultdict(int)\\n        m, n = len(words[-1]), len(target)\\n        for word in words:\\n            for i, c in enumerate(word):\\n                dt[i,c] += 1\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if j == n: return 1\\n            if i == m: return 0\\n            res = 0\\n            if dt[i,target[j]]:\\n                res = (res + dt[i,target[j]]*dfs(i+1,j+1))%M\\n            res = (res + dfs(i+1,j))%M\\n            return res\\n        return dfs(0,0)",
                "codeTag": "Java"
            },
            {
                "id": 1355590,
                "title": "c-simple-bottom-up-dp",
                "content": "I was unable to find any bottom up DP solution with a simple recurrence relation in the discussion section, so here it is.\\n```\\n    int numWays(vector<string>& words, string target) {\\n        int n = words.size();\\n        int m = words[0].length();\\n        int t = target.size();\\n        \\n        int M = 1000000007;\\n\\n        vector<vector<int>> freq(m, vector<int>(26, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                freq[j][words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(t, vector<int>(m, 0));\\n        \\n        // bottom-up\\n        for (int i = 0; i < t; i++) {  \\n            char c = target[i]-\\'a\\';\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0)\\n                    dp[i][j] = freq[i][c];\\n                else if (i == 0)\\n                    dp[i][j] = dp[i][j-1] + freq[j][c];\\n                else if (j == 0)\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = (dp[i][j-1] + (long long)dp[i-1][j-1]*freq[j][c])%M;\\n            }\\n        }\\n        \\n        return dp[t-1][m-1];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "I was unable to find any bottom up DP solution with a simple recurrence relation in the discussion section, so here it is.\\n```\\n    int numWays(vector<string>& words, string target) {\\n        int n = words.size();\\n        int m = words[0].length();\\n        int t = target.size();\\n        \\n        int M = 1000000007;\\n\\n        vector<vector<int>> freq(m, vector<int>(26, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                freq[j][words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(t, vector<int>(m, 0));\\n        \\n        // bottom-up\\n        for (int i = 0; i < t; i++) {  \\n            char c = target[i]-\\'a\\';\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0)\\n                    dp[i][j] = freq[i][c];\\n                else if (i == 0)\\n                    dp[i][j] = dp[i][j-1] + freq[j][c];\\n                else if (j == 0)\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = (dp[i][j-1] + (long long)dp[i-1][j-1]*freq[j][c])%M;\\n            }\\n        }\\n        \\n        return dp[t-1][m-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 918050,
                "title": "java-solution",
                "content": "# Non Optimized solution 1:\\nStart from target index 0, and word index 0\\n- Check every word that has a matching character \\n- if matching found, in the remaining target and words length, find the found and add them and return\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n            if(target.length() == 0) return 0;\\n        return ways(words, target, 0, 0);\\n    }\\n    \\n    int ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index == target.length()) return 1;\\n        int remaining = target.length() - t_index-1;\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            for(int j=w_index; j<word.length()-remaining; j++){\\n                if(word.charAt(j) == target.charAt(t_index)){\\n\\t\\t\\t\\t\\t// match found, find the match of remaining and count them all together\\n                    count += ways(words, target, t_index + 1, j+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\\n\\n# Slightly Optimized Solution 2:\\nThe above solution can be optimized by remembering the counts once they are calculated in a map or a matrix.\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n            if(target.length() == 0) return 0;\\n        m = new Long[target.length()][words[0].length() ]; \\n        return (int) ways(words, target, 0, 0);\\n    }\\n    \\n    Long[][] m ;\\n    long ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index >= target.length()) return 1;\\n        if(w_index >= words[0].length() ) return 0;\\n        if(words[0].length() - w_index < target.length()-t_index) return 0;\\n        \\n        if(m[t_index][w_index] != null) return m[t_index][w_index];\\n        \\n        int remaining = target.length() - t_index-1;\\n        long count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            for(int j=w_index; j<word.length()-remaining; j++){\\n                if(word.charAt(j) == target.charAt(t_index)){\\n                    count += ways(words, target, t_index + 1, j+1);\\n                }\\n            }\\n        }\\n        m[t_index][w_index] = count%1000000007;\\n        return m[t_index][w_index];\\n    }\\n    \\n}\\n```\\nThe solution can be further optimized if we just focus on current character of words in the for loop.\\nFor other combinations, we can simply try to find them once the first for loop exits.\\n# Acceptable Optimized Solution 3:\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        if(target.length() == 0) return 0;\\n        m = new Long[target.length()][words[0].length() ]; \\n        return (int) ways(words, target, 0, 0);\\n    }\\n    \\n    Long[][] m ;\\n    long ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index >= target.length()) return 1;\\n        if(w_index >= words[0].length() ) return 0;\\n        if(words[0].length() - w_index < target.length()-t_index) return 0;\\n        \\n        if(m[t_index][w_index] != null) return m[t_index][w_index];\\n        \\n        int remaining = target.length() - t_index-1;\\n        long count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            if(word.charAt(w_index) == target.charAt(t_index)){\\n                count += ways(words, target, t_index + 1, w_index+1);\\n            }\\n        }\\n        // instead of doing it in the for loop, find it separately\\n        count += ways(words, target, t_index, w_index + 1);\\n        m[t_index][w_index] = count%1000000007;\\n        return m[t_index][w_index];\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n            if(target.length() == 0) return 0;\\n        return ways(words, target, 0, 0);\\n    }\\n    \\n    int ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index == target.length()) return 1;\\n        int remaining = target.length() - t_index-1;\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            for(int j=w_index; j<word.length()-remaining; j++){\\n                if(word.charAt(j) == target.charAt(t_index)){\\n\\t\\t\\t\\t\\t// match found, find the match of remaining and count them all together\\n                    count += ways(words, target, t_index + 1, j+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n            if(target.length() == 0) return 0;\\n        m = new Long[target.length()][words[0].length() ]; \\n        return (int) ways(words, target, 0, 0);\\n    }\\n    \\n    Long[][] m ;\\n    long ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index >= target.length()) return 1;\\n        if(w_index >= words[0].length() ) return 0;\\n        if(words[0].length() - w_index < target.length()-t_index) return 0;\\n        \\n        if(m[t_index][w_index] != null) return m[t_index][w_index];\\n        \\n        int remaining = target.length() - t_index-1;\\n        long count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            for(int j=w_index; j<word.length()-remaining; j++){\\n                if(word.charAt(j) == target.charAt(t_index)){\\n                    count += ways(words, target, t_index + 1, j+1);\\n                }\\n            }\\n        }\\n        m[t_index][w_index] = count%1000000007;\\n        return m[t_index][w_index];\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        if(target.length() == 0) return 0;\\n        m = new Long[target.length()][words[0].length() ]; \\n        return (int) ways(words, target, 0, 0);\\n    }\\n    \\n    Long[][] m ;\\n    long ways(String[] words, String target, int t_index, int w_index){\\n        if(t_index >= target.length()) return 1;\\n        if(w_index >= words[0].length() ) return 0;\\n        if(words[0].length() - w_index < target.length()-t_index) return 0;\\n        \\n        if(m[t_index][w_index] != null) return m[t_index][w_index];\\n        \\n        int remaining = target.length() - t_index-1;\\n        long count = 0;\\n        for(int i=0; i<words.length; i++){\\n            String word = words[i];\\n            if(word.charAt(w_index) == target.charAt(t_index)){\\n                count += ways(words, target, t_index + 1, w_index+1);\\n            }\\n        }\\n        // instead of doing it in the for loop, find it separately\\n        count += ways(words, target, t_index, w_index + 1);\\n        m[t_index][w_index] = count%1000000007;\\n        return m[t_index][w_index];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433760,
                "title": "java-dp-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(k*(m+n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int m, n;\\n  int[][] freq;\\n  Map<Pair<Integer, Integer>, Long> dp = new HashMap<>();\\n\\n  public long numWays(String target, int i, int k) {\\n    if (i == n) return 1;\\n    if (m-k < n-i) return 0;\\n\\n    var key = new Pair(i, k);\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n    var cnt = 0L;\\n    for (var j=k; j<m; j++) {\\n      cnt += freq[j][target.charAt(i) - \\'a\\'] * numWays(target, i+1, j+1);\\n      cnt %= 1000000007;\\n    }\\n    dp.put(key, cnt);\\n    return cnt;\\n  }\\n\\n  public int numWays(String[] words, String target) {\\n    m = words[0].length();\\n    n = target.length();\\n    freq = new int[m][26];\\n\\n    for (var word : words)\\n      for (var i=0; i<m; i++)\\n        freq[i][word.charAt(i) - \\'a\\']++;\\n\\n    return (int) numWays(target, 0, 0);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  int m, n;\\n  int[][] freq;\\n  Map<Pair<Integer, Integer>, Long> dp = new HashMap<>();\\n\\n  public long numWays(String target, int i, int k) {\\n    if (i == n) return 1;\\n    if (m-k < n-i) return 0;\\n\\n    var key = new Pair(i, k);\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n    var cnt = 0L;\\n    for (var j=k; j<m; j++) {\\n      cnt += freq[j][target.charAt(i) - \\'a\\'] * numWays(target, i+1, j+1);\\n      cnt %= 1000000007;\\n    }\\n    dp.put(key, cnt);\\n    return cnt;\\n  }\\n\\n  public int numWays(String[] words, String target) {\\n    m = words[0].length();\\n    n = target.length();\\n    freq = new int[m][26];\\n\\n    for (var word : words)\\n      for (var i=0; i<m; i++)\\n        freq[i][word.charAt(i) - \\'a\\']++;\\n\\n    return (int) numWays(target, 0, 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424213,
                "title": "just-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words, target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            }  \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words, target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            }  \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424175,
                "title": "python-3-7-lines-using-transpose-of-target-t-m-84-79",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n  \\n        m, n = len(words[0]),len(target)\\n        ans = [1]+ [0]*n\\n        words = list(map(Counter,zip(*map(list,words))))\\n\\n        for word in words:\\n            for i in reversed(range(n)):\\n                ans[i+1] += ans[i] * word[target[i]] %1000000007\\n\\n        return ans[n] %1000000007\\n\\n```\\n[https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/submissions/934810558/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n  \\n        m, n = len(words[0]),len(target)\\n        ans = [1]+ [0]*n\\n        words = list(map(Counter,zip(*map(list,words))))\\n\\n        for word in words:\\n            for i in reversed(range(n)):\\n                ans[i+1] += ans[i] * word[target[i]] %1000000007\\n\\n        return ans[n] %1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423907,
                "title": "java-memoization-tabulation-pre-computing-with-comments",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(w * k) + O(l * k ) where* :\\nw - numbers of words\\nk - length of the target\\nl - length of each word in words\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int n;\\n    private int l;\\n    private int m;\\n    private String t;\\n    private static Long[][] dp;\\n    private static int[][] cnt;\\n    private int MOD = (int)1e9 + 7;\\n\\n\\n    public long dfs(int i,int k)\\n    {   \\n        // if our target string get exhausted then we managed to form a string\\n        if(k == m)\\n          return 1;\\n     //if our word gets exhausted first it means it is not possible\\n        if(i == l)\\n          return 0;\\n     \\n//already cached return the respective value\\n        if(dp[i][k] != null)\\n        {\\n            return dp[i][k];\\n        }  \\n  \\n//here we have two choices ,either to include the current character or\\n//not include\\n\\n//if not included , we simply move forward to the next charcter\\n        dp[i][k] = dfs(i + 1,k);\\n \\n        int c = t.charAt(k);\\n //cnt[i][c-\\'a\\'] != 0 represents there is an option to take this \\n//character,we multiply it with cnt[i][c-\\'a\\'] \\n//inorder not to duplicate work for the same character with the same parameters among multiple words. \\n        if(cnt[i][c - \\'a\\'] != 0)\\n        { \\n       \\n          dp[i][k] +=  (cnt[i][c - \\'a\\']) * dfs(i + 1,k + 1);\\n          dp[i][k] %= MOD;\\n        }\\n\\n         return dp[i][k];\\n        \\n    }\\n    public int numWays(String[] words, String target) {\\n         \\n          t = target;\\n          n = words.length;\\n          l = words[0].length();\\n          m = target.length();\\n          dp = new Long[l][m];\\n          \\n       //cnt is used to store the occurence of a character at that particular index among all words\\n          cnt = new int[l][26];\\n\\n          for(int i = 0;i < l;i++)\\n          {\\n              for(int j = 0;j < n;j++)\\n              {\\n                  cnt[i][words[j].charAt(i) - \\'a\\'] += 1;\\n              }\\n          }\\n\\n\\n          return (int)dfs(0,0);\\n    }\\n}\\n```\\n# tabulation\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n           int n = words.length, m = words[0].length();\\n        int[][] cnt = new int[m][26];\\n        long[][] dp = new long[m + 1][target.length() + 1];\\n        \\n        int T = target.length(),MOD = (int)1e9 + 7;\\n        \\n        for(int i = 0;i < n;i++)\\n        {\\n            for(int j = 0;j < m;j++)\\n            {\\n                char c = words[i].charAt(j);\\n\\n                cnt[j][c - \\'a\\'] += 1;\\n            }\\n        }\\n\\n       // base case\\n        for(int i = 0;i <= m;i++)\\n          dp[i][T] = 1;\\n\\n\\n        for(int i = m - 1;i >= 0 ;i--)\\n        {\\n            for(int k = T - 1;k >= 0;k--)\\n            {  \\n\\n\\n               long notPick = dp[i + 1][k];\\n               long pick = 0;\\n\\n               char c = target.charAt(k) ;\\n               int freq = cnt[i][c - \\'a\\'];\\n\\n               if(freq != 0)\\n               {\\n                   pick += (freq * dp[i + 1][k+ 1]) % MOD;\\n               }\\n\\n               dp[i][k] = (pick + notPick) % MOD;\\n\\n            }\\n        }\\n    \\n        return (int)dp[0][0];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int n;\\n    private int l;\\n    private int m;\\n    private String t;\\n    private static Long[][] dp;\\n    private static int[][] cnt;\\n    private int MOD = (int)1e9 + 7;\\n\\n\\n    public long dfs(int i,int k)\\n    {   \\n        // if our target string get exhausted then we managed to form a string\\n        if(k == m)\\n          return 1;\\n     //if our word gets exhausted first it means it is not possible\\n        if(i == l)\\n          return 0;\\n     \\n//already cached return the respective value\\n        if(dp[i][k] != null)\\n        {\\n            return dp[i][k];\\n        }  \\n  \\n//here we have two choices ,either to include the current character or\\n//not include\\n\\n//if not included , we simply move forward to the next charcter\\n        dp[i][k] = dfs(i + 1,k);\\n \\n        int c = t.charAt(k);\\n //cnt[i][c-\\'a\\'] != 0 represents there is an option to take this \\n//character,we multiply it with cnt[i][c-\\'a\\'] \\n//inorder not to duplicate work for the same character with the same parameters among multiple words. \\n        if(cnt[i][c - \\'a\\'] != 0)\\n        { \\n       \\n          dp[i][k] +=  (cnt[i][c - \\'a\\']) * dfs(i + 1,k + 1);\\n          dp[i][k] %= MOD;\\n        }\\n\\n         return dp[i][k];\\n        \\n    }\\n    public int numWays(String[] words, String target) {\\n         \\n          t = target;\\n          n = words.length;\\n          l = words[0].length();\\n          m = target.length();\\n          dp = new Long[l][m];\\n          \\n       //cnt is used to store the occurence of a character at that particular index among all words\\n          cnt = new int[l][26];\\n\\n          for(int i = 0;i < l;i++)\\n          {\\n              for(int j = 0;j < n;j++)\\n              {\\n                  cnt[i][words[j].charAt(i) - \\'a\\'] += 1;\\n              }\\n          }\\n\\n\\n          return (int)dfs(0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n           int n = words.length, m = words[0].length();\\n        int[][] cnt = new int[m][26];\\n        long[][] dp = new long[m + 1][target.length() + 1];\\n        \\n        int T = target.length(),MOD = (int)1e9 + 7;\\n        \\n        for(int i = 0;i < n;i++)\\n        {\\n            for(int j = 0;j < m;j++)\\n            {\\n                char c = words[i].charAt(j);\\n\\n                cnt[j][c - \\'a\\'] += 1;\\n            }\\n        }\\n\\n       // base case\\n        for(int i = 0;i <= m;i++)\\n          dp[i][T] = 1;\\n\\n\\n        for(int i = m - 1;i >= 0 ;i--)\\n        {\\n            for(int k = T - 1;k >= 0;k--)\\n            {  \\n\\n\\n               long notPick = dp[i + 1][k];\\n               long pick = 0;\\n\\n               char c = target.charAt(k) ;\\n               int freq = cnt[i][c - \\'a\\'];\\n\\n               if(freq != 0)\\n               {\\n                   pick += (freq * dp[i + 1][k+ 1]) % MOD;\\n               }\\n\\n               dp[i][k] = (pick + notPick) % MOD;\\n\\n            }\\n        }\\n    \\n        return (int)dp[0][0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423769,
                "title": "swift-solution-using-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        var words = Array(words)\\n        var target = Array(target)\\n        var n = words[0].count\\n        var m = target.count\\n\\n        var dp = [Int](repeating: 0, count: m+1)\\n        dp[0] = 1\\n\\n        var count = [[Int]](repeating: [Int](repeating: 0, count: 26), count: n)\\n\\n        for word in words {\\n            for (i, char) in word.enumerated() {\\n                count[i][Int(char.asciiValue!) - 97] += 1\\n            }\\n        }\\n        for i in 0...n-1 {\\n            for j in stride(from: m-1, through: 0, by: -1) {\\n                dp[j+1] += dp[j]*(count[i][Int(target[j].asciiValue!) - 97])%1000000007\\n                dp[j+1] = dp[j+1]%1000000007\\n            }\\n        }\\n        return dp[m]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        var words = Array(words)\\n        var target = Array(target)\\n        var n = words[0].count\\n        var m = target.count\\n\\n        var dp = [Int](repeating: 0, count: m+1)\\n        dp[0] = 1\\n\\n        var count = [[Int]](repeating: [Int](repeating: 0, count: 26), count: n)\\n\\n        for word in words {\\n            for (i, char) in word.enumerated() {\\n                count[i][Int(char.asciiValue!) - 97] += 1\\n            }\\n        }\\n        for i in 0...n-1 {\\n            for j in stride(from: m-1, through: 0, by: -1) {\\n                dp[j+1] += dp[j]*(count[i][Int(target[j].asciiValue!) - 97])%1000000007\\n                dp[j+1] = dp[j+1]%1000000007\\n            }\\n        }\\n        return dp[m]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423661,
                "title": "python-short-and-clean-recursive-dp",
                "content": "# Complexity\\n- Time complexity: $$O((m + n) * k)$$\\n\\n- Space complexity: $$O((m + n) * k)$$\\n\\nwhere,\\n`n is number of words`,\\n`m is length of target`,\\n`k is length of one word`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def numWays(self, words: list[str], target: str) -> int:\\n        columns = list(map(Counter, zip(*words)))\\n\\n        @cache\\n        def ways(i: int, j: int) -> int:\\n            if j < 0: return 1\\n            if i < j: return 0\\n            col, ch = columns[i], target[j]\\n            return (ways(i - 1, j) + (ways(i - 1, j - 1) * col[ch] if ch in col else 0)) % 1_000_000_007\\n        \\n        return ways(len(columns) - 1, len(target) - 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numWays(self, words: list[str], target: str) -> int:\\n        columns = list(map(Counter, zip(*words)))\\n\\n        @cache\\n        def ways(i: int, j: int) -> int:\\n            if j < 0: return 1\\n            if i < j: return 0\\n            col, ch = columns[i], target[j]\\n            return (ways(i - 1, j) + (ways(i - 1, j - 1) * col[ch] if ch in col else 0)) % 1_000_000_007\\n        \\n        return ways(len(columns) - 1, len(target) - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421478,
                "title": "easy-c-solution-dfs-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Creating an Dp vector for not repeating same coords again and again.\\n2. Implement dfs for both if there charchter matches or not.\\n3. Base condition can be if j reached end of target for 1 and if remaining characters are more in target then words[i]. \\n\\n# Complexity\\n- $a=words[0].length()$\\n $b=target.length()$\\n $c=words.size()$\\n\\n- Time complexity: $O(a*b*c)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(a*b)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt(vector<string>& words,string target,int i,int j,vector<vector<int>>& dp){\\n        if(j==target.length()) return 1;\\n        if(words[0].length()-i<target.length()-j) return 0;\\n        if(dp[i][j]!=0) return dp[i][j];\\n        long long int ans=0,cnt2=0;\\n        for(int k=0;k<words.size();k++){\\n            if(words[k][i]==target[j]) cnt2++;\\n        }\\n        if(cnt2!=0) ans+=cnt2*cnt(words,target,i+1,j+1,dp);\\n        ans+=cnt(words,target,i+1,j,dp);\\n        dp[i][j]=ans%1000000007;\\n        return ans%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n=words[0].length(),m=target.length();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        return cnt(words,target,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt(vector<string>& words,string target,int i,int j,vector<vector<int>>& dp){\\n        if(j==target.length()) return 1;\\n        if(words[0].length()-i<target.length()-j) return 0;\\n        if(dp[i][j]!=0) return dp[i][j];\\n        long long int ans=0,cnt2=0;\\n        for(int k=0;k<words.size();k++){\\n            if(words[k][i]==target[j]) cnt2++;\\n        }\\n        if(cnt2!=0) ans+=cnt2*cnt(words,target,i+1,j+1,dp);\\n        ans+=cnt(words,target,i+1,j,dp);\\n        dp[i][j]=ans%1000000007;\\n        return ans%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n=words[0].length(),m=target.length();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        return cnt(words,target,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756711,
                "title": "python3-clean-memoized-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        # Per-index dict of character counts in words.\\n        charPositionDict = defaultdict(lambda: defaultdict(int))\\n        for word in words:\\n            for idx, c in enumerate(word):\\n                charPositionDict[idx][c]+=1\\n        \\n        # Number of ways to create word[i:] using character indexes k,k+1,...\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # We\\'ve reached the end of target word.\\n            if i == len(target):\\n                return 1\\n            # Not enough characters remain, no results possible.\\n            if len(target) - i - 1 > len(words[0]) - k - 1:\\n                return 0\\n            \\n            # Number of formations using position k.\\n            ret=(charPositionDict[k][target[i]]*dp(i+1, k+1))\\n            # Number of formations not using position k.\\n            ret+=dp(i, k+1)\\n            return ret % (10**9 + 7)\\n        \\n        return dp(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        # Per-index dict of character counts in words.\\n        charPositionDict = defaultdict(lambda: defaultdict(int))\\n        for word in words:\\n            for idx, c in enumerate(word):\\n                charPositionDict[idx][c]+=1\\n        \\n        # Number of ways to create word[i:] using character indexes k,k+1,...\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # We\\'ve reached the end of target word.\\n            if i == len(target):\\n                return 1\\n            # Not enough characters remain, no results possible.\\n            if len(target) - i - 1 > len(words[0]) - k - 1:\\n                return 0\\n            \\n            # Number of formations using position k.\\n            ret=(charPositionDict[k][target[i]]*dp(i+1, k+1))\\n            # Number of formations not using position k.\\n            ret+=dp(i, k+1)\\n            return ret % (10**9 + 7)\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340682,
                "title": "python-commented-dp-hash-table-beats-100",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        mod=10**9+7\\n        @lru_cache(None)\\n        def dp(target_index,word_index):\\n\\t\\t    #if target_index reaches last element of target\\n            if target_index==t_n:\\n                return 1\\n\\t\\t\\t#if remaining target length is greater than remianing length of any word in words,\\n\\t\\t\\t#then words can\\'t be formed,hence return zero\\n            if w_n-word_index<t_n-target_index:\\n                return 0\\n            c=target[target_index]\\n            #we skip the current word_index\\n            ans=dp(target_index,word_index+1)\\n            #we use the current word_index\\n            if c in count[word_index]:\\n                ans+=dp(target_index+1,word_index+1)*count[word_index][c]\\n            return ans\\n        t_n=len(target)\\n        w_n=len(words[0])\\n\\t\\t#count is a list of dictionary which stores counts of all letters\\n\\t\\t#appearing in all words at a particular index(common to all words)\\n        #so length of count will be w_n\\n        count = [collections.Counter(word) for word in zip(*words)]\\n        return dp(0,0)%mod\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        mod=10**9+7\\n        @lru_cache(None)\\n        def dp(target_index,word_index):\\n\\t\\t    #if target_index reaches last element of target\\n            if target_index==t_n:\\n                return 1\\n\\t\\t\\t#if remaining target length is greater than remianing length of any word in words,\\n\\t\\t\\t#then words can\\'t be formed,hence return zero\\n            if w_n-word_index<t_n-target_index:\\n                return 0\\n            c=target[target_index]\\n            #we skip the current word_index\\n            ans=dp(target_index,word_index+1)\\n            #we use the current word_index\\n            if c in count[word_index]:\\n                ans+=dp(target_index+1,word_index+1)*count[word_index][c]\\n            return ans\\n        t_n=len(target)\\n        w_n=len(words[0])\\n\\t\\t#count is a list of dictionary which stores counts of all letters\\n\\t\\t#appearing in all words at a particular index(common to all words)\\n        #so length of count will be w_n\\n        count = [collections.Counter(word) for word in zip(*words)]\\n        return dp(0,0)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917669,
                "title": "concise-c-solution-o-n-m",
                "content": "\\n\\nwe don\\'t need to consider the index of `words`.  \\nconsider the words: [\"acca\",\"bbbb\",\"caca\"]  \\na | c | c | a  \\nb | b | b | b  \\nc | a | c | a  \\nso the dp[i][j] represent the `i-th` index in `word`(see vertical view above) with `j-th` index in target. there are 2 branches we can have:   \\n1. if the i-th index has `target[j]`, the we can do `dfs(t, i + 1, j + 1)`  \\n2. we can always ignore the current `i-th` index and try the next one: `dfs(t, i + 1, j)`;  \\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    long long M = 1e9 + 7;\\n    vector<map<int, int> > chIdx;\\n    long long dfs(string &t, int i, int j) {\\n        if(i >= chIdx.size()) return j == t.size();\\n        if(j == t.size()) return 1;\\n        if(dp[i][j] >= 0) return dp[i][j];\\n        long long res = 0;\\n        if(chIdx[i][t[j]])\\n            res = dfs(t, i + 1, j + 1) * chIdx[i][t[j]];\\n        res += dfs(t, i + 1, j);\\n        res %= M;\\n        return dp[i][j] = res;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp, -1, sizeof(dp));\\n        chIdx.resize((words[0].size()));\\n        for(auto &word : words) {\\n            for(int i = 0; i < word.size(); ++i) {\\n                ++chIdx[i][word[i]];\\n            }\\n        }\\n        return dfs(target, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    long long M = 1e9 + 7;\\n    vector<map<int, int> > chIdx;\\n    long long dfs(string &t, int i, int j) {\\n        if(i >= chIdx.size()) return j == t.size();\\n        if(j == t.size()) return 1;\\n        if(dp[i][j] >= 0) return dp[i][j];\\n        long long res = 0;\\n        if(chIdx[i][t[j]])\\n            res = dfs(t, i + 1, j + 1) * chIdx[i][t[j]];\\n        res += dfs(t, i + 1, j);\\n        res %= M;\\n        return dp[i][j] = res;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp, -1, sizeof(dp));\\n        chIdx.resize((words[0].size()));\\n        for(auto &word : words) {\\n            for(int i = 0; i < word.size(); ++i) {\\n                ++chIdx[i][word[i]];\\n            }\\n        }\\n        return dfs(target, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424670,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $target\\n     * @return Integer\\n     */\\n    function numWays($words, $target)\\n    {\\n        $n = strlen($words[0]);\\n        $h = array_fill(0, $n, array_fill_keys(range(\\'a\\', \\'z\\'), 0));\\n\\n        foreach ($words as $word) {\\n            for ($i = 0; $i < $n; $i++) {\\n                $h[$i][$word[$i]]++;\\n            }\\n        }\\n        $a = [];\\n        $a[1] = array_fill(-1, $n + 1, 1);\\n        $a[0] = array_fill(-1, $n + 1, 0);\\n        for ($i = 0; $i < strlen($target); $i++) {\\n            $s = 0;\\n            $c = $i % 2;\\n            for ($j = $i; $j < $n; $j++) {\\n                $s += $a[1 - $c][$j - 1] * $h[$j][$target[$i]];\\n                $a[$c][$j] = $s % (10 ** 9 + 7);\\n            }\\n        }\\n\\n        return end($a[$c]) % (10 ** 9 + 7);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $target\\n     * @return Integer\\n     */\\n    function numWays($words, $target)\\n    {\\n        $n = strlen($words[0]);\\n        $h = array_fill(0, $n, array_fill_keys(range(\\'a\\', \\'z\\'), 0));\\n\\n        foreach ($words as $word) {\\n            for ($i = 0; $i < $n; $i++) {\\n                $h[$i][$word[$i]]++;\\n            }\\n        }\\n        $a = [];\\n        $a[1] = array_fill(-1, $n + 1, 1);\\n        $a[0] = array_fill(-1, $n + 1, 0);\\n        for ($i = 0; $i < strlen($target); $i++) {\\n            $s = 0;\\n            $c = $i % 2;\\n            for ($j = $i; $j < $n; $j++) {\\n                $s += $a[1 - $c][$j - 1] * $h[$j][$target[$i]];\\n                $a[$c][$j] = $s % (10 ** 9 + 7);\\n            }\\n        }\\n\\n        return end($a[$c]) % (10 ** 9 + 7);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424240,
                "title": "swift-dp-solution-with-pictures",
                "content": "# Intuition\\nTo solve the problem, it is necessary to go through all possible ways and count them. The condition can be reformulated as follows: find the maximum number of ways to compose the target string. Then we are faced with an optimization problem that can be solved by dynamic programming.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLet $N$ is the length of words, $M$ is the length of target and $L$ is the number of words.\\n\\nThe first and most important thing that you need to understand when you solve a problem with this method is to separate out a subproblem of smaller dimension. Here is mine for the current one:\\n\\n**The number of ways to form target suffix from words suffix-slice**\\nwhere all words are put one under one to construct the matrix\\n\\nConsider the example\\n```\\nwords: [\"acca\", \"bbbb\", \"caba\"]\\ntarget: \"aba\"\\n```\\n\\n![slice-target-suffix.png](https://assets.leetcode.com/users/images/5e72dea1-d973-41c2-a0d1-6cbda31076d3_1681651320.5142152.png)\\n\\nWe start with the subproblem to count how many ways to form the last character of the target string from the last matrix column. Obviously it is the character occurrences number in the last column. \\n\\nIncrease the dimension: to form the last character of the target string from the last two matrix columns. It\\'s occurrences number in the next-to-last column plus already computed value for the last column. Then for the last three columns, four, five, until you fill in for the entire words matrix.\\n\\n> For the dynamic programming matrix, we use a little trick - add one additional cell with zero value to not worry about index out of bounds errors\\n\\n![init-dp.png](https://assets.leetcode.com/users/images/57d303f2-6af6-4ab4-8564-7b0d28c724ef_1681652228.3314867.png)\\n\\nScale up: solve the problem for the last two characters of the target string. We already know the answer for the last character. Now we are interested in the number of combinations with one more letter. For each next column, this is the number of occurrences of the new letter multiplied by the result of the subtask without this letter from the next column plus the result of the subtask with this letter from the next column.\\n\\nExample: let\\'s take a look on statement from the picture below \\n`d[1][1] = 6 = 1 * 2 + 4`\\n\\n![dp-step.png](https://assets.leetcode.com/users/images/1d6340ef-bdf1-485f-bedc-cf67a6e78ec6_1681652878.2097678.png)\\nIt\\'s a subtask for matrix-slice $$\\\\begin{bmatrix}c&c&a\\\\\\\\b&b&b\\\\\\\\a&b&a\\\\end{bmatrix}$$ and suffix `\"ba\"`.\\nWe count **one** `\"b\"` character in the first slice column $$\\\\begin{bmatrix}c\\\\\\\\b\\\\\\\\a\\\\end{bmatrix}$$ and we\\'ve already known that there are **two** characters `\"a\"` in the rest slice part $$\\\\begin{bmatrix}c&a\\\\\\\\b&b\\\\\\\\b&a\\\\end{bmatrix}$$ (result of a lower dimension problem `d[2][2]`). So we have **two** ways to form string `\"ba\"` (multiplication). But we also have **four** ways to construct `\"ba\"` from column 2 (result of previous iteration), we shouldn\\'t forget it in the result, let\\'s put them together.\\n\\nPerform similar actions until we know the result for the entire target string.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n- Time complexity: $O(N*L + N*M)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N*M)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfinal class Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        let n = words[0].count\\n        let m = target.count\\n        guard m <= n else {\\n            return 0\\n        }\\n        let data = words.map(Array.init)\\n        let target = Array(target)\\n        let modulo = 1_000_000_007\\n\\n        var freq = Array(repeating: [Character: Int](), count: n)\\n        var d = Array(repeating: Array(repeating: 0, count: n + 1), count: m)\\n\\n        // init freq and the dp base for the last character of the target\\n        for col in (0..<n).reversed() {\\n            for row in 0..<words.count {\\n                freq[col][data[row][col], default: 0] += 1\\n            }\\n            d[m - 1][col] = freq[col][target[m - 1], default: 0] + d[m - 1][col + 1]\\n        }\\n\\n        // make dp steps\\n        for k in (0..<(m - 1)).reversed() {\\n            let skip = m - k\\n            let bound = (n + 1) - skip\\n            for col in (0..<bound).reversed() {\\n                d[k][col] = (freq[col][target[k], default: 0] * d[k + 1][col + 1]) % modulo\\n                d[k][col] = (d[k][col] + d[k][col + 1]) % modulo\\n            }\\n        }\\n        \\n        return d[0][0]\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nwords: [\"acca\", \"bbbb\", \"caba\"]\\ntarget: \"aba\"\\n```\n```\\nfinal class Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        let n = words[0].count\\n        let m = target.count\\n        guard m <= n else {\\n            return 0\\n        }\\n        let data = words.map(Array.init)\\n        let target = Array(target)\\n        let modulo = 1_000_000_007\\n\\n        var freq = Array(repeating: [Character: Int](), count: n)\\n        var d = Array(repeating: Array(repeating: 0, count: n + 1), count: m)\\n\\n        // init freq and the dp base for the last character of the target\\n        for col in (0..<n).reversed() {\\n            for row in 0..<words.count {\\n                freq[col][data[row][col], default: 0] += 1\\n            }\\n            d[m - 1][col] = freq[col][target[m - 1], default: 0] + d[m - 1][col + 1]\\n        }\\n\\n        // make dp steps\\n        for k in (0..<(m - 1)).reversed() {\\n            let skip = m - k\\n            let bound = (n + 1) - skip\\n            for col in (0..<bound).reversed() {\\n                d[k][col] = (freq[col][target[k], default: 0] * d[k + 1][col + 1]) % modulo\\n                d[k][col] = (d[k][col] + d[k][col + 1]) % modulo\\n            }\\n        }\\n        \\n        return d[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423991,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int mod = 1e9 + 7;\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>> freq(n, vector<int>(26, 0));\\n        for (int j = 0; j < n; j++)\\n         {\\n            for (int i = 0; i < m; i++) \\n            {\\n                freq[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        vector<long long> dp(target.size() + 1, 0);\\n        dp[0] = 1;\\n        for (int j = 0; j < n; j++) \\n        {\\n            for (int i = target.size(); i > 0; i--) \\n            {\\n                dp[i] = (dp[i] + dp[i-1] * freq[j][target[i-1] - \\'a\\']) % mod;\\n            }\\n        }\\n        return dp[target.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int mod = 1e9 + 7;\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>> freq(n, vector<int>(26, 0));\\n        for (int j = 0; j < n; j++)\\n         {\\n            for (int i = 0; i < m; i++) \\n            {\\n                freq[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        vector<long long> dp(target.size() + 1, 0);\\n        dp[0] = 1;\\n        for (int j = 0; j < n; j++) \\n        {\\n            for (int i = target.size(); i > 0; i--) \\n            {\\n                dp[i] = (dp[i] + dp[i-1] * freq[j][target[i-1] - \\'a\\']) % mod;\\n            }\\n        }\\n        return dp[target.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423792,
                "title": "java-top-down-dp-memoization-approach",
                "content": "```\\n// Approach 2: Top-Down DP (Memoization)\\n\\n// Time complexity: O(n * k + m * k)\\n// Space complexity: O(m * k)\\n\\nclass Solution {\\n    int[][] count;\\n    int MOD = (int) (Math.pow(10, 9) + 7);\\n    Long[][] memo;\\n    \\n    public int numWays(String[] words, String target) {\\n        count = new int[26][words[0].length()];\\n        memo = new Long[words[0].length()][target.length()];\\n        \\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                count[word.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n        \\n        return (int) dfs(target, 0, 0);\\n    }\\n    \\n    private long dfs(String target, int i, int k) {\\n        if (k == target.length())\\n            return 1;\\n        \\n        if (i == count[0].length)\\n            return 0;\\n        \\n        if (memo[i][k] != null)\\n            return memo[i][k];\\n        \\n        memo[i][k] = dfs(target, i + 1, k);  \\n        memo[i][k] += count[target.charAt(k) - \\'a\\'][i] * dfs(target, i + 1, k + 1);\\n        \\n        return memo[i][k] % MOD;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Approach 2: Top-Down DP (Memoization)\\n\\n// Time complexity: O(n * k + m * k)\\n// Space complexity: O(m * k)\\n\\nclass Solution {\\n    int[][] count;\\n    int MOD = (int) (Math.pow(10, 9) + 7);\\n    Long[][] memo;\\n    \\n    public int numWays(String[] words, String target) {\\n        count = new int[26][words[0].length()];\\n        memo = new Long[words[0].length()][target.length()];\\n        \\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                count[word.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n        \\n        return (int) dfs(target, 0, 0);\\n    }\\n    \\n    private long dfs(String target, int i, int k) {\\n        if (k == target.length())\\n            return 1;\\n        \\n        if (i == count[0].length)\\n            return 0;\\n        \\n        if (memo[i][k] != null)\\n            return memo[i][k];\\n        \\n        memo[i][k] = dfs(target, i + 1, k);  \\n        memo[i][k] += count[target.charAt(k) - \\'a\\'][i] * dfs(target, i + 1, k + 1);\\n        \\n        return memo[i][k] % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423727,
                "title": "c-easy-to-understand-4-lines-of-dp-code-basic-dp-simple-knapsack",
                "content": "# Intuition Think Simple Knapsack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Store Count of characters at each position and simple knapsack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    int f(int i,int j,string &t,int l,vector<vector<long long int>> &ct,vector<vector<long long int>> &dp){\\n        if(j==t.size()) return 1;\\n        if(i==l) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long long int take=((ct[i][t[j]-\\'a\\']%M)*(f(i+1,j+1,t,l,ct,dp)%M))%M;\\n        long long int notake=f(i+1,j,t,l,ct,dp)%M;\\n        return dp[i][j]=((take%M)+(notake%M))%M;\\n    }\\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> ct(w[0].size(),vector<long long int> (26,0));\\n        for(int i=0;i<w.size();i++){\\n            for(int j=0;j<w[i].size();j++) ct[j][w[i][j]-\\'a\\']++;\\n        }\\n        vector<vector<long long int>> dp(w[0].size(),vector<long long int> (t.size(),-1));\\n        return f(0,0,t,w[0].size(),ct,dp)%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    int f(int i,int j,string &t,int l,vector<vector<long long int>> &ct,vector<vector<long long int>> &dp){\\n        if(j==t.size()) return 1;\\n        if(i==l) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long long int take=((ct[i][t[j]-\\'a\\']%M)*(f(i+1,j+1,t,l,ct,dp)%M))%M;\\n        long long int notake=f(i+1,j,t,l,ct,dp)%M;\\n        return dp[i][j]=((take%M)+(notake%M))%M;\\n    }\\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> ct(w[0].size(),vector<long long int> (26,0));\\n        for(int i=0;i<w.size();i++){\\n            for(int j=0;j<w[i].size();j++) ct[j][w[i][j]-\\'a\\']++;\\n        }\\n        vector<vector<long long int>> dp(w[0].size(),vector<long long int> (t.size(),-1));\\n        return f(0,0,t,w[0].size(),ct,dp)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423635,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        n, mod = len(target), 10**9 + 7\\n        res = [1] + [0] * n\\n        for i in xrange(len(words[0])):\\n            count = collections.Counter(w[i] for w in words)\\n            for j in xrange(n - 1, -1, -1):\\n                res[j + 1] += res[j] * count[target[j]] % mod\\n        return res[n] % mod\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        n, mod = len(target), 10**9 + 7\\n        res = [1] + [0] * n\\n        for i in xrange(len(words[0])):\\n            count = collections.Counter(w[i] for w in words)\\n            for j in xrange(n - 1, -1, -1):\\n                res[j + 1] += res[j] * count[target[j]] % mod\\n        return res[n] % mod\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422585,
                "title": "bottom-up-dp-o-n-memory-in-rust",
                "content": "# Complexity\\n- Time complexity:\\n$$O(k\\\\cdot n + m\\\\cdot (n-m))$$, where $$k$$ is number of words, $$n$$ is word length, and $$m$$ is target length.\\n\\n- Space complexity:\\n$$O(27\\\\cdot n) = O(n)$$, where $$n$$ is word length, as we store character counts and dp arrays.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn num_ways(words: Vec<String>, target: String) -> i32 {\\n        const MOD:i64 = 1_000_000_007;\\n        let n = words[0].len();\\n        let counts = words.iter().fold(vec![[0; 26]; n], |mut counts, w| {\\n            for (i, c) in w.bytes().enumerate() {\\n                let c = (c - b\\'a\\') as usize;\\n                counts[i][c] += 1;\\n            }\\n            counts\\n        });\\n        let m = target.len();\\n        let mut dp = vec![1; n+1];\\n        for (ti, c) in target.bytes().enumerate().rev() {\\n            let c = (c - b\\'a\\') as usize;\\n            let last = n - m + ti;\\n            let mut num_ways_for_tail = dp[last+1];\\n            for i in (ti..=last).rev() {\\n                let num_ways_not_taking_c = if i==last { 0 } else { dp[i+1] };\\n                let num_ways_taking_c = counts[i][c] * num_ways_for_tail;\\n                num_ways_for_tail = dp[i];\\n                dp[i] = (num_ways_not_taking_c + num_ways_taking_c) % MOD;\\n            }\\n        }\\n\\n        dp[0] as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_ways(words: Vec<String>, target: String) -> i32 {\\n        const MOD:i64 = 1_000_000_007;\\n        let n = words[0].len();\\n        let counts = words.iter().fold(vec![[0; 26]; n], |mut counts, w| {\\n            for (i, c) in w.bytes().enumerate() {\\n                let c = (c - b\\'a\\') as usize;\\n                counts[i][c] += 1;\\n            }\\n            counts\\n        });\\n        let m = target.len();\\n        let mut dp = vec![1; n+1];\\n        for (ti, c) in target.bytes().enumerate().rev() {\\n            let c = (c - b\\'a\\') as usize;\\n            let last = n - m + ti;\\n            let mut num_ways_for_tail = dp[last+1];\\n            for i in (ti..=last).rev() {\\n                let num_ways_not_taking_c = if i==last { 0 } else { dp[i+1] };\\n                let num_ways_taking_c = counts[i][c] * num_ways_for_tail;\\n                num_ways_for_tail = dp[i];\\n                dp[i] = (num_ways_not_taking_c + num_ways_taking_c) % MOD;\\n            }\\n        }\\n\\n        dp[0] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422262,
                "title": "c-recursion-memoization-take-or-not-take-concept",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    int recur(int i,int j,vector<string> &words,string &target,vector<vector<int>> &dp)\\n    {\\n        if(j == target.size())\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        int n = words[0].size();\\n        if(i == n || n - i < target.size() - j)\\n        {\\n            return 0;\\n        }\\n\\n        long long take = 0;\\n        for(int idx=0;idx<words.size();idx++)\\n        {\\n            if(words[idx][i] == target[j])\\n            {\\n                take += recur(i + 1,j+1,words,target,dp) % MOD;\\n            }\\n        }\\n        int not_take = recur(i + 1,j,words,target,dp) % MOD;\\n\\n        return dp[i][j] = (take + not_take) % MOD;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(n + 1,vector<int>(m + 1,-1));\\n        return recur(0,0,words,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    int recur(int i,int j,vector<string> &words,string &target,vector<vector<int>> &dp)\\n    {\\n        if(j == target.size())\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        int n = words[0].size();\\n        if(i == n || n - i < target.size() - j)\\n        {\\n            return 0;\\n        }\\n\\n        long long take = 0;\\n        for(int idx=0;idx<words.size();idx++)\\n        {\\n            if(words[idx][i] == target[j])\\n            {\\n                take += recur(i + 1,j+1,words,target,dp) % MOD;\\n            }\\n        }\\n        int not_take = recur(i + 1,j,words,target,dp) % MOD;\\n\\n        return dp[i][j] = (take + not_take) % MOD;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(n + 1,vector<int>(m + 1,-1));\\n        return recur(0,0,words,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421548,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421520,
                "title": "hard-made-easy-java-recursive-memoization-easy-to-understand-explanation",
                "content": "# Algorithm Explanation:\\n\\nThe problem is to find the number of ways to form the target string using characters from given words. The solution provides two implementations of the same recursive approach with different optimizations: Memoization and Recursion.\\n\\n### Recursive Approach:\\nThe recursive approach uses a helper function \"rec\" that takes two parameters, the current index i in the words and the current index j in the target string. The base cases of the recursion are when j equals the length of the target string, return 1 (string is formed) and when i equals the length of the words, return 0 (string is not formed).\\nFor each character in the target string, we check if there is a corresponding character in the ith index of the words. If there is, we add the number of ways to form the rest of the string after this character to our answer.\\n\\n### Memoization:\\nThe memoization approach is similar to the recursive approach, but we store the results of the previously computed subproblems in an array named \"arr\". Before computing the subproblem, we check if it has been computed before, and if it has, we return the stored result.\\n\\n# Time Complexity:\\nRecursive Approach:\\nIn the recursive approach, we have to explore all possible combinations of characters from the input words to form the target string. For each character in the target string, we have to iterate through all the characters in the input words. Therefore, the time complexity of the recursive approach is```O(n^m)```\\n where n is the length of each word in the input array and m is the length of the target string.\\n\\nMemoization:\\nIn the memoization approach, we store the results of the previously computed subproblems in an array. Before computing the subproblem, we check if it has been computed before, and if it has, we return the stored result. This optimization ensures that we only compute each subproblem once. Therefore, the time complexity of the memoization approach is``` O(nm)```\\nwhere n is the length of each word in the input array and m is the length of the target string.\\n# Code\\n## **Recusive:-**\\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    String target;\\n    int n;\\n    int m;\\n    int cnt[][];\\n    public int numWays(String[] words, String target) {\\n        this.target=target;\\n        n=words[0].length();\\n        m=target.length();\\n        cnt=new int[n][26];\\n        for(String word:words){\\n            for(int i=0;i<n;i++){\\n                cnt[i][word.charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return rec(0,0);\\n    }\\n    public int rec(int i,int j){\\n        if(j==m)return 1;\\n        if(i==n)return 0;\\n        int ind=target.charAt(j)-\\'a\\';\\n        int ans=rec(i+1,j);\\n        if(cnt[i][ind]>0){\\n            ans=(ans+((rec(i+1,j+1))%mod*cnt[i][ind])%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n## **Memoization:-** \\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    String target;\\n    int n;\\n    int m;\\n    int cnt[][];\\n    Integer[][]arr;\\n    public int numWays(String[] words, String target) {\\n        this.target=target;\\n        n=words[0].length();\\n        m=target.length();\\n        arr=new Integer[n][m];\\n        cnt=new int[n][26];\\n        for(String word:words){\\n            for(int i=0;i<n;i++){\\n                cnt[i][word.charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return rec(0,0);\\n    }\\n    public int rec(int i,int j){\\n        if(j==m)return 1;\\n        if(i==n)return 0;\\n        if(arr[i][j]!=null)return arr[i][j];\\n        int ind=target.charAt(j)-\\'a\\';\\n        int ans=rec(i+1,j);\\n        if(cnt[i][ind]>0){\\n            ans=(ans+((rec(i+1,j+1))%mod*cnt[i][ind])%mod)%mod;\\n        }\\n        return arr[i][j]=ans;\\n    }\\n}\\n```\\n![2wjw5c.jpg](https://assets.leetcode.com/users/images/2a65d351-8860-436e-8a76-ddaf98371f0a_1681645140.5937288.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```O(n^m)```\n``` O(nm)```\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    String target;\\n    int n;\\n    int m;\\n    int cnt[][];\\n    public int numWays(String[] words, String target) {\\n        this.target=target;\\n        n=words[0].length();\\n        m=target.length();\\n        cnt=new int[n][26];\\n        for(String word:words){\\n            for(int i=0;i<n;i++){\\n                cnt[i][word.charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return rec(0,0);\\n    }\\n    public int rec(int i,int j){\\n        if(j==m)return 1;\\n        if(i==n)return 0;\\n        int ind=target.charAt(j)-\\'a\\';\\n        int ans=rec(i+1,j);\\n        if(cnt[i][ind]>0){\\n            ans=(ans+((rec(i+1,j+1))%mod*cnt[i][ind])%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    String target;\\n    int n;\\n    int m;\\n    int cnt[][];\\n    Integer[][]arr;\\n    public int numWays(String[] words, String target) {\\n        this.target=target;\\n        n=words[0].length();\\n        m=target.length();\\n        arr=new Integer[n][m];\\n        cnt=new int[n][26];\\n        for(String word:words){\\n            for(int i=0;i<n;i++){\\n                cnt[i][word.charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return rec(0,0);\\n    }\\n    public int rec(int i,int j){\\n        if(j==m)return 1;\\n        if(i==n)return 0;\\n        if(arr[i][j]!=null)return arr[i][j];\\n        int ind=target.charAt(j)-\\'a\\';\\n        int ans=rec(i+1,j);\\n        if(cnt[i][ind]>0){\\n            ans=(ans+((rec(i+1,j+1))%mod*cnt[i][ind])%mod)%mod;\\n        }\\n        return arr[i][j]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421428,
                "title": "kotlin-count-and-search",
                "content": "```\\nclass Solution {\\n  fun numWays(words: Array<String>, target: String): Int {\\n    val MOD: Int = 1_000_000_007\\n    val n = words[0].length\\n    val counts = Array(n) {IntArray(26)}\\n    for (word in words) {\\n      for (i in 0 until n)\\n        counts[i][word[i] - \\'a\\']++\\n    }\\n    val memo = Array(n) {IntArray(target.length) { -1 } }\\n    fun dfs(column: Int, idx: Int): Int {\\n      if (idx == target.length) return 1\\n      if (column == n) return 0\\n      if (memo[column][idx] == -1) {\\n        var tmp = dfs(column + 1, idx)\\n        val ch = target[idx] - \\'a\\'\\n        if (counts[column][ch] != 0)\\n          tmp = ((tmp + counts[column][ch].toLong() * dfs(column + 1, idx + 1)) % MOD).toInt()\\n        memo[column][idx] = tmp\\n      }\\n      return memo[column][idx]\\n    }\\n    return dfs(0, 0)\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun numWays(words: Array<String>, target: String): Int {\\n    val MOD: Int = 1_000_000_007\\n    val n = words[0].length\\n    val counts = Array(n) {IntArray(26)}\\n    for (word in words) {\\n      for (i in 0 until n)\\n        counts[i][word[i] - \\'a\\']++\\n    }\\n    val memo = Array(n) {IntArray(target.length) { -1 } }\\n    fun dfs(column: Int, idx: Int): Int {\\n      if (idx == target.length) return 1\\n      if (column == n) return 0\\n      if (memo[column][idx] == -1) {\\n        var tmp = dfs(column + 1, idx)\\n        val ch = target[idx] - \\'a\\'\\n        if (counts[column][ch] != 0)\\n          tmp = ((tmp + counts[column][ch].toLong() * dfs(column + 1, idx + 1)) % MOD).toInt()\\n        memo[column][idx] = tmp\\n      }\\n      return memo[column][idx]\\n    }\\n    return dfs(0, 0)\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421396,
                "title": "easy-understand-simple-method-beats-99-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Java:\\nSince the length of all words in `words` is same, a count array `dics` can be maintained, where `dics[i][j]` means that in the `i`th character of all words, the number of occurrences of the character `j`.\\n\\nThen create `opt[i][j]`, use `words[i...]` as a dictionary, the number of solutions for constructing the string `target[j...]`.\\n\\nConsider how to construct the first character of the string `target[j...]`, there are two cases:\\n\\n- Not used the character at position `i` in the dictionary. At this point, the problem comes down to using `words[i+1...]` as a dictionary to construct strings, so the corresponding number of solutions is `opt [i+1][j]`\\n- Use the character at position `i` in the dictionary. At this point, in the entire dictionary, there are a total of `dics[i][target[j]]` words to choose. After selecting any one of the words, according to the question, we cannot select the `i-th` character of any word or the characters before it. Therefore, in order to get the following string `target[j+1...]`, there will be opt[i+1][j+1] solutions\\n\\nAccording to the principle of addition and multiplication, the total number of solutions is:\\n`opt[i][j] = opt[i+1][j] + opt[i+1][j+1] \\u22C5 dics[i][target[j]]`\\n\\n\\n## Python:\\nThe hash table array records the number of occurrences of characters at each word position in words.\\n\\nAfter choosing words[j][k] to build the target, you can only continue to build it from k + 1, so it is the 01 knapsack problem.\\n\\nBuild a deep search, the parameters are the character subscripts in words and the character subscripts in target.\\n\\nIf the target has been traversed, it means that the solution is feasible and returns 1.\\n\\nIf the remaining subscripts in words are less than the remaining subscripts in target, it means that the solution is not feasible and returns 0.\\n\\nWhen the specified character in target does not appear in the specified character position hash table in words, it means that you can only continue to traverse the subscripts of words.\\n\\nIn other cases, there are two options: choose or not choose, if you choose, multiply by the number of characters in the position in the hash table\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(MN)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    private static int MOD = (int) 1e9 + 7;\\n\\n    public int numWays(String[] words, String target) {\\n        int w_length = words[0].length();\\n        int t_length = target.length();\\n        int[][] dics = new int[w_length + 1][26];\\n        for (String word : words) {\\n            char[] wordArray = word.toCharArray();\\n\\t\\t\\tfor (int i = 1; i <= w_length; i++) \\n\\t\\t\\t\\tdics[i][wordArray[i - 1] - \\'a\\']++;\\n        }\\n\\n        long[][] opt = new long[w_length + 1][t_length + 1];\\n        for (int i = 0; i <= w_length; i++)\\n\\t\\t\\topt[i][0] = 1;\\n\\t\\tfor (int i = 1; i <= t_length; i++) {\\n\\t\\t\\tint to = w_length - t_length + i;\\n\\t\\t\\tint c = target.charAt(i - 1) - \\'a\\';\\n\\t\\t\\tfor (int j = i; j <= to; j++) {\\n\\t\\t\\t\\tlong cur =  opt[j - 1][i] + opt[j - 1][i - 1] * dics[j][c];\\n\\t\\t\\t\\topt[j][i] = (cur + MOD) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (int) opt[w_length][t_length];\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long dfs(vector<vector<long>>& dp, vector<vector<int>>& cnt, string& target, int i, int j, int n, int m) {\\n        if (j == m) return 1;\\n        if (n - i < m - j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        long val = cnt[i][target[j] - \\'a\\'] * dfs(dp, cnt, target, i + 1, j + 1, n, m);\\n        val += dfs(dp, cnt, target, i + 1, j, n, m);\\n        val %= mod;\\n        return dp[i][j] = val;;\\n    }\\n    \\n    \\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].length();\\n        vector<vector<int>> cnt(n, vector<int>(26, 0));\\n        for (const auto& s: words) {\\n            for (int i = 0; i < n; i++) {\\n                cnt[i][s[i]-\\'a\\']++;\\n            }\\n        }\\n        \\n        int m = target.length();\\n        vector<vector<long>> dp(n, vector<long>(m, -1));\\n        return dfs(dp, cnt, target, 0, 0, n, m);\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m, n = len(words), len(words[0])\\n        l = len(target)\\n        d = [{} for i in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                c = words[i][j]\\n                d[j][c] = d[j].get(c, 0) + 1\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == l:\\n                return 1\\n            elif n - i < l - j:\\n                return 0\\n            if target[j] not in d[i]:\\n                return dfs(i + 1, j)\\n            return (dfs(i + 1, j) + d[i][target[j]] * dfs(i + 1, j + 1)) % mod\\n        mod = 10 ** 9 + 7\\n        return dfs(0, 0)\\n```\\n\\n**Please upvate if helpful!!**\\n\\n![image.png](https://assets.leetcode.com/users/images/4cfe106c-39c2-421d-90ca-53a7797ed7b5_1680845537.3804016.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static int MOD = (int) 1e9 + 7;\\n\\n    public int numWays(String[] words, String target) {\\n        int w_length = words[0].length();\\n        int t_length = target.length();\\n        int[][] dics = new int[w_length + 1][26];\\n        for (String word : words) {\\n            char[] wordArray = word.toCharArray();\\n\\t\\t\\tfor (int i = 1; i <= w_length; i++) \\n\\t\\t\\t\\tdics[i][wordArray[i - 1] - \\'a\\']++;\\n        }\\n\\n        long[][] opt = new long[w_length + 1][t_length + 1];\\n        for (int i = 0; i <= w_length; i++)\\n\\t\\t\\topt[i][0] = 1;\\n\\t\\tfor (int i = 1; i <= t_length; i++) {\\n\\t\\t\\tint to = w_length - t_length + i;\\n\\t\\t\\tint c = target.charAt(i - 1) - \\'a\\';\\n\\t\\t\\tfor (int j = i; j <= to; j++) {\\n\\t\\t\\t\\tlong cur =  opt[j - 1][i] + opt[j - 1][i - 1] * dics[j][c];\\n\\t\\t\\t\\topt[j][i] = (cur + MOD) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (int) opt[w_length][t_length];\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long dfs(vector<vector<long>>& dp, vector<vector<int>>& cnt, string& target, int i, int j, int n, int m) {\\n        if (j == m) return 1;\\n        if (n - i < m - j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        long val = cnt[i][target[j] - \\'a\\'] * dfs(dp, cnt, target, i + 1, j + 1, n, m);\\n        val += dfs(dp, cnt, target, i + 1, j, n, m);\\n        val %= mod;\\n        return dp[i][j] = val;;\\n    }\\n    \\n    \\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].length();\\n        vector<vector<int>> cnt(n, vector<int>(26, 0));\\n        for (const auto& s: words) {\\n            for (int i = 0; i < n; i++) {\\n                cnt[i][s[i]-\\'a\\']++;\\n            }\\n        }\\n        \\n        int m = target.length();\\n        vector<vector<long>> dp(n, vector<long>(m, -1));\\n        return dfs(dp, cnt, target, 0, 0, n, m);\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m, n = len(words), len(words[0])\\n        l = len(target)\\n        d = [{} for i in range(n)]\\n        for i in range(m):\\n            for j in range(n):\\n                c = words[i][j]\\n                d[j][c] = d[j].get(c, 0) + 1\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == l:\\n                return 1\\n            elif n - i < l - j:\\n                return 0\\n            if target[j] not in d[i]:\\n                return dfs(i + 1, j)\\n            return (dfs(i + 1, j) + d[i][target[j]] * dfs(i + 1, j + 1)) % mod\\n        mod = 10 ** 9 + 7\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747691,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int numWays(vector<string>& words, string target) {\\n        int n = target.length(), mod = 1e9 + 7;\\n        vector<long> res(n + 1);\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            vector<int> count(26);\\n            for (auto& w : words)\\n                count[w[i] - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target[j] - \\'a\\'] % mod;\\n            }\\n        }\\n        return res[n] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int numWays(vector<string>& words, string target) {\\n        int n = target.length(), mod = 1e9 + 7;\\n        vector<long> res(n + 1);\\n        res[0] = 1;\\n        for (int i = 0; i < words[0].length(); ++i) {\\n            vector<int> count(26);\\n            for (auto& w : words)\\n                count[w[i] - \\'a\\']++;\\n            for (int j = n - 1; j >= 0; --j) {\\n                res[j + 1] += res[j] * count[target[j] - \\'a\\'] % mod;\\n            }\\n        }\\n        return res[n] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413915,
                "title": "c-solution-dp-preprocessing",
                "content": "Let\\'s say you are at index `i` in the `target` string, and at index `i` in the `words` vector. If there exist any single word in `words` such that `target[i] == word[j]`, then you can form the index `i` of `target` with index `j` of the `words` and recursively. One can see the `dp` skeleton from the redundant computations. `dp[i][j]` indicates how many ways are there to form the substring `target[0..j]` using only `word[0..i]`, i.e. using only first `i+1` columns of word in `words` vector. If there exist any single word in `words` such that `target[i] == word[j]`, then `dp[i][j] = sum(dp[i-k][j-1] for 1 <= k <= i)`.\\n\\nThe above solution works in complexity `O(n*l*k*k)`, where `n = words.size()`, `l = words[0].length()`, and `k = target.length()`. You can make tow optimization to the solution:\\n1. By preprocess all the words in the `words` vector. For index `i` in `words` vector, create a frequency map `frequencies` that store the frequency any character in `ith` column of `words`, i.e. `frequencies[i][c]` gives you the frequency of character `c` in the `i` column of `words`. That would bring down the complexity by a factor of `O(n)` to `O(l*k*k)` with preprocessing done in `O(n*l)`.\\n2. By storing the prefix sum so as to avoid computing the summation every time. That would bring down the complexity by another factor of `O(k)` to `O(l*k)` with prefix sum computed on the go.\\n\\nComplexity:\\nTime => `O(n*l + l*k) = O((n+k)*l)`, where `n = words.size()`, `l = words[0].length()`, and `k = target.length()`\\nSpace => `O(l*k)` extra, where `n = words.size()`, `l = words[0].length()`, and `k = target.length()`\\n\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words.size(), l = words[0].length(), k = target.length();\\n        vector<unordered_map<char, int>> frequencies(l);\\n        for(auto& word: words){\\n            for(int i = 0; i < l; i++){\\n                frequencies[i][word[i]]++;\\n            }\\n        }\\n        long long int modn = 1000000007;\\n        vector<vector<long long int>> dp(k+1, vector<long long int>(l+1, 0L));\\n        for(int i = 0; i <= l; i++){\\n            dp[0][i] = 1L;\\n        }\\n        for(int i = 1; i <= k; i++){\\n            for(int j = 1; j <= l; j++){\\n                dp[i][j] = dp[i][j-1] + 1L* frequencies[j-1][target[i-1]] * dp[i-1][j-1];\\n                dp[i][j] %= modn;\\n            }\\n        }\\n        return dp[k][l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words.size(), l = words[0].length(), k = target.length();\\n        vector<unordered_map<char, int>> frequencies(l);\\n        for(auto& word: words){\\n            for(int i = 0; i < l; i++){\\n                frequencies[i][word[i]]++;\\n            }\\n        }\\n        long long int modn = 1000000007;\\n        vector<vector<long long int>> dp(k+1, vector<long long int>(l+1, 0L));\\n        for(int i = 0; i <= l; i++){\\n            dp[0][i] = 1L;\\n        }\\n        for(int i = 1; i <= k; i++){\\n            for(int j = 1; j <= l; j++){\\n                dp[i][j] = dp[i][j-1] + 1L* frequencies[j-1][target[i-1]] * dp[i-1][j-1];\\n                dp[i][j] %= modn;\\n            }\\n        }\\n        return dp[k][l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986176,
                "title": "python3-dp-solution-with-image-explanation-beats-99",
                "content": "# Intuition\\nBy collecting the histograms of chars at each index of the word, we can spot all the possible ways in which we can form the target string. We can then construct a 2D dp matrix of prefix sums that yields the result.\\n\\nFor example:\\n**Input**: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\\n**Matrix**:\\n![image](https://assets.leetcode.com/users/images/19859151-842c-4a0d-aba1-969c24886497_1651054617.5462017.png)\\n\\nDP formula: \\n```\\ndp[histogram_idx][target_char_idx] = dp[histogram_idx-1][target_char_idx-1] * histograms[histogram_idx][target_char[target_char_idx]] + sum(dp[histogram_idx][:target_char_idx] \\n```\\n\\n# Approach\\n1. Iterate through the words, to collect a character histogram for each char index. This yields an array of histograms (equal to the length of every word string).\\n2. Iterate through the charactes of the target string. Each iteration has its own `dp` array. For each iteration, slide a window (of length equal to the remaining characters of the target) along the histograms array in order to populate the `dp` array of this iteration.\\n3. The `dp` array is a monotonically increasing prefix sum, where we keep adding the frequency of the target char multiplied by the value of the `previous_dp` that was computed for the previous target char iteration.\\n4. Return the last element of the `dp` array of the last iteration.\\n```\\nclass Solution:\\n    MOD = 10**9+7\\n\\n    def numWays(self, words: List[str], target: str) -> int:\\n        word_len = len(words[0])\\n        histograms: MutableSequence[MutableMapping[str, int]] = [\\n            defaultdict(int) for _ in range(word_len)\\n        ]\\n            \\n        for word in words:\\n            for i, c in enumerate(word):\\n                histograms[i][c] += 1\\n        \\n        previous_dp = [1] * (word_len+1)\\n        for target_idx, c in enumerate(target):\\n            dp = [0] * (word_len+1)\\n            remaining = len(target) - target_idx\\n    \\n            for hist_idx in range(target_idx, word_len-remaining+1):\\n                c_freq = histograms[hist_idx][c]\\n                dp[hist_idx+1] = ((c_freq * previous_dp[hist_idx]) + dp[hist_idx]) % self.MOD\\n\\n            previous_dp = dp\\n\\n        return dp[-1]\\n```\\n# Complexity\\n**Runtime**: O(N\\\\*M), where N is the length of every string in the `words` array and M is the the length of the words array itslef. \\n**Space**: O(N), where N is the length of every string in the `words` array. We have N histograms, where each of them may contain at most 26 entries (length of alphabet). The dp array is also of size N +1.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[histogram_idx][target_char_idx] = dp[histogram_idx-1][target_char_idx-1] * histograms[histogram_idx][target_char[target_char_idx]] + sum(dp[histogram_idx][:target_char_idx] \\n```\n```\\nclass Solution:\\n    MOD = 10**9+7\\n\\n    def numWays(self, words: List[str], target: str) -> int:\\n        word_len = len(words[0])\\n        histograms: MutableSequence[MutableMapping[str, int]] = [\\n            defaultdict(int) for _ in range(word_len)\\n        ]\\n            \\n        for word in words:\\n            for i, c in enumerate(word):\\n                histograms[i][c] += 1\\n        \\n        previous_dp = [1] * (word_len+1)\\n        for target_idx, c in enumerate(target):\\n            dp = [0] * (word_len+1)\\n            remaining = len(target) - target_idx\\n    \\n            for hist_idx in range(target_idx, word_len-remaining+1):\\n                c_freq = histograms[hist_idx][c]\\n                dp[hist_idx+1] = ((c_freq * previous_dp[hist_idx]) + dp[hist_idx]) % self.MOD\\n\\n            previous_dp = dp\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244687,
                "title": "c-freq-count-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    vector<vector<int>>v;\\n    int dp[1001][1001];\\n    ll get(int i,int k,string &t)\\n    {\\n        if(i>=t.size())\\n            return 1;\\n        if(k>=v.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=(v[k][t[i]-\\'a\\']*get(i+1,k+1,t))%mod;\\n        res=(res+get(i,k+1,t))%mod;\\n        return dp[i][k]=res;\\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=words[0].size();\\n        v.resize(n,vector<int>(26,0));\\n        for(auto w:words)\\n        {\\n            for(int i=0;i<n;i++)\\n                v[i][w[i]-\\'a\\']++;\\n        }\\n        return get(0,0,target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    vector<vector<int>>v;\\n    int dp[1001][1001];\\n    ll get(int i,int k,string &t)\\n    {\\n        if(i>=t.size())\\n            return 1;\\n        if(k>=v.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=(v[k][t[i]-\\'a\\']*get(i+1,k+1,t))%mod;\\n        res=(res+get(i,k+1,t))%mod;\\n        return dp[i][k]=res;\\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=words[0].size();\\n        v.resize(n,vector<int>(26,0));\\n        for(auto w:words)\\n        {\\n            for(int i=0;i<n;i++)\\n                v[i][w[i]-\\'a\\']++;\\n        }\\n        return get(0,0,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101522,
                "title": "python3-top-down-dp",
                "content": "**Algo**\\n1) Collect frequency table of each column of `words`. \\n2) Define `fn(i, k)` as the number of ways to form `target[i:]` with letters starting from `k`th column; \\n\\t2.1) The key recursive relationship is `fn(i, k) = freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)` where the 1st term takes the letter from `k`th column and the 2nd term skips `k`th column. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        freq = [defaultdict(int) for _ in range(len(words[0]))]\\n        for word in words: \\n            for i, c in enumerate(word): \\n                freq[i][c] += 1\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return number of ways to form target[i:] w/ col k.\"\"\"\\n            if i == len(target): return 1\\n            if k == len(words[0]): return 0 \\n            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)\\n        \\n        return fn(0, 0) % 1_000_000_007\\n``` \\n\\n**Analysis**\\nTime complexity `O(MN + TN)`\\nSpace complexity `O(TN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        freq = [defaultdict(int) for _ in range(len(words[0]))]\\n        for word in words: \\n            for i, c in enumerate(word): \\n                freq[i][c] += 1\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return number of ways to form target[i:] w/ col k.\"\"\"\\n            if i == len(target): return 1\\n            if k == len(words[0]): return 0 \\n            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)\\n        \\n        return fn(0, 0) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917792,
                "title": "python-dp-memorisation",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m = len(words[0])\\n        rec = [defaultdict(int) for _ in range(m)]\\n        for i in range(len(words)):\\n            for j in range(m):\\n                rec[j][words[i][j]] += 1\\n                \\n        @lru_cache(None)\\n        def ways(ind, t):\\n            if t >= len(target):\\n                return 1\\n            if (ind >= m): return 0\\n            ans = 0\\n            ans += ways(ind + 1, t + 1) * rec[ind][target[t]]\\n            ans += ways(ind + 1, t)\\n            return ans\\n        mod = int(1e9+7)\\n        return ways(0, 0) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m = len(words[0])\\n        rec = [defaultdict(int) for _ in range(m)]\\n        for i in range(len(words)):\\n            for j in range(m):\\n                rec[j][words[i][j]] += 1\\n                \\n        @lru_cache(None)\\n        def ways(ind, t):\\n            if t >= len(target):\\n                return 1\\n            if (ind >= m): return 0\\n            ans = 0\\n            ans += ways(ind + 1, t + 1) * rec[ind][target[t]]\\n            ans += ways(ind + 1, t)\\n            return ans\\n        mod = int(1e9+7)\\n        return ways(0, 0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917673,
                "title": "python-top-down-dp-w-memoization-and-optimization",
                "content": "The state is i,j the index we are currently in for words and target. We can just have one index i for all words in words array because of constraint. Using one index in words nullifies all previous indices. Only look forwards. At each state, two choices, use the index if possible, and don\\'t use the index. \\n\\nTop Down DP w/ memoization doesn\\'t work by itself. Too slow to iterate through all words and check if index of each word matches index at target. So instead, keep array of dictionaries indexLetters[i][elem] which tells you the count of letters at index i in words. i.e. words = [\"acca\",\"bbbb\",\"caca\"] -> [i=0:{a:2,c:2},i=1:{b:4},i=2:{a:2,c:2}]. \\n\\nO(n^2),O(n^2) time and space. \\n\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        indexLetters = [defaultdict(int) for _ in range(len(words[0]))]\\n        for word in words:\\n            for i,elem in enumerate(word):\\n                indexLetters[i][elem] += 1\\n        \\n        @lru_cache(None)\\n        def helper(i,j): # i indexes words, j indexes target\\n            if i == len(words[0]):  \\n                if j == len(target):\\n                    return 1\\n                else:\\n                    return 0\\n            elif j == len(target):\\n                return 1\\n            else:\\n                count = helper(i+1,j) # don\\'t use this index\\n                indexLetterCount = indexLetters[i][target[j]]\\n                if indexLetterCount != 0:\\n                    count += indexLetterCount*helper(i+1,j+1) # use this index\\n                return count\\n        \\n        return helper(0,0) % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        indexLetters = [defaultdict(int) for _ in range(len(words[0]))]\\n        for word in words:\\n            for i,elem in enumerate(word):\\n                indexLetters[i][elem] += 1\\n        \\n        @lru_cache(None)\\n        def helper(i,j): # i indexes words, j indexes target\\n            if i == len(words[0]):  \\n                if j == len(target):\\n                    return 1\\n                else:\\n                    return 0\\n            elif j == len(target):\\n                return 1\\n            else:\\n                count = helper(i+1,j) # don\\'t use this index\\n                indexLetterCount = indexLetters[i][target[j]]\\n                if indexLetterCount != 0:\\n                    count += indexLetterCount*helper(i+1,j+1) # use this index\\n                return count\\n        \\n        return helper(0,0) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783799,
                "title": "recursion-memoization",
                "content": "**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n\\n# Recursion\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    public int numWays(String[] words, String target) {\\n        return numWays(words,target,0,0);\\n    }\\n    public int numWays(String[] words, String target, int currentWord, int targetIndex) {\\n        if(targetIndex>=target.length()){\\n            return 1;\\n        }\\n        if(currentWord>=words[0].length() ||  (words[0].length()-currentWord)<(target.length()-targetIndex)){\\n              return 0;\\n          }\\n        long count=0;\\n        long notInclude=(numWays(words,target,currentWord+1,targetIndex))%mod;\\n        for(int i=0; i<words.length ; i++){\\n            if(words[i].charAt(currentWord)==target.charAt(targetIndex)){\\n               count++;\\n            }\\n        }\\n        long include=((count%mod)*(numWays(words,target,currentWord+1,targetIndex+1))%mod)%mod;\\n        return (int)(include+notInclude)%mod;\\n    }\\n}\\n```\\n______\\n# Memoization\\n```\\nclass Solution {\\n    Integer[][] memo;\\n    int mod=1000000007;\\n    public int numWays(String[] words, String target) {\\n        memo=new Integer[words[0].length()][target.length()];\\n        return numWays(words,target,0,0);\\n    }\\n    public int numWays(String[] words, String target, int currentWord, int targetIndex) {\\n        if(targetIndex>=target.length()){\\n            return 1;\\n        }\\n        if(currentWord>=words[0].length() ||  (words[0].length()-currentWord)<(target.length()-targetIndex)){\\n              return 0;\\n        }\\n        if(memo[currentWord][targetIndex]!=null){\\n            return memo[currentWord][targetIndex];\\n        }\\n        long count=0;\\n        long notInclude=(numWays(words,target,currentWord+1,targetIndex))%mod;\\n        for(int i=0; i<words.length ; i++){\\n            if(words[i].charAt(currentWord)==target.charAt(targetIndex)){\\n               count++;\\n            }\\n        }\\n        long include=((count%mod)*(numWays(words,target,currentWord+1,targetIndex+1))%mod)%mod;\\n        return memo[currentWord][targetIndex] = (int)(include+notInclude)%mod;\\n    }\\n}\\n```\\n________\\n**Up Vote if Helps**![image.png](https://assets.leetcode.com/users/images/23d8443e-ac59-49d5-99f0-9273a2147be2_1687635435.0337658.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int numWays(String[] words, String target) {\\n        return numWays(words,target,0,0);\\n    }\\n    public int numWays(String[] words, String target, int currentWord, int targetIndex) {\\n        if(targetIndex>=target.length()){\\n            return 1;\\n        }\\n        if(currentWord>=words[0].length() ||  (words[0].length()-currentWord)<(target.length()-targetIndex)){\\n              return 0;\\n          }\\n        long count=0;\\n        long notInclude=(numWays(words,target,currentWord+1,targetIndex))%mod;\\n        for(int i=0; i<words.length ; i++){\\n            if(words[i].charAt(currentWord)==target.charAt(targetIndex)){\\n               count++;\\n            }\\n        }\\n        long include=((count%mod)*(numWays(words,target,currentWord+1,targetIndex+1))%mod)%mod;\\n        return (int)(include+notInclude)%mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    int mod=1000000007;\\n    public int numWays(String[] words, String target) {\\n        memo=new Integer[words[0].length()][target.length()];\\n        return numWays(words,target,0,0);\\n    }\\n    public int numWays(String[] words, String target, int currentWord, int targetIndex) {\\n        if(targetIndex>=target.length()){\\n            return 1;\\n        }\\n        if(currentWord>=words[0].length() ||  (words[0].length()-currentWord)<(target.length()-targetIndex)){\\n              return 0;\\n        }\\n        if(memo[currentWord][targetIndex]!=null){\\n            return memo[currentWord][targetIndex];\\n        }\\n        long count=0;\\n        long notInclude=(numWays(words,target,currentWord+1,targetIndex))%mod;\\n        for(int i=0; i<words.length ; i++){\\n            if(words[i].charAt(currentWord)==target.charAt(targetIndex)){\\n               count++;\\n            }\\n        }\\n        long include=((count%mod)*(numWays(words,target,currentWord+1,targetIndex+1))%mod)%mod;\\n        return memo[currentWord][targetIndex] = (int)(include+notInclude)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432000,
                "title": "java-pick-not-pick-recursion-with-dp-with-code-comments-easy",
                "content": "#      class Solution {\\n    int mod=(int)1e9+7;\\n    public long rec(int j,int i,String[] words,String target,int n,int m,long[][] dp,int[][] fre)\\n    {\\n        if(i==m) // i runs on target\\n            return 1;\\n        if(j==n) // j runs on column number of words array\\n            return 0;\\n        if(dp[j][i]!=-1)\\n            return dp[j][i];\\n        long pick=0;\\n        long notpick=0;\\n        char ch=target.charAt(i);\\n            if(fre[ch-\\'a\\'][j]>0) // same character is present in column no j\\n            {   \\n                    pick=(fre[ch-\\'a\\'][j]*rec(j+1,i+1,words,target,n,m,dp,fre))%mod;\\n            }\\n            notpick=rec(j+1,i,words,target,n,m,dp,fre)%mod;\\n        return dp[j][i]=(pick+notpick)%mod;\\n    }\\n    public int numWays(String[] words, String target) {\\n        int n=words[0].length();\\n        int i=0;\\n        int[][] fre=new int[26][n]; // calculating frequency column wise\\n        while(i<n)\\n        {\\n            for(String str:words)\\n            {\\n                char ch=str.charAt(i);\\n                fre[ch-\\'a\\'][i]++;            \\n            }\\n            i++;\\n        }\\n        int m=target.length();\\n        if(n<m)\\n            return 0;\\n        long[][] dp=new long[n+1][m+1];\\n        for(long[] arr:dp)\\n        {\\n            Arrays.fill(arr,-1);\\n        }\\n        return (int)rec(0,0,words,target,n,m,dp,fre);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int mod=(int)1e9+7;\\n    public long rec(int j,int i,String[] words,String target,int n,int m,long[][] dp,int[][] fre)\\n    {\\n        if(i==m) // i runs on target\\n            return 1;\\n        if(j==n) // j runs on column number of words array\\n            return 0;\\n        if(dp[j][i]!=-1)\\n            return dp[j][i];\\n        long pick=0;\\n        long notpick=0;\\n        char ch=target.charAt(i);\\n            if(fre[ch-\\'a\\'][j]>0) // same character is present in column no j\\n            {   \\n                    pick=(fre[ch-\\'a\\'][j]*rec(j+1,i+1,words,target,n,m,dp,fre))%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3425263,
                "title": "why-one-of-my-approach-is-tle-while-i-think-these-two-have-same-time-complexity",
                "content": "I personally think these two should have same time complexity,\\nbut finally the first one will lead to TLE. Can anyone help me figure out why this condition happened ?\\n```\\nclass Solution {\\npublic:\\n    int n,m, mod = pow(10,9)+7;\\n    int numWays(vector<string>& words, string target) {\\n        n = words.size(), m = target.size();\\n        vector<vector<int>> g(words[0].size()+1,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<words[i].size();j++)\\n                g[j][words[i][j]-\\'a\\']++;\\n            \\n        vector<vector<int>> dp(m, vector<int>(words[0].size()+1, -1));\\n        int ans = dfs(target, 0, 0, dp, g);\\n        return ans;\\n       \\n    }\\n    int dfs(string& target, int id, int k, vector<vector<int>>& dp, vector<vector<int>>& g){\\n        if(id == m)\\n            return 1;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long count = 0;\\n        for(int i=k;i<g.size();i++){\\n            if(g[i][target[id]-\\'a\\']!=0){\\n                count = (count + (long long)g[i][target[id]-\\'a\\']*dfs(target, id+1, i+1, dp, g))%mod;\\n            }\\n        }\\n        return dp[id][k] = count%mod;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m, mod = pow(10,9)+7;\\n    int numWays(vector<string>& words, string target) {\\n        n = words.size(), m = target.size();\\n        vector<vector<int>> g(words[0].size()+1,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<words[i].size();j++)\\n                g[j][words[i][j]-\\'a\\']++;\\n            \\n        vector<vector<int>> dp(m, vector<int>(words[0].size()+1, -1));\\n        return dfs(target, 0, 0, dp, g);\\n    }\\n    int dfs(string& target, int id, int k, vector<vector<int>>& dp, vector<vector<int>>& g){\\n        if(id == m)\\n            return 1;\\n        if(k == g.size())\\n            return 0;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long count = 0;\\n        count = dfs(target, id+1, k+1, dp, g)*(long)g[k][target[id]-\\'a\\'];\\n        count += dfs(target, id, k+1, dp, g);\\n        return dp[id][k] = count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m, mod = pow(10,9)+7;\\n    int numWays(vector<string>& words, string target) {\\n        n = words.size(), m = target.size();\\n        vector<vector<int>> g(words[0].size()+1,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<words[i].size();j++)\\n                g[j][words[i][j]-\\'a\\']++;\\n            \\n        vector<vector<int>> dp(m, vector<int>(words[0].size()+1, -1));\\n        int ans = dfs(target, 0, 0, dp, g);\\n        return ans;\\n       \\n    }\\n    int dfs(string& target, int id, int k, vector<vector<int>>& dp, vector<vector<int>>& g){\\n        if(id == m)\\n            return 1;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long count = 0;\\n        for(int i=k;i<g.size();i++){\\n            if(g[i][target[id]-\\'a\\']!=0){\\n                count = (count + (long long)g[i][target[id]-\\'a\\']*dfs(target, id+1, i+1, dp, g))%mod;\\n            }\\n        }\\n        return dp[id][k] = count%mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n,m, mod = pow(10,9)+7;\\n    int numWays(vector<string>& words, string target) {\\n        n = words.size(), m = target.size();\\n        vector<vector<int>> g(words[0].size()+1,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<words[i].size();j++)\\n                g[j][words[i][j]-\\'a\\']++;\\n            \\n        vector<vector<int>> dp(m, vector<int>(words[0].size()+1, -1));\\n        return dfs(target, 0, 0, dp, g);\\n    }\\n    int dfs(string& target, int id, int k, vector<vector<int>>& dp, vector<vector<int>>& g){\\n        if(id == m)\\n            return 1;\\n        if(k == g.size())\\n            return 0;\\n        if(dp[id][k]!=-1)\\n            return dp[id][k];\\n        long long count = 0;\\n        count = dfs(target, id+1, k+1, dp, g)*(long)g[k][target[id]-\\'a\\'];\\n        count += dfs(target, id, k+1, dp, g);\\n        return dp[id][k] = count%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424725,
                "title": "memoized-solution-dp-c",
                "content": "```\\nclass Solution {\\n    long dfs(int i, int j, int n, int m, vector<unordered_map<char, int>> &v, string &t, int mod, vector<vector<int>> &dp) {\\n        if(j == m) return 1;\\n        if(i == n) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        long  pick = v[i][t[j]] * dfs(i + 1, j + 1, n, m, v, t, mod, dp);\\n        long notpick = dfs(i + 1, j, n, m, v, t, mod, dp);\\n\\n        return dp[i][j] = (pick + notpick) % mod;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size(),  mod = 1e9 + 7;\\n        vector<unordered_map<char, int>> v(n, unordered_map<char, int>());\\n\\n        for(string w : words) {\\n            for(int i=0; i<n; i++) v[i][w[i]]++;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return dfs(0, 0, n, m, v, target, mod, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long dfs(int i, int j, int n, int m, vector<unordered_map<char, int>> &v, string &t, int mod, vector<vector<int>> &dp) {\\n        if(j == m) return 1;\\n        if(i == n) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        long  pick = v[i][t[j]] * dfs(i + 1, j + 1, n, m, v, t, mod, dp);\\n        long notpick = dfs(i + 1, j, n, m, v, t, mod, dp);\\n\\n        return dp[i][j] = (pick + notpick) % mod;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size(),  mod = 1e9 + 7;\\n        vector<unordered_map<char, int>> v(n, unordered_map<char, int>());\\n\\n        for(string w : words) {\\n            for(int i=0; i<n; i++) v[i][w[i]]++;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        return dfs(0, 0, n, m, v, target, mod, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424473,
                "title": "easy-and-fast-c-solution-with-explanation",
                "content": "# Intuition\\nThe problem asks us to find the number of ways to form the target string using characters from the given list of words. We can use dynamic programming to solve this problem.\\n\\n# Approach\\nWe can use a dynamic programming approach to solve this problem. We can create a **dp** array of size equal to the length of the **target** string. **dp[i]** represents the number of ways to form the target string up to index **i** using characters from the given list of **words**.\\n\\nWe iterate over each position in the **words** and calculate the frequency of each letter at that position. Then we iterate over each character in the **target** string in reverse order and update **dp[targetIndex]** if the current character in **target** matches a character in **words** at the current position.\\n\\nThe final result is stored in **dp[dp.Length - 1]**.\\n\\n# Complexity\\n- Time complexity: $$O(n\\u2217m)$$ where $$n$$ is the length of **words[0]** and $$m$$ is the length of **target**.\\n\\n- Space complexity: $$O(m)$$ where $$m$$ is the length of **target**.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    private const long Modulus = 1000000007;\\n\\n    public int NumWays(string[] words, string target)\\n    {\\n        long[] dp = new long[target.Length];\\n\\n        for (int position = 0; position < words[0].Length; position++)\\n        {\\n            int[] letterFrequency = CalculateLetterFrequencyAtPosition(words, position);\\n\\n            for (int targetIndex = Math.Min(position, target.Length - 1); targetIndex >= 0; targetIndex--)\\n            {\\n                int letterIndex = target[targetIndex] - \\'a\\';\\n                if (letterFrequency[letterIndex] > 0)\\n                {\\n                    dp[targetIndex] += (targetIndex == 0) ? letterFrequency[letterIndex] : dp[targetIndex - 1] * letterFrequency[letterIndex];\\n                    dp[targetIndex] %= Modulus;\\n                }\\n            }\\n        }\\n\\n        return (int)dp[dp.Length - 1];\\n    }\\n\\n    private int[] CalculateLetterFrequencyAtPosition(string[] words, int position)\\n    {\\n        int[] letterFrequency = new int[26];\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            letterFrequency[words[i][position] - \\'a\\']++;\\n        }\\n        return letterFrequency;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    private const long Modulus = 1000000007;\\n\\n    public int NumWays(string[] words, string target)\\n    {\\n        long[] dp = new long[target.Length];\\n\\n        for (int position = 0; position < words[0].Length; position++)\\n        {\\n            int[] letterFrequency = CalculateLetterFrequencyAtPosition(words, position);\\n\\n            for (int targetIndex = Math.Min(position, target.Length - 1); targetIndex >= 0; targetIndex--)\\n            {\\n                int letterIndex = target[targetIndex] - \\'a\\';\\n                if (letterFrequency[letterIndex] > 0)\\n                {\\n                    dp[targetIndex] += (targetIndex == 0) ? letterFrequency[letterIndex] : dp[targetIndex - 1] * letterFrequency[letterIndex];\\n                    dp[targetIndex] %= Modulus;\\n                }\\n            }\\n        }\\n\\n        return (int)dp[dp.Length - 1];\\n    }\\n\\n    private int[] CalculateLetterFrequencyAtPosition(string[] words, int position)\\n    {\\n        int[] letterFrequency = new int[26];\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            letterFrequency[words[i][position] - \\'a\\']++;\\n        }\\n        return letterFrequency;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424128,
                "title": "java-dp-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndynamic programmin concepts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    long MOD = 1000000007;\\n    public int numWays(String[] words, String target) {\\n        \\n        int len = target.length();\\n        int max = words[0].length();\\n        \\n        int[][] charFrequency = new int[max][26];\\n\\t\\t// creating table for each character upto some point\\n        for (String word : words) {\\n            for (int i = 0; i < max; i++) {\\n                charFrequency[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        long[][] dp = new long[len+1][max+1];\\n\\t\\t// filling first row of array with 1\\n        dp[0] = LongStream.range(0, max+1).map(e->1).toArray();\\n        \\n        for (int i = 1; i <= len; i++) {            \\n            for (int ch = i; ch <= max + i - len; ch++) {\\n                dp[i][ch] = (dp[i-1][ch-1] * \\n                    charFrequency[ch-1][target.charAt(i - 1)-\\'a\\']% MOD + dp[i][ch-1])%MOD;\\n            }\\n        }\\n        System.out.println(Arrays.deepToString(dp));\\n        \\n        return (int) dp[len][max];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    long MOD = 1000000007;\\n    public int numWays(String[] words, String target) {\\n        \\n        int len = target.length();\\n        int max = words[0].length();\\n        \\n        int[][] charFrequency = new int[max][26];\\n\\t\\t// creating table for each character upto some point\\n        for (String word : words) {\\n            for (int i = 0; i < max; i++) {\\n                charFrequency[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        long[][] dp = new long[len+1][max+1];\\n\\t\\t// filling first row of array with 1\\n        dp[0] = LongStream.range(0, max+1).map(e->1).toArray();\\n        \\n        for (int i = 1; i <= len; i++) {            \\n            for (int ch = i; ch <= max + i - len; ch++) {\\n                dp[i][ch] = (dp[i-1][ch-1] * \\n                    charFrequency[ch-1][target.charAt(i - 1)-\\'a\\']% MOD + dp[i][ch-1])%MOD;\\n            }\\n        }\\n        System.out.println(Arrays.deepToString(dp));\\n        \\n        return (int) dp[len][max];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423757,
                "title": "java-naive-recursion-brute-force-approach",
                "content": "```\\n// Approach 1: Naive Recursion (Brute Force) - TLE\\n\\nclass Solution {\\n    int[][] count;\\n    int MOD = (int) (Math.pow(10, 9) + 7);\\n    \\n    public int numWays(String[] words, String target) {\\n        count = new int[26][words[0].length()];\\n        \\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                count[word.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n        \\n        return (int) dfs(target, 0, 0);\\n    }\\n    \\n    private long dfs(String target, int i, int k) {\\n        if (k == target.length())\\n            return 1;\\n        \\n        if (i == count[0].length)\\n            return 0;\\n        \\n        long res = dfs(target, i + 1, k);  \\n        res += count[target.charAt(k) - \\'a\\'][i] * dfs(target, i + 1, k + 1);\\n        \\n        return res % MOD;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Approach 1: Naive Recursion (Brute Force) - TLE\\n\\nclass Solution {\\n    int[][] count;\\n    int MOD = (int) (Math.pow(10, 9) + 7);\\n    \\n    public int numWays(String[] words, String target) {\\n        count = new int[26][words[0].length()];\\n        \\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                count[word.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n        \\n        return (int) dfs(target, 0, 0);\\n    }\\n    \\n    private long dfs(String target, int i, int k) {\\n        if (k == target.length())\\n            return 1;\\n        \\n        if (i == count[0].length)\\n            return 0;\\n        \\n        long res = dfs(target, i + 1, k);  \\n        res += count[target.charAt(k) - \\'a\\'][i] * dfs(target, i + 1, k + 1);\\n        \\n        return res % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423728,
                "title": "easy-dp-approach-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp(int grt,int ind,int n, map<int,map<char,int>>& v, string &tar,vector<vector<int>>&t){\\n    \\n     if(ind==tar.size())return 1;\\n   if(n==grt)return 0;\\n   if(t[grt][ind]!=-1)return t[grt][ind];\\n   long long int res=0,M=1e9+7;\\n\\n // if it is taken\\n\\n res+=(((v[grt][tar[ind]])%M)*(dp(grt+1,ind+1,n,v,tar,t)%M))%M;\\n\\n// if not taken \\n\\n   res+=(dp(grt+1,ind,n,v,tar,t)%M);\\n   return t[grt][ind]= res%M;\\n}\\n    int numWays(vector<string>& v, string tar) {\\n\\n// to store frequency map is declared\\n\\n        map<int,map<char,int>>m;\\n        if(tar.size()>v[0].size())return 0;\\n        vector<vector<int>>t(v[0].size()+2,vector<int>(tar.size(),-1));\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<v[0].size();j++){\\n                m[j][v[i][j]]++;\\n            }\\n        }\\n           long long int M=1e9+7;\\n       return  dp(0,0,v[0].size(),m,tar,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp(int grt,int ind,int n, map<int,map<char,int>>& v, string &tar,vector<vector<int>>&t){\\n    \\n     if(ind==tar.size())return 1;\\n   if(n==grt)return 0;\\n   if(t[grt][ind]!=-1)return t[grt][ind];\\n   long long int res=0,M=1e9+7;\\n\\n // if it is taken\\n\\n res+=(((v[grt][tar[ind]])%M)*(dp(grt+1,ind+1,n,v,tar,t)%M))%M;\\n\\n// if not taken \\n\\n   res+=(dp(grt+1,ind,n,v,tar,t)%M);\\n   return t[grt][ind]= res%M;\\n}\\n    int numWays(vector<string>& v, string tar) {\\n\\n// to store frequency map is declared\\n\\n        map<int,map<char,int>>m;\\n        if(tar.size()>v[0].size())return 0;\\n        vector<vector<int>>t(v[0].size()+2,vector<int>(tar.size(),-1));\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<v[0].size();j++){\\n                m[j][v[i][j]]++;\\n            }\\n        }\\n           long long int M=1e9+7;\\n       return  dp(0,0,v[0].size(),m,tar,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423642,
                "title": "intuitive-java-dp-solution-with-explanation",
                "content": "# Approach\\nWe store a dp 2D array where each element `[i, j]` corresponds to how many solutions we\\'ve found where we look at current index `i` of a word in the dictionary and we\\'ve matched `j` characters from target. \\n\\nWe then recursively loop over the words and each time we find a matching character at index `index` in words and `targetIndex` in target, we recursively call for `index + 1` and `targetIndex + 1`. After that, we also call for `index` and `targetIndex + 1` outside the for loop, for the case where at position `index` in words, none of the characters match the current character in target.\\n\\nBase cases are:\\n- when `targetIndex` reached the length of target i.e. we matched all characters of `target`, we return 1\\n- when the amount of characters left in target is grater than the amount of indexes left to check in words, we return 0\\n- when we have visited the problem before, hence return the `dp` solution of the subproblem\\n\\nAlso, make sure to add `% 10^9 + 7` for each modification of the `dp` array, and also make the `dp` array long to avoid overflows. Also make sure to cast the result back to int.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long[][] dp = new long[words[0].length()][target.length()];\\n        boolean[][] dpVisited = new boolean[words[0].length()][target.length()];\\n\\n        return (int) (rec(dp, dpVisited, words, target, 0, 0) % 1000000007);\\n    }\\n\\n    private long rec(long[][] dp, boolean[][] dpVisited, String[] words, String target, int index, int targetIndex){\\n        if(targetIndex == target.length()) return 1;\\n        if(target.length() - targetIndex > words[0].length() - index) return 0;\\n        if(dpVisited[index][targetIndex]) return dp[index][targetIndex];\\n\\n        dpVisited[index][targetIndex] = true;\\n\\n        for(String word: words){\\n            if(word.charAt(index) == target.charAt(targetIndex)) {\\n                dp[index][targetIndex] += rec(dp, dpVisited, words, target, index + 1, targetIndex + 1) % 1000000007;\\n            }\\n        }\\n        dp[index][targetIndex] += rec(dp, dpVisited, words, target, index + 1, targetIndex) % 1000000007;\\n        \\n        return dp[index][targetIndex];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long[][] dp = new long[words[0].length()][target.length()];\\n        boolean[][] dpVisited = new boolean[words[0].length()][target.length()];\\n\\n        return (int) (rec(dp, dpVisited, words, target, 0, 0) % 1000000007);\\n    }\\n\\n    private long rec(long[][] dp, boolean[][] dpVisited, String[] words, String target, int index, int targetIndex){\\n        if(targetIndex == target.length()) return 1;\\n        if(target.length() - targetIndex > words[0].length() - index) return 0;\\n        if(dpVisited[index][targetIndex]) return dp[index][targetIndex];\\n\\n        dpVisited[index][targetIndex] = true;\\n\\n        for(String word: words){\\n            if(word.charAt(index) == target.charAt(targetIndex)) {\\n                dp[index][targetIndex] += rec(dp, dpVisited, words, target, index + 1, targetIndex + 1) % 1000000007;\\n            }\\n        }\\n        dp[index][targetIndex] += rec(dp, dpVisited, words, target, index + 1, targetIndex) % 1000000007;\\n        \\n        return dp[index][targetIndex];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423480,
                "title": "c-hashing-dp-won-t-need-any-editorial-after-this",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Step 1\\n    - At first I made an array hash of words[0] sized whose each element is a map.\\n    - `map<char,int> hash[words[0].size()];`\\n    - Basically I want to store frequency of every character for each `i` from `0 to words[0].size()`\\n    - ```\\n      for(int i=0; i<words.size(); i++){\\n        for(int j=0; j<words[i].size(); j++){\\n            hash[j][words[i][j]]++;\\n        }\\n      }\\n    - If `words = [\"abba\",\"abfd\",\"bcaa\"]` then the hash container will look like\\n    - For `i=0 -> [a-2, b-1]`\\n    - For `i=1 -> [b-2, c-1]`\\n    - For `i=2 -> [a-1, b-1, f-1]`\\n    - For `i=3 -> [a-2, d-1]`\\n    \\n1. Step 2\\n    - Now set `i=0 and j=0`\\n    - In recursion there is two option.\\n    - Option 1 is for each `i` just check if `hash[i][target[j]] > 0` means on `ith index` there is some character that matches with `target[j]`. If it is then do ->\\n      - `take=hash[i][target[j]] * ex(i+1,j+1,n,hash,target,dp);`\\n    - Reason behind multiplying by frequency is, Assume on the `ith index` there is total `7 number of \\'a\\'` where `target[j]=\\'a\\'`then the target word can be made by each `\\'a\\'` through 7 different ways.\\n    - And option 2 is `not_take=ex(i+1,j,n,hash,target,dp);` means I dont want to select the `ith index` for making the target word.\\n    - Base case will be :-\\n    - ```\\n      if(j>=target.size()) return 1; // One way found.\\n      if(i>=n) return 0; // Out of words.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(words[0].size() * target.size())` For Recursion\\n`O(words[0].size() * words.size())` For Making the Hash container\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(words[0].size() * target.size())` For DP Table\\n`O(words.size() * 26 sized map at max)` For Making the Hash container\\n\\n![Cute-Puppies.3.meme.webp](https://assets.leetcode.com/users/images/042b3f73-9642-4159-a0d6-666874a76664_1681647280.383377.webp)\\n\\n# Code\\n```\\nclass Solution {\\nint mod=1e9+7;\\n\\nprivate:\\n    long long ex(int i, int j, int n, map<char,int> *hash, string &target, vector<vector<int>> &dp){\\n        if(j>=target.size()) return 1;\\n        if(i>=n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        long long ans=0;\\n        if(hash[i][target[j]]>0){\\n            long long take=hash[i][target[j]]*ex(i+1,j+1,n,hash,target,dp)%mod;\\n            ans=(ans+take)%mod;\\n        }\\n        long long not_take=ex(i+1,j,n,hash,target,dp)%mod;\\n        ans=(ans+not_take)%mod;\\n\\n        return dp[i][j]=ans;\\n    }\\n\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        map<char,int> hash[words[0].size()];\\n        for(int i=0; i<words.size(); i++){\\n            for(int j=0; j<words[i].size(); j++){\\n                hash[j][words[i][j]]++;\\n            }\\n        }\\n\\n        vector<vector<int>> dp(words[0].size(), vector<int>(target.size(),-1));\\n        return (int)ex(0,0,words[0].size(),hash,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n      for(int i=0; i<words.size(); i++){\\n        for(int j=0; j<words[i].size(); j++){\\n            hash[j][words[i][j]]++;\\n        }\\n      }\\n    - If `words = [\"abba\",\"abfd\",\"bcaa\"]` then the hash container will look like\\n    - For `i=0 -> [a-2, b-1]`\\n    - For `i=1 -> [b-2, c-1]`\\n    - For `i=2 -> [a-1, b-1, f-1]`\\n    - For `i=3 -> [a-2, d-1]`\\n    \\n1. Step 2\\n    - Now set `i=0 and j=0`\\n    - In recursion there is two option.\\n    - Option 1 is for each `i` just check if `hash[i][target[j]] > 0` means on `ith index` there is some character that matches with `target[j]`. If it is then do ->\\n      - `take=hash[i][target[j]] * ex(i+1,j+1,n,hash,target,dp);`\\n    - Reason behind multiplying by frequency is, Assume on the `ith index` there is total `7 number of \\'a\\'` where `target[j]=\\'a\\'`then the target word can be made by each `\\'a\\'` through 7 different ways.\\n    - And option 2 is `not_take=ex(i+1,j,n,hash,target,dp);` means I dont want to select the `ith index` for making the target word.\\n    - Base case will be :-\\n    - ```\n```\\nclass Solution {\\nint mod=1e9+7;\\n\\nprivate:\\n    long long ex(int i, int j, int n, map<char,int> *hash, string &target, vector<vector<int>> &dp){\\n        if(j>=target.size()) return 1;\\n        if(i>=n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        long long ans=0;\\n        if(hash[i][target[j]]>0){\\n            long long take=hash[i][target[j]]*ex(i+1,j+1,n,hash,target,dp)%mod;\\n            ans=(ans+take)%mod;\\n        }\\n        long long not_take=ex(i+1,j,n,hash,target,dp)%mod;\\n        ans=(ans+not_take)%mod;\\n\\n        return dp[i][j]=ans;\\n    }\\n\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        map<char,int> hash[words[0].size()];\\n        for(int i=0; i<words.size(); i++){\\n            for(int j=0; j<words[i].size(); j++){\\n                hash[j][words[i][j]]++;\\n            }\\n        }\\n\\n        vector<vector<int>> dp(words[0].size(), vector<int>(target.size(),-1));\\n        return (int)ex(0,0,words[0].size(),hash,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423454,
                "title": "java-solution-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce an index is visited we cannot pick any character behind that index. So keeping a track of the character that is required and the frequency of that character at a given index ,we can find a recursive solution to solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion + DP\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    static long dp[][];\\n    static long div=(long)1e9 +7;\\n    static int count[][];\\n    public static int numWays(String[] words, String target) {\\n        int n=target.length();\\n        int m=words[0].length();\\n        int m1=words.length;\\n        dp=new long[n][m];\\n        count=new int[m][26];\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) dp[i][j]=-1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<m1;j++){\\n                count[i][words[j].charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return (int)func(target,words,0,0);\\n    }\\n    public static long func(String target,String words[],int ind1,int ind2)\\n    {\\n        int n=target.length();\\n        int m=words[0].length();\\n        if(m-ind2<n-ind1) return 0;\\n        if(ind1>=n) return 1;\\n        if(ind2>=m) return 0;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        long k1=0;\\n        long c=count[ind2][target.charAt(ind1)-\\'a\\'];\\n        if(c!=0) k1+=((c%div)*(func(target,words,ind1+1,ind2+1))%div)%div;\\n        k1+=func(target,words,ind1,ind2+1)%div;\\n        return dp[ind1][ind2]=k1%div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static long dp[][];\\n    static long div=(long)1e9 +7;\\n    static int count[][];\\n    public static int numWays(String[] words, String target) {\\n        int n=target.length();\\n        int m=words[0].length();\\n        int m1=words.length;\\n        dp=new long[n][m];\\n        count=new int[m][26];\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) dp[i][j]=-1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<m1;j++){\\n                count[i][words[j].charAt(i)-\\'a\\']++;\\n            }\\n        }\\n        return (int)func(target,words,0,0);\\n    }\\n    public static long func(String target,String words[],int ind1,int ind2)\\n    {\\n        int n=target.length();\\n        int m=words[0].length();\\n        if(m-ind2<n-ind1) return 0;\\n        if(ind1>=n) return 1;\\n        if(ind2>=m) return 0;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        long k1=0;\\n        long c=count[ind2][target.charAt(ind1)-\\'a\\'];\\n        if(c!=0) k1+=((c%div)*(func(target,words,ind1+1,ind2+1))%div)%div;\\n        k1+=func(target,words,ind1,ind2+1)%div;\\n        return dp[ind1][ind2]=k1%div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423316,
                "title": "keep-the-frequency-count-handy-from-bruteforce-to-accepted-solution",
                "content": "recursive(TLE)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t)%mod;\\n        int tot = 0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(t[targetindex] == w[i][wordindex])\\n                tot++;\\n        }\\n        \\n        long long int pick = (tot%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t)%mod;\\n        \\n        return (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        \\n        return solve(0,0,w,t);\\n    }\\n};\\n```\\n\\nmemoization(TLE)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t,vector<vector<long long int>> &cache)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        if(cache[targetindex][wordindex]!=-1)\\n            return cache[targetindex][wordindex];\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t,cache)%mod;\\n        int tot = 0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(t[targetindex] == w[i][wordindex])\\n                tot++;\\n        }\\n        \\n        long long int pick = (tot%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t,cache)%mod;\\n        \\n        return cache[targetindex][wordindex] = (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> cache(t.size(),vector<long long int> (w[0].size(),-1));\\n        return solve(0,0,w,t,cache);\\n    }\\n};\\n```\\n\\nmemoization optimised (Acc)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t,vector<vector<long long int>> &cache,vector<vector<long long int>> &freq)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(wordindex >= freq.size())\\n        {\\n            return 0;\\n        }\\n        \\n        if(cache[targetindex][wordindex]!=-1)\\n            return cache[targetindex][wordindex];\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t,cache,freq)%mod;\\n        long long int pick = 0;\\n        int cha = t[targetindex]-\\'a\\';\\n        if(freq[wordindex][cha]!=0){\\n         pick = (freq[wordindex][cha]%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t,cache,freq)%mod;\\n        }\\n        \\n        return cache[targetindex][wordindex] = (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> cache(t.size(),vector<long long int> (w[0].size(),-1));\\n        vector<vector<long long int>> freq(w[0].size(),vector<long long int> (26,0));\\n        \\n        for(int i=0;i<w.size();i++)\\n        {\\n            for(int j=0;j<w[0].size();j++)\\n            {\\n                freq[j][w[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return solve(0,0,w,t,cache,freq);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t)%mod;\\n        int tot = 0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(t[targetindex] == w[i][wordindex])\\n                tot++;\\n        }\\n        \\n        long long int pick = (tot%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t)%mod;\\n        \\n        return (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        \\n        return solve(0,0,w,t);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t,vector<vector<long long int>> &cache)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        if(cache[targetindex][wordindex]!=-1)\\n            return cache[targetindex][wordindex];\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t,cache)%mod;\\n        int tot = 0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(t[targetindex] == w[i][wordindex])\\n                tot++;\\n        }\\n        \\n        long long int pick = (tot%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t,cache)%mod;\\n        \\n        return cache[targetindex][wordindex] = (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> cache(t.size(),vector<long long int> (w[0].size(),-1));\\n        return solve(0,0,w,t,cache);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int solve(int targetindex, int wordindex,vector<string>& w, string &t,vector<vector<long long int>> &cache,vector<vector<long long int>> &freq)\\n    {\\n        if(targetindex >= t.length())\\n            return 1;\\n        if(wordindex >= w[0].length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(wordindex >= freq.size())\\n        {\\n            return 0;\\n        }\\n        \\n        if(cache[targetindex][wordindex]!=-1)\\n            return cache[targetindex][wordindex];\\n        \\n        long long int notpick = solve(targetindex,wordindex+1,w,t,cache,freq)%mod;\\n        long long int pick = 0;\\n        int cha = t[targetindex]-\\'a\\';\\n        if(freq[wordindex][cha]!=0){\\n         pick = (freq[wordindex][cha]%mod)*(long long int)solve(targetindex+1,wordindex+1,w,t,cache,freq)%mod;\\n        }\\n        \\n        return cache[targetindex][wordindex] = (pick+notpick)%mod;\\n        \\n        \\n    }\\n    \\n    int numWays(vector<string>& w, string t) {\\n        vector<vector<long long int>> cache(t.size(),vector<long long int> (w[0].size(),-1));\\n        vector<vector<long long int>> freq(w[0].size(),vector<long long int> (26,0));\\n        \\n        for(int i=0;i<w.size();i++)\\n        {\\n            for(int j=0;j<w[0].size();j++)\\n            {\\n                freq[j][w[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return solve(0,0,w,t,cache,freq);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423284,
                "title": "dp-c-tabulation-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int mod=1e9+7;\\n        int n=target.size();\\n        int m=words[0].size();\\n\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n\\n        unordered_map<int,unordered_map<char,int>> map;\\n\\n        for(auto x:words){\\n            for(int i=0;i<x.size();i++){\\n                map[i][x[i]]++;\\n            }\\n        }\\n        \\n        dp[m-1][n-1]=map[m-1][target[n-1]];\\n\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=dp[i+1][n-1]+map[i][target[n-1]];\\n        }\\n\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=(dp[i+1][j+1]*1LL*map[i][target[j]]+dp[i+1][j])%mod;\\n                dp[i][j]%=mod;\\n            }\\n        }\\n\\n        return dp[0][0];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int mod=1e9+7;\\n        int n=target.size();\\n        int m=words[0].size();\\n\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n\\n        unordered_map<int,unordered_map<char,int>> map;\\n\\n        for(auto x:words){\\n            for(int i=0;i<x.size();i++){\\n                map[i][x[i]]++;\\n            }\\n        }\\n        \\n        dp[m-1][n-1]=map[m-1][target[n-1]];\\n\\n        for(int i=m-2;i>=0;i--){\\n            dp[i][n-1]=dp[i+1][n-1]+map[i][target[n-1]];\\n        }\\n\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                dp[i][j]=(dp[i+1][j+1]*1LL*map[i][target[j]]+dp[i+1][j])%mod;\\n                dp[i][j]%=mod;\\n            }\\n        }\\n\\n        return dp[0][0];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423149,
                "title": "easy-recursive-dp-memoization-solution",
                "content": "# Intuition\\nGive Contraints are very small and all string in word vector are of same length, so we need to store the frequency of all characters at ith index in each string in word vector.\\n\\nAnd then just recursively check for possible combination by taking each character of target one by one.\\n\\n# Complexity\\n- Time complexity:\\nTo store the frequency of characters at ith index = O(word.size()*word[i].length()) \\n\\nDP using Memoization = O(word[i].length()*target.length())\\n\\n- Space complexity:\\nFor frequency matrix = O(word.size()*word[i].length())\\n\\nFor memoization matrix = O(word[i].length()*target.length())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getWays(vector<vector<int>> &memo,vector<vector<int>> &ip,string &tar,int k,int j){\\n        if(memo[k][j]==-1){\\n            if(k==0) return 1;\\n            if(j==0) return 0;\\n            memo[k][j]=0;\\n            for(int i=j-1;i>=k-1;i--){\\n                memo[k][j]=(memo[k][j]+((long long)ip[i][tar[k-1]-\\'a\\']*getWays(memo,ip,tar,k-1,i)%1000000007))%1000000007;\\n            }\\n        }\\n        return memo[k][j];\\n    }\\n\\n    int numWays(vector<string>& wod, string tar) {\\n        int k=wod[0].size()-tar.length()+1;\\n        if(k<=0) return 0;\\n        else{\\n            vector<vector<int>> ip(wod[0].size(),vector<int>(26,0));\\n            for(int i=0;i<wod.size();i++){\\n                for(int j=0;j<wod[0].size();j++){\\n                    ip[j][wod[i][j]-\\'a\\']++;\\n                }\\n            }\\n            vector<vector<int>> memo(tar.length()+1,vector<int>(ip.size()+1,-1));\\n            return getWays(memo,ip,tar,tar.length(),ip.size());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getWays(vector<vector<int>> &memo,vector<vector<int>> &ip,string &tar,int k,int j){\\n        if(memo[k][j]==-1){\\n            if(k==0) return 1;\\n            if(j==0) return 0;\\n            memo[k][j]=0;\\n            for(int i=j-1;i>=k-1;i--){\\n                memo[k][j]=(memo[k][j]+((long long)ip[i][tar[k-1]-\\'a\\']*getWays(memo,ip,tar,k-1,i)%1000000007))%1000000007;\\n            }\\n        }\\n        return memo[k][j];\\n    }\\n\\n    int numWays(vector<string>& wod, string tar) {\\n        int k=wod[0].size()-tar.length()+1;\\n        if(k<=0) return 0;\\n        else{\\n            vector<vector<int>> ip(wod[0].size(),vector<int>(26,0));\\n            for(int i=0;i<wod.size();i++){\\n                for(int j=0;j<wod[0].size();j++){\\n                    ip[j][wod[i][j]-\\'a\\']++;\\n                }\\n            }\\n            vector<vector<int>> memo(tar.length()+1,vector<int>(ip.size()+1,-1));\\n            return getWays(memo,ip,tar,tar.length(),ip.size());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423126,
                "title": "c-solution-recursion-memoization-tabulation",
                "content": "- Store frequency of each character at ith index.\\n- pick (if you pick, instead of making calls frequency times, just multiply the frequency with the single call return value) and not pick for each index.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n     int solveRec(int ind,int x,vector<vector<int>>&arr,string target){\\n       \\n            if(ind==target.size()) return 1;\\n            if(arr.size()-x<target.size() -ind) return 0;\\n             long long  ans=solveRec(ind,x+1,arr,target);\\n\\n             if(arr[x][(target[ind]-\\'a\\')]){\\n                int cnt= arr[x][target[ind]-\\'a\\'];\\n                ans=(ans+(cnt*1ll*solveRec(ind+1,x+1,arr,target))%mod)%mod;\\n              }\\n\\n            return (int)ans%mod;\\n    }\\n\\n    int solveMemo(int ind,int x,vector<vector<int>>&arr,string target,vector<vector<int>>&dp){\\n       \\n            if(ind==target.size()) return 1;\\n            if(arr.size()-x<target.size() -ind) return 0;\\n            if(dp[ind][x]!=-1) return dp[ind][x];\\n             long long  ans=solveMemo(ind,x+1,arr,target,dp);\\n   \\n            if(arr[x][(target[ind]-\\'a\\')]){\\n                int cnt= arr[x][target[ind]-\\'a\\'];\\n                ans=(ans+(cnt*1ll*solveMemo(ind+1,x+1,arr,target,dp))%mod)%mod;\\n            }\\n            \\n        \\n            return dp[ind][x]=(int)ans%mod;\\n        \\n    }\\n    int solveTabu(vector<vector<int>>&arr,string target){\\n\\n            vector<vector<int>>dp(target.size()+1,vector<int>(arr.size()+1,0));\\n            for(int i=0;i<arr.size();i++){\\n                dp[target.size()][i]=1;\\n            }\\n\\n            for(int ind=target.size()-1;ind>=0;ind--){\\n                for(int x=arr.size()-2;x>=0;x--){\\n                    long long  ans=dp[ind][x+1];\\n                    if(arr[x][(target[ind]-\\'a\\')]){\\n                    int cnt= arr[x][target[ind]-\\'a\\'];\\n                    ans=(ans+(cnt*1ll*dp[ind+1][x+1])%mod)%mod;\\n                    }\\n                    dp[ind][x]=(int)ans%mod;\\n                }\\n            }\\n            return dp[0][0];\\n\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>arr(words[0].size()+1,vector<int>(27,0));\\n        for(auto it:words){\\n            for(int i=0;i<it.size();i++){\\n                arr[i][(it[i])-\\'a\\']++;\\n            }\\n        }\\n        vector<vector<int>>dp(target.size()+1,vector<int>(words[0].size()+1,-1));\\n        // return solveRec(0,0,arr,target);\\n        // return solveMemo(0,0,arr,target,dp);\\n        return solveTabu(arr,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n     int solveRec(int ind,int x,vector<vector<int>>&arr,string target){\\n       \\n            if(ind==target.size()) return 1;\\n            if(arr.size()-x<target.size() -ind) return 0;\\n             long long  ans=solveRec(ind,x+1,arr,target);\\n\\n             if(arr[x][(target[ind]-\\'a\\')]){\\n                int cnt= arr[x][target[ind]-\\'a\\'];\\n                ans=(ans+(cnt*1ll*solveRec(ind+1,x+1,arr,target))%mod)%mod;\\n              }\\n\\n            return (int)ans%mod;\\n    }\\n\\n    int solveMemo(int ind,int x,vector<vector<int>>&arr,string target,vector<vector<int>>&dp){\\n       \\n            if(ind==target.size()) return 1;\\n            if(arr.size()-x<target.size() -ind) return 0;\\n            if(dp[ind][x]!=-1) return dp[ind][x];\\n             long long  ans=solveMemo(ind,x+1,arr,target,dp);\\n   \\n            if(arr[x][(target[ind]-\\'a\\')]){\\n                int cnt= arr[x][target[ind]-\\'a\\'];\\n                ans=(ans+(cnt*1ll*solveMemo(ind+1,x+1,arr,target,dp))%mod)%mod;\\n            }\\n            \\n        \\n            return dp[ind][x]=(int)ans%mod;\\n        \\n    }\\n    int solveTabu(vector<vector<int>>&arr,string target){\\n\\n            vector<vector<int>>dp(target.size()+1,vector<int>(arr.size()+1,0));\\n            for(int i=0;i<arr.size();i++){\\n                dp[target.size()][i]=1;\\n            }\\n\\n            for(int ind=target.size()-1;ind>=0;ind--){\\n                for(int x=arr.size()-2;x>=0;x--){\\n                    long long  ans=dp[ind][x+1];\\n                    if(arr[x][(target[ind]-\\'a\\')]){\\n                    int cnt= arr[x][target[ind]-\\'a\\'];\\n                    ans=(ans+(cnt*1ll*dp[ind+1][x+1])%mod)%mod;\\n                    }\\n                    dp[ind][x]=(int)ans%mod;\\n                }\\n            }\\n            return dp[0][0];\\n\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>arr(words[0].size()+1,vector<int>(27,0));\\n        for(auto it:words){\\n            for(int i=0;i<it.size();i++){\\n                arr[i][(it[i])-\\'a\\']++;\\n            }\\n        }\\n        vector<vector<int>>dp(target.size()+1,vector<int>(words[0].size()+1,-1));\\n        // return solveRec(0,0,arr,target);\\n        // return solveMemo(0,0,arr,target,dp);\\n        return solveTabu(arr,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422960,
                "title": "little-solution-speaking-more",
                "content": "```\\nconst int MOD = 1e9+7;\\nconst int N = 1e3+3;\\nint dp[N][N];\\nclass Solution {\\n    int rec(int i, int j, const string &target, int n, vector<unordered_map<char, int> > &kStr, int k){\\n        if(j == n) return 1;\\n        if(n-j > k-i) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int &ans = dp[i][j];\\n        ans = rec(i+1, j, target, n, kStr, k);\\n        unordered_map<char, int> &mp = kStr[i];\\n        if(mp.find(target[j]) != mp.end())\\n            ans = (ans + (1ll*rec(i+1, j+1, target, n, kStr, k)*mp[target[j]])%MOD)%MOD;\\n        return ans;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp, -1, sizeof dp);\\n        int n = words.size(), m = words[0].size();\\n        vector<unordered_map<char, int>> kStr(m);\\n        for(int j = 0; j<m; j++) for(int i = 0; i<n; i++) kStr[j][words[i][j]]++;\\n        return rec(0, 0, target, target.size(), kStr, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = 1e9+7;\\nconst int N = 1e3+3;\\nint dp[N][N];\\nclass Solution {\\n    int rec(int i, int j, const string &target, int n, vector<unordered_map<char, int> > &kStr, int k){\\n        if(j == n) return 1;\\n        if(n-j > k-i) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int &ans = dp[i][j];\\n        ans = rec(i+1, j, target, n, kStr, k);\\n        unordered_map<char, int> &mp = kStr[i];\\n        if(mp.find(target[j]) != mp.end())\\n            ans = (ans + (1ll*rec(i+1, j+1, target, n, kStr, k)*mp[target[j]])%MOD)%MOD;\\n        return ans;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp, -1, sizeof dp);\\n        int n = words.size(), m = words[0].size();\\n        vector<unordered_map<char, int>> kStr(m);\\n        for(int j = 0; j<m; j++) for(int i = 0; i<n; i++) kStr[j][words[i][j]]++;\\n        return rec(0, 0, target, target.size(), kStr, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422957,
                "title": "easy-bottom-up-dp-with-explantion-go",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we calculate the frequency of each letter appearing at each position, then use a dp array to store the number of schemes, where `dp[i][j]` represents the number of schemes to form the target string starting from the i<sup>th</sup> character, using the frequency array starting from the j<sup>th</sup> column. We traverse the target string from back to front and update the dp array based on the state transition equation. Finally, return `dp[0][0]` as the result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(max(len(words),n)*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc numWays(words []string, target string) int {\\n\\tmod := int(1e9 + 7)\\n\\tn := len(target)\\n\\tm := len(words[0])\\n\\n\\tfor _, word := range words {\\n\\t\\tfor i, ch := range word {\\n\\t\\t\\tfreq[i][ch-\\'a\\']++\\n\\t\\t}\\n\\t}\\n\\n\\tdp := make([][]int, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tfor j := m - 1; j >= 0; j-- {\\n\\t\\t\\tif i == n-1 {\\n\\t\\t\\t\\tif j == m-1 {\\n\\t\\t\\t\\t\\tdp[i][j] = freq[j][target[i]-\\'a\\'] \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j+1] + freq[j][target[i]-\\'a\\']) % mod \\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif j != m-1 {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j+1] + dp[i+1][j+1]*freq[j][target[i]-\\'a\\']) % mod \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc numWays(words []string, target string) int {\\n\\tmod := int(1e9 + 7)\\n\\tn := len(target)\\n\\tm := len(words[0])\\n\\n\\tfor _, word := range words {\\n\\t\\tfor i, ch := range word {\\n\\t\\t\\tfreq[i][ch-\\'a\\']++\\n\\t\\t}\\n\\t}\\n\\n\\tdp := make([][]int, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tfor j := m - 1; j >= 0; j-- {\\n\\t\\t\\tif i == n-1 {\\n\\t\\t\\t\\tif j == m-1 {\\n\\t\\t\\t\\t\\tdp[i][j] = freq[j][target[i]-\\'a\\'] \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j+1] + freq[j][target[i]-\\'a\\']) % mod \\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif j != m-1 {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j+1] + dp[i+1][j+1]*freq[j][target[i]-\\'a\\']) % mod \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422689,
                "title": "beats-95-dp-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>dp;\\n    vector<vector<int>>freq;\\n    \\n    long getWords(vector<string>&words, string &target, int i, int j){\\n        if(j == target.size())return 1;\\n        if(i == words[0].size() || words[0].size() - i < target.size() - j) return 0;\\n        \\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        long count = 0;\\n        int  curPos = target[j] - \\'a\\';\\n        count += getWords(words, target, i + 1, j);\\n        count += freq[i][curPos] * getWords(words, target, i + 1, j + 1);\\n        \\n        return dp[i][j] = count % 1000000007;\\n    }\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        \\n        dp.resize(words[0].size(), vector<int>(target.size(), -1));\\n        freq.resize(words[0].size(), vector<int>(26, 0));\\n        \\n        for(int i=0; i<words.size(); i++){\\n            for(int j = 0; j < words[0].size(); j++){\\n                int  curPos = words[i][j] - \\'a\\';\\n                freq[j][curPos]++;\\n            }\\n        }\\n        return getWords(words,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422682,
                "title": "number-of-ways-to-form-a-target-string-given-a-dictionary-java-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Initialize variables k and m to represent the length of words and target string respectively.\\n2. Create a 2D integer array cnt of size k x 26, where cnt[i][j] stores the count of occurrences of the j-th character in the i-th position of words.\\n3. Implement a recursive function dfs() with memoization, which takes parameters i and t representing the current index of words and target string respectively, along with other parameters m, cnt, target, and memo.\\n1. Base cases:\\n1. If t is equal to m, it means we have formed the target string, so return 1.\\n2. If i is greater than or equal to k, it means we have exhausted all the characters in words, so return 0.\\n3. Check if the result for the current parameters i and t is already memoized. If yes, return the memoized result.\\n4. Initialize a variable res to store the result for the current parameters.\\n5. If the count of the character target.charAt(t) in the i-th position of words is greater than 0, then we can form the current character of the target using this character. So, we multiply the count with the result of dfs(i + 1, t + 1, m, cnt, target, memo).\\n6. Add the result of dfs(i + 1, t, m, cnt, target, memo) to res as we can also skip the current character in words.\\nTake modulo of res with MOD to avoid integer overflow.\\nMemoize the result for the current parameters i and t in the memo map.\\n7. Return res as the final result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(k * m), where k is the length of words and m is the length of the target string. This is because we need to iterate through the words array and target string, and the memoization helps in avoiding redundant computations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(k), as we need to store the counts of characters in the words array and also the memoization map.\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int numWays(String[] words, String target) {\\n        int k = words[0].length();\\n        int m = target.length();\\n        int[][] cnt = new int[k][26];\\n\\n        for (int i = 0; i < k; i++) {\\n            for (String word : words) {\\n                cnt[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n\\n        Map<String, Integer> memo = new HashMap<>();\\n        return (int) dfs(0, 0, m, cnt, target, memo);\\n    }\\n\\n    private long dfs(int i, int t, int m, int[][] cnt, String target, Map<String, Integer> memo) {\\n        if (t == m) {\\n            return 1;\\n        }\\n        if (i >= cnt.length) {\\n            return 0;\\n        }\\n\\n        String key = i + \"_\" + t;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        long res = 0;\\n        if (cnt[i][target.charAt(t) - \\'a\\'] > 0) {\\n            res += cnt[i][target.charAt(t) - \\'a\\'] * dfs(i + 1, t + 1, m, cnt, target, memo);\\n        }\\n        res += dfs(i + 1, t, m, cnt, target, memo);\\n\\n        res %= MOD;\\n        memo.put(key, (int) res);\\n        return res;\\n    }\\n}\\n\\n```\\nplease upvote it if you find it helpful.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int numWays(String[] words, String target) {\\n        int k = words[0].length();\\n        int m = target.length();\\n        int[][] cnt = new int[k][26];\\n\\n        for (int i = 0; i < k; i++) {\\n            for (String word : words) {\\n                cnt[i][word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n\\n        Map<String, Integer> memo = new HashMap<>();\\n        return (int) dfs(0, 0, m, cnt, target, memo);\\n    }\\n\\n    private long dfs(int i, int t, int m, int[][] cnt, String target, Map<String, Integer> memo) {\\n        if (t == m) {\\n            return 1;\\n        }\\n        if (i >= cnt.length) {\\n            return 0;\\n        }\\n\\n        String key = i + \"_\" + t;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        long res = 0;\\n        if (cnt[i][target.charAt(t) - \\'a\\'] > 0) {\\n            res += cnt[i][target.charAt(t) - \\'a\\'] * dfs(i + 1, t + 1, m, cnt, target, memo);\\n        }\\n        res += dfs(i + 1, t, m, cnt, target, memo);\\n\\n        res %= MOD;\\n        memo.put(key, (int) res);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422441,
                "title": "java-simple-memoization-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    private int mod=(int)1e9+7;\\n    public int numWays(String[] words, String target) {\\n        int charsAtInd[][]=new int[words[0].length()][26];\\n        for(int j=0;j<words[0].length();j++){\\n            for(String w:words)    charsAtInd[j][w.charAt(j)-\\'a\\']++;\\n        }\\n        return (int)get_ans(words,0,0,target,charsAtInd,new Long[words[0].length()][target.length()]);\\n    }\\n    private long get_ans(String []words,int i,int j,String target,int charsAtInd[][],Long [][]dp){\\n        if(j==target.length() || words[0].length()-i-1<target.length()-j-1)     \\n            return j==target.length()?1:0;\\n        if(dp[i][j]!=null)  return dp[i][j];\\n        long ways=get_ans(words,i+1,j,target,charsAtInd,dp);\\n        if(charsAtInd[i][target.charAt(j)-\\'a\\']>0)     \\n            ways=(ways+(charsAtInd[i][target.charAt(j)-\\'a\\']*get_ans(words,i+1,j+1,target,charsAtInd,dp))%mod)%mod;\\n        return dp[i][j]=ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int mod=(int)1e9+7;\\n    public int numWays(String[] words, String target) {\\n        int charsAtInd[][]=new int[words[0].length()][26];\\n        for(int j=0;j<words[0].length();j++){\\n            for(String w:words)    charsAtInd[j][w.charAt(j)-\\'a\\']++;\\n        }\\n        return (int)get_ans(words,0,0,target,charsAtInd,new Long[words[0].length()][target.length()]);\\n    }\\n    private long get_ans(String []words,int i,int j,String target,int charsAtInd[][],Long [][]dp){\\n        if(j==target.length() || words[0].length()-i-1<target.length()-j-1)     \\n            return j==target.length()?1:0;\\n        if(dp[i][j]!=null)  return dp[i][j];\\n        long ways=get_ans(words,i+1,j,target,charsAtInd,dp);\\n        if(charsAtInd[i][target.charAt(j)-\\'a\\']>0)     \\n            ways=(ways+(charsAtInd[i][target.charAt(j)-\\'a\\']*get_ans(words,i+1,j+1,target,charsAtInd,dp))%mod)%mod;\\n        return dp[i][j]=ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422324,
                "title": "python-3-top-down-dp",
                "content": "# Intuition\\nThis question\\'s constraints are quite harsh imo.\\n\\nThere are 2 state variables:\\n1.index of target\\n2.index of word in words list\\n\\nYou can\\'t save indexes of all characters in each word in a defaultdict(list) and then do binary search, which will cost you log(n) time and get TLE. This was my first trial mistake.\\n\\nYou need to save frequency of characters in each index of words.\\n\\n# Approach\\ntop down dp\\n\\n# Complexity\\n- Time complexity:\\nO(mn + nl) -> read all characters in words and do dp\\n\\n- Space complexity:\\nO(mn + nl) -> mapp\\'s size and dp\\'s cache size\\n\\nm = len(words)\\nn = len(words[0])\\nl = len(target)\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        import collections\\n\\n        mapp = collections.defaultdict(collections.Counter)  # char index in word: {char: freq}\\n        for word in words:\\n            for char_ind, char in enumerate(word):\\n                mapp[char_ind][char] += 1\\n\\n        @lru_cache(None)\\n        def dp(it, iw):  # return int, possibility\\n            nonlocal target\\n            if it == len(target):  # reached terminal\\n                return 1\\n            if iw == len(words[0]):  # need more char but can\\'t get more\\n                return 0\\n\\n            if target[it] in mapp[iw]:\\n                r1 = dp(it + 1, iw + 1)  # take iw for it, you have mapp[iw][target[it]] extra combinations\\n                r2 = dp(it, iw + 1)  # skip iw\\n                return r1 * mapp[iw][target[it]] + r2\\n            else:\\n                r1 = dp(it, iw + 1)\\n                return r1\\n\\n        mod = 10 ** 9 + 7\\n        return dp(0, 0) % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        import collections\\n\\n        mapp = collections.defaultdict(collections.Counter)  # char index in word: {char: freq}\\n        for word in words:\\n            for char_ind, char in enumerate(word):\\n                mapp[char_ind][char] += 1\\n\\n        @lru_cache(None)\\n        def dp(it, iw):  # return int, possibility\\n            nonlocal target\\n            if it == len(target):  # reached terminal\\n                return 1\\n            if iw == len(words[0]):  # need more char but can\\'t get more\\n                return 0\\n\\n            if target[it] in mapp[iw]:\\n                r1 = dp(it + 1, iw + 1)  # take iw for it, you have mapp[iw][target[it]] extra combinations\\n                r2 = dp(it, iw + 1)  # skip iw\\n                return r1 * mapp[iw][target[it]] + r2\\n            else:\\n                r1 = dp(it, iw + 1)\\n                return r1\\n\\n        mod = 10 ** 9 + 7\\n        return dp(0, 0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422307,
                "title": "1639-number-of-ways-to-form-a-target-string-given-a-dictionary",
                "content": "# Intuition\\nIn this problem we need to find number of ways to form the target string using the letters from dictonary words.But if we selected Kth character from a string then for remaining characters of target we cannot choose a character of any string in dictonary having index i <= k.\\n\\n# Approach\\nThis is a DP problem, and the state of dp used is two as there are two changing variables the character index i and character j of target string.\\nWe will hash the count of each character at ith index in every string using a vector of size n * 26.\\nbasic modular addition and multiplication will be needed.\\nNow all possible ways by taking character from ith index of string can be found by multiplying the count of target[j] at all ith indexes with (solve(i+1 , j+1 ,n , m , target). I first used a loop of and did take not take for every character at index i of strings and tried to make target but it gave TLE.\\nOverall addition of taking all chars equal to target[j] at ith index and skipping ith index is the answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N*T)$$ where N = length of word in words and T = target.size()\\n- Space complexity:\\n$$O(1001*1001)$$ overall N*2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] ;\\n    const long long mod = 1e9 + 7;\\n    int solve(int i , int j ,int n, vector<vector<int>>&m, string &target)\\n    {\\n        int ts = target.size();\\n        if(j == ts)\\n        {\\n            return 1;\\n        }\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }easaaa\\n        int ans = 0;\\n        int ans1 =  ((m[i][target[j] - \\'a\\']%mod) * (solve(i+1 , j+1 ,n , m , target)%mod))%mod; \\n        int ans2 = solve(i+1 , j ,n, m , target)%mod; \\n        ans = (ans1%mod + ans2%mod)%mod;\\n        return dp[i][j] = ans;\\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>>m(words[0].size() , vector<int>(26 , 0)); \\n        for(auto it : words)\\n        {\\n            for(int i = 0;i< it.size();i++)\\n            {\\n                m[i][it[i] - \\'a\\']++;\\n            }\\n        }\\n        vector<int>store;\\n        int n = words[0].size();\\n        int ans =  solve(0 , 0 , n , m , target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001] ;\\n    const long long mod = 1e9 + 7;\\n    int solve(int i , int j ,int n, vector<vector<int>>&m, string &target)\\n    {\\n        int ts = target.size();\\n        if(j == ts)\\n        {\\n            return 1;\\n        }\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }easaaa\\n        int ans = 0;\\n        int ans1 =  ((m[i][target[j] - \\'a\\']%mod) * (solve(i+1 , j+1 ,n , m , target)%mod))%mod; \\n        int ans2 = solve(i+1 , j ,n, m , target)%mod; \\n        ans = (ans1%mod + ans2%mod)%mod;\\n        return dp[i][j] = ans;\\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>>m(words[0].size() , vector<int>(26 , 0)); \\n        for(auto it : words)\\n        {\\n            for(int i = 0;i< it.size();i++)\\n            {\\n                m[i][it[i] - \\'a\\']++;\\n            }\\n        }\\n        vector<int>store;\\n        int n = words[0].size();\\n        int ans =  solve(0 , 0 , n , m , target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422221,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nconst numWays = function (words, target) {\\n    const mod = 1e9 + 7,\\n        result = new Array(target.length + 1).fill(0);\\n    result[0] = 1;\\n    \\n    for (let i = 0; i < words[0].length; i++) {\\n        let count = new Array(26).fill(0);\\n        for (let word of words) {\\n            count[word.charCodeAt(i) - 97]++;\\n        }\\n        for (let j = target.length - 1; j >= 0; --j) {\\n            result[j + 1] += result[j] * count[target.charCodeAt(j) - 97] % mod;\\n        }\\n    }\\n    return result[target.length] % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nconst numWays = function (words, target) {\\n    const mod = 1e9 + 7,\\n        result = new Array(target.length + 1).fill(0);\\n    result[0] = 1;\\n    \\n    for (let i = 0; i < words[0].length; i++) {\\n        let count = new Array(26).fill(0);\\n        for (let word of words) {\\n            count[word.charCodeAt(i) - 97]++;\\n        }\\n        for (let j = target.length - 1; j >= 0; --j) {\\n            result[j + 1] += result[j] * count[target.charCodeAt(j) - 97] % mod;\\n        }\\n    }\\n    return result[target.length] % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422023,
                "title": "python-memorization-and-dp-explained",
                "content": "We can build a function `buildTarget(kth, tidx)` to count the number of ways to build `target[tidx:] `from `kth` character of the words.\\n\\nThere are two ways to build the` target[tidx:]`:\\n(1) select the `kth` character from` words` if `target[tidx]` exist: --> next iteration will be: `buildTarget(kth + 1, tidx + 1)`\\n(2) do not select the `kth` character from `words`: --> next iteration will be: `buildTarget(kth + 1, tidx)`\\n\\nJust need to take care of the boundary conditions.\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        self.len_dict = len(words)\\n        self.len_wd = len(words[0])\\n        self.len_t = len(target)\\n        self.words = words\\n        self.target = target\\n            \\n        # build a list that can help calculate the number of a certain character at a certain index\\n        self.char_cnt = []\\n        for i in range(self.len_wd):\\n            cnt = [0] * 32\\n            for j in range(self.len_dict):\\n                cnt[ord(words[j][i]) - 97] += 1\\n            self.char_cnt.append(cnt)\\n        \\n        # dp array to store the number of ways building target[tidx:] starting from kth character\\n        self.dp = collections.defaultdict(lambda: None)\\n        # boundary condition:\\n        for i in range(self.len_wd + 1):\\n            self.dp[i, self.len_t] = 1\\n        \\n        return self.buildTarget(0, 0) % (1000000007)\\n\\t\\t\\n    \\n    def buildTarget(self, kth, tidx):\\n        if self.dp[kth, tidx] is None:\\n            # boundary condition:\\n            if self.len_t - tidx > self.len_wd - kth:\\n                self.dp[kth, tidx] = 0\\n            else:\\n                total = 0\\n                c_cnt = self.char_cnt[kth][ord(self.target[tidx]) - 97]\\n                if c_cnt:\\n                    total += (self.buildTarget(kth + 1, tidx + 1) * c_cnt)\\n                total += self.buildTarget(kth + 1, tidx)\\n                self.dp[kth, tidx] = total\\n        return self.dp[kth, tidx]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        self.len_dict = len(words)\\n        self.len_wd = len(words[0])\\n        self.len_t = len(target)\\n        self.words = words\\n        self.target = target\\n            \\n        # build a list that can help calculate the number of a certain character at a certain index\\n        self.char_cnt = []\\n        for i in range(self.len_wd):\\n            cnt = [0] * 32\\n            for j in range(self.len_dict):\\n                cnt[ord(words[j][i]) - 97] += 1\\n            self.char_cnt.append(cnt)\\n        \\n        # dp array to store the number of ways building target[tidx:] starting from kth character\\n        self.dp = collections.defaultdict(lambda: None)\\n        # boundary condition:\\n        for i in range(self.len_wd + 1):\\n            self.dp[i, self.len_t] = 1\\n        \\n        return self.buildTarget(0, 0) % (1000000007)\\n\\t\\t\\n    \\n    def buildTarget(self, kth, tidx):\\n        if self.dp[kth, tidx] is None:\\n            # boundary condition:\\n            if self.len_t - tidx > self.len_wd - kth:\\n                self.dp[kth, tidx] = 0\\n            else:\\n                total = 0\\n                c_cnt = self.char_cnt[kth][ord(self.target[tidx]) - 97]\\n                if c_cnt:\\n                    total += (self.buildTarget(kth + 1, tidx + 1) * c_cnt)\\n                total += self.buildTarget(kth + 1, tidx)\\n                self.dp[kth, tidx] = total\\n        return self.dp[kth, tidx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421657,
                "title": "easy-solution-recursion-memoization-optimised-step-by-step",
                "content": "Memoization (85/89):\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int f(int i, int j,vector<string>& words, string &target,vector<vector<int>>&dp ){\\n        \\n        if(j>=target.size()){\\n            return 1;\\n        }\\n    \\n        if(i>= words[0].size())return 0;\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        long count=0;\\n        \\n        for(int k=0;k<words.size();k++){\\n            if(words[k][i]==target[j]){\\n                count+=f(i+1,j+1,words,target,dp)%mod;\\n            }\\n        }\\n        count+=f(i+1,j,words,target,dp)%mod;\\n        \\n        return dp[i][j]= count%mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        \\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n        return f(0,0,words,target,dp);\\n    }\\n};\\n```\\n\\nOptimised using storing frequency:\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int f(int i, int j,vector<string>& words, string &target,vector<vector<int>>&freq,vector<vector<int>>&dp ){\\n        \\n        if(j>=target.size()){\\n            return 1;\\n        }\\n    \\n        if(i>= words[0].size())return 0;\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        long count=0;\\n        \\n        int charpos=target[j]-\\'a\\';\\n        count+=(long long)freq[i][charpos]*f(i+1,j+1,words,target,freq,dp)%mod;\\n        count+=f(i+1,j,words,target,freq,dp)%mod;\\n        \\n        return dp[i][j]= count%mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        \\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n        vector<vector<int>>freq(words[0].size(),vector<int>(26,0));\\n        \\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[0].size();j++){\\n                int charpos=words[i][j]-\\'a\\';\\n                freq[j][charpos]++;\\n            }\\n        }\\n        \\n        return f(0,0,words,target,freq,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int f(int i, int j,vector<string>& words, string &target,vector<vector<int>>&dp ){\\n        \\n        if(j>=target.size()){\\n            return 1;\\n        }\\n    \\n        if(i>= words[0].size())return 0;\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        long count=0;\\n        \\n        for(int k=0;k<words.size();k++){\\n            if(words[k][i]==target[j]){\\n                count+=f(i+1,j+1,words,target,dp)%mod;\\n            }\\n        }\\n        count+=f(i+1,j,words,target,dp)%mod;\\n        \\n        return dp[i][j]= count%mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        \\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n        return f(0,0,words,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421583,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n=len(words[0])\\n        m=len(target)\\n        mod=10**9+7\\n        dp=[0]*(m+1)\\n        dp[0]=1\\n        count=[[0]*26 for _ in range(n)]\\n        for i in range(n):\\n            for word in words:\\n                count[i][ord(word[i])-ord(\\'a\\')]+=1\\n\\n        for i in range(n):\\n            for j in range(m-1,-1,-1):\\n                dp[j+1]+=dp[j]*count[i][ord(target[j])-ord(\\'a\\')]\\n                dp[j+1]%=mod\\n\\n        return dp[m]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n=len(words[0])\\n        m=len(target)\\n        mod=10**9+7\\n        dp=[0]*(m+1)\\n        dp[0]=1\\n        count=[[0]*26 for _ in range(n)]\\n        for i in range(n):\\n            for word in words:\\n                count[i][ord(word[i])-ord(\\'a\\')]+=1\\n\\n        for i in range(n):\\n            for j in range(m-1,-1,-1):\\n                dp[j+1]+=dp[j]*count[i][ord(target[j])-ord(\\'a\\')]\\n                dp[j+1]%=mod\\n\\n        return dp[m]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421517,
                "title": "java-runtime-51-ms-beats-89-7-memory-49-2-mb-beats-86-34",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long []dp = new long[target.length()];\\n        long mod = 1000000007;\\n        for(int i=0;i<words[0].length();i++){\\n            int []a = new int[26];\\n            for(int j=0;j<words.length;j++){\\n                a[words[j].charAt(i)-\\'a\\'] ++;\\n            }\\n            for(int j= Math.min(i, target.length()-1);j>=0;j--){\\n                if(a[target.charAt(j) - \\'a\\'] > 0){\\n                    dp[j] += j == 0 ? a[target.charAt(j)-\\'a\\'] : dp[j-1]*a[target.charAt(j)-\\'a\\'];\\n                    dp[j] %= mod;\\n                }\\n            }\\n        }\\n        return (int)dp[dp.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long []dp = new long[target.length()];\\n        long mod = 1000000007;\\n        for(int i=0;i<words[0].length();i++){\\n            int []a = new int[26];\\n            for(int j=0;j<words.length;j++){\\n                a[words[j].charAt(i)-\\'a\\'] ++;\\n            }\\n            for(int j= Math.min(i, target.length()-1);j>=0;j--){\\n                if(a[target.charAt(j) - \\'a\\'] > 0){\\n                    dp[j] += j == 0 ? a[target.charAt(j)-\\'a\\'] : dp[j-1]*a[target.charAt(j)-\\'a\\'];\\n                    dp[j] %= mod;\\n                }\\n            }\\n        }\\n        return (int)dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421474,
                "title": "python-dp-memoization",
                "content": "```\\nclass word_index:\\n    def __init__(self):\\n        self.char_set = set()\\n        self.frequencies = defaultdict(int)\\n    def add_char(self, char):\\n        self.char_set.add(char)\\n        self.frequencies[char] += 1\\n\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        # seperate each word into its characters and map them to an index\\n        # [\"acca\", \"bbbb\", \"caca\"] -> {1: set([a, b, c]), 2: set([c, b, a]), 3: set([c, b]), 4: set([a, b])}\\n        # add frequency array to each index to avoid word collisions\\n\\n        # solve using dp\\n        # let dp[i][k] be the number of ways to form target[i:] at index k\\n        # if k == m: res = 1\\n        # if i == n: res = 0\\n        # dp[i][k] = include * freq + skip\\n        \\n        n = len(words[0])\\n        m = len(target)\\n\\n        word_map = defaultdict(word_index)\\n\\n        for word in words:\\n            for i in range(n):\\n                word_map[i].add_char(word[i])\\n        \\n        dp = [[None] * m for i in range(n)]\\n\\n        def solve(i, k):\\n            if k == m:\\n                return 1\\n            elif i == n:\\n                return 0\\n            elif dp[i][k] is not None:\\n                return dp[i][k]\\n\\n            if target[k] in word_map[i].char_set:\\n                dp[i][k] = solve(i + 1, k + 1) * word_map[i].frequencies[target[k]] + solve(i + 1, k) \\n            else:\\n                dp[i][k] = solve(i + 1, k)\\n            return dp[i][k]\\n        \\n        mod = 10**9 + 7\\n        return solve(0, 0) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass word_index:\\n    def __init__(self):\\n        self.char_set = set()\\n        self.frequencies = defaultdict(int)\\n    def add_char(self, char):\\n        self.char_set.add(char)\\n        self.frequencies[char] += 1\\n\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        # seperate each word into its characters and map them to an index\\n        # [\"acca\", \"bbbb\", \"caca\"] -> {1: set([a, b, c]), 2: set([c, b, a]), 3: set([c, b]), 4: set([a, b])}\\n        # add frequency array to each index to avoid word collisions\\n\\n        # solve using dp\\n        # let dp[i][k] be the number of ways to form target[i:] at index k\\n        # if k == m: res = 1\\n        # if i == n: res = 0\\n        # dp[i][k] = include * freq + skip\\n        \\n        n = len(words[0])\\n        m = len(target)\\n\\n        word_map = defaultdict(word_index)\\n\\n        for word in words:\\n            for i in range(n):\\n                word_map[i].add_char(word[i])\\n        \\n        dp = [[None] * m for i in range(n)]\\n\\n        def solve(i, k):\\n            if k == m:\\n                return 1\\n            elif i == n:\\n                return 0\\n            elif dp[i][k] is not None:\\n                return dp[i][k]\\n\\n            if target[k] in word_map[i].char_set:\\n                dp[i][k] = solve(i + 1, k + 1) * word_map[i].frequencies[target[k]] + solve(i + 1, k) \\n            else:\\n                dp[i][k] = solve(i + 1, k)\\n            return dp[i][k]\\n        \\n        mod = 10**9 + 7\\n        return solve(0, 0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421442,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n, m = len(words[0]), len(target)\\n        maps = [Counter() for _ in range(n)]\\n        for word in words:\\n            for i, c in enumerate(word):\\n                maps[i][c] += 1\\n        @cache\\n        def dp(i, j):\\n            if j >= m: return 1\\n            if i >= n: return 0\\n            v = maps[i][target[j]]\\n            return dp(i + 1, j) + dp(i + 1, j + 1) * v\\n        return dp(0, 0) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        n, m = len(words[0]), len(target)\\n        maps = [Counter() for _ in range(n)]\\n        for word in words:\\n            for i, c in enumerate(word):\\n                maps[i][c] += 1\\n        @cache\\n        def dp(i, j):\\n            if j >= m: return 1\\n            if i >= n: return 0\\n            v = maps[i][target[j]]\\n            return dp(i + 1, j) + dp(i + 1, j + 1) * v\\n        return dp(0, 0) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421390,
                "title": "daily-leetcoding-challenge-april-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3330342,
                "title": "c-bottom-up-dp",
                "content": "# DP\\ndp[i, j] - the number of ways to form first i characters from target using first j characters from words array\\n\\n# Complexity\\n- Time complexity: $$O(kn + mn)$$\\n\\n- Space complexity: $$O(26n + mn)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int NumWays(string[] words, string target)\\n    {\\n        const long mod = 1_000_000_007;\\n\\n        int m = target.Length;\\n        int n = words[0].Length;\\n\\n        if (m > n)\\n        {\\n            return 0;\\n        }\\n\\n        long[,] count = new long[26, n];\\n\\n        foreach (string word in words)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                count[word[j] - \\'a\\', j]++;\\n            }\\n        }\\n\\n        long[,] dp = new long[m + 1, n + 1];\\n\\n        for (int j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = 1;\\n        }\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = i; j <= n; j++)\\n            {\\n                dp[i, j] = (dp[i, j - 1] + count[target[i - 1] - \\'a\\', j - 1] * dp[i - 1, j - 1]) % mod;\\n            }\\n        }\\n\\n        return (int)dp[m, n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int NumWays(string[] words, string target)\\n    {\\n        const long mod = 1_000_000_007;\\n\\n        int m = target.Length;\\n        int n = words[0].Length;\\n\\n        if (m > n)\\n        {\\n            return 0;\\n        }\\n\\n        long[,] count = new long[26, n];\\n\\n        foreach (string word in words)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                count[word[j] - \\'a\\', j]++;\\n            }\\n        }\\n\\n        long[,] dp = new long[m + 1, n + 1];\\n\\n        for (int j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = 1;\\n        }\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = i; j <= n; j++)\\n            {\\n                dp[i, j] = (dp[i, j - 1] + count[target[i - 1] - \\'a\\', j - 1] * dp[i - 1, j - 1]) % mod;\\n            }\\n        }\\n\\n        return (int)dp[m, n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488907,
                "title": "java-bottom-up-approach-explained-in-detail-tc-sc-explained",
                "content": "// Startegy - Bottom Up solution\\n// My dp[i] array holds the MAX num of ways to form a string of length \\'i\\'\\n\\n// How DP is filled ?\\n// NOTE : ALL the word in words[] are of same length so we can know that freq[i-th char] from ALL the word\\'s i-th char (if there are 5 words and 3 words have \\'a\\' at index 0 and 2 words ahve \\'b\\' at index 0 so ---> freq[] array which corresponds to i-th index of words would show a freq of 3 for \\'a\\' and 2 for \\'b\\' and 0 for rest)\\n\\n// 1. At EACH INDEX of words, find the FREQ of EACH char -> So EACH index will have a corresponding int[26] array holding the freq of each char at \\'i-th\\' idx\\n// 2. Once we have this, we try to FILL our DP\\n// OBSERVATION: At any moment, the MAX length of \\'target\\' we can try to form is \\'i\\' (since we know the freq of char at \\'i\\', we can only try to find the number of ways to fill \\'target\\' at index \\'i\\' or less than \\'i\\')\\n// 2.1 Because of above observation, the MAX \\'j\\' which we can take anytime is \\'i\\'\\n// 2.2 If j == 0, this means that there is NOTHING that has been formed yet (or tried to form), so MAX ways to form target(j) is freq[of char present at target(j)]\\n// 2.3 At anytime (j != 0), the TOTAL number of ways to FILL the char at index \\'j\\' of target is \\n// THE NUMBER of ways to fill \\'j - 1\\' char (held in dp[j - 1]) * (multiply by) the FREQ of char at freq[] (basically, lets say freq[j] = 2 and dp[j - 1] = 4, so this means to form target upto \\'j - 1\\' there are 4 ways and currently 2 different word from words[] has \\'char\\' at curr location so 4 * 2 = 8)\\n\\n// TC : O(M * N); M = words.length; N = words[0].length\\n// SC : O(N)\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long dp[] = new long[target.length()]; // dp[i] means NUMBER of ways to form a string upto length \\'i\\'\\n        long mod = 1000000000 + 7;\\n        \\n        for(int i = 0; i < words[0].length(); i++) { // since ALL words are of same length, i = idx in a word\\n            int[] freq = new int[26]; // freq of EACH char at \\'i-th\\' idx from EACH word\\n            for(String word : words) {\\n                freq[word.charAt(i) - \\'a\\']++; // for each idx, we know the freq of each char\\n            }\\n            \\n            // The max length we can take care at this time is \\'i\\' (since we have freq of each char at \\'i\\' and we already have dp[i - 1])\\n            for(int j = Math.min(i, target.length() - 1); j >= 0; j--) { // MAX we can fill upto now is until \\'i-th\\' idx\\n                if(freq[target.charAt(j) - \\'a\\'] > 0) { // we are trying to see if we can make \\'target\\'s index \\'j\\'\\' from freq[]\\n                    // if the idx = 0, nothing has been formed yet so max ways to form target(j) = freq[target.charAt(j) - \\'a\\']\\n                    // if j != 0, meaning we have previously found the MAX ways to find the dp[j - 1] so for dp[j] its just prev num of ways multiply by current freq\\n                    dp[j] += (j == 0) ? freq[target.charAt(j) - \\'a\\'] : dp[j - 1] * freq[target.charAt(j) - \\'a\\']; // we calculate dp[j] for every \\'i\\' so keep adding to the answer (+=)\\n                    dp[j] %= mod; // we need to mod\\n                }\\n            }\\n        }\\n        return (int)dp[dp.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        long dp[] = new long[target.length()]; // dp[i] means NUMBER of ways to form a string upto length \\'i\\'\\n        long mod = 1000000000 + 7;\\n        \\n        for(int i = 0; i < words[0].length(); i++) { // since ALL words are of same length, i = idx in a word\\n            int[] freq = new int[26]; // freq of EACH char at \\'i-th\\' idx from EACH word\\n            for(String word : words) {\\n                freq[word.charAt(i) - \\'a\\']++; // for each idx, we know the freq of each char\\n            }\\n            \\n            // The max length we can take care at this time is \\'i\\' (since we have freq of each char at \\'i\\' and we already have dp[i - 1])\\n            for(int j = Math.min(i, target.length() - 1); j >= 0; j--) { // MAX we can fill upto now is until \\'i-th\\' idx\\n                if(freq[target.charAt(j) - \\'a\\'] > 0) { // we are trying to see if we can make \\'target\\'s index \\'j\\'\\' from freq[]\\n                    // if the idx = 0, nothing has been formed yet so max ways to form target(j) = freq[target.charAt(j) - \\'a\\']\\n                    // if j != 0, meaning we have previously found the MAX ways to find the dp[j - 1] so for dp[j] its just prev num of ways multiply by current freq\\n                    dp[j] += (j == 0) ? freq[target.charAt(j) - \\'a\\'] : dp[j - 1] * freq[target.charAt(j) - \\'a\\']; // we calculate dp[j] for every \\'i\\' so keep adding to the answer (+=)\\n                    dp[j] %= mod; // we need to mod\\n                }\\n            }\\n        }\\n        return (int)dp[dp.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355976,
                "title": "2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int mod  = 1e9 +7;\\n    int rec(int idx1,int idx2,string &target,vector<vector<int>> &adj){\\n        if(idx2>=target.size()) return 1;\\n        if(idx1>=adj.size()) return 0;\\n        if(dp[idx1][idx2] !=-1) return dp[idx1][idx2];\\n        // take\\n        if(adj[idx1][target[idx2]-\\'a\\']>0) {\\n            long long a = (1ll * adj[idx1][target[idx2]-\\'a\\'] * rec(idx1 +1,idx2+1,target,adj)) % mod;\\n            long long b = rec(idx1 + 1, idx2, target ,adj) % mod;\\n            return dp[idx1][idx2] = (a + b) % mod;\\n        }\\n        return dp[idx1][idx2] = rec(idx1 + 1, idx2, target ,adj) % mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n= words.size();\\n        vector<vector<int>> adj(words[0].size(),vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            for(int j =0;j<words[i].size();j++)\\n                adj[j][words[i][j] - \\'a\\']++;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,target,adj);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int mod  = 1e9 +7;\\n    int rec(int idx1,int idx2,string &target,vector<vector<int>> &adj){\\n        if(idx2>=target.size()) return 1;\\n        if(idx1>=adj.size()) return 0;\\n        if(dp[idx1][idx2] !=-1) return dp[idx1][idx2];\\n        // take\\n        if(adj[idx1][target[idx2]-\\'a\\']>0) {\\n            long long a = (1ll * adj[idx1][target[idx2]-\\'a\\'] * rec(idx1 +1,idx2+1,target,adj)) % mod;\\n            long long b = rec(idx1 + 1, idx2, target ,adj) % mod;\\n            return dp[idx1][idx2] = (a + b) % mod;\\n        }\\n        return dp[idx1][idx2] = rec(idx1 + 1, idx2, target ,adj) % mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n= words.size();\\n        vector<vector<int>> adj(words[0].size(),vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            for(int j =0;j<words[i].size();j++)\\n                adj[j][words[i][j] - \\'a\\']++;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,target,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266699,
                "title": "easy-c-recursion-with-memoization",
                "content": "```\\n#define ll long long \\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int f[1001][26];\\n    int helper(vector<string>& v, string &s,int i,int n,int j,int m){\\n        if(j==m) return 1;\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        ll ans=0;\\n        ans=(ans+f[i][s[j]-\\'a\\']*(ll)helper(v,s,i+1,n,j+1,m)%mod)%mod;\\n        ans=(ans+helper(v,s,i+1,n,j,m)%mod)%mod;\\n        return dp[i][j]=(ans%mod);\\n    }\\n    int numWays(vector<string>& v, string s) {\\n        int n=v[0].size();\\n        int m=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(f,0,sizeof(f));\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<n;j++){\\n                f[j][v[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return helper(v,s,0,n,0,m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int f[1001][26];\\n    int helper(vector<string>& v, string &s,int i,int n,int j,int m){\\n        if(j==m) return 1;\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        ll ans=0;\\n        ans=(ans+f[i][s[j]-\\'a\\']*(ll)helper(v,s,i+1,n,j+1,m)%mod)%mod;\\n        ans=(ans+helper(v,s,i+1,n,j,m)%mod)%mod;\\n        return dp[i][j]=(ans%mod);\\n    }\\n    int numWays(vector<string>& v, string s) {\\n        int n=v[0].size();\\n        int m=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(f,0,sizeof(f));\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<n;j++){\\n                f[j][v[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return helper(v,s,0,n,0,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213419,
                "title": "c-dp-knapsack-pattern",
                "content": "* Post Inspired By [@votrubac](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/discuss/917708/C%2B%2BPython3-Top-Down-and-Bottom-Up)\\n\\n * At each index of words[i] , store count of each character `a-z`.\\n\\n* Then at each index , we have two choices , either `choose current i` to make up target or `skip i `.\\n\\n* Number of ways will be frequency of each character multplied all together.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll dp[1000][1000] , MOD = 1e9 + 7 , n ;\\n    map<ll,map<char,ll>> f ;\\n    \\n    int solve(int i , int t , string &target){\\n        if(i >= n) return t == target.size() ;\\n        if(dp[i][t] != -1) return dp[i][t] ;\\n        \\n        ll op1 = 0 , op2 = 0 ;\\n        op1 = solve(i + 1 , t , target) % MOD ; //skip\\n        if(f[i][target[t]]) op2 = (f[i][target[t]] % MOD * solve(i+1,t+1,target) % MOD) % MOD ; //choose i\\n        \\n        return dp[i][t] = (op1 + op2) % MOD ;\\n        \\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp,-1,sizeof(dp)) ; \\n        n = words[0].size() ;\\n        for(auto &x : words)\\n            for(int i = 0 ; i < (int)x.size() ; ++i ) ++f[i][x[i]] ;\\n        \\n        return solve(0,0,target) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll dp[1000][1000] , MOD = 1e9 + 7 , n ;\\n    map<ll,map<char,ll>> f ;\\n    \\n    int solve(int i , int t , string &target){\\n        if(i >= n) return t == target.size() ;\\n        if(dp[i][t] != -1) return dp[i][t] ;\\n        \\n        ll op1 = 0 , op2 = 0 ;\\n        op1 = solve(i + 1 , t , target) % MOD ; //skip\\n        if(f[i][target[t]]) op2 = (f[i][target[t]] % MOD * solve(i+1,t+1,target) % MOD) % MOD ; //choose i\\n        \\n        return dp[i][t] = (op1 + op2) % MOD ;\\n        \\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp,-1,sizeof(dp)) ; \\n        n = words[0].size() ;\\n        for(auto &x : words)\\n            for(int i = 0 ; i < (int)x.size() ; ++i ) ++f[i][x[i]] ;\\n        \\n        return solve(0,0,target) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681768,
                "title": "javascript-solution-dynamic-programming",
                "content": "Taken from https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/discuss/917779/JavaC%2B%2BPython-Space-O(N)\\n\\n```js\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nconst numWays = function (words, target) {\\n    const mod = 1e9 + 7,\\n        result = new Array(target.length + 1).fill(0);\\n    result[0] = 1;\\n    \\n    for (let i = 0; i < words[0].length; i++) {\\n        let count = new Array(26).fill(0);\\n        for (let word of words) {\\n            count[word.charCodeAt(i) - 97]++;\\n        }\\n        for (let j = target.length - 1; j >= 0; --j) {\\n            result[j + 1] += result[j] * count[target.charCodeAt(j) - 97] % mod;\\n        }\\n    }\\n    return result[target.length] % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nconst numWays = function (words, target) {\\n    const mod = 1e9 + 7,\\n        result = new Array(target.length + 1).fill(0);\\n    result[0] = 1;\\n    \\n    for (let i = 0; i < words[0].length; i++) {\\n        let count = new Array(26).fill(0);\\n        for (let word of words) {\\n            count[word.charCodeAt(i) - 97]++;\\n        }\\n        for (let j = target.length - 1; j >= 0; --j) {\\n            result[j + 1] += result[j] * count[target.charCodeAt(j) - 97] % mod;\\n        }\\n    }\\n    return result[target.length] % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304830,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    int mod = (int) (Math.pow(10, 9) + 7);\\n\\n    public int numWays(String[] words, String target) {\\n        int rows = words[0].length();\\n        int cols = 26;\\n        int[][] dp = new int[rows + 1][target.length()];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        int[][] map = new int[rows][cols];\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                map[i][idx]++;\\n            }\\n        }\\n        \\n        return go(map, 0, 0, target, dp);\\n    }\\n\\n     private int go(int[][] words, int idx, int tIdx, String target, int[][] dp) {\\n        if (tIdx >= target.length()) {\\n            return 1;\\n        }\\n        if (idx >= words.length) {\\n            return 0;\\n        }\\n        if (dp[idx][tIdx] != -1) {\\n            return dp[idx][tIdx];\\n        }\\n        int ch = target.charAt(tIdx) - \\'a\\';\\n        long total = 0;\\n        total += go(words, idx + 1, tIdx, target, dp) % mod;\\n        total += ((long) words[idx][ch] * go(words, idx + 1, tIdx + 1, target, dp)) % mod;\\n        dp[idx][tIdx] = (int) (total % mod);\\n        return dp[idx][tIdx];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = (int) (Math.pow(10, 9) + 7);\\n\\n    public int numWays(String[] words, String target) {\\n        int rows = words[0].length();\\n        int cols = 26;\\n        int[][] dp = new int[rows + 1][target.length()];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        int[][] map = new int[rows][cols];\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                int idx = word.charAt(i) - \\'a\\';\\n                map[i][idx]++;\\n            }\\n        }\\n        \\n        return go(map, 0, 0, target, dp);\\n    }\\n\\n     private int go(int[][] words, int idx, int tIdx, String target, int[][] dp) {\\n        if (tIdx >= target.length()) {\\n            return 1;\\n        }\\n        if (idx >= words.length) {\\n            return 0;\\n        }\\n        if (dp[idx][tIdx] != -1) {\\n            return dp[idx][tIdx];\\n        }\\n        int ch = target.charAt(tIdx) - \\'a\\';\\n        long total = 0;\\n        total += go(words, idx + 1, tIdx, target, dp) % mod;\\n        total += ((long) words[idx][ch] * go(words, idx + 1, tIdx + 1, target, dp)) % mod;\\n        dp[idx][tIdx] = (int) (total % mod);\\n        return dp[idx][tIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291067,
                "title": "swift-dp-speed-time-by-pre-process-words-o-n-k",
                "content": "```swift\\nclass Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        let mod = Int(1e9 + 7)\\n        var target = Array(target)\\n\\n        let n = words[0].count\\n        let k = target.count\\n\\n        // charArr[i][j] means, how many char i at word[j] in words\\n        var charArr = Array(\\n            repeating: Array(repeating: 0, count: n),\\n            count: 26\\n        )\\n\\n        let char_a = Character(\"a\").asciiValue!\\n        for word in words {\\n            var wordArr = Array(word)\\n            for i in 0..<n {\\n                let index = Int(wordArr[i].asciiValue! - char_a)\\n                charArr[index][i] += 1\\n            }\\n        }\\n\\n        // dp[i][j], number of ways use 0...i index to form target[0...k]\\n        var dp = Array(\\n            repeating: Array(repeating: 0, count: k),\\n            count: n\\n        )\\n\\n\\t\\t// index to help quick find next starting of i\\n        var index = 0\\n        for j in 0..<k {\\n            var temp = -1\\n            for i in index..<n {\\n                // print(\"i\", i)\\n                let c = Int(target[j].asciiValue! - char_a)\\n                let val = charArr[c][i]\\n                if val > 0, temp == -1 {\\n                    temp = i\\n                }\\n                dp[i][j] = (dp[i][j] + (i > 0 ? dp[i-1][j] : 0) + val * (i > 0 && j > 0 ? dp[i-1][j-1] : 1)) % mod\\n            }\\n\\n            // temp == -1 means cannot find next proper index\\n            if temp == -1 { return 0 }\\n            index = temp + 1\\n            // print(index, j )\\n        }\\n\\n        // print(dp)\\n        return dp[n-1][k-1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nclass Solution {\\n    func numWays(_ words: [String], _ target: String) -> Int {\\n        let mod = Int(1e9 + 7)\\n        var target = Array(target)\\n\\n        let n = words[0].count\\n        let k = target.count\\n\\n        // charArr[i][j] means, how many char i at word[j] in words\\n        var charArr = Array(\\n            repeating: Array(repeating: 0, count: n),\\n            count: 26\\n        )\\n\\n        let char_a = Character(\"a\").asciiValue!\\n        for word in words {\\n            var wordArr = Array(word)\\n            for i in 0..<n {\\n                let index = Int(wordArr[i].asciiValue! - char_a)\\n                charArr[index][i] += 1\\n            }\\n        }\\n\\n        // dp[i][j], number of ways use 0...i index to form target[0...k]\\n        var dp = Array(\\n            repeating: Array(repeating: 0, count: k),\\n            count: n\\n        )\\n\\n\\t\\t// index to help quick find next starting of i\\n        var index = 0\\n        for j in 0..<k {\\n            var temp = -1\\n            for i in index..<n {\\n                // print(\"i\", i)\\n                let c = Int(target[j].asciiValue! - char_a)\\n                let val = charArr[c][i]\\n                if val > 0, temp == -1 {\\n                    temp = i\\n                }\\n                dp[i][j] = (dp[i][j] + (i > 0 ? dp[i-1][j] : 0) + val * (i > 0 && j > 0 ? dp[i-1][j-1] : 1)) % mod\\n            }\\n\\n            // temp == -1 means cannot find next proper index\\n            if temp == -1 { return 0 }\\n            index = temp + 1\\n            // print(index, j )\\n        }\\n\\n        // print(dp)\\n        return dp[n-1][k-1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114536,
                "title": "python-using-memo",
                "content": "```\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9+7\\n        m = len(words[0])\\n        n = len(target)\\n        freq = [defaultdict(int) for _ in range(m)]\\n        for word in words: \\n            for i, char in enumerate(word): \\n                freq[i][char] += 1\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            # return number of ways to form target[i:] at col j\\n            if (i, j) in memo:\\n                return memo[(i,j)]\\n            if i == n:\\n                return 1\\n            if j == m:\\n                return 0\\n\\n            res = (dfs(i, j+1) + dfs(i+1, j+1)*freq[j][target[i]]) % mod\\n            memo[(i, j)] = res\\n            \\n            return res\\n            \\n        return dfs(0, 0)\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        \"\"\"\\n        :type words: List[str]\\n        :type target: str\\n        :rtype: int\\n        \"\"\"\\n        mod = 10**9+7\\n        m = len(words[0])\\n        n = len(target)\\n        freq = [defaultdict(int) for _ in range(m)]\\n        for word in words: \\n            for i, char in enumerate(word): \\n                freq[i][char] += 1\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            # return number of ways to form target[i:] at col j\\n            if (i, j) in memo:\\n                return memo[(i,j)]\\n            if i == n:\\n                return 1\\n            if j == m:\\n                return 0\\n\\n            res = (dfs(i, j+1) + dfs(i+1, j+1)*freq[j][target[i]]) % mod\\n            memo[(i, j)] = res\\n            \\n            return res\\n            \\n        return dfs(0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035149,
                "title": "python3-concise-top-down-dp",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m, n = len(words[0]), len(target)\\n        d = [Counter() for _ in range(m)]\\n        for w in words:\\n            for j, c in enumerate(w):\\n                d[j][c] += 1\\n                \\n        @lru_cache(None)        \\n        def dfs(i, j):\\n            if i == n: return 1\\n            if j == m: return 0\\n            return (dfs(i, j+1) + dfs(i+1, j+1) * d[j][target[i]]) % int(1e9 + 7)\\n        \\n        return dfs(0, 0)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        m, n = len(words[0]), len(target)\\n        d = [Counter() for _ in range(m)]\\n        for w in words:\\n            for j, c in enumerate(w):\\n                d[j][c] += 1\\n                \\n        @lru_cache(None)        \\n        def dfs(i, j):\\n            if i == n: return 1\\n            if j == m: return 0\\n            return (dfs(i, j+1) + dfs(i+1, j+1) * d[j][target[i]]) % int(1e9 + 7)\\n        \\n        return dfs(0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 938038,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = target.size();\\n        int n = words[0].size();\\n        int t = words.size();\\n        // dp[i][j] -- numbers of ways to form target[0, i) using all word[0, j)\\n        vector<vector<long>> dp(m+1, vector<long>(n+1, 0));\\n        for (int j=0; j<=n; j++) {\\n            dp[0][j] = 1; // able to form a empty string anyway\\n        }\\n        \\n        // arr[i][j] -- numbers of \\'a\\'+j in position i across all words\\n        vector<vector<int>> arr(n, vector<int>(26, 0));\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<t; j++) {\\n                arr[i][(words[j][i]-\\'a\\')]++;\\n            }\\n        }\\n        \\n        for (int i=1; i<=m; i++) {\\n            for (int j=1; j<=n; j++) {\\n                dp[i][j] = (arr[j-1][target[i-1]-\\'a\\'] * dp[i-1][j-1]) % mod;\\n                dp[i][j] = (dp[i][j] +  dp[i][j-1]) % (mod);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\nprivate:\\n    int mod = 1e9+7;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = target.size();\\n        int n = words[0].size();\\n        int t = words.size();\\n        // dp[i][j] -- numbers of ways to form target[0, i) using all word[0, j)\\n        vector<vector<long>> dp(m+1, vector<long>(n+1, 0));\\n        for (int j=0; j<=n; j++) {\\n            dp[0][j] = 1; // able to form a empty string anyway\\n        }\\n        \\n        // arr[i][j] -- numbers of \\'a\\'+j in position i across all words\\n        vector<vector<int>> arr(n, vector<int>(26, 0));\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<t; j++) {\\n                arr[i][(words[j][i]-\\'a\\')]++;\\n            }\\n        }\\n        \\n        for (int i=1; i<=m; i++) {\\n            for (int j=1; j<=n; j++) {\\n                dp[i][j] = (arr[j-1][target[i-1]-\\'a\\'] * dp[i-1][j-1]) % mod;\\n                dp[i][j] = (dp[i][j] +  dp[i][j-1]) % (mod);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\nprivate:\\n    int mod = 1e9+7;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934934,
                "title": "from-o-mn-3-o-mn-2-o-mn-detailed-explanation-with-intuition",
                "content": "To start, we must first identify a state for the DP. Say we match ```target[i]``` to ```words[j][k]```, then we are interested in the number of ways to form ```target[0:i - 1]``` using up to index ```k - 1``` of all the words since then we can simply attach ```words[j][k]``` onto the end of any of those.\\n\\nThis suggests that we use state ```(ind, minAllowableK)``` where ```ind``` is the location in target and ```minAllowableK``` is the smallest possible value of ```k``` we can use.\\n\\nWe can represent the transition as ```dp[ind + 1][k + 1] = sum over 0 <= kk <= k (dp[ind][kk])``` and our base case is evidently ```dp[0][0]=1```. Now a simple ```O(MN^3)``` solution is possible by looping as follows:\\n\\n```Java\\n//NOTE: I\\'m ignoring modulus till the final solution\\nint m = target.length();\\nint n = words[0].length();\\nint[][] dp = new int[m + 1][n + 1];\\ndp[0][0] = 1;\\n\\nfor (int ind = 0; ind < m; ind++) {\\n\\tchar c = target.charAt(ind);\\n\\t\\n\\tfor (String word : words) {\\n\\t\\tfor (int k = 0; k < n; k++) {\\n\\t\\t\\tchar wordC = word.charAt(k);\\n\\t\\t\\t\\n\\t\\t\\tif (c == wordC) {\\n\\t\\t\\t\\tfor (int kk = 0; kk <= k; kk++) {\\n\\t\\t\\t\\t\\tdp[ind + 1][k + 1] += dp[ind][kk];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint ans = 0;\\n\\nfor (int i = 0; i <= n; i++) {\\n\\tans += dp[m][i];\\n}\\n\\nreturn ans;\\n```\\n\\nNext, we can make the observation that everytime there is a match at ```word.charAt(k)```, all we\\'re doing is adding the prefix sum at the k\\'th index of the previous row ```dp[ind - 1]```. Therefore we can remove the for loop if we maintain a prefix sum and reduce the runtime to ```O(MN^2)```:\\n\\n```Java\\nint m = target.length();\\nint n = words[0].length();\\nint[][] dp = new int[m + 1][n + 1];\\ndp[0][0] = 1;\\n\\n//Create prefixSum array and fill with all 1\\'s since for the dp[0][k], only dp[0][0]=1 is non-zero.\\nint[] prefixSum = new int[n + 1];\\nArrays.fill(prefixSum, 1);\\n\\nfor (int ind = 0; ind < m; ind++) {\\n\\tchar c = target.charAt(ind);\\n\\n\\tfor (String word : words) {\\n\\t\\tfor (int k = 0; k < word.length(); k++) {\\n\\t\\t\\tchar wordChr = word.charAt(k);\\n\\n\\t\\t\\tif (c == wordChr) {\\n\\t\\t\\t\\t//If we found a match then add the prefixSum up to our current index k\\n\\t\\t\\t\\tdp[ind + 1][k + 1] += prefixSum[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t//Reset the array to 0\\n\\tArrays.fill(prefixSum, 0);\\n\\t\\n\\t//Calculate the new values, dp[ind][0] = 0 for all ind != 0 (Not enough characters to fill up to ind)\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i - 1] + dp[ind + 1][i];\\n\\t}\\n\\n}\\n\\nreturn prefixSum[n];\\n```\\n\\nNow from the constraints we know that we need an ```O(MN)``` solution. It doesn\\'t seem possible to speed up the iteration over ```k``` but do we notice any extra work being done in the looping over every string and is there a way to improve this? \\n\\nNotice that for each word we check each ```k``` to see if the word contains the target character at that index. Therefore, after looping over all the strings for a state ```(ind, k)```, we simply added ```prefixSum[k] * (The number of characters = target[ind] @ words[i][k] for every i)```. This allows us to remove looping over all of the words and we arrive at our desired ```O(MN)``` solution:\\n\\n```Java\\npublic int numWays(String[] words, String target) {\\n\\tint mod = (int)(1e9 + 7);\\n\\tint m = target.length();\\n\\tint n = words[0].length();\\n\\tint[][] dp = new int[m + 1][n + 1];\\n\\tdp[0][0] = 1;\\n\\n\\tlong[] prefix = new long[n + 1];\\n\\tArrays.fill(prefix, 1);\\n\\n\\t//Create an array to keep track of the count of all the characters at every index\\n\\tint[][] cnt = new int[n][26];\\n\\n\\t//Iterate over every word filling in the array\\n\\tfor (String word : words) {\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tcnt[i][c - \\'a\\']++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int ind = 0; ind < m; ind++) {\\n\\t\\tchar c = target.charAt(ind);      \\n\\n\\t\\t//Can also start this loop and the prefix loop at ind since it\\'s impossible to have completed a string of length l before l characters,\\n\\t\\tfor (int k = ind; k < n; k++) {\\n\\t\\t\\tdp[ind + 1][k + 1] = (dp[ind + 1][k + 1] + (int)((cnt[k][c - \\'a\\'] * prefix[k]) % mod)) % mod;\\n\\t\\t}\\n\\n\\t\\tArrays.fill(prefix, 0);\\n\\t\\tprefix[0] = 0;\\n\\n\\t\\tfor (int k = Math.max(1, ind); k <= n; k++) {\\n\\t\\t\\tprefix[k] = (prefix[k - 1] + dp[ind + 1][k]) % mod;\\n\\t\\t}\\n\\t} \\n\\n\\treturn (int)prefix[n];\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```target[i]```\n```words[j][k]```\n```target[0:i - 1]```\n```k - 1```\n```words[j][k]```\n```(ind, minAllowableK)```\n```ind```\n```minAllowableK```\n```k```\n```dp[ind + 1][k + 1] = sum over 0 <= kk <= k (dp[ind][kk])```\n```dp[0][0]=1```\n```O(MN^3)```\n```Java\\n//NOTE: I\\'m ignoring modulus till the final solution\\nint m = target.length();\\nint n = words[0].length();\\nint[][] dp = new int[m + 1][n + 1];\\ndp[0][0] = 1;\\n\\nfor (int ind = 0; ind < m; ind++) {\\n\\tchar c = target.charAt(ind);\\n\\t\\n\\tfor (String word : words) {\\n\\t\\tfor (int k = 0; k < n; k++) {\\n\\t\\t\\tchar wordC = word.charAt(k);\\n\\t\\t\\t\\n\\t\\t\\tif (c == wordC) {\\n\\t\\t\\t\\tfor (int kk = 0; kk <= k; kk++) {\\n\\t\\t\\t\\t\\tdp[ind + 1][k + 1] += dp[ind][kk];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nint ans = 0;\\n\\nfor (int i = 0; i <= n; i++) {\\n\\tans += dp[m][i];\\n}\\n\\nreturn ans;\\n```\n```word.charAt(k)```\n```dp[ind - 1]```\n```O(MN^2)```\n```Java\\nint m = target.length();\\nint n = words[0].length();\\nint[][] dp = new int[m + 1][n + 1];\\ndp[0][0] = 1;\\n\\n//Create prefixSum array and fill with all 1\\'s since for the dp[0][k], only dp[0][0]=1 is non-zero.\\nint[] prefixSum = new int[n + 1];\\nArrays.fill(prefixSum, 1);\\n\\nfor (int ind = 0; ind < m; ind++) {\\n\\tchar c = target.charAt(ind);\\n\\n\\tfor (String word : words) {\\n\\t\\tfor (int k = 0; k < word.length(); k++) {\\n\\t\\t\\tchar wordChr = word.charAt(k);\\n\\n\\t\\t\\tif (c == wordChr) {\\n\\t\\t\\t\\t//If we found a match then add the prefixSum up to our current index k\\n\\t\\t\\t\\tdp[ind + 1][k + 1] += prefixSum[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t//Reset the array to 0\\n\\tArrays.fill(prefixSum, 0);\\n\\t\\n\\t//Calculate the new values, dp[ind][0] = 0 for all ind != 0 (Not enough characters to fill up to ind)\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i - 1] + dp[ind + 1][i];\\n\\t}\\n\\n}\\n\\nreturn prefixSum[n];\\n```\n```O(MN)```\n```k```\n```k```\n```(ind, k)```\n```prefixSum[k] * (The number of characters = target[ind] @ words[i][k] for every i)```\n```O(MN)```\n```Java\\npublic int numWays(String[] words, String target) {\\n\\tint mod = (int)(1e9 + 7);\\n\\tint m = target.length();\\n\\tint n = words[0].length();\\n\\tint[][] dp = new int[m + 1][n + 1];\\n\\tdp[0][0] = 1;\\n\\n\\tlong[] prefix = new long[n + 1];\\n\\tArrays.fill(prefix, 1);\\n\\n\\t//Create an array to keep track of the count of all the characters at every index\\n\\tint[][] cnt = new int[n][26];\\n\\n\\t//Iterate over every word filling in the array\\n\\tfor (String word : words) {\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tcnt[i][c - \\'a\\']++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int ind = 0; ind < m; ind++) {\\n\\t\\tchar c = target.charAt(ind);      \\n\\n\\t\\t//Can also start this loop and the prefix loop at ind since it\\'s impossible to have completed a string of length l before l characters,\\n\\t\\tfor (int k = ind; k < n; k++) {\\n\\t\\t\\tdp[ind + 1][k + 1] = (dp[ind + 1][k + 1] + (int)((cnt[k][c - \\'a\\'] * prefix[k]) % mod)) % mod;\\n\\t\\t}\\n\\n\\t\\tArrays.fill(prefix, 0);\\n\\t\\tprefix[0] = 0;\\n\\n\\t\\tfor (int k = Math.max(1, ind); k <= n; k++) {\\n\\t\\t\\tprefix[k] = (prefix[k - 1] + dp[ind + 1][k]) % mod;\\n\\t\\t}\\n\\t} \\n\\n\\treturn (int)prefix[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932457,
                "title": "c-dp",
                "content": "```\\n    int numWays(vector<string>& words, string target) {\\n        const long long mod = 1e9+7;\\n        const int n = words[0].size();\\n        auto counter = vector(n, vector(128,0));\\n        for(auto& s:words){\\n            for(int i=0;i<n;i++) counter[i][s[i]]++;\\n        }\\n        //dp[i][j] = cnt[i][target[j]] * (dp[i-1][j-1] + dp[i-2][j-1]+...)\\n        //         = cnt[..] + vsum[i-1][j-1]\\n        const int m = target.size();\\n        auto vdp = vector(n+1, vector(m+1, 0LL)), vsum = vdp;\\n        vdp[0][0] = 1;\\n        for(int i=0;i<n;i++) vsum[i][0] = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vdp[i+1][j+1] = counter[i][target[j]] * vsum[i][j] % mod;\\n                vsum[i+1][j+1] = (vsum[i][j+1] + vdp[i+1][j+1]) % mod;\\n            }\\n        }\\n        return vsum[n][m];\\n    }",
                "solutionTags": [],
                "code": "```\\n    int numWays(vector<string>& words, string target) {\\n        const long long mod = 1e9+7;\\n        const int n = words[0].size();\\n        auto counter = vector(n, vector(128,0));\\n        for(auto& s:words){\\n            for(int i=0;i<n;i++) counter[i][s[i]]++;\\n        }\\n        //dp[i][j] = cnt[i][target[j]] * (dp[i-1][j-1] + dp[i-2][j-1]+...)\\n        //         = cnt[..] + vsum[i-1][j-1]\\n        const int m = target.size();\\n        auto vdp = vector(n+1, vector(m+1, 0LL)), vsum = vdp;\\n        vdp[0][0] = 1;\\n        for(int i=0;i<n;i++) vsum[i][0] = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vdp[i+1][j+1] = counter[i][target[j]] * vsum[i][j] % mod;\\n                vsum[i+1][j+1] = (vsum[i][j+1] + vdp[i+1][j+1]) % mod;\\n            }\\n        }\\n        return vsum[n][m];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 930023,
                "title": "python-short-and-fast",
                "content": "```\\nclass Solution:\\n    def numWays(self, W: List[str], T: str) -> int:\\n        n, m = len(W[0]), len(T)\\n        counts = [Counter([w[i] for w in W]) for i in range(n)]\\n        @lru_cache(None)\\n        def help(i,j):\\n            if n - i < m - j: return 0\\n            if j == m: return 1\\n            return (counts[i][T[j]] * help(i+1,j+1) + help(i+1,j)) % (10**9+7)\\n        return help(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, W: List[str], T: str) -> int:\\n        n, m = len(W[0]), len(T)\\n        counts = [Counter([w[i] for w in W]) for i in range(n)]\\n        @lru_cache(None)\\n        def help(i,j):\\n            if n - i < m - j: return 0\\n            if j == m: return 1\\n            return (counts[i][T[j]] * help(i+1,j+1) + help(i+1,j)) % (10**9+7)\\n        return help(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928794,
                "title": "python-simple-recursive-with-memo-and-dp-iterative-solution",
                "content": "dp(i,j) means number of words[..i],target[..j] match.\\ndp(i,j)=dp(i-1,j)+dp(i-1,j-1)*counter_i[target[j]], simple Knapsack logic.\\nuse one dimensional: dp(j)+=dp(j-1)*counter_i[target[j]], iterate from len(target) to 0.\\ncorner case:\\nfor i=0, only dp[0][0] should be calculated, move forward one bit,dp[1][1]+=dp[0][0]*cnt[...]\\njust set dp[0][0]=1,dp[0][j]=0\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if j==0:#means match target[0] only \\n                return sum(cnts[t][target[j]] for t in range(i+1))\\n            elif i==0:#i==0 and j>0\\n                return 0\\n            return dp(i-1,j)+dp(i-1,j-1)*cnts[i][target[j]]\\n        \\n        n=len(words[0])\\n        cnts=[collections.Counter(w[i] for w in words) for i in range(n)]\\n        return dp(n-1,len(target)-1)%(10**9+7)\\n\\t\\t\\n```\\n```\\nclass Solution(object):\\n    def numWays(self, words, target):\\n        dp=[1]+[0]*len(target)  \\n        for i in range(len(words[0])):\\n            counter_i=collections.Counter(w[i] for w in words)\\n            for j in range(1,len(target)+1)[::-1]:\\n                dp[j]+=dp[j-1]*counter_i[target[j-1]]\\n        return dp[-1]%(10**9+7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        @lru_cache(None)\\n        def dp(i,j):\\n            if j==0:#means match target[0] only \\n                return sum(cnts[t][target[j]] for t in range(i+1))\\n            elif i==0:#i==0 and j>0\\n                return 0\\n            return dp(i-1,j)+dp(i-1,j-1)*cnts[i][target[j]]\\n        \\n        n=len(words[0])\\n        cnts=[collections.Counter(w[i] for w in words) for i in range(n)]\\n        return dp(n-1,len(target)-1)%(10**9+7)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922943,
                "title": "c-similar-to-knapsack-dp-easy-approach-faster-than-98-58",
                "content": "\\n```\\n#include <bits/stdc++.h>\\ntypedef long long int ll;\\nll mod = 1e9+7;\\n\\n\\nclass Solution {\\npublic:\\n    string tt;            //global defined target string\\n    int fq[1001][26];      //global defined frequency array\\n    \\n    ll solve(vector<vector<ll>> &dp,  int k1, int k2)\\n    {\\n        // Base Conditions\\n        if(k2 > k1)\\n        {\\n            return ll(0); \\n        }\\n        if(k2 <0)\\n        {\\n            return ll(1);\\n        }\\n        \\n        // DP\\n        if(dp[k1][k2] != ll(-1))\\n        {\\n            return dp[k1][k2];\\n        }\\n        \\n        // Temporary ans for this recursion\\n        ll tans = ll(0);\\n        \\n        tans+=solve(dp, k1-1, k2); //skip k1 index\\n        tans%=mod;\\n        \\n        // include the character from the k1 index of words if it matches with the k2 index of target\\n        if(fq[k1][tt[k2]-\\'a\\'] > 0)\\n        {\\n            tans = (tans+  (ll(fq[k1][tt[k2]-\\'a\\'])*solve(dp, k1-1, k2-1))%mod)%mod;\\n        }\\n        \\n        // Update DP\\n        dp[k1][k2] = tans;\\n        return tans;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        tt =target;\\n        \\n        if(target.length() > words[0].length()){\\n            return 0;\\n        }\\n        \\n        int nw = words.size();\\n        int wl = words[0].length();\\n        int tl = target.length();\\n        \\n        // Update frequency array\\n        for(int i = 0; i<wl; i++)\\n        {\\n            // Initialisation\\n            for(int k = 0; k<26; k++)\\n            {\\n                fq[i][k] = 0;\\n            }\\n            \\n            // Updating frequency\\n            for(int j = 0; j<nw; j++)\\n            {\\n                fq[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        // Define DP vector\\n        vector<vector<ll>> dp(wl, vector<ll>(tl,ll(-1)));\\n        \\n        // Store long long int value in tans\\n        ll tans = solve(dp, wl-1, tl-1);\\n        \\n        // Convert ll to int\\n        int ans = int(tans%mod);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\ntypedef long long int ll;\\nll mod = 1e9+7;\\n\\n\\nclass Solution {\\npublic:\\n    string tt;            //global defined target string\\n    int fq[1001][26];      //global defined frequency array\\n    \\n    ll solve(vector<vector<ll>> &dp,  int k1, int k2)\\n    {\\n        // Base Conditions\\n        if(k2 > k1)\\n        {\\n            return ll(0); \\n        }\\n        if(k2 <0)\\n        {\\n            return ll(1);\\n        }\\n        \\n        // DP\\n        if(dp[k1][k2] != ll(-1))\\n        {\\n            return dp[k1][k2];\\n        }\\n        \\n        // Temporary ans for this recursion\\n        ll tans = ll(0);\\n        \\n        tans+=solve(dp, k1-1, k2); //skip k1 index\\n        tans%=mod;\\n        \\n        // include the character from the k1 index of words if it matches with the k2 index of target\\n        if(fq[k1][tt[k2]-\\'a\\'] > 0)\\n        {\\n            tans = (tans+  (ll(fq[k1][tt[k2]-\\'a\\'])*solve(dp, k1-1, k2-1))%mod)%mod;\\n        }\\n        \\n        // Update DP\\n        dp[k1][k2] = tans;\\n        return tans;\\n        \\n    }\\n    \\n    int numWays(vector<string>& words, string target) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        tt =target;\\n        \\n        if(target.length() > words[0].length()){\\n            return 0;\\n        }\\n        \\n        int nw = words.size();\\n        int wl = words[0].length();\\n        int tl = target.length();\\n        \\n        // Update frequency array\\n        for(int i = 0; i<wl; i++)\\n        {\\n            // Initialisation\\n            for(int k = 0; k<26; k++)\\n            {\\n                fq[i][k] = 0;\\n            }\\n            \\n            // Updating frequency\\n            for(int j = 0; j<nw; j++)\\n            {\\n                fq[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        // Define DP vector\\n        vector<vector<ll>> dp(wl, vector<ll>(tl,ll(-1)));\\n        \\n        // Store long long int value in tans\\n        ll tans = solve(dp, wl-1, tl-1);\\n        \\n        // Convert ll to int\\n        int ans = int(tans%mod);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 919783,
                "title": "python-bottom-up-o-n-m-easy-explanation",
                "content": "Here is my solution, I added comments, so that it is easy to read and understand\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \"\"\"\\n        Bottom-up dynamic-programming. \\n        \\n        dp[i][j] denotes the number of possibilities to get to the\\n        jth intex of target by using the letters of each word in words up to index i\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        dp = [[0 for _ in range(len(target))] for _ in range(len(words[0]))]\\n        \\n        # count[i] counts all the letters which are at position i in any word in words \\n        count = [[0] * 26 for _ in range(len(words[0]))]\\n        for i in range(len(words[0])):\\n            for word in words:\\n                count[i][ord(word[i])-97] += 1\\n        \\n        # Base-Case\\n        for i in range(len(words[0])):\\n            dp[i][0] = count[i][ord(target[0])-97] + dp[i-1][0] if i > 0 else count[i][ord(target[0])-97]\\n\\n        # Recursion   \\n        for i in range(1,len(words[0])):\\n            for j in range(1, len(target)):                \\n                dp[i][j] = ((count[i][ord(target[j])-97] * dp[i-1][j-1]) + dp[i-1][j]) % MOD\\n        \\n        return dp[-1][-1] % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \"\"\"\\n        Bottom-up dynamic-programming. \\n        \\n        dp[i][j] denotes the number of possibilities to get to the\\n        jth intex of target by using the letters of each word in words up to index i\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        dp = [[0 for _ in range(len(target))] for _ in range(len(words[0]))]\\n        \\n        # count[i] counts all the letters which are at position i in any word in words \\n        count = [[0] * 26 for _ in range(len(words[0]))]\\n        for i in range(len(words[0])):\\n            for word in words:\\n                count[i][ord(word[i])-97] += 1\\n        \\n        # Base-Case\\n        for i in range(len(words[0])):\\n            dp[i][0] = count[i][ord(target[0])-97] + dp[i-1][0] if i > 0 else count[i][ord(target[0])-97]\\n\\n        # Recursion   \\n        for i in range(1,len(words[0])):\\n            for j in range(1, len(target)):                \\n                dp[i][j] = ((count[i][ord(target[j])-97] * dp[i-1][j-1]) + dp[i-1][j]) % MOD\\n        \\n        return dp[-1][-1] % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918654,
                "title": "accepted-c-dp-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n\\n        public int NumWays(string[] words, string target)\\n        {\\n            checked\\n            {\\n                int m = words[0].Length;\\n                List<int>[] indices = new List<int>[26];\\n                IDictionary<int, int>[] maps = new IDictionary<int, int>[26];\\n                for (int i = 0; i < 26; i++)\\n                {\\n                    indices[i] = new List<int>();\\n                }\\n\\n                foreach (var word in words)\\n                {\\n                    for (int i = 0; i < word.Length; i++)\\n                    {\\n                        indices[word[i] - \\'a\\'].Add(i);\\n                    }\\n                }\\n\\n                for (int i = 0; i < 26; i++)\\n                {\\n                    IDictionary<int, int> map = new Dictionary<int, int>();\\n                    foreach (var idx in indices[i])\\n                    {\\n                        if (!map.ContainsKey(idx))\\n                        {\\n                            map[idx] = 0;\\n                        }\\n\\n                        map[idx]++;\\n                    }\\n\\n                    maps[i] = map;\\n                }\\n\\n                int[,] dp = new int[target.Length + 1, m];\\n\\n                for (int i = 0; i < m; i++)\\n                {\\n                    dp[0, i] = 1;\\n                }\\n\\n                for (int len = 1; len <= target.Length; len++)\\n                {\\n                    var map = maps[target[len - 1] - \\'a\\'];\\n                    for (int idx = 0; idx < m; idx++)\\n                    {\\n                        if (idx != 0)\\n                        {\\n                            dp[len, idx] = dp[len, idx - 1];\\n                            if (map.ContainsKey(idx))\\n                            {\\n                                dp[len, idx] += (int)(((long) dp[len - 1, idx - 1] * (long) map[idx]) % MODULO);\\n                                dp[len, idx] %= MODULO;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            if (len == 1 && map.ContainsKey(idx))\\n                            {\\n                                dp[len, idx] = map[idx];\\n                            }\\n                        }\\n\\n                    }\\n                }\\n\\n\\n                return dp[target.Length, m - 1];\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n\\n        public int NumWays(string[] words, string target)\\n        {\\n            checked\\n            {\\n                int m = words[0].Length;\\n                List<int>[] indices = new List<int>[26];\\n                IDictionary<int, int>[] maps = new IDictionary<int, int>[26];\\n                for (int i = 0; i < 26; i++)\\n                {\\n                    indices[i] = new List<int>();\\n                }\\n\\n                foreach (var word in words)\\n                {\\n                    for (int i = 0; i < word.Length; i++)\\n                    {\\n                        indices[word[i] - \\'a\\'].Add(i);\\n                    }\\n                }\\n\\n                for (int i = 0; i < 26; i++)\\n                {\\n                    IDictionary<int, int> map = new Dictionary<int, int>();\\n                    foreach (var idx in indices[i])\\n                    {\\n                        if (!map.ContainsKey(idx))\\n                        {\\n                            map[idx] = 0;\\n                        }\\n\\n                        map[idx]++;\\n                    }\\n\\n                    maps[i] = map;\\n                }\\n\\n                int[,] dp = new int[target.Length + 1, m];\\n\\n                for (int i = 0; i < m; i++)\\n                {\\n                    dp[0, i] = 1;\\n                }\\n\\n                for (int len = 1; len <= target.Length; len++)\\n                {\\n                    var map = maps[target[len - 1] - \\'a\\'];\\n                    for (int idx = 0; idx < m; idx++)\\n                    {\\n                        if (idx != 0)\\n                        {\\n                            dp[len, idx] = dp[len, idx - 1];\\n                            if (map.ContainsKey(idx))\\n                            {\\n                                dp[len, idx] += (int)(((long) dp[len - 1, idx - 1] * (long) map[idx]) % MODULO);\\n                                dp[len, idx] %= MODULO;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            if (len == 1 && map.ContainsKey(idx))\\n                            {\\n                                dp[len, idx] = map[idx];\\n                            }\\n                        }\\n\\n                    }\\n                }\\n\\n\\n                return dp[target.Length, m - 1];\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917737,
                "title": "python-defaultdict-counter-lru-cache-simple-and-concise",
                "content": "Memoization with the help of lru_cache.\\nPositions store number of occurences of a character c at position k in all of the words of the list.\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        mod = 10 ** 9 + 7\\n        m = len(words[0])\\n        n = len(target)\\n        positions = defaultdict(Counter)\\n        \\n        for i in range(len(words)):\\n            for j in range(m):\\n                positions[j][words[i][j]] += 1\\n                \\n        @lru_cache(None)\\n        def back(i, start):\\n            if i == n:\\n                return 1\\n            if start == m:\\n                return 0\\n            ans = 0\\n            ans += back(i, start + 1) % mod\\n            if positions[start][target[i]]:\\n                ans += positions[start][target[i]] * back(i + 1, start + 1) % mod\\n            return ans\\n            \\n        return back(0, 0) % mod\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        mod = 10 ** 9 + 7\\n        m = len(words[0])\\n        n = len(target)\\n        positions = defaultdict(Counter)\\n        \\n        for i in range(len(words)):\\n            for j in range(m):\\n                positions[j][words[i][j]] += 1\\n                \\n        @lru_cache(None)\\n        def back(i, start):\\n            if i == n:\\n                return 1\\n            if start == m:\\n                return 0\\n            ans = 0\\n            ans += back(i, start + 1) % mod\\n            if positions[start][target[i]]:\\n                ans += positions[start][target[i]] * back(i + 1, start + 1) % mod\\n            return ans\\n            \\n        return back(0, 0) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917713,
                "title": "python-dfs-w-memoization",
                "content": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \\n        # counts[i] is a hash-map that holds the frequencies for letters at position i in each word\\n        counts = [collections.Counter(w[i] for w in words) for i in range(len(words[0]))]\\n        \\n        # Now, we find every path through counts that uses no more than len(words[0]) - len(targets) \"skips\"\\n        # A skip means we do not include counts[ci][target[ti]] in the intermediate result for this path\\n        ans = 0\\n        @functools.lru_cache(None)\\n        def dfs(ci, skips):   # ci -> counts index\\n            # Target index is ci - the number of skips we\\'ve used\\n            ti = ci-skips\\n            if ti == len(target):\\n                return 1\\n            \\n            # This means we couldn\\'t create the target string using this path\\n            if ci == len(counts):\\n                return 0\\n            \\n            res = counts[ci][target[ti]] * dfs(ci+1, skips)\\n            if skips < len(words[0])-len(target):\\n                res += dfs(ci+1, skips+1)\\n            \\n            return res\\n        \\n        return dfs(0, 0) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \\n        # counts[i] is a hash-map that holds the frequencies for letters at position i in each word\\n        counts = [collections.Counter(w[i] for w in words) for i in range(len(words[0]))]\\n        \\n        # Now, we find every path through counts that uses no more than len(words[0]) - len(targets) \"skips\"\\n        # A skip means we do not include counts[ci][target[ti]] in the intermediate result for this path\\n        ans = 0\\n        @functools.lru_cache(None)\\n        def dfs(ci, skips):   # ci -> counts index\\n            # Target index is ci - the number of skips we\\'ve used\\n            ti = ci-skips\\n            if ti == len(target):\\n                return 1\\n            \\n            # This means we couldn\\'t create the target string using this path\\n            if ci == len(counts):\\n                return 0\\n            \\n            res = counts[ci][target[ti]] * dfs(ci+1, skips)\\n            if skips < len(words[0])-len(target):\\n                res += dfs(ci+1, skips+1)\\n            \\n            return res\\n        \\n        return dfs(0, 0) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047451,
                "title": "2-d-dp-intiution-from",
                "content": "# Intuition:\\nThe goal is to count the number of ways to form the target string using characters from the given list of words.\\n\\n# Approach:\\n\\nDeclare constants for numWords (number of words in the input), wordLength (length of each word), targetLength (length of the target string), and MOD (a constant to perform modulo operations).\\n\\nCreate a 2D vector dp of dimensions (wordLength + 1) x (targetLength + 1) to store the number of ways to form the target string.\\n\\nCreate a 2D vector count of dimensions (wordLength x 26) to count the occurrences of each character (\\'a\\' to \\'z\\') at each position in the words.\\n\\nInitialize count by iterating through all the words and incrementing the count of characters at each position.\\n\\nInitialize the base case: dp[i][0] for all i to 1 because there is one way to form an empty target string.\\n\\nIterate through i from 1 to wordLength and j from 1 to targetLength:\\n\\nCalculate dp[i][j] as the product of the count of the current character in words at position i-1 (indexed at 0) and dp[i-1][j-1], plus dp[i-1][j]. This recurrence relation counts the number of ways to form the target string up to position j.\\n\\nApply modulo MOD to the result to avoid overflow.\\n\\nFinally, return dp[wordLength][targetLength], which represents the total number of ways to form the target string.\\n\\n# Complexity:\\n\\nTime complexity: O(numWords x wordLength x targetLength)\\nSpace complexity: O(wordLength x targetLength)\\nThe code efficiently calculates the number of ways to form the target string using dynamic programming and character counts in the words vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        const int numWords = words.size();\\n        const int wordLength = words[0].size();\\n        const int targetLength = target.size();\\n        const int MOD = 1000000007;\\n\\n        vector<vector<long long>> dp(wordLength + 1, vector<long long>(targetLength + 1, 0));\\n        vector<vector<int>> count(wordLength, vector<int>(26, 0));\\n        for(int i=0;i<numWords;i++){\\n            for(int j=0;j<wordLength;j++){\\n                count[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<=wordLength;i++){\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i <= wordLength; i++) {\\n            for (int j = 1; j <= targetLength; j++) {\\n                dp[i][j] = (count[i-1][target[j-1] - \\'a\\'] * dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[wordLength][targetLength];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        const int numWords = words.size();\\n        const int wordLength = words[0].size();\\n        const int targetLength = target.size();\\n        const int MOD = 1000000007;\\n\\n        vector<vector<long long>> dp(wordLength + 1, vector<long long>(targetLength + 1, 0));\\n        vector<vector<int>> count(wordLength, vector<int>(26, 0));\\n        for(int i=0;i<numWords;i++){\\n            for(int j=0;j<wordLength;j++){\\n                count[j][words[i][j] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<=wordLength;i++){\\n            dp[i][0] = 1;\\n        }\\n\\n        for (int i = 1; i <= wordLength; i++) {\\n            for (int j = 1; j <= targetLength; j++) {\\n                dp[i][j] = (count[i-1][target[j-1] - \\'a\\'] * dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[wordLength][targetLength];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044031,
                "title": "dynamic-programming-memonization-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int freq[][];\\n    int MOD=1000000007;\\n    int memo[][];\\n    public int numWays(String[] words, String target) {\\n       freq=new int[26][words[0].length()];\\n       m=target.length();\\n       n=words[0].length();\\n       memo=new int[m][n];\\n       for(int mem[]:memo)Arrays.fill(mem,-1);\\n       for(int i=0;i<words.length;i++){\\n           for(int j=0;j<n;j++){\\n               char ch=words[i].charAt(j);\\n               freq[ch-\\'a\\'][j]++;\\n           }\\n       }\\n       return (int)solve(0,0,target);\\n    }\\n    public long solve(int i,int j,String target){\\n           if(i==m)return 1;\\n\\n           if(j==n)return 0;\\n           if(memo[i][j]!=-1)return memo[i][j];\\n           int nottaken=(int)solve(i,j+1,target)%MOD;\\n           int taken=(int)((long)freq[target.charAt(i)-\\'a\\'][j]*solve(i+1,j+1,target)%MOD);\\n\\n           return memo[i][j]= (nottaken+taken)%MOD;\\n       }\\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int freq[][];\\n    int MOD=1000000007;\\n    int memo[][];\\n    public int numWays(String[] words, String target) {\\n       freq=new int[26][words[0].length()];\\n       m=target.length();\\n       n=words[0].length();\\n       memo=new int[m][n];\\n       for(int mem[]:memo)Arrays.fill(mem,-1);\\n       for(int i=0;i<words.length;i++){\\n           for(int j=0;j<n;j++){\\n               char ch=words[i].charAt(j);\\n               freq[ch-\\'a\\'][j]++;\\n           }\\n       }\\n       return (int)solve(0,0,target);\\n    }\\n    public long solve(int i,int j,String target){\\n           if(i==m)return 1;\\n\\n           if(j==n)return 0;\\n           if(memo[i][j]!=-1)return memo[i][j];\\n           int nottaken=(int)solve(i,j+1,target)%MOD;\\n           int taken=(int)((long)freq[target.charAt(i)-\\'a\\'][j]*solve(i+1,j+1,target)%MOD);\\n\\n           return memo[i][j]= (nottaken+taken)%MOD;\\n       }\\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001918,
                "title": "c-dp-time-o-n2-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>> enc(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                ++enc[j][words[i][j] - \\'a\\'];\\n\\n        int l = target.size();\\n        if (n < l)\\n            return 0;\\n\\n        ll MOD_NUM = 1000000007LL;\\n        vector<ll> dp(n + 1, 0LL);\\n        dp[0] = 1LL;\\n\\n        for (int i = 0; i < l; ++i) {\\n            ll cumSum = accumulate(dp.begin(), dp.end(), 0LL);\\n            for (int j = n; j >= 0; --j) {\\n                if (j <= i) {\\n                    dp[j] = 0LL;\\n                } else {\\n                    cumSum -= dp[j];\\n                    dp[j] = (enc[j - 1][target[i] - \\'a\\'] * cumSum) % MOD_NUM;\\n                }\\n            }\\n        }\\n\\n        ll ret = accumulate(dp.begin() + l, dp.end(), 0LL) % MOD_NUM;\\n\\n        return (int)ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n\\n        int m = words.size(), n = words[0].size();\\n        vector<vector<int>> enc(n, vector<int>(26, 0));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                ++enc[j][words[i][j] - \\'a\\'];\\n\\n        int l = target.size();\\n        if (n < l)\\n            return 0;\\n\\n        ll MOD_NUM = 1000000007LL;\\n        vector<ll> dp(n + 1, 0LL);\\n        dp[0] = 1LL;\\n\\n        for (int i = 0; i < l; ++i) {\\n            ll cumSum = accumulate(dp.begin(), dp.end(), 0LL);\\n            for (int j = n; j >= 0; --j) {\\n                if (j <= i) {\\n                    dp[j] = 0LL;\\n                } else {\\n                    cumSum -= dp[j];\\n                    dp[j] = (enc[j - 1][target[i] - \\'a\\'] * cumSum) % MOD_NUM;\\n                }\\n            }\\n        }\\n\\n        ll ret = accumulate(dp.begin() + l, dp.end(), 0LL) % MOD_NUM;\\n\\n        return (int)ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994312,
                "title": "simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can see from the problem that we can only take words upto some index j. This indicates a dp problem of form 2. DP steps:\\n\\n1. Determine form: form 2 ending form\\n2. DP meaning: dp(i, j) = number of ways to form i length prefix of target with first j letters of all words\\n3. Recursion: dp(i, j) = dp(i-1, j-1)*(number of target[i] at position j across words) + dp(i, j-1)\\n4. Base case: for i = 0, there is always 1 way for any j. If target has a length more than any of the words then impossible.\\n5. Optimization: we can solve this iteratively. For i > j the answer is always 0.  **use long long for dp** to avoid overflow\\n\\n# Complexity\\n- Time complexity: O(n*m) where n is the length of target and m is the length of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m) for iterative version\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = target.size();\\n\\n        int MOD = 1000000007;\\n\\n        if(words[0].size() < n)\\n        {\\n            return 0;\\n        }\\n\\n        int m = words[0].size();\\n\\n        vector<vector<long>> count(m+1, vector<long>(26, 0));\\n\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            for(int j = 1; j<=words[i].size(); j++)\\n            {\\n                count[j][(int)(words[i][j-1] - \\'a\\')]++;\\n            }\\n        }\\n\\n        vector<vector<long>> dp(n+1, vector<long>(m+1, 0));\\n\\n        for(int j = 0; j<=m; j++)\\n        {\\n            dp[0][j] = 1;\\n        }\\n\\n        for(int i = 1; i<=n; i++)\\n        {\\n            for(int j = 1; j<=m; j++)\\n            {\\n                if(i > j)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else\\n                {\\n                    dp[i][j] = ((dp[i-1][j-1]*count[j][(int)(target[i-1]-\\'a\\')])%MOD + dp[i][j-1])%MOD;\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = target.size();\\n\\n        int MOD = 1000000007;\\n\\n        if(words[0].size() < n)\\n        {\\n            return 0;\\n        }\\n\\n        int m = words[0].size();\\n\\n        vector<vector<long>> count(m+1, vector<long>(26, 0));\\n\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            for(int j = 1; j<=words[i].size(); j++)\\n            {\\n                count[j][(int)(words[i][j-1] - \\'a\\')]++;\\n            }\\n        }\\n\\n        vector<vector<long>> dp(n+1, vector<long>(m+1, 0));\\n\\n        for(int j = 0; j<=m; j++)\\n        {\\n            dp[0][j] = 1;\\n        }\\n\\n        for(int i = 1; i<=n; i++)\\n        {\\n            for(int j = 1; j<=m; j++)\\n            {\\n                if(i > j)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else\\n                {\\n                    dp[i][j] = ((dp[i-1][j-1]*count[j][(int)(target[i-1]-\\'a\\')])%MOD + dp[i][j-1])%MOD;\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978194,
                "title": "python-memoization",
                "content": "\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        dp = [[-1 for j in range(len(target))] for i in range(len(words[0]))]\\n        letterFreq = [[0 for j in range(26)] for i in range(len(words[0]))]\\n        for i in range(len(words[0])):\\n            for word in words:\\n                letterFreq[i][ord(word[i])-97] += 1\\n        \\n        def dfs(k, j):\\n            if j==len(target):\\n                return 1\\n            if k==len(words[0]):\\n                return 0\\n            if dp[k][j] > -1:\\n                return dp[k][j]\\n            dp[k][j] = dfs(k+1 , j) + letterFreq[k][ord(target[j])-97] * dfs(k+1, j+1)\\n            return dp[k][j]\\n        return dfs(0, 0) % (10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        dp = [[-1 for j in range(len(target))] for i in range(len(words[0]))]\\n        letterFreq = [[0 for j in range(26)] for i in range(len(words[0]))]\\n        for i in range(len(words[0])):\\n            for word in words:\\n                letterFreq[i][ord(word[i])-97] += 1\\n        \\n        def dfs(k, j):\\n            if j==len(target):\\n                return 1\\n            if k==len(words[0]):\\n                return 0\\n            if dp[k][j] > -1:\\n                return dp[k][j]\\n            dp[k][j] = dfs(k+1 , j) + letterFreq[k][ord(target[j])-97] * dfs(k+1, j+1)\\n            return dp[k][j]\\n        return dfs(0, 0) % (10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911303,
                "title": "recursive-with-memoization-easy-to-read-fewer-lines-do-not-mean-better",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n    // Count characters at each idx of word\\n    const dict = {};\\n    for (let i = 0 ; i < words[0].length ; i++) {\\n        const count = Array(26).fill(0);\\n\\n        for (let j = 0 ; j < words.length ; j++) {\\n            const c = words[j][i];\\n            const idx = c.charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\n            count[idx] += 1;\\n        }\\n\\n        dict[i] = count;\\n    }\\n\\n    const cache = [];\\n    for (let i = 0 ; i < words[0].length ; i++) {\\n        cache.push(Array(target.length).fill(null));\\n    }\\n\\n    return find(cache, dict, target, words[0].length, 0, 0);\\n};\\n\\nfunction find(cache, dict, target, maxWordLength, charIdx, targetIdx) {\\n    if (targetIdx >= target.length) {\\n        return 1;\\n    }\\n\\n    if (charIdx >= maxWordLength) {\\n        return 0;\\n    }\\n\\n    if (cache[charIdx][targetIdx] !== null) {\\n        return cache[charIdx][targetIdx];\\n    }\\n\\n    // Skip this charIdx\\n    let count = find(cache, dict, target, maxWordLength, charIdx + 1, targetIdx);\\n\\n    const wanted = target[targetIdx];\\n    const idx = wanted.charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\n    // Use this charIdx\\n    if (dict[charIdx][idx] > 0) {\\n        count += dict[charIdx][idx] * find(cache, dict, target, maxWordLength, charIdx + 1, targetIdx + 1);\\n    }\\n\\n    cache[charIdx][targetIdx] = count % 1000000007;\\n    return cache[charIdx][targetIdx];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n    // Count characters at each idx of word\\n    const dict = {};\\n    for (let i = 0 ; i < words[0].length ; i++) {\\n        const count = Array(26).fill(0);\\n\\n        for (let j = 0 ; j < words.length ; j++) {\\n            const c = words[j][i];\\n            const idx = c.charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\n            count[idx] += 1;\\n        }\\n\\n        dict[i] = count;\\n    }\\n\\n    const cache = [];\\n    for (let i = 0 ; i < words[0].length ; i++) {\\n        cache.push(Array(target.length).fill(null));\\n    }\\n\\n    return find(cache, dict, target, words[0].length, 0, 0);\\n};\\n\\nfunction find(cache, dict, target, maxWordLength, charIdx, targetIdx) {\\n    if (targetIdx >= target.length) {\\n        return 1;\\n    }\\n\\n    if (charIdx >= maxWordLength) {\\n        return 0;\\n    }\\n\\n    if (cache[charIdx][targetIdx] !== null) {\\n        return cache[charIdx][targetIdx];\\n    }\\n\\n    // Skip this charIdx\\n    let count = find(cache, dict, target, maxWordLength, charIdx + 1, targetIdx);\\n\\n    const wanted = target[targetIdx];\\n    const idx = wanted.charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\n    // Use this charIdx\\n    if (dict[charIdx][idx] > 0) {\\n        count += dict[charIdx][idx] * find(cache, dict, target, maxWordLength, charIdx + 1, targetIdx + 1);\\n    }\\n\\n    cache[charIdx][targetIdx] = count % 1000000007;\\n    return cache[charIdx][targetIdx];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901218,
                "title": "c-dp-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int alp_size = 26;\\n        int target_len = target.size();\\n        int word_len = words[0].size();\\n        int M = 1e9 + 7;\\n\\n        vector<vector<int>> char_col_freq(alp_size, vector<int>(word_len + 1, 0));\\n\\n        for(auto& word: words){\\n            for(int i = 1; i <= word_len; ++i){\\n                char c = word[i-1];\\n                char_col_freq[c-\\'a\\'][i] ++;\\n            }\\n        }\\n\\n        vector<vector<LL>> dp(target_len + 1, vector<LL>(word_len + 1, 0));\\n        for(int i = 0; i <= word_len; ++i){\\n            dp[0][i] = 1;\\n        }\\n\\n        for(int tlen = 1; tlen <= target_len; ++tlen){\\n            for(int col = 1; col <= word_len; ++col){\\n                if(tlen > col)\\n                    continue;\\n                char c = target[tlen-1];\\n                dp[tlen][col] = dp[tlen][col-1] + dp[tlen-1][col-1] * char_col_freq[c-\\'a\\'][col];\\n                dp[tlen][col] %= M;\\n            }\\n        }\\n\\n        return (int)dp[target_len][word_len];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int alp_size = 26;\\n        int target_len = target.size();\\n        int word_len = words[0].size();\\n        int M = 1e9 + 7;\\n\\n        vector<vector<int>> char_col_freq(alp_size, vector<int>(word_len + 1, 0));\\n\\n        for(auto& word: words){\\n            for(int i = 1; i <= word_len; ++i){\\n                char c = word[i-1];\\n                char_col_freq[c-\\'a\\'][i] ++;\\n            }\\n        }\\n\\n        vector<vector<LL>> dp(target_len + 1, vector<LL>(word_len + 1, 0));\\n        for(int i = 0; i <= word_len; ++i){\\n            dp[0][i] = 1;\\n        }\\n\\n        for(int tlen = 1; tlen <= target_len; ++tlen){\\n            for(int col = 1; col <= word_len; ++col){\\n                if(tlen > col)\\n                    continue;\\n                char c = target[tlen-1];\\n                dp[tlen][col] = dp[tlen][col-1] + dp[tlen-1][col-1] * char_col_freq[c-\\'a\\'][col];\\n                dp[tlen][col] %= M;\\n            }\\n        }\\n\\n        return (int)dp[target_len][word_len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776924,
                "title": "c-easy-solution-dp",
                "content": "```\\npublic class Solution {\\n    public int NumWays(string[] words, string target) {\\n        int mod = ((int)1e9) + 7;\\n        int n = words[0].Length,m = target.Length;\\n        int[][] dp = new int[n][];\\n        for(int i = 0; i < n;i++){\\n            dp[i] = new int[m];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int i, int j){\\n            if(j >= m) return 1;\\n            if(i >= n || m - j > n - i) return 0;\\n            if(dp[i][j] != -1)return dp[i][j];\\n            int res = solve(i + 1,j) % mod;\\n            foreach(var word in words){\\n                if(word[i] == target[j])\\n                    res = (res % mod +  solve(i + 1,j + 1) % mod) % mod;\\n            }\\n            return dp[i][j] = res % mod;\\n        }\\n        return solve(0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumWays(string[] words, string target) {\\n        int mod = ((int)1e9) + 7;\\n        int n = words[0].Length,m = target.Length;\\n        int[][] dp = new int[n][];\\n        for(int i = 0; i < n;i++){\\n            dp[i] = new int[m];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int i, int j){\\n            if(j >= m) return 1;\\n            if(i >= n || m - j > n - i) return 0;\\n            if(dp[i][j] != -1)return dp[i][j];\\n            int res = solve(i + 1,j) % mod;\\n            foreach(var word in words){\\n                if(word[i] == target[j])\\n                    res = (res % mod +  solve(i + 1,j + 1) % mod) % mod;\\n            }\\n            return dp[i][j] = res % mod;\\n        }\\n        return solve(0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712295,
                "title": "simple-c-solution-dynamic-programming-memoization-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<vector<long long>>&freq,string &target,int &len,vector<vector<long long>>&dp){\\n    if(index==target.length())return 1;\\n    else if(index<target.length()-1 && prev>=len)return 0;\\n    else if(target.length()-index>(len-prev))return 0;\\n    if(dp[index][prev+1]!=-1)return dp[index][prev+1];\\n    long long ans=0;\\n    for(int i=prev+1;i<len;i++){\\n        long long curr=0;\\n            curr=((freq[i][target[index]-\\'a\\'])%mod*(hope(index+1,i,freq,target,len,dp)%mod))%mod;\\n        \\n        ans=(ans%mod+curr%mod)%mod;\\n\\n    }\\n    return dp[index][prev+1]=ans;\\n}\\n\\n    int numWays(vector<string>& words, string target) {\\n        int len=words[0].length();\\n       vector<vector<long long>>freq(len,vector<long long>(26,0));\\n       for(int i=0;i<words.size();i++){\\n           for(int j=0;j<words[i].length();j++){\\n               freq[j][words[i][j]-\\'a\\']=freq[j][words[i][j]-\\'a\\']+1;\\n           }\\n       } \\n       vector<vector<long long>>dp(target.length(),vector<long long>(len+1,-1));\\n       long long answer= hope(0,-1,freq,target,len,dp)%mod;\\n       int final_ans=(int)answer;\\n       return final_ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<vector<long long>>&freq,string &target,int &len,vector<vector<long long>>&dp){\\n    if(index==target.length())return 1;\\n    else if(index<target.length()-1 && prev>=len)return 0;\\n    else if(target.length()-index>(len-prev))return 0;\\n    if(dp[index][prev+1]!=-1)return dp[index][prev+1];\\n    long long ans=0;\\n    for(int i=prev+1;i<len;i++){\\n        long long curr=0;\\n            curr=((freq[i][target[index]-\\'a\\'])%mod*(hope(index+1,i,freq,target,len,dp)%mod))%mod;\\n        \\n        ans=(ans%mod+curr%mod)%mod;\\n\\n    }\\n    return dp[index][prev+1]=ans;\\n}\\n\\n    int numWays(vector<string>& words, string target) {\\n        int len=words[0].length();\\n       vector<vector<long long>>freq(len,vector<long long>(26,0));\\n       for(int i=0;i<words.size();i++){\\n           for(int j=0;j<words[i].length();j++){\\n               freq[j][words[i][j]-\\'a\\']=freq[j][words[i][j]-\\'a\\']+1;\\n           }\\n       } \\n       vector<vector<long long>>dp(target.length(),vector<long long>(len+1,-1));\\n       long long answer= hope(0,-1,freq,target,len,dp)%mod;\\n       int final_ans=(int)answer;\\n       return final_ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698999,
                "title": "simple-dp-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2D DP - D[i, j] = how many ways target[0..i] is formed considering words upto to jth index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        oc = Counter()\\n        for word in words:\\n            for i, c in enumerate(word):\\n                oc[(c, i)] += 1\\n        m, n = len(words[0]), len(target)\\n        D = [[0 for _ in range(m)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                if i > j:\\n                    continue\\n                elif i == 0 and j == 0:\\n                    D[i][j] = oc[(target[0], 0)]\\n                elif i == 0:\\n                    D[i][j] = D[i][j - 1] + oc[(target[i], j)]\\n                else:\\n                    D[i][j] = D[i][j - 1] + D[i - 1][j - 1] * oc[(target[i], j)]\\n        return D[n - 1][m - 1] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        oc = Counter()\\n        for word in words:\\n            for i, c in enumerate(word):\\n                oc[(c, i)] += 1\\n        m, n = len(words[0]), len(target)\\n        D = [[0 for _ in range(m)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                if i > j:\\n                    continue\\n                elif i == 0 and j == 0:\\n                    D[i][j] = oc[(target[0], 0)]\\n                elif i == 0:\\n                    D[i][j] = D[i][j - 1] + oc[(target[i], j)]\\n                else:\\n                    D[i][j] = D[i][j - 1] + D[i - 1][j - 1] * oc[(target[i], j)]\\n        return D[n - 1][m - 1] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659055,
                "title": "rust-c-7ms-100-probably-the-most-efficient-code-possible",
                "content": "# Intuition\\n\\nSomehow dynamic programming should be involved.\\n\\n# Approach\\n\\nI literally have no idea.\\nThough it is similar to [Stone Game III](https://leetcode.com/problems/stone-game-iii/).\\n\\n# Complexity\\n\\nGiven a word dictionary of length $k$ with each word\\'s length $n$, and a target string of length $m$,\\n\\n- Time complexity:\\n$$O(nk + m(n-m))$$\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```rust []\\n// Turn word dict to frequency map\\npub fn preproc(words: Vec<String>) -> Vec<[usize; 32]> {\\n    let n = words[0].len();\\n\\n    let mut freq_map = vec![[0; 32]; n]; // 28 chars in alphabet\\n\\n    for word in words {\\n        for (i, c) in word.chars().enumerate() {\\n            let c = c as usize - \\'a\\' as usize;\\n            freq_map[i][c] += 1;\\n        }\\n    }\\n\\n    freq_map\\n}\\n\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    const MOD: usize = 1_000_000_007;\\n\\n    pub fn _impl(words: Vec<String>, target: String) -> Option<usize> {\\n        if words.is_empty() { return None; }\\n        \\n        let mut target = target.chars()\\n            .map(|c| c as usize - \\'a\\' as usize)\\n            .collect::<Vec<_>>(); // convert string to vec of chars\\n        let mut freq_map = preproc(words); // frequency map for each index\\n\\n        let (m, n) = (target.len(), freq_map.len());\\n        if m > n { return None; }\\n\\n        target.reverse();\\n        freq_map.reverse(); // WHY DO YOU HATE YOURSELF\\n\\n        let dp_len = n - m + 1;\\n        let mut dp = VecDeque::from(vec![1usize; dp_len]); // magic\\n\\n        for (i, c) in target.into_iter().enumerate() { // what??\\n            let mut count_prev = 0usize;\\n\\n            for j in (0..(n-m+1)) { // ??\\n                let mut head = dp.pop_front().unwrap();\\n\\n                head *= freq_map[i + j][c]; // WAT?????\\n                head += count_prev;\\n                head %= Self::MOD;\\n\\n                dp.push_back(head);\\n\\n                count_prev = head;\\n            }\\n        }\\n\\n        dp.pop_back()\\n    }\\n\\n    pub fn num_ways(words: Vec<String>, target: String) -> i32 {\\n        Self::_impl(words, target)\\n            .unwrap_or(0) as i32\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\nprivate:\\n    vector<vector<unsigned long>> preproc(const vector<string>& words) {\\n        auto n = words[0].size();\\n\\n        vector<vector<unsigned long>> vec;\\n\\n        for (auto i = 0; i < n; i += 1) {\\n            vec.emplace_back(26, 0);\\n        }\\n\\n        for (auto word : words) {\\n            for (auto i = 0; i < word.size(); i += 1) {\\n                auto c = word[i];\\n                vec[i][c - \\'a\\'] += 1;\\n            }\\n        }\\n\\n        return vec;\\n    }\\n\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        if (words.empty()) return 0;\\n\\n        auto freq_map = preproc(words);\\n        auto m = target.size();\\n        auto n = freq_map.size();\\n        \\n        if (m > n) return 0;\\n\\n        reverse(begin(freq_map), end(freq_map));\\n        reverse(begin(target), end(target));\\n\\n        unsigned long MOD = 1000000007;\\n\\n        auto dp_len = n - m + 1;\\n        deque<unsigned long> dp;\\n        for (auto i = 0; i < dp_len; i += 1) {\\n            dp.push_back(1);\\n        }\\n\\n        for (auto i = 0; i < target.size(); i += 1) {\\n            int c = target[i] - \\'a\\';\\n\\n            unsigned long count_prev = 0;\\n\\n            for (auto j = 0; j < n-m+1; j += 1) {\\n                auto count_next = dp.front();\\n                dp.pop_front();\\n\\n                count_next *= freq_map[i+j][c];\\n                count_next += count_prev;\\n                count_next %= MOD;\\n\\n                count_prev = count_next;\\n                dp.push_back(count_next);\\n            }\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```rust []\\n// Turn word dict to frequency map\\npub fn preproc(words: Vec<String>) -> Vec<[usize; 32]> {\\n    let n = words[0].len();\\n\\n    let mut freq_map = vec![[0; 32]; n]; // 28 chars in alphabet\\n\\n    for word in words {\\n        for (i, c) in word.chars().enumerate() {\\n            let c = c as usize - \\'a\\' as usize;\\n            freq_map[i][c] += 1;\\n        }\\n    }\\n\\n    freq_map\\n}\\n\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    const MOD: usize = 1_000_000_007;\\n\\n    pub fn _impl(words: Vec<String>, target: String) -> Option<usize> {\\n        if words.is_empty() { return None; }\\n        \\n        let mut target = target.chars()\\n            .map(|c| c as usize - \\'a\\' as usize)\\n            .collect::<Vec<_>>(); // convert string to vec of chars\\n        let mut freq_map = preproc(words); // frequency map for each index\\n\\n        let (m, n) = (target.len(), freq_map.len());\\n        if m > n { return None; }\\n\\n        target.reverse();\\n        freq_map.reverse(); // WHY DO YOU HATE YOURSELF\\n\\n        let dp_len = n - m + 1;\\n        let mut dp = VecDeque::from(vec![1usize; dp_len]); // magic\\n\\n        for (i, c) in target.into_iter().enumerate() { // what??\\n            let mut count_prev = 0usize;\\n\\n            for j in (0..(n-m+1)) { // ??\\n                let mut head = dp.pop_front().unwrap();\\n\\n                head *= freq_map[i + j][c]; // WAT?????\\n                head += count_prev;\\n                head %= Self::MOD;\\n\\n                dp.push_back(head);\\n\\n                count_prev = head;\\n            }\\n        }\\n\\n        dp.pop_back()\\n    }\\n\\n    pub fn num_ways(words: Vec<String>, target: String) -> i32 {\\n        Self::_impl(words, target)\\n            .unwrap_or(0) as i32\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\nprivate:\\n    vector<vector<unsigned long>> preproc(const vector<string>& words) {\\n        auto n = words[0].size();\\n\\n        vector<vector<unsigned long>> vec;\\n\\n        for (auto i = 0; i < n; i += 1) {\\n            vec.emplace_back(26, 0);\\n        }\\n\\n        for (auto word : words) {\\n            for (auto i = 0; i < word.size(); i += 1) {\\n                auto c = word[i];\\n                vec[i][c - \\'a\\'] += 1;\\n            }\\n        }\\n\\n        return vec;\\n    }\\n\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        if (words.empty()) return 0;\\n\\n        auto freq_map = preproc(words);\\n        auto m = target.size();\\n        auto n = freq_map.size();\\n        \\n        if (m > n) return 0;\\n\\n        reverse(begin(freq_map), end(freq_map));\\n        reverse(begin(target), end(target));\\n\\n        unsigned long MOD = 1000000007;\\n\\n        auto dp_len = n - m + 1;\\n        deque<unsigned long> dp;\\n        for (auto i = 0; i < dp_len; i += 1) {\\n            dp.push_back(1);\\n        }\\n\\n        for (auto i = 0; i < target.size(); i += 1) {\\n            int c = target[i] - \\'a\\';\\n\\n            unsigned long count_prev = 0;\\n\\n            for (auto j = 0; j < n-m+1; j += 1) {\\n                auto count_next = dp.front();\\n                dp.pop_front();\\n\\n                count_next *= freq_map[i+j][c];\\n                count_next += count_prev;\\n                count_next %= MOD;\\n\\n                count_prev = count_next;\\n                dp.push_back(count_next);\\n            }\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586561,
                "title": "tle-tle-tle-accepted-o-n-2-space-solution",
                "content": "# Intuition\\n\\nWe try to form the target string considering all the possible strings and caching the result along the way.\\n\\nThe code below shows the though process and the improvements made to get the solution to accepted state.\\n\\nIts not much but it\\'s honest work.\\n\\nUpvote if you find this helpful.\\n\\n# Code\\nFirst Attempt\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        @cache\\n        def calc(i, k):\\n\\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            for l in range(0, len(words)):\\n                for m in range(k, len(words[0])):\\n                    if target[i] == words[l][m]:\\n                        ans += calc(i+1, m+1)\\n                        ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\\nSecond Attempt\\n\\nAdding a check to terminate early if the remaining letters in words are lesser than what is required to complete target string.\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            for l in range(0, len(words)):\\n                for m in range(k, len(words[0])):\\n                    if target[i] == words[l][m]:\\n                        ans += calc(i+1, m+1)\\n                        ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\\n\\nThird Attempt:\\n\\nRealizing the fact that if multiple strings have common same character at the kth position then we can precompute the number of strings having the kth character same and multiply that with result of computing the result from next character to avoid the outer for loop.\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        d = {i:{} for i in range(len(words[0]))}\\n\\n        for i in range(len(words[0])):\\n            for j in range(len(words)):\\n                d[i][words[j][i]] = 1 if words[j][i] not in d[i] else d[i][words[j][i]]+1\\n        \\n\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            # for l in range(0, len(words)):\\n            for m in range(k, len(words[0])):\\n                if target[i] in d[m]:\\n                    ans += d[m][target[i]]*calc(i+1, m+1)\\n                    ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\\n\\nFinal Accepted Solution\\n\\nFurther optimizing to not even call the calc function again for the scenarios where we know eventually it will result in a 0\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        d = {i:{} for i in range(len(words[0]))}\\n\\n        for i in range(len(words[0])):\\n            for j in range(len(words)):\\n                d[i][words[j][i]] = 1 if words[j][i] not in d[i] else d[i][words[j][i]]+1\\n        \\n\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            # for l in range(0, len(words)):\\n            for m in range(k, len(words[0])):\\n                if len(target) - (i+1) > (len(words[0]) - (m+1)):\\n                    break\\n                if target[i] in d[m]:\\n                    ans += d[m][target[i]]*calc(i+1, m+1)\\n                    ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        @cache\\n        def calc(i, k):\\n\\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            for l in range(0, len(words)):\\n                for m in range(k, len(words[0])):\\n                    if target[i] == words[l][m]:\\n                        ans += calc(i+1, m+1)\\n                        ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            for l in range(0, len(words)):\\n                for m in range(k, len(words[0])):\\n                    if target[i] == words[l][m]:\\n                        ans += calc(i+1, m+1)\\n                        ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        d = {i:{} for i in range(len(words[0]))}\\n\\n        for i in range(len(words[0])):\\n            for j in range(len(words)):\\n                d[i][words[j][i]] = 1 if words[j][i] not in d[i] else d[i][words[j][i]]+1\\n        \\n\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            # for l in range(0, len(words)):\\n            for m in range(k, len(words[0])):\\n                if target[i] in d[m]:\\n                    ans += d[m][target[i]]*calc(i+1, m+1)\\n                    ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        if len(target) > len(words[0]):\\n            return 0\\n        mod = (10**9) + 7\\n        d = {i:{} for i in range(len(words[0]))}\\n\\n        for i in range(len(words[0])):\\n            for j in range(len(words)):\\n                d[i][words[j][i]] = 1 if words[j][i] not in d[i] else d[i][words[j][i]]+1\\n        \\n\\n        @cache\\n        def calc(i, k):\\n            if len(target) - (i+1) > (len(words[0]) - (k+1)):\\n                return 0 \\n            if i == len(target):\\n                return 1\\n            if k == len(words[0]):\\n                return 0\\n            ans = 0\\n            # for l in range(0, len(words)):\\n            for m in range(k, len(words[0])):\\n                if len(target) - (i+1) > (len(words[0]) - (m+1)):\\n                    break\\n                if target[i] in d[m]:\\n                    ans += d[m][target[i]]*calc(i+1, m+1)\\n                    ans %= mod\\n            \\n            return ans\\n        \\n        return calc(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484967,
                "title": "easy-python-solution-with-94-tc-using-dp",
                "content": "p\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        dp = dict()\\n        l = len(words[0])\\n        m = len(target)\\n        n = len(words)\\n        count = [[0] * 26 for _ in range(l)]\\n        for i in range(l):\\n            for word in words:\\n                count[i][ord(word[i]) - 97] += 1\\n        @cache\\n        def solve(j, k):\\n            if(k == m):\\n                return 1\\n            if(j == l or m-k > l-j):\\n                return 0\\n            if((j, k) in dp):\\n                return dp[(j, k)]\\n            dp[(j, k)] = solve(j+1, k+1)*count[j][ord(target[k])-97] + solve(j+1, k)\\n            return dp[(j, k)]\\n        return solve(0, 0) % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        dp = dict()\\n        l = len(words[0])\\n        m = len(target)\\n        n = len(words)\\n        count = [[0] * 26 for _ in range(l)]\\n        for i in range(l):\\n            for word in words:\\n                count[i][ord(word[i]) - 97] += 1\\n        @cache\\n        def solve(j, k):\\n            if(k == m):\\n                return 1\\n            if(j == l or m-k > l-j):\\n                return 0\\n            if((j, k) in dp):\\n                return dp[(j, k)]\\n            dp[(j, k)] = solve(j+1, k+1)*count[j][ord(target[k])-97] + solve(j+1, k)\\n            return dp[(j, k)]\\n        return solve(0, 0) % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471534,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numWays(words: Array[String], target: String): Int = {\\n        val cnt = words.map(_.toArray).transpose.map(_.groupBy(identity).mapValues(_.size.toLong))\\n        val dp = Array.ofDim[Long](target.length, words(0).length)\\n        for((ch, i) <- target.zipWithIndex){\\n            for(j <- 0 until  words(0).length){\\n                if(i == 0)\\n                    if(j == 0) dp(i)(j) = cnt(0).getOrElse(ch, 0L)\\n                    else dp(i)(j) = dp(i)(j - 1) + cnt(j).getOrElse(ch, 0L)\\n                else if(i <= j) dp(i)(j) = (dp(i)(j - 1) + dp(i - 1)(j - 1) * cnt(j).getOrElse(ch, 0L)) % 1000000007\\n            }\\n        }\\n        dp.last.last.toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numWays(words: Array[String], target: String): Int = {\\n        val cnt = words.map(_.toArray).transpose.map(_.groupBy(identity).mapValues(_.size.toLong))\\n        val dp = Array.ofDim[Long](target.length, words(0).length)\\n        for((ch, i) <- target.zipWithIndex){\\n            for(j <- 0 until  words(0).length){\\n                if(i == 0)\\n                    if(j == 0) dp(i)(j) = cnt(0).getOrElse(ch, 0L)\\n                    else dp(i)(j) = dp(i)(j - 1) + cnt(j).getOrElse(ch, 0L)\\n                else if(i <= j) dp(i)(j) = (dp(i)(j - 1) + dp(i - 1)(j - 1) * cnt(j).getOrElse(ch, 0L)) % 1000000007\\n            }\\n        }\\n        dp.last.last.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3469234,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        n=len(words)\\n        m=len(words[0])\\n        cnt=defaultdict(int)\\n        for i in words:\\n            for j,k in enumerate(i):\\n                # index=ord(k)-ord(\\'a\\')\\n                cnt[(j,k)]+=1\\n        \\n        dp={}\\n        \\n        def dfs(i,k):\\n            if i==len(target):\\n                return 1\\n            if k==m:\\n                return 0\\n            if (i,k) in dp:\\n                return dp[(i,k)]\\n            c=target[i]\\n            dp[(i,k)]=dfs(i,k+1)\\n            dp[(i,k)]+=cnt[(k,c)]*dfs(i+1,k+1)\\n            return dp[(i,k)]%(10**9+7)\\n        return dfs(0,0)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        n=len(words)\\n        m=len(words[0])\\n        cnt=defaultdict(int)\\n        for i in words:\\n            for j,k in enumerate(i):\\n                # index=ord(k)-ord(\\'a\\')\\n                cnt[(j,k)]+=1\\n        \\n        dp={}\\n        \\n        def dfs(i,k):\\n            if i==len(target):\\n                return 1\\n            if k==m:\\n                return 0\\n            if (i,k) in dp:\\n                return dp[(i,k)]\\n            c=target[i]\\n            dp[(i,k)]=dfs(i,k+1)\\n            dp[(i,k)]+=cnt[(k,c)]*dfs(i+1,k+1)\\n            return dp[(i,k)]%(10**9+7)\\n        return dfs(0,0)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462709,
                "title": "python-o-n-hashmap-dp-recursion-intuitive-technical-explanation",
                "content": "# Intuition\\ndd, dp = default dict, dynamic programming\\n\\n# Approach\\nThe dp matrix is used for memoization (its not actually that dynamic tbh). It stores on row $i$, column $j$ the number of ways form the substring $target[i:]$ with letters from a word in words with from index >= j.\\n\\nThe dd nested hashmap is used to store at each index $j$ for words (you can only use letters in words after the index $j$) the letters and the number of that letter available at index $j$. (The number of letters available is the number of ways you can pick a letter at index $j$ from a word in words)\\n\\nOnce you have the dd and dp data structures set up, checking if the $i\\'th$ letter in the target (both 0-indexed) can be built with the $i\\'th$ letter in some word from words gives:\\n\\n1 = When no word in words has at index[j] the i\\'th letter in target that we are trying to add\\n2 = When words have at index j the letter you need right now\\n1) $targetAcquired(i, j+1)$: Increase the index j for words\\n\\n2) $dp[i][j]: (dd[j][t[i]] * targetAcquired(i+1, j+1)) + * targetAcquired(i, j+1)$\\n\\nWhere $dd[j][t[i]]$: the number of that letter a.k.a the number of ways you can pick a letter, and $targetAcquired(i, j+1)$: the number of ways you could have still made the word if you skipped using that index)\\n\\nThats why the base cases are $1$ and $0$. When you hit the target you\\'ve made $1$ instance of the target (and the 1 gets recursively multiplied) and the index in words is greater than the length of the longest words theres $0$ ways to make target.\\n\\n# Complexity\\nu = words.length\\nv = length of longest word\\nn = target.length\\n\\nCreating dd is O(v) when the scenario has real words - the length of English words are relatively constant as opposed to say, an essay.\\n\\nThe recursion has worst case time complexity O(v\\\\*n). This occurs when there is a match and the index i could be used or not used. The index j for target always increases, but the dp matrix prevents there ever from being more than O(v\\\\*n) recursive function calls that calls itself again.\\n\\nTime complexity:\\nO(n)\\n\\n\\n\\n\\n# Code\\n```\\n# Makes a hashmap of value: number of times the value appears\\nfrom collections import Counter as C\\n\\n\\nclass Solution:\\n    def numWays(self, w: List[str], t: str) -> int:\\n\\n        def targetAcquired(i, j):\\n            if i == n: return 1\\n            if j == m: return 0\\n            if dp[i][j] > -1: return dp[i][j]\\n\\n            if t[i] not in dd[j]:\\n                dp[i][j] = targetAcquired(i, j+1)\\n                return dp[i][j]\\n\\n            dp[i][j] = dd[j][t[i]] * targetAcquired(i+1, j+1) + 1 * targetAcquired(i, j+1)\\n            return dp[i][j] % (10**9 + 7)\\n\\n        dp = [[-1]*len(w[0]) for i in range(len(t))]\\n        dd = {i: C([w[j][i] for j in range(len(w))]) for i in range(len(w[0]))}\\n        m, n = len(dd), len(t)\\n        return targetAcquired(0, 0) % (10**9 + 7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# Makes a hashmap of value: number of times the value appears\\nfrom collections import Counter as C\\n\\n\\nclass Solution:\\n    def numWays(self, w: List[str], t: str) -> int:\\n\\n        def targetAcquired(i, j):\\n            if i == n: return 1\\n            if j == m: return 0\\n            if dp[i][j] > -1: return dp[i][j]\\n\\n            if t[i] not in dd[j]:\\n                dp[i][j] = targetAcquired(i, j+1)\\n                return dp[i][j]\\n\\n            dp[i][j] = dd[j][t[i]] * targetAcquired(i+1, j+1) + 1 * targetAcquired(i, j+1)\\n            return dp[i][j] % (10**9 + 7)\\n\\n        dp = [[-1]*len(w[0]) for i in range(len(t))]\\n        dd = {i: C([w[j][i] for j in range(len(w))]) for i in range(len(w[0]))}\\n        m, n = len(dd), len(t)\\n        return targetAcquired(0, 0) % (10**9 + 7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444185,
                "title": "c-recursion-bottom-up-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint mod = 1e9 + 7;\\n\\tint solve(int wi, int ti, vector<string> &words, string target, vector<vector< long long >> &cnt, vector< vector< long long>> &dp)\\n\\t{\\n\\t\\tif (ti == target.length())\\n\\t\\t\\treturn 1;\\n\\t\\tif (wi == words[0].length())\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp[wi][ti] != -1)\\n\\t\\t\\treturn dp[wi][ti];\\n\\n\\t\\tlong long ways = 0;\\n\\t\\tways += (solve(wi + 1, ti + 1, words, target, cnt, dp) *cnt[wi][target[ti] - \\'a\\']) % mod;\\n\\n\\t\\tways += solve(wi + 1, ti, words, target, cnt, dp) % mod;\\n\\t\\treturn dp[wi][ti] = (ways % mod);\\n\\t}\\n\\n\\tint numWays(vector<string> &words, string target)\\n\\t{\\n\\t\\tint W = words[0].length(), L = target.length();\\n\\n\\t\\tvector<vector < long long>> cnt(W + 1, vector < long long > (27, 0));\\n\\t\\tvector<vector < long long>> dp(W + 1, vector < long long > (L + 1, 0));\\n\\n\\t\\tfor (int i = 0; i < words.size(); i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < W; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt[j][words[i][j] - \\'a\\'] += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int wi = W; wi >= 0; wi--)\\n\\t\\t{\\n\\t\\t\\tfor (int ti = L; ti >= 0; ti--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (ti == L)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[wi][ti] = 1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (wi == W)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[wi][ti] = 0;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong long ways = 0;\\n\\t\\t\\t\\tways += (dp[wi + 1][ti + 1] *cnt[wi][target[ti] - \\'a\\']) % mod;\\n\\n\\t\\t\\t\\tways += dp[wi + 1][ti] % mod;\\n\\t\\t\\t\\tdp[wi][ti] = (ways % mod);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0] % mod;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint mod = 1e9 + 7;\\n\\tint solve(int wi, int ti, vector<string> &words, string target, vector<vector< long long >> &cnt, vector< vector< long long>> &dp)\\n\\t{\\n\\t\\tif (ti == target.length())\\n\\t\\t\\treturn 1;\\n\\t\\tif (wi == words[0].length())\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (dp[wi][ti] != -1)\\n\\t\\t\\treturn dp[wi][ti];\\n\\n\\t\\tlong long ways = 0;\\n\\t\\tways += (solve(wi + 1, ti + 1, words, target, cnt, dp) *cnt[wi][target[ti] - \\'a\\']) % mod;\\n\\n\\t\\tways += solve(wi + 1, ti, words, target, cnt, dp) % mod;\\n\\t\\treturn dp[wi][ti] = (ways % mod);\\n\\t}\\n\\n\\tint numWays(vector<string> &words, string target)\\n\\t{\\n\\t\\tint W = words[0].length(), L = target.length();\\n\\n\\t\\tvector<vector < long long>> cnt(W + 1, vector < long long > (27, 0));\\n\\t\\tvector<vector < long long>> dp(W + 1, vector < long long > (L + 1, 0));\\n\\n\\t\\tfor (int i = 0; i < words.size(); i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < W; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt[j][words[i][j] - \\'a\\'] += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int wi = W; wi >= 0; wi--)\\n\\t\\t{\\n\\t\\t\\tfor (int ti = L; ti >= 0; ti--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (ti == L)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[wi][ti] = 1;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (wi == W)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[wi][ti] = 0;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong long ways = 0;\\n\\t\\t\\t\\tways += (dp[wi + 1][ti + 1] *cnt[wi][target[ti] - \\'a\\']) % mod;\\n\\n\\t\\t\\t\\tways += dp[wi + 1][ti] % mod;\\n\\t\\t\\t\\tdp[wi][ti] = (ways % mod);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0] % mod;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443533,
                "title": "i-have-questions-help-a-beginner",
                "content": "This question was a few days ago, I watched some videos and I understood a little bit the DP part of this problem, but I don\\'t understand everything in the editorial first solution. I just cannot let this question go like that. I feel like is a really good question \\nto learn from.\\n    I am gonna ask some dumb questions because I need confirmations what I understood. \\n\\nQuestions:\\n   1. Why dp matrix row length is `m + 1`? Why column is `k + 1` ?\\n   2. Can someone explain me what exactly I am doing in the nested for loops, editorial is not really clear\\n        - I understand that `dp[i + 1][j + 1]` goes to the next string, if we pick from `target[i]` we have to move forward with the string and column, right?\\n\\nWhat I don\\'t really understand is ` dp[i][j] be the number of ways to build the prefix of target of length i using only the j leftmost columns.` We aren\\'t building a prefix, we just count..\\n\\nThen `i < m`, I don\\'t understand the explanation very well.\\n\\nAt the end I got that matrix in the debugger, and its not really clear how I build it.\\n\\nThank you for your time and effort\\n\\nPS: I am also very tired and I have trouble to focus lately because of iron defficency, I am trying to fix that. And I really don\\'t want to close all the tabs and move on, I don\\'t wanna memorize this, I wanna know why I build that end matrix, I can\\'t visualize what am I doing.\\n\\n\\n# Code\\n    public int NumWays(string[] words, string target)\\n        {\\n            // problem constraint \"return it modulo 10^9 + 7.\"\\n            const int mod = 1000000007;\\n\\n            //  the length of strings in words\\n            var k = words[0].Length;\\n\\n            //  be the length of target\\n            var m = target.Length;\\n\\n            /*\\n                We can imagine words as a matrix containing n rows (each being a word) and k columns.\\n                The process of building target is as follows. We iterate over columns of the matrix from left to right, and at each of them, we have two options: \\n                    1. to pick a character at the current column \\n                    OR\\n                    2. to skip.\\n            */\\n\\n            // Let frequencyCount[c][j] denote the number of occurrences of the character c in the j-th column of the matrix \\u2013 one can precompute this before calculating the DP.\\n            var frequencyCount = new int[26][];\\n\\n            // we initialize frequency count array\\n            for (var i = 0; i < frequencyCount.Length; i++)\\n                frequencyCount[i] = new int[k];\\n\\n            /*\\n                0 1 2 3\\n                a c c a\\n                b b b b \\n                c a c a\\n\\n                Count character c in the j-th column index\\n                a  1 1 0 2 \\n                b  1 1 1 1 \\n                c  1 1 2 0\\n                d  0 0 0 0 \\n                e  0 0 0 0\\n                \\n                ..\\n                0 0 0 0\\n\\n                I am having an array of all characters which have an array for their frequency in the words\\n            */\\n            for (var i = 0; i < k; i++)\\n                foreach (var word in words)\\n                    frequencyCount[word[i] - \\'a\\'][i]++;\\n\\n            // We initialize dp matrix with m + 1 rows\\n            // Why m + 1 rows?\\n            double[][] dp = new double[m + 1][];\\n\\n            for (var i = 0; i < dp.Length; i++)\\n                dp[i] = new double[k + 1]; // why k + 1 columns\\n\\n            dp[0][0] = 1;\\n\\n            // dp[i][j] be the number of ways to build the prefix of target of length i using only the j leftmost columns.\\n            // Why i <= m\\n            for (var i = 0; i <= m; i++)\\n            {\\n                for (var j = 0; j < k; j++)\\n                {\\n                    // if i < m, we need to add the character target[i] to the currently built prefix; otherwise, we have completely built the string target.\\n                    if (i < m)\\n                    {\\n                        // When we choose a character target[i] from the j-th column and add it to the current prefix (which has length i before adding), its length becomes i + 1. \\n                        // After this, we cannot use the j-th column, and have to move to the (j + 1)-th one. It describes a transition from the state dp[i][j] to dp[i + 1][j + 1]\\n                        dp[i + 1][j + 1] += frequencyCount[target[i] - \\'a\\'][j] * dp[i][j];\\n\\n                        //  In how many ways can one perform such a transition? The number of ways to choose a character target[i] in the j-th column equals cnt[target[i]][j] \\u2013 the number of its occurrences. \\n                        //  Therefore, we can do dp[i + 1][j + 1] += cnt[target[i]][j] * dp[i][j].\\n                        dp[i + 1][j + 1] %= mod;\\n                    }\\n                    // When we skip the j-th column and move on to the (j + 1)-th one, we do not add anything to the current prefix, and its length remains equal to i\\n                    dp[i][j + 1] += dp[i][j];\\n\\n                    // Here we have a transition from the state dp[i][j] to dp[i][j + 1]. There is one way not to choose any character, therefore we can do dp[i][j + 1] += dp[i][j].\\n                    dp[i][j + 1] %= mod;\\n                }\\n            }\\n\\n            // The answer to the problem is dp[m][k] \\u2013 we need to build the string of length m using k columns.\\n            /*\\n                1 1 1 1 1\\n                0 1 2 2 4\\n                0 0 1 3 5\\n                0 0 0 0 6\\n            */\\n            return (int)dp[m][k];\\n        }",
                "solutionTags": [
                    "C#"
                ],
                "code": "This question was a few days ago, I watched some videos and I understood a little bit the DP part of this problem, but I don\\'t understand everything in the editorial first solution. I just cannot let this question go like that. I feel like is a really good question \\nto learn from.\\n    I am gonna ask some dumb questions because I need confirmations what I understood. \\n\\nQuestions:\\n   1. Why dp matrix row length is `m + 1`? Why column is `k + 1` ?\\n   2. Can someone explain me what exactly I am doing in the nested for loops, editorial is not really clear\\n        - I understand that `dp[i + 1][j + 1]` goes to the next string, if we pick from `target[i]` we have to move forward with the string and column, right?\\n\\nWhat I don\\'t really understand is ` dp[i][j] be the number of ways to build the prefix of target of length i using only the j leftmost columns.` We aren\\'t building a prefix, we just count..\\n\\nThen `i < m`, I don\\'t understand the explanation very well.\\n\\nAt the end I got that matrix in the debugger, and its not really clear how I build it.\\n\\nThank you for your time and effort\\n\\nPS: I am also very tired and I have trouble to focus lately because of iron defficency, I am trying to fix that. And I really don\\'t want to close all the tabs and move on, I don\\'t wanna memorize this, I wanna know why I build that end matrix, I can\\'t visualize what am I doing.\\n\\n\\n# Code\\n    public int NumWays(string[] words, string target)\\n        {\\n            // problem constraint \"return it modulo 10^9 + 7.\"\\n            const int mod = 1000000007;\\n\\n            //  the length of strings in words\\n            var k = words[0].Length;\\n\\n            //  be the length of target\\n            var m = target.Length;\\n\\n            /*\\n                We can imagine words as a matrix containing n rows (each being a word) and k columns.\\n                The process of building target is as follows. We iterate over columns of the matrix from left to right, and at each of them, we have two options: \\n                    1. to pick a character at the current column \\n                    OR\\n                    2. to skip.\\n            */\\n\\n            // Let frequencyCount[c][j] denote the number of occurrences of the character c in the j-th column of the matrix \\u2013 one can precompute this before calculating the DP.\\n            var frequencyCount = new int[26][];\\n\\n            // we initialize frequency count array\\n            for (var i = 0; i < frequencyCount.Length; i++)\\n                frequencyCount[i] = new int[k];\\n\\n            /*\\n                0 1 2 3\\n                a c c a\\n                b b b b \\n                c a c a\\n\\n                Count character c in the j-th column index\\n                a  1 1 0 2 \\n                b  1 1 1 1 \\n                c  1 1 2 0\\n                d  0 0 0 0 \\n                e  0 0 0 0\\n                \\n                ..\\n                0 0 0 0\\n\\n                I am having an array of all characters which have an array for their frequency in the words\\n            */\\n            for (var i = 0; i < k; i++)\\n                foreach (var word in words)\\n                    frequencyCount[word[i] - \\'a\\'][i]++;\\n\\n            // We initialize dp matrix with m + 1 rows\\n            // Why m + 1 rows?\\n            double[][] dp = new double[m + 1][];\\n\\n            for (var i = 0; i < dp.Length; i++)\\n                dp[i] = new double[k + 1]; // why k + 1 columns\\n\\n            dp[0][0] = 1;\\n\\n            // dp[i][j] be the number of ways to build the prefix of target of length i using only the j leftmost columns.\\n            // Why i <= m\\n            for (var i = 0; i <= m; i++)\\n            {\\n                for (var j = 0; j < k; j++)\\n                {\\n                    // if i < m, we need to add the character target[i] to the currently built prefix; otherwise, we have completely built the string target.\\n                    if (i < m)\\n                    {\\n                        // When we choose a character target[i] from the j-th column and add it to the current prefix (which has length i before adding), its length becomes i + 1. \\n                        // After this, we cannot use the j-th column, and have to move to the (j + 1)-th one. It describes a transition from the state dp[i][j] to dp[i + 1][j + 1]\\n                        dp[i + 1][j + 1] += frequencyCount[target[i] - \\'a\\'][j] * dp[i][j];\\n\\n                        //  In how many ways can one perform such a transition? The number of ways to choose a character target[i] in the j-th column equals cnt[target[i]][j] \\u2013 the number of its occurrences. \\n                        //  Therefore, we can do dp[i + 1][j + 1] += cnt[target[i]][j] * dp[i][j].\\n                        dp[i + 1][j + 1] %= mod;\\n                    }\\n                    // When we skip the j-th column and move on to the (j + 1)-th one, we do not add anything to the current prefix, and its length remains equal to i\\n                    dp[i][j + 1] += dp[i][j];\\n\\n                    // Here we have a transition from the state dp[i][j] to dp[i][j + 1]. There is one way not to choose any character, therefore we can do dp[i][j + 1] += dp[i][j].\\n                    dp[i][j + 1] %= mod;\\n                }\\n            }\\n\\n            // The answer to the problem is dp[m][k] \\u2013 we need to build the string of length m using k columns.\\n            /*\\n                1 1 1 1 1\\n                0 1 2 2 4\\n                0 0 1 3 5\\n                0 0 0 0 6\\n            */\\n            return (int)dp[m][k];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3439897,
                "title": "with-recursion-but-failed-with-time-complexity",
                "content": "# Intuition\\nDP solution is hard to understand. Dimag nu dahi thai gayu.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static int mod = 1000000007;\\n    public void match(int[] result, String[] words, String target, StringBuilder input, int previousWordIndex) {\\n\\n        if (input.length() == target.length()) {\\n            if(input.toString().equals(target)) {\\n                result[0] = (result[0]+1)%mod;\\n            }\\n            return;\\n        }\\n\\n        for (String word : words) {\\n            for (int i= previousWordIndex+1; i< words[0].length(); i++) {\\n                input.append(word.charAt(i));\\n                if (target.startsWith(input.toString())) {\\n                    match(result, words, target, input, i);\\n                }\\n                input.deleteCharAt(input.length()-1);\\n            }  \\n        }\\n        \\n\\n    }\\n\\n     public int numWays(String[] words, String target) {\\n        int[] result = new int[1];\\n        match(result, words, target, new StringBuilder(), -1);\\n        return result[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int mod = 1000000007;\\n    public void match(int[] result, String[] words, String target, StringBuilder input, int previousWordIndex) {\\n\\n        if (input.length() == target.length()) {\\n            if(input.toString().equals(target)) {\\n                result[0] = (result[0]+1)%mod;\\n            }\\n            return;\\n        }\\n\\n        for (String word : words) {\\n            for (int i= previousWordIndex+1; i< words[0].length(); i++) {\\n                input.append(word.charAt(i));\\n                if (target.startsWith(input.toString())) {\\n                    match(result, words, target, input, i);\\n                }\\n                input.deleteCharAt(input.length()-1);\\n            }  \\n        }\\n        \\n\\n    }\\n\\n     public int numWays(String[] words, String target) {\\n        int[] result = new int[1];\\n        match(result, words, target, new StringBuilder(), -1);\\n        return result[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437468,
                "title": "recursive-memoization-optimisation-c",
                "content": "# Recursive Code (TLE)\\n```\\nclass Solution \\n{\\npublic:\\n    int f(int i, int j, vector<string>& words, string target)\\n    {\\n        if(j==target.size()) return 1;\\n        int ans=0;\\n        for(auto word: words)\\n        {\\n            for(int x=i; x<word.size(); x++)\\n            {\\n                if(word[x]==target[j])\\n                {\\n                    ans+=f(x+1,j+1,words,target);\\n                }\\n            }\\n        }\\n        return ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        return f(0,0,words,target);   \\n    }\\n};\\n```\\nNow let\\'s memoize!!\\n\\n# Memoized Code (TLE)\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[1100][1100];\\n    int mod=1e9+7;\\n    int f(int i, int j, vector<string>& words, string &target)\\n    {\\n        if(j==target.size()) return 1;\\n        int ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        for(auto word: words)\\n        {\\n            for(int x=i; x<word.size(); x++)\\n            {\\n                if(word[x]==target[j])\\n                {\\n                    dp[x+1][j+1]=f(x+1,j+1,words,target);\\n                    ans=(ans+dp[x+1][j+1])%mod;\\n                }\\n            }\\n        }\\n        return dp[i][j]=ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,words,target);   \\n    }\\n};\\n```\\nAh! Still TLE !!\\n\\nOptimisation - We can store number of occurances of each letter in each column beforehand.\\n\\n# Optimised Code (Passed)\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[1100][1100];\\n    int mod=1e9+7;\\n    int f(int i, int j, vector<vector<int>> &v, string &target)\\n    {\\n        if(j==target.size()) return 1;\\n        if(i==v.size()) return 0;\\n        long long ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(v[i][target[j]-\\'a\\']) ans=(ans+(long long)v[i][target[j]-\\'a\\']*f(i+1,j+1,v,target)%mod)%mod;\\n        ans=(ans+f(i+1,j,v,target))%mod;\\n        return dp[i][j]=ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int n=words[0].size();\\n        vector<vector<int>> v(n,vector<int> (26,0));\\n        for(auto word: words)\\n        {\\n            for(int x=0; x<n; x++)\\n            {\\n                v[x][word[x]-\\'a\\']++;\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,v,target);   \\n    }\\n};\\n```\\n\\n#     Wohooo!!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int f(int i, int j, vector<string>& words, string target)\\n    {\\n        if(j==target.size()) return 1;\\n        int ans=0;\\n        for(auto word: words)\\n        {\\n            for(int x=i; x<word.size(); x++)\\n            {\\n                if(word[x]==target[j])\\n                {\\n                    ans+=f(x+1,j+1,words,target);\\n                }\\n            }\\n        }\\n        return ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        return f(0,0,words,target);   \\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int dp[1100][1100];\\n    int mod=1e9+7;\\n    int f(int i, int j, vector<string>& words, string &target)\\n    {\\n        if(j==target.size()) return 1;\\n        int ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        for(auto word: words)\\n        {\\n            for(int x=i; x<word.size(); x++)\\n            {\\n                if(word[x]==target[j])\\n                {\\n                    dp[x+1][j+1]=f(x+1,j+1,words,target);\\n                    ans=(ans+dp[x+1][j+1])%mod;\\n                }\\n            }\\n        }\\n        return dp[i][j]=ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,words,target);   \\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int dp[1100][1100];\\n    int mod=1e9+7;\\n    int f(int i, int j, vector<vector<int>> &v, string &target)\\n    {\\n        if(j==target.size()) return 1;\\n        if(i==v.size()) return 0;\\n        long long ans=0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(v[i][target[j]-\\'a\\']) ans=(ans+(long long)v[i][target[j]-\\'a\\']*f(i+1,j+1,v,target)%mod)%mod;\\n        ans=(ans+f(i+1,j,v,target))%mod;\\n        return dp[i][j]=ans;      \\n    }\\n    int numWays(vector<string>& words, string target) \\n    {\\n        int n=words[0].size();\\n        vector<vector<int>> v(n,vector<int> (26,0));\\n        for(auto word: words)\\n        {\\n            for(int x=0; x<n; x++)\\n            {\\n                v[x][word[x]-\\'a\\']++;\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,v,target);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435999,
                "title": "c-solution-number-of-ways-to-form-a-target-string-given-a-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string.h>\\n\\nint numWays(char ** words, int wordsSize, char * target) \\n{\\n    int t = strlen(target);\\n    int w = strlen(words[0]); // Fixed width of all the words in \\'words\\' pointer\\n\\n    /* Getting memory for a frequency matrix for a specific character in the current column of the words 2 D array. 26 ==> 26 letters in alphabet */\\n    unsigned long long * f = malloc(sizeof(unsigned long long)  * w * 26);\\n\\n    /* Initializing with Zero */\\n    for (int i = 0; i < 26; i++)\\n        for (int j = 0; j < w; j++)\\n            f[(i * w) + j] = 0;\\n\\n    /* Transition matrix */\\n    unsigned long long * trans = malloc(sizeof(unsigned long long) * (t + 1) * (w + 1));\\n    for (int i = 0; i < (w+1); i++)\\n        for (int j = 0; j < (t+1); j++)\\n            trans[(i * (t+1)) + j] = 0;\\n\\n    /* Populate frequence matrix of characters column by column for each word in words*/\\n    for (int j = 0; j < w; j++)\\n        for (int i = 0; i < wordsSize; i++)\\n            f[((words[i][j] - \\'a\\') * w) + j]++;\\n\\n    /* Base case => trans[0][0]. \"1\" way to select nothing */\\n    trans[0] = 1;\\n\\n    for (int i = 0; i <= t; i++)\\n    {\\n        int r = (i * (w + 1)); // Getting the 2 D row index for a 1 D array. \\n\\n        for (int j = 0; j < w; j++)\\n        {\\n            if (i < t)\\n            {\\n                unsigned long long int freq  =   f[ ( ( target[i] - \\'a\\' ) * w ) + j ];\\n                unsigned long long int dp =  trans[r + j];\\n                \\n                /* res = dp * freq */\\n                unsigned long long int res =  ((dp % 1000000007) * (freq % 1000000007)) % 1000000007;\\n\\n                /* trans[i + 1][j + 1] += (trans[i][j] * freq of target[i] char in jth column ) */\\n                trans[ (r + (w+1) ) + (j + 1)] += res ;\\n            }\\n\\n            /* trans[i][j + 1] += trans[i][j] */\\n            trans[r + (j + 1)] += trans[r + j];\\n        }\\n    }\\n        \\n    return trans[(t * (w+1)) + w] % 1000000007;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <string.h>\\n\\nint numWays(char ** words, int wordsSize, char * target) \\n{\\n    int t = strlen(target);\\n    int w = strlen(words[0]); // Fixed width of all the words in \\'words\\' pointer\\n\\n    /* Getting memory for a frequency matrix for a specific character in the current column of the words 2 D array. 26 ==> 26 letters in alphabet */\\n    unsigned long long * f = malloc(sizeof(unsigned long long)  * w * 26);\\n\\n    /* Initializing with Zero */\\n    for (int i = 0; i < 26; i++)\\n        for (int j = 0; j < w; j++)\\n            f[(i * w) + j] = 0;\\n\\n    /* Transition matrix */\\n    unsigned long long * trans = malloc(sizeof(unsigned long long) * (t + 1) * (w + 1));\\n    for (int i = 0; i < (w+1); i++)\\n        for (int j = 0; j < (t+1); j++)\\n            trans[(i * (t+1)) + j] = 0;\\n\\n    /* Populate frequence matrix of characters column by column for each word in words*/\\n    for (int j = 0; j < w; j++)\\n        for (int i = 0; i < wordsSize; i++)\\n            f[((words[i][j] - \\'a\\') * w) + j]++;\\n\\n    /* Base case => trans[0][0]. \"1\" way to select nothing */\\n    trans[0] = 1;\\n\\n    for (int i = 0; i <= t; i++)\\n    {\\n        int r = (i * (w + 1)); // Getting the 2 D row index for a 1 D array. \\n\\n        for (int j = 0; j < w; j++)\\n        {\\n            if (i < t)\\n            {\\n                unsigned long long int freq  =   f[ ( ( target[i] - \\'a\\' ) * w ) + j ];\\n                unsigned long long int dp =  trans[r + j];\\n                \\n                /* res = dp * freq */\\n                unsigned long long int res =  ((dp % 1000000007) * (freq % 1000000007)) % 1000000007;\\n\\n                /* trans[i + 1][j + 1] += (trans[i][j] * freq of target[i] char in jth column ) */\\n                trans[ (r + (w+1) ) + (j + 1)] += res ;\\n            }\\n\\n            /* trans[i][j + 1] += trans[i][j] */\\n            trans[r + (j + 1)] += trans[r + j];\\n        }\\n    }\\n        \\n    return trans[(t * (w+1)) + w] % 1000000007;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3435995,
                "title": "python-6-dp-solutions-but-they-use-progressively-less-memory-for-the-dp-structure",
                "content": "Even when the crux of a dynamic programming solution seems to be filling in a big $M\\\\operatorname{x}N$ matrix, it is often possible to get away with using much less space than $O(MN)$ space for the dp data structure. It depends on the recurrence relation. Here I show 7 solutions, 6 of which are dp solutions. The first dp solution used $O(LN)$ space for the dp part. The last dp solution used only $O(L-N)$ space for the dp part.\\n\\nSummary of the solutions which use pregressively less memory for the dp structure\\n1. dfs solution\\n2. dp solution using size $(N+1)(L+1)$ dp matrix\\n3. dp solution using two size $L+1$ dp lists\\n4. dp solution using size $L+1$ dp list and one `dp_ip1_kp1` variable\\n5. dp solution using size $L$ dp list and one `dp_ip1_kp1` variable\\n6. dp solution using size $L-N+2$ dp list\\n7. dp solution using size $L-N+1$ dp list\\n\\nLet\\n- `N = len(target)`\\n- `L = len(words[0]`.\\n- $d_{i,k}$ be the number of ways to form `target[i:]` from `[word[k:] for word in words]`\\n- $f(k, ch)$ be the number of times character ch occurs as the $k$th character of a word in `words`, i.e. $f(k, ch) = $ `sum(1 for word in words if word[k] == ch)`\\n\\nMy solutions are based on the following reccurrence relation\\n\\n$$d_{i,k} = \\\\sum_{j=k}^{L-N+i}f(j, t_i) \\\\cdot d_{i+1,k+1}$$\\n\\nwhich I was able to later simplify to\\n\\n$$d_{i,k} = f(k, t_i) \\\\cdot d_{i+1,k+1} + d_{i,k+1}$$\\n\\nwhere $t_i = $ `target[i]`.\\n\\n---\\n# Solutons\\n\\n## Version 1\\n- Alt 1: Cache\\'d `dfs(i, k)` using unsimplified recurrence relation\\n- Alt 2: accumulated `dfs(i, k, acc)` also using unsimplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        # Alt 1\\n        @cache\\n        def dfs(i=0, k=0): # i <= k <= L-N+i; i <= N\\n            # assert i <= k <= L-N+i and i <= N\\n\\n            # # Alt 1a\\n            # if i == N or k == L:\\n            #     return i == N\\n\\n            # Alt 1b\\n            # k == L means\\n            # i <= k == L <= L-N+i\\n            # 0 <= -N+i\\n            # N <= i\\n            # i >= N\\n            # we also have i <= N\\n            # so i == N\\n            # so k == L implies i == N\\n            # which means we can simplify Alt 1a above to\\n            if i == N:\\n                return 1\\n            \\n            ch = target[i]\\n            return sum(\\n                freqs[k][ch] * dfs(i+1, k+1)\\n                for k in range(k, LmNp1 + i)\\n                if freqs[k][ch])\\n        \\n        # # Alt 2: Causes TLE in test case 49/89\\n        # def dfs(i=0, k=0, acc=1): # i <= k <= L-N+i; i <= N\\n        #     # assert i <= k <= L-N+i and i <= N\\n        #     if i == N:\\n        #         return acc\\n            \\n        #     ch = target[i]\\n        #     return sum(\\n        #         dfs(i+1, k+1, acc * freqs[k][ch])\\n        #         for k in range(k, LmNp1 + i)\\n        #         if freqs[k][ch])\\n        \\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        return dfs() % MOD\\n```\\n\\n\\n## Version 2\\n- Alt 1: size $(N+1)(L+1)$ dp matrix using unsimplified recurrence relation\\n- Alt 2: size $(N+1)(L+1)$ dp matrix using using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        # dp[i][k] is the number of ways to form target[i:] with [word[k:] for word in words]\\n        dp = [[0] * (L+1) for _ in range(N)]\\n        dp.append([0] * N + [1] * LmNp1)\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            for k in range(LmN + i, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n\\n                # dp[i][k] = sum(freqs[k][ch] * dp[i+1][k+1] for k in range(k, LmNp1 + i)) # Alt 1\\n                dp[i][k] = freqs[k][ch] * dp[i+1][k+1] + dp[i][k+1] # Alt 2\\n\\n        return dp[0][0] % MOD\\n```\\n\\n\\n## Version 3\\n- size $2(L+1)$ dp matrix (`dp_i` and `dp_ip1`) using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        # pre-swapped, will be unswapped in the first iteration of the for i loop\\n        dp_ip1 = [0] * (L+1)\\n        dp_i = [0] * N + [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            dp_i, dp_ip1 = dp_ip1, dp_i\\n            max_k = LmN + i\\n            dp_i[max_k + 1] = 0 # so that dp_i[k+1] is correct in the first iteration of the for k loop\\n            for k in range(max_k, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k] = freqs[k][ch] * dp_ip1[k+1] + dp_i[k+1]\\n\\n        return dp_i[0] % MOD\\n```\\n\\n\\n## Version 4\\n- size $L+1$ dp list (`dp_i`) and `dp_ip1_kp1` variable using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        dp_i = [0] * N + [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            K = LmN + i\\n            dp_ip1_kp1 = dp_i[K + 1] # so that dp_ip1_kp1 is correct in the first iteration of the for k loop\\n            dp_i[K + 1] = 0 # so that dp_i[k+1] is correct in the first iteration of the for k loop\\n            for k in range(K, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k], dp_ip1_kp1 = freqs[k][ch] * dp_ip1_kp1 + dp_i[k+1], dp_i[k]\\n\\n        return dp_i[0] % MOD\\n```\\n\\n\\n## Version 5\\n- size $L$ dp list (`dp_i`) and `dp_ip1_kp1` variable using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        dp_i = [0] * N + [1] * LmN\\n        dp_ip1_kp1 = 1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            K = LmN + i\\n\\n            # iteration k == K\\n            dp_i[K], dp_ip1_kp1 = freqs[K][ch] * dp_ip1_kp1, dp_i[K]\\n\\n            for k in range(K-1, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k], dp_ip1_kp1 = freqs[k][ch] * dp_ip1_kp1 + dp_i[k+1], dp_i[k]\\n            \\n            dp_ip1_kp1 = dp_i[K]\\n\\n        return dp_i[0] % MOD\\n```\\n\\n\\n## Version 6\\n- size $L-N+2$ dp list (`dp_i`) using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        \\n        dp_i = [1] * LmNp1 + [0]\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n\\n            # # Alt 1\\n            # K = LmN + i\\n            # for k in range(K, i-1, -1):\\n            #     kk = k - i\\n            #     # i <= k <= L-N+i; i < N\\n            #     # assert i <= k <= L-N+i and i < N\\n            #     dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n\\n            # # Alt 2\\n            # for kk in range(LmN, -1, -1):\\n            #     k = kk + i\\n            #     # i <= k <= L-N+i; i < N\\n            #     # assert i <= k <= L-N+i and i < N\\n            #     dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n\\n            # Alt 3\\n            k = LmN + i\\n            for kk in range(LmN, -1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n                k -= 1\\n\\n        return dp_i[0] % MOD\\n```\\n\\n\\n## Version 7\\n- size $L-N+1$ dp list (`dp_i`) using simplified recurrence relation\\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        \\n        dp_i = [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n\\n            k = LmN + i\\n            # iteration kk == LmN\\n            dp_i[-1] = freqs[k][ch] * dp_i[-1]\\n            k -= 1\\n\\n            for kk in range(LmN-1, -1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n                k -= 1\\n\\n        return dp_i[0] % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        # Alt 1\\n        @cache\\n        def dfs(i=0, k=0): # i <= k <= L-N+i; i <= N\\n            # assert i <= k <= L-N+i and i <= N\\n\\n            # # Alt 1a\\n            # if i == N or k == L:\\n            #     return i == N\\n\\n            # Alt 1b\\n            # k == L means\\n            # i <= k == L <= L-N+i\\n            # 0 <= -N+i\\n            # N <= i\\n            # i >= N\\n            # we also have i <= N\\n            # so i == N\\n            # so k == L implies i == N\\n            # which means we can simplify Alt 1a above to\\n            if i == N:\\n                return 1\\n            \\n            ch = target[i]\\n            return sum(\\n                freqs[k][ch] * dfs(i+1, k+1)\\n                for k in range(k, LmNp1 + i)\\n                if freqs[k][ch])\\n        \\n        # # Alt 2: Causes TLE in test case 49/89\\n        # def dfs(i=0, k=0, acc=1): # i <= k <= L-N+i; i <= N\\n        #     # assert i <= k <= L-N+i and i <= N\\n        #     if i == N:\\n        #         return acc\\n            \\n        #     ch = target[i]\\n        #     return sum(\\n        #         dfs(i+1, k+1, acc * freqs[k][ch])\\n        #         for k in range(k, LmNp1 + i)\\n        #         if freqs[k][ch])\\n        \\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        return dfs() % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        # dp[i][k] is the number of ways to form target[i:] with [word[k:] for word in words]\\n        dp = [[0] * (L+1) for _ in range(N)]\\n        dp.append([0] * N + [1] * LmNp1)\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            for k in range(LmN + i, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n\\n                # dp[i][k] = sum(freqs[k][ch] * dp[i+1][k+1] for k in range(k, LmNp1 + i)) # Alt 1\\n                dp[i][k] = freqs[k][ch] * dp[i+1][k+1] + dp[i][k+1] # Alt 2\\n\\n        return dp[0][0] % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        # pre-swapped, will be unswapped in the first iteration of the for i loop\\n        dp_ip1 = [0] * (L+1)\\n        dp_i = [0] * N + [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            dp_i, dp_ip1 = dp_ip1, dp_i\\n            max_k = LmN + i\\n            dp_i[max_k + 1] = 0 # so that dp_i[k+1] is correct in the first iteration of the for k loop\\n            for k in range(max_k, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k] = freqs[k][ch] * dp_ip1[k+1] + dp_i[k+1]\\n\\n        return dp_i[0] % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        dp_i = [0] * N + [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            K = LmN + i\\n            dp_ip1_kp1 = dp_i[K + 1] # so that dp_ip1_kp1 is correct in the first iteration of the for k loop\\n            dp_i[K + 1] = 0 # so that dp_i[k+1] is correct in the first iteration of the for k loop\\n            for k in range(K, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k], dp_ip1_kp1 = freqs[k][ch] * dp_ip1_kp1 + dp_i[k+1], dp_i[k]\\n\\n        return dp_i[0] % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n\\n        dp_i = [0] * N + [1] * LmN\\n        dp_ip1_kp1 = 1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n            K = LmN + i\\n\\n            # iteration k == K\\n            dp_i[K], dp_ip1_kp1 = freqs[K][ch] * dp_ip1_kp1, dp_i[K]\\n\\n            for k in range(K-1, i-1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[k], dp_ip1_kp1 = freqs[k][ch] * dp_ip1_kp1 + dp_i[k+1], dp_i[k]\\n            \\n            dp_ip1_kp1 = dp_i[K]\\n\\n        return dp_i[0] % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        \\n        dp_i = [1] * LmNp1 + [0]\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n\\n            # # Alt 1\\n            # K = LmN + i\\n            # for k in range(K, i-1, -1):\\n            #     kk = k - i\\n            #     # i <= k <= L-N+i; i < N\\n            #     # assert i <= k <= L-N+i and i < N\\n            #     dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n\\n            # # Alt 2\\n            # for kk in range(LmN, -1, -1):\\n            #     k = kk + i\\n            #     # i <= k <= L-N+i; i < N\\n            #     # assert i <= k <= L-N+i and i < N\\n            #     dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n\\n            # Alt 3\\n            k = LmN + i\\n            for kk in range(LmN, -1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n                k -= 1\\n\\n        return dp_i[0] % MOD\\n```\n```\\nMOD = 10**9 + 7\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        N = len(target)\\n        L = len(words[0])\\n        if L < N:\\n            return 0\\n        # L >= N\\n        LmN = L-N # >= 0\\n        LmNp1 = L-N+1 # >= 1\\n\\n        freqs = [Counter() for _ in range(L)]\\n        for word in words:\\n            for k, ch in enumerate(word):\\n                freqs[k][ch] += 1\\n        \\n        dp_i = [1] * LmNp1\\n\\n        for i in range(N-1, -1, -1):\\n            ch = target[i]\\n\\n            k = LmN + i\\n            # iteration kk == LmN\\n            dp_i[-1] = freqs[k][ch] * dp_i[-1]\\n            k -= 1\\n\\n            for kk in range(LmN-1, -1, -1):\\n                # i <= k <= L-N+i; i < N\\n                # assert i <= k <= L-N+i and i < N\\n                dp_i[kk] = freqs[k][ch] * dp_i[kk] + dp_i[kk+1]\\n                k -= 1\\n\\n        return dp_i[0] % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434753,
                "title": "simple-short-java-solution-with-dp-beats-98-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int MODULAR = (int) Math.pow(10, 9) + 7;\\n\\n    // target length - str length + str index <= target index <= str index\\n    public int numWays(String[] words, String target) {\\n        int[] countWord = new int[26];\\n        int[] numWays = new int[target.length()];       \\n\\n        for(int i = words[0].length() - 1; i >= 0; i --) {\\n            for(int w = 0; w < words.length; w ++) countWord[words[w].charAt(i) - \\'a\\']++;\\n            for(int j = Math.max(target.length() - words[0].length() + i, 0); j < target.length() && j <= i; j ++) {\\n                int t = target.charAt(j) - \\'a\\';\\n                int multiplier = 1;\\n                if(j < target.length() - 1) multiplier = numWays[j + 1];\\n                long temp = (long) countWord[t] * multiplier % MODULAR;\\n                numWays[j] = (numWays[j] + (int) temp) % MODULAR;\\n            }\\n\\n            countWord = new int[26]; \\n        }\\n\\n        return numWays[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MODULAR = (int) Math.pow(10, 9) + 7;\\n\\n    // target length - str length + str index <= target index <= str index\\n    public int numWays(String[] words, String target) {\\n        int[] countWord = new int[26];\\n        int[] numWays = new int[target.length()];       \\n\\n        for(int i = words[0].length() - 1; i >= 0; i --) {\\n            for(int w = 0; w < words.length; w ++) countWord[words[w].charAt(i) - \\'a\\']++;\\n            for(int j = Math.max(target.length() - words[0].length() + i, 0); j < target.length() && j <= i; j ++) {\\n                int t = target.charAt(j) - \\'a\\';\\n                int multiplier = 1;\\n                if(j < target.length() - 1) multiplier = numWays[j + 1];\\n                long temp = (long) countWord[t] * multiplier % MODULAR;\\n                numWays[j] = (numWays[j] + (int) temp) % MODULAR;\\n            }\\n\\n            countWord = new int[26]; \\n        }\\n\\n        return numWays[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434685,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Dp and Memoization Solution,gets Accepted\\u2705    \\n    int mod=1e9+7;\\n    int dp[1000][1001];   \\n    int find(int id,vector<vector<int>>& fre,string& target,int col,int n,int m){\\n        if(id==n){\\n            return 1;\\n        }\\n        if(col==m){\\n            return 0;\\n        }\\n        if(dp[id][col]!=-1){\\n            return dp[id][col];\\n        }\\n        int not_pick=find(id,fre,target,col+1,n,m);\\n        int pick=0;\\n        if(fre[col][target[id]-\\'a\\']!=0){\\n            int curr=fre[col][target[id]-\\'a\\'];\\n            pick=(((long)curr*(long)find(id+1,fre,target,col+1,n,m)%mod)%mod)%mod;\\n        }\\n        return dp[id][col]=(pick +not_pick)%mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=target.size(),m=words[0].size();\\n        vector<vector<int>> fre(m,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                fre[j][words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return find(0,fre,target,0,n,m);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Dp and Memoization Solution,gets Accepted\\u2705    \\n    int mod=1e9+7;\\n    int dp[1000][1001];   \\n    int find(int id,vector<vector<int>>& fre,string& target,int col,int n,int m){\\n        if(id==n){\\n            return 1;\\n        }\\n        if(col==m){\\n            return 0;\\n        }\\n        if(dp[id][col]!=-1){\\n            return dp[id][col];\\n        }\\n        int not_pick=find(id,fre,target,col+1,n,m);\\n        int pick=0;\\n        if(fre[col][target[id]-\\'a\\']!=0){\\n            int curr=fre[col][target[id]-\\'a\\'];\\n            pick=(((long)curr*(long)find(id+1,fre,target,col+1,n,m)%mod)%mod)%mod;\\n        }\\n        return dp[id][col]=(pick +not_pick)%mod;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=target.size(),m=words[0].size();\\n        vector<vector<int>> fre(m,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                fre[j][words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        return find(0,fre,target,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432425,
                "title": "c-dynamic-programming-o-n-word-size-m-n-m-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * word.size() + m * (n - m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size();\\n        vector<vector<int>> h (n, vector<int> (26,0));\\n        for (auto& word:words) {\\n            for (int j = 0; j < n; j++) {\\n                h[j][word[j]-\\'a\\']++;\\n            }\\n        }\\n        vector<int> prev (n+1, 1);\\n        vector<int> cur (n+1, 0);\\n        int m = target.length();\\n        for (int i = 1; i <= m; i++) {\\n            cur[i-1] = 0;\\n            for (int j = i; j <= n - m + i; j++) {\\n                cur[j] = (cur[j-1] + (long)prev[j-1] * h[j-1][target[i-1]-\\'a\\'])%dev;\\n            }\\n            swap(cur, prev);\\n        }\\n        return prev[n];\\n    }\\nprivate:\\n    int dev = 1000000007;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size();\\n        vector<vector<int>> h (n, vector<int> (26,0));\\n        for (auto& word:words) {\\n            for (int j = 0; j < n; j++) {\\n                h[j][word[j]-\\'a\\']++;\\n            }\\n        }\\n        vector<int> prev (n+1, 1);\\n        vector<int> cur (n+1, 0);\\n        int m = target.length();\\n        for (int i = 1; i <= m; i++) {\\n            cur[i-1] = 0;\\n            for (int j = i; j <= n - m + i; j++) {\\n                cur[j] = (cur[j-1] + (long)prev[j-1] * h[j-1][target[i-1]-\\'a\\'])%dev;\\n            }\\n            swap(cur, prev);\\n        }\\n        return prev[n];\\n    }\\nprivate:\\n    int dev = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431788,
                "title": "simple-dynamic-programming-solution-golang",
                "content": "Store the count of letters in all words at a given index, store this data in this form of 2D array. Use this array to find the number of combination for a particular index \\n```\\nvar mod = 1000000007\\n\\nfunc search(charGrid [][]int, idx, k, n, m int, target string, dp [][]int) int {\\n\\tif k >= m {\\n\\t\\treturn 1\\n\\t}\\n\\tif idx >= n {\\n\\t\\treturn 0\\n\\t}\\n\\tif dp[idx][k] != -1 {\\n\\t\\treturn dp[idx][k]\\n\\t}\\n\\tvar take, notTake = 0, 0\\n\\tif charGrid[idx][target[k]-\\'a\\'] > 0 {\\n\\t\\ttake = charGrid[idx][target[k]-\\'a\\'] * search(charGrid, idx+1, k+1, n, m, target, dp)\\n\\t}\\n\\tnotTake = search(charGrid, idx+1, k, n, m, target, dp)\\n\\tdp[idx][k] = (take + notTake) % mod\\n\\treturn dp[idx][k]\\n}\\n\\n\\nfunc numWays(words []string, target string) int {\\n  charGrid := make([][]int, len(words[0]))\\n\\tfor i := 0; i < len(words[0]); i++ {\\n\\t\\tcharGrid[i] = make([]int, 27)\\n\\t  for k := 0; k < 27; k++ {\\n\\t\\t  charGrid[i][k] = 0\\n\\t  }\\n\\t  for j := 0; j < len(words); j++ {\\n\\t\\t  charGrid[i][words[j][i]-\\'a\\']++\\n\\t  }\\n  }\\n\\tdp := make([][]int, len(words[0]))\\n\\tfor i := 0; i < len(words[0]); i++ {\\n\\t\\tdp[i] = make([]int, len(target))\\n\\t\\tfor j := 0; j < len(target); j++ {\\n\\t\\t\\tdp[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\treturn search(charGrid, 0, 0, len(words[0]), len(target), target, dp) \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mod = 1000000007\\n\\nfunc search(charGrid [][]int, idx, k, n, m int, target string, dp [][]int) int {\\n\\tif k >= m {\\n\\t\\treturn 1\\n\\t}\\n\\tif idx >= n {\\n\\t\\treturn 0\\n\\t}\\n\\tif dp[idx][k] != -1 {\\n\\t\\treturn dp[idx][k]\\n\\t}\\n\\tvar take, notTake = 0, 0\\n\\tif charGrid[idx][target[k]-\\'a\\'] > 0 {\\n\\t\\ttake = charGrid[idx][target[k]-\\'a\\'] * search(charGrid, idx+1, k+1, n, m, target, dp)\\n\\t}\\n\\tnotTake = search(charGrid, idx+1, k, n, m, target, dp)\\n\\tdp[idx][k] = (take + notTake) % mod\\n\\treturn dp[idx][k]\\n}\\n\\n\\nfunc numWays(words []string, target string) int {\\n  charGrid := make([][]int, len(words[0]))\\n\\tfor i := 0; i < len(words[0]); i++ {\\n\\t\\tcharGrid[i] = make([]int, 27)\\n\\t  for k := 0; k < 27; k++ {\\n\\t\\t  charGrid[i][k] = 0\\n\\t  }\\n\\t  for j := 0; j < len(words); j++ {\\n\\t\\t  charGrid[i][words[j][i]-\\'a\\']++\\n\\t  }\\n  }\\n\\tdp := make([][]int, len(words[0]))\\n\\tfor i := 0; i < len(words[0]); i++ {\\n\\t\\tdp[i] = make([]int, len(target))\\n\\t\\tfor j := 0; j < len(target); j++ {\\n\\t\\t\\tdp[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\treturn search(charGrid, 0, 0, len(words[0]), len(target), target, dp) \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431174,
                "title": "typescript-full-explanation-comments-easy-to-understand-bottom-up-dp-o-n-m",
                "content": "# Intuition\\nFor each of the `words`, consider if we can match a given character of `target` at a given index of the word. If there is a match, add the character to the prefix of `target` we\\'re building and continue to the character at the next index of the `target`, advancing the index of `words` we\\'re matching against. Also consider skipping the character at this index and see if we can match the given character of `target` at the next index.\\n\\nThe paramaters to the depth-first-search approach described above are `targetIndex`, `wordIndex`, `wordCharIndex`. We can memoize these parameters to avoid recomputing duplicate branches of the recursion tree.\\n\\nThe DFS approach works, but we know it\\'s not feasible since we\\'d end up with nine 9s of runtime complexity, i.e., our three parameters would result in `words.length * words[i].length * target.length`. This is equivalent to `1,000 * 1,000 * 1,000 = 1,000,000,000` in the worst case, even if we memoize.\\n\\nA hint for a path forward is that we only have to consider lowercase English letters. If we precompute the freqency of each letter at a given index across all words, we can eliminate the iteration over each word while building the prefix and reduce our time complexity to a feasible range.\\n\\n# Approach\\nPrecompute the frequency that each character of the alphabet appears at a given index of `words`. Next, use a dynamic programming matrix to track the number of ways to construct a prefix of `target` of length `i` using characters from index `0` to `j` from `words`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(target.length * words[0].length)$$\\n\\n- Space complexity:\\n$$O(target.length * words[0].length)$$\\n\\n# Code\\n```\\nfunction numWays(words: string[], target: string): number {\\n  const alphabetCharCount = 26;\\n  const mod = 1000_000_000 + 7;\\n\\n  // Array to store the number of times a character appears at each index.\\n  const freq = new Array(words[0].length)\\n    .fill(null)\\n    .map(() => new Array(alphabetCharCount).fill(0));\\n\\n  // Treat \"a\" as our zero index.\\n  const zeroCharCode = \\'a\\'.charCodeAt(0);\\n\\n  for (const word of words) {\\n    for (let i = 0; i < word.length; i++) {\\n      ++freq[i][word.charCodeAt(i) - zeroCharCode];\\n    }\\n  }\\n\\n  // console.table(freq);\\n\\n  // Capture the number of ways to choose i characters of target from the 0 to\\n  // jth column.\\n  const dp = new Array(target.length + 1).fill(null).map(() => {\\n    // Add one more column for the terminate condition of our transition equation\\n    // below.\\n    return new Array(words[0].length + 1).fill(0);\\n  });\\n\\n  // There is one way to choose zero characters from the first column\\n  dp[0][0] = 1;\\n\\n  for (let i = 0; i <= target.length; i++) {\\n    // We can\\'t start at a column less than i because that would mean\\n    // we added characters to the 0 to j prefix of target that weren\\'t\\n    // from our word list.\\n    for (let j = i; j < words[0].length; j++) {\\n      // console.log(`i: ${i}, j: ${j}`);\\n      // Have we added all characters of the target?\\n      if (i < target.length) {\\n        // We can add more characters here if any words have a matching character\\n        // in this column. The number of ways will be the number of words that\\n        // have a character at this column multiplied by the number of ways we\\n        // got to the current prefix of characters. It\\'s just like it we have two\\n        // choices of beans at the first station of Chipotle and now we\\'re choosing\\n        // meats at station two, the number of ways to fill a burrito at station\\n        // two is: (2 beans) x (# of meats).\\n        // console.log(\\n        //   `Char count of \"${target.charAt(i)}\" at column ${j}: ${\\n        //     freq[j][target.charCodeAt(i) - zeroCharCode]\\n        //   }`\\n        // );\\n\\n        dp[i + 1][j + 1] =\\n          dp[i][j] * freq[j][target.charCodeAt(i) - zeroCharCode];\\n        dp[i + 1][j + 1] %= mod;\\n      }\\n\\n      // Skip this column and give the next column the same number of ways since\\n      // we are not selecting any characters here. Be sure to add to the existing\\n      // ways we already calculated.\\n      dp[i][j + 1] += dp[i][j];\\n      dp[i][j + 1] %= mod;\\n\\n      // console.table(dp);\\n    }\\n  }\\n\\n  // console.table(dp);\\n\\n  // Return the number of ways to form all characters of the target using all\\n  // possible columns.\\n  return dp[target.length][words[0].length];\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction numWays(words: string[], target: string): number {\\n  const alphabetCharCount = 26;\\n  const mod = 1000_000_000 + 7;\\n\\n  // Array to store the number of times a character appears at each index.\\n  const freq = new Array(words[0].length)\\n    .fill(null)\\n    .map(() => new Array(alphabetCharCount).fill(0));\\n\\n  // Treat \"a\" as our zero index.\\n  const zeroCharCode = \\'a\\'.charCodeAt(0);\\n\\n  for (const word of words) {\\n    for (let i = 0; i < word.length; i++) {\\n      ++freq[i][word.charCodeAt(i) - zeroCharCode];\\n    }\\n  }\\n\\n  // console.table(freq);\\n\\n  // Capture the number of ways to choose i characters of target from the 0 to\\n  // jth column.\\n  const dp = new Array(target.length + 1).fill(null).map(() => {\\n    // Add one more column for the terminate condition of our transition equation\\n    // below.\\n    return new Array(words[0].length + 1).fill(0);\\n  });\\n\\n  // There is one way to choose zero characters from the first column\\n  dp[0][0] = 1;\\n\\n  for (let i = 0; i <= target.length; i++) {\\n    // We can\\'t start at a column less than i because that would mean\\n    // we added characters to the 0 to j prefix of target that weren\\'t\\n    // from our word list.\\n    for (let j = i; j < words[0].length; j++) {\\n      // console.log(`i: ${i}, j: ${j}`);\\n      // Have we added all characters of the target?\\n      if (i < target.length) {\\n        // We can add more characters here if any words have a matching character\\n        // in this column. The number of ways will be the number of words that\\n        // have a character at this column multiplied by the number of ways we\\n        // got to the current prefix of characters. It\\'s just like it we have two\\n        // choices of beans at the first station of Chipotle and now we\\'re choosing\\n        // meats at station two, the number of ways to fill a burrito at station\\n        // two is: (2 beans) x (# of meats).\\n        // console.log(\\n        //   `Char count of \"${target.charAt(i)}\" at column ${j}: ${\\n        //     freq[j][target.charCodeAt(i) - zeroCharCode]\\n        //   }`\\n        // );\\n\\n        dp[i + 1][j + 1] =\\n          dp[i][j] * freq[j][target.charCodeAt(i) - zeroCharCode];\\n        dp[i + 1][j + 1] %= mod;\\n      }\\n\\n      // Skip this column and give the next column the same number of ways since\\n      // we are not selecting any characters here. Be sure to add to the existing\\n      // ways we already calculated.\\n      dp[i][j + 1] += dp[i][j];\\n      dp[i][j + 1] %= mod;\\n\\n      // console.table(dp);\\n    }\\n  }\\n\\n  // console.table(dp);\\n\\n  // Return the number of ways to form all characters of the target using all\\n  // possible columns.\\n  return dp[target.length][words[0].length];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427676,
                "title": "python-top-down-dp",
                "content": "# Intuition\\nFirst create a counter array. Each index i will have the count of the ith index in word for each word in words.\\nFor each state, we either advance the counter pointer or both the counter pointer and the target pointer.\\n\\n# Space & Time Complexity\\nO(N * W) with:\\n    - N the number of words in word\\n    - W the length of the largest word\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        a = []    \\n        for w in words: \\n            for i, c in enumerate(w):\\n                if i == len(a):    \\n                    a.append(Counter())    \\n                a[i][c] += 1    \\n\\n        @lru_cache(None)\\n        def dp(i, j):        \\n            if j == len(target):    \\n                return 1    \\n            if i == len(a): \\n                return 0    \\n            res = 0    \\n            if target[j] in a[i]: \\n                res += a[i][target[j]] * dp(i + 1, j + 1)    \\n            res += dp(i + 1, j)    \\n            return res   \\n\\n        return dp(0, 0) % ((10 ** 9) + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        a = []    \\n        for w in words: \\n            for i, c in enumerate(w):\\n                if i == len(a):    \\n                    a.append(Counter())    \\n                a[i][c] += 1    \\n\\n        @lru_cache(None)\\n        def dp(i, j):        \\n            if j == len(target):    \\n                return 1    \\n            if i == len(a): \\n                return 0    \\n            res = 0    \\n            if target[j] in a[i]: \\n                res += a[i][target[j]] * dp(i + 1, j + 1)    \\n            res += dp(i + 1, j)    \\n            return res   \\n\\n        return dp(0, 0) % ((10 ** 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427532,
                "title": "o-m-k-n-m-with-bottom-up-and-top-down",
                "content": "# Intuition\\nStore all the character in map that provides info how much times this cahracter is seen before particular location (including)\\n\\n# Approach\\nWrite top-down and convert to bottom-up\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(nm)\\n\\n\\nm is length of word\\nn is length of target\\nk is length of words\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] memo;\\n    int mod = 1000000007;\\n    long[][] countOfChars;\\n    int n,m;\\n    public int numWays(String[] words, String target) {\\n        n = target.length();\\n        m = words[0].length();\\n        countOfChars = new long[26][m];\\n\\n        for(String w : words){\\n            for(int i = 0; i < w.length(); i++){\\n                countOfChars[w.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n\\n        memo = new int[n+1][m+1];\\n        Arrays.stream(memo).forEach(ar -> Arrays.fill(ar, -1));\\n        // return  countWays(words, target, n, m);\\n        return countWays(words, target);\\n    }\\n\\n    public int countWays(String[] words, String target, int i, int takenSoFar){\\n        if(i == 0){\\n            return 1;\\n        }\\n\\n        if(takenSoFar == 0){\\n            return 0;\\n        }\\n\\n        if(memo[i][takenSoFar] != -1){\\n            return memo[i][takenSoFar];\\n        }\\n\\n\\n        char whatWeNeed = target.charAt(i-1);\\n        long ans = countWays(words, target, i, takenSoFar - 1) % mod;\\n\\n        ans  += (countOfChars[whatWeNeed - \\'a\\'][takenSoFar-1]   * countWays(words, target, i-1, takenSoFar - 1) ) % mod;\\n\\n\\n\\n        return memo[i][takenSoFar] =  (int) ans % mod;\\n    }\\n\\n// start with base case of recursion\\n     public int countWays(String[] words, String target){\\n        int n = target.length(), m = words[0].length();\\n        long[][] dp = new long[n+1][m+1]; // i - target char, j is word char\\n        Arrays.stream(dp).forEach(ar -> ar[0] = 0);\\n        Arrays.fill(dp[0], 1);\\n\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                dp[i][j] = dp[i][j-1] % mod;\\n                char whatWeNeed = target.charAt(i-1);\\n\\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * countOfChars[whatWeNeed - \\'a\\'][j-1] ) % mod;\\n            }\\n        }\\n\\n\\n         return (int) dp[n][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    int mod = 1000000007;\\n    long[][] countOfChars;\\n    int n,m;\\n    public int numWays(String[] words, String target) {\\n        n = target.length();\\n        m = words[0].length();\\n        countOfChars = new long[26][m];\\n\\n        for(String w : words){\\n            for(int i = 0; i < w.length(); i++){\\n                countOfChars[w.charAt(i) - \\'a\\'][i]++;\\n            }\\n        }\\n\\n        memo = new int[n+1][m+1];\\n        Arrays.stream(memo).forEach(ar -> Arrays.fill(ar, -1));\\n        // return  countWays(words, target, n, m);\\n        return countWays(words, target);\\n    }\\n\\n    public int countWays(String[] words, String target, int i, int takenSoFar){\\n        if(i == 0){\\n            return 1;\\n        }\\n\\n        if(takenSoFar == 0){\\n            return 0;\\n        }\\n\\n        if(memo[i][takenSoFar] != -1){\\n            return memo[i][takenSoFar];\\n        }\\n\\n\\n        char whatWeNeed = target.charAt(i-1);\\n        long ans = countWays(words, target, i, takenSoFar - 1) % mod;\\n\\n        ans  += (countOfChars[whatWeNeed - \\'a\\'][takenSoFar-1]   * countWays(words, target, i-1, takenSoFar - 1) ) % mod;\\n\\n\\n\\n        return memo[i][takenSoFar] =  (int) ans % mod;\\n    }\\n\\n// start with base case of recursion\\n     public int countWays(String[] words, String target){\\n        int n = target.length(), m = words[0].length();\\n        long[][] dp = new long[n+1][m+1]; // i - target char, j is word char\\n        Arrays.stream(dp).forEach(ar -> ar[0] = 0);\\n        Arrays.fill(dp[0], 1);\\n\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                dp[i][j] = dp[i][j-1] % mod;\\n                char whatWeNeed = target.charAt(i-1);\\n\\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * countOfChars[whatWeNeed - \\'a\\'][j-1] ) % mod;\\n            }\\n        }\\n\\n\\n         return (int) dp[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427521,
                "title": "both-bottom-up-iterative-as-well-top-down-memoized-code-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterative solution is bottom up\\nmemoized recursive code is top down\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod;\\n\\n    long long help(int i,int j,vector<vector<long long>>&dp,vector<vector<int>>&c,string &target){\\n\\n\\n        //first the base of this recursive function \\n        if(j==0){\\n            return i==0?1:0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        dp[i][j]=help(i,j-1,dp,c,target);\\n        if(i>0){\\n            dp[i][j]+=c[target[i-1]-\\'a\\'][j-1]*help(i-1,j-1,dp,c,target);\\n        }\\n        dp[i][j]%=mod;\\n        return dp[i][j];\\n    }\\n    int numWays(vector<string>& words, string target) {\\n\\n        int n=words.size();\\n        int m=target.size();\\n        int k=words[0].size();\\n        mod=1e9+7;\\n\\n        vector<vector<int>>c(26,vector<int>(k+1,0));\\n\\n        for(auto e:words){\\n            for(int i=0;i<k;i++){\\n                c[e[i]-\\'a\\'][i]++;\\n            }\\n        }\\n\\n        vector<vector<long long >>dp(m+1,vector<long long>(k+1,-1));\\n\\n\\n        return help(m,k,dp,c,target);\\n\\n\\n        \\n    }\\n};\\nnow this is the iterative bottom up solution\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n\\n        //leetcode editorial solution well explained\\n\\n        //we can assume words as agrid matrix\\n        int n=words.size();\\n        int k=words[0].size();\\n        int m=target.size();\\n        int mod=1e9+7;\\n        vector<vector<long long>>dp(m+1,vector<long long>(k+1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-total number of ways to make prefix of target with length i with atmost first j columns of\\n        //the matrix\\n        vector<vector<long long>>c(26,vector<long long >(k+1,0));\\n        //intialise the all the frequencies with zero\\n        //c[i][j] will tell the occurence of \\'a\\'+i char in the jth column\\n\\n        for(auto e:words){\\n            for(int i=0;i<k;i++){\\n                c[e[i]-\\'a\\'][i]++;\\n            }\\n        }\\n        dp[0][0]=1;\\n\\n        //now we will build answer of the biggest subproblem ina iterative bottom up manner\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<k;j++){\\n                if(i<m){\\n                    (dp[i+1][j+1]+=dp[i][j]*c[target[i]-\\'a\\'][j])%=mod;\\n                }\\n                dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod;\\n               \\n\\n            }\\n        }\\n        //finally we will be returning the answer from the bigget subproblem side \\n        return (int)dp[m][k];\\n\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod;\\n\\n    long long help(int i,int j,vector<vector<long long>>&dp,vector<vector<int>>&c,string &target){\\n\\n\\n        //first the base of this recursive function \\n        if(j==0){\\n            return i==0?1:0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        dp[i][j]=help(i,j-1,dp,c,target);\\n        if(i>0){\\n            dp[i][j]+=c[target[i-1]-\\'a\\'][j-1]*help(i-1,j-1,dp,c,target);\\n        }\\n        dp[i][j]%=mod;\\n        return dp[i][j];\\n    }\\n    int numWays(vector<string>& words, string target) {\\n\\n        int n=words.size();\\n        int m=target.size();\\n        int k=words[0].size();\\n        mod=1e9+7;\\n\\n        vector<vector<int>>c(26,vector<int>(k+1,0));\\n\\n        for(auto e:words){\\n            for(int i=0;i<k;i++){\\n                c[e[i]-\\'a\\'][i]++;\\n            }\\n        }\\n\\n        vector<vector<long long >>dp(m+1,vector<long long>(k+1,-1));\\n\\n\\n        return help(m,k,dp,c,target);\\n\\n\\n        \\n    }\\n};\\nnow this is the iterative bottom up solution\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n\\n        //leetcode editorial solution well explained\\n\\n        //we can assume words as agrid matrix\\n        int n=words.size();\\n        int k=words[0].size();\\n        int m=target.size();\\n        int mod=1e9+7;\\n        vector<vector<long long>>dp(m+1,vector<long long>(k+1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-total number of ways to make prefix of target with length i with atmost first j columns of\\n        //the matrix\\n        vector<vector<long long>>c(26,vector<long long >(k+1,0));\\n        //intialise the all the frequencies with zero\\n        //c[i][j] will tell the occurence of \\'a\\'+i char in the jth column\\n\\n        for(auto e:words){\\n            for(int i=0;i<k;i++){\\n                c[e[i]-\\'a\\'][i]++;\\n            }\\n        }\\n        dp[0][0]=1;\\n\\n        //now we will build answer of the biggest subproblem ina iterative bottom up manner\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<k;j++){\\n                if(i<m){\\n                    (dp[i+1][j+1]+=dp[i][j]*c[target[i]-\\'a\\'][j])%=mod;\\n                }\\n                dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod;\\n               \\n\\n            }\\n        }\\n        //finally we will be returning the answer from the bigget subproblem side \\n        return (int)dp[m][k];\\n\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427242,
                "title": "kotlin-dfs-with-memoization-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = 1000000000 + 7\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n        \\n        val dp = Array(n){LongArray(m){-1L}}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != -1L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return dfs(0, 0).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = 1000000000 + 7\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n        \\n        val dp = Array(n){LongArray(m){-1L}}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != -1L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return dfs(0, 0).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426838,
                "title": "java-recursive-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    String target;\\n    int[][] cnt;\\n    int mod = 1000000007;\\n    long[][] memo;\\n    public int numWays(String[] words, String target) {\\n        this.target = target;\\n    \\n        memo = new long[words[0].length()][target.length()];\\n        cnt = new int[26][words[0].length()];\\n\\n        for(int i=0; i<words[0].length(); i++){  \\n            Arrays.fill(memo[i], -1);   \\n            for(int j=0; j< words.length; j++){\\n                char c = words[j].charAt(i);\\n                cnt[c-\\'a\\'][i] += 1;\\n            }\\n        }\\n\\n        return  (int)dp(0, 0)%mod;\\n    }\\n\\n    public long dp(int j, int i){\\n        if(j >= target.length()){\\n            return 1;\\n        }\\n\\n        if(i >= cnt[0].length){\\n            return 0;\\n        }\\n\\n        if(memo[i][j] == -1){\\n            long count = dp(j, i+1)%mod;;\\n            count += (dp(j+1, i+1) * cnt[target.charAt(j) - \\'a\\'][i])%mod ;\\n            memo[i][j] = (count);\\n        }\\n        return memo[i][j];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    String target;\\n    int[][] cnt;\\n    int mod = 1000000007;\\n    long[][] memo;\\n    public int numWays(String[] words, String target) {\\n        this.target = target;\\n    \\n        memo = new long[words[0].length()][target.length()];\\n        cnt = new int[26][words[0].length()];\\n\\n        for(int i=0; i<words[0].length(); i++){  \\n            Arrays.fill(memo[i], -1);   \\n            for(int j=0; j< words.length; j++){\\n                char c = words[j].charAt(i);\\n                cnt[c-\\'a\\'][i] += 1;\\n            }\\n        }\\n\\n        return  (int)dp(0, 0)%mod;\\n    }\\n\\n    public long dp(int j, int i){\\n        if(j >= target.length()){\\n            return 1;\\n        }\\n\\n        if(i >= cnt[0].length){\\n            return 0;\\n        }\\n\\n        if(memo[i][j] == -1){\\n            long count = dp(j, i+1)%mod;;\\n            count += (dp(j+1, i+1) * cnt[target.charAt(j) - \\'a\\'][i])%mod ;\\n            memo[i][j] = (count);\\n        }\\n        return memo[i][j];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426580,
                "title": "c-dp-with-memo-100-time-114ms-70-space-34-9mb",
                "content": "Okay, this really looked, given both the constraints and the logic involved, like a DP problem.\\n\\nHaving for form `\"aba\"`, for example, we can see how our solution is given by the number of ways we can find an `\\'a\\'`, multiplied by the number of ways we can find a `\\'b\\'` AFTER the initial `\\'a\\'`, multiplied the number of ways we can find another `\\'a\\'` which appears AFTER a `\\'b\\'` that was in turn preceded by another `\\'a\\'`.\\n\\nThe first test case gives a decent breakdown of how that would work.\\n\\nTo code our solution, let\\'s declare first of all `modVal` with the value demanded by the spec to provide a result fitting an `int`, then we will declare a few instance variables:\\n* `memo` is a matrix of `1000` per `1000` cells that we will use to store precomputed results of our recursive calls;\\n* `charMap` will store the information of how many characters (column) we find at each specific position (row) in `words`;\\n* `sLen` and `wLen` will store respectively the length of our `target` string and `words`;\\n* `s` will store our initial input string.\\n\\nIn the main function, we will populate this variables, by:\\n* `swap`ping `s` and `target`;\\n* assigning the proper values to both `sLen` and `wLen`;\\n* filling all the cells of `memo` with `-1`;\\n* parsing each `word` in `words` and for each position `i` in it, we will increase its matching frequency counter (ie: `charMap[i][word[i] - \\'a\\']`) by `1`.\\n\\nWe can now invoke `dfs` (I know, not real graph to traverse here, but in my mind this kind of problem is just a decision tree we have to navigate) and `return` its final result.\\n\\nThis function will takee two indexes `sPos` and `wordPos` and:\\n* `return` `1` when we are done parsing `s` (ie: `sPos == sLen`);\\n* `return` `0` when we are out of boundaries with `words` (ie: `wordPos == wLen`);\\n* check if we already encountered this specific case (ie: `memo[sPos][wordPos]` does not have the initial placeholder value of `-1`) and if so, just `return` the previously found result;\\n* compute our result as a sum of:\\n    * the product of many times the current character `s[sPos]` can be found at position `wordPos` (ie: `charMap[wordPos][s[sPos] - \\'a\\']` multiplied all the matches for all the following characters (ie: `dfs(sPos + 1, wordPos + 1)`);\\n    * the number of times we can find a match of all characters we are looking for after the current position in `words` (ie: `dfs(sPos, wordPos + 1)`);\\n* store that result in `memo[sPos][wordPos]`;\\n* `return` it.\\n\\n# Complexity\\n- Time complexity: $$O(s * w)$$ (with `s` being the length of our target string and `w` the length of each word in `words`)\\n- Space complexity: $$O(s * w)$$\\n\\n# Code\\n```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long memo[1000][1000];\\n    int charMap[1000][26] = {}, sLen, wLen;\\n    string s;\\n    long long dfs(int sPos = 0, int wordPos = 0) {\\n        // base case: out of boundaries\\n        if (sPos == sLen) return 1;\\n        if (wordPos == wLen) return 0;\\n        // base case: been here already\\n        if (memo[sPos][wordPos] != -1) return memo[sPos][wordPos];\\n        // general case\\n        memo[sPos][wordPos] = (charMap[wordPos][s[sPos] - \\'a\\'] * dfs(sPos + 1, wordPos + 1) + dfs(sPos, wordPos + 1)) % modVal;\\n        return memo[sPos][wordPos];\\n    }\\npublic:\\n    int numWays(vector<string> &words, string &target) {\\n        // populating class variables\\n        swap(target, s);\\n        sLen = s.size(), wLen = words[0].size();\\n        fill(memo[0], memo[999] + 1000, -1);\\n        for (auto &word: words) {\\n            for (int i = 0; i < wLen; i++) {\\n                charMap[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        return dfs() % modVal;\\n    }\\n};\\n```\\n\\nFurther optimised approach where we have better ending conditions for `dfs` and a way less expensive call to `fill` `memo` with preset values; I shaved ~130ms off with this polishing \\uD83D\\uDC4C.\\n\\nSurprisingly trying to fill `memo` with `memset` (ie: `memset(memo[0], -1, 1000 * wLen * sizeof(long long));`) did not give me much of an advantage:\\n\\n```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long memo[1000][1000];\\n    int charMap[1000][26] = {}, sLen, wLen;\\n    string s;\\n    long long dfs(int sPos = 0, int wordPos = 0) {\\n        // base case: done parsing\\n        if (sPos == sLen) return 1;\\n        // base case: not enough characters left\\n        if (wLen - wordPos < sLen - sPos) return 0;\\n        // support variables\\n        long long &res = memo[sPos][wordPos];\\n        // base case: been here already\\n        if (res != -1) return res;\\n        // general case\\n        res = charMap[wordPos][s[sPos] - \\'a\\'] * dfs(sPos + 1, wordPos + 1) + dfs(sPos, wordPos + 1);\\n        if (res >= modVal) res %= modVal;\\n        return res;\\n    }\\npublic:\\n    int numWays(vector<string> &words, string &target) {\\n        // populating class variables\\n        swap(target, s);\\n        sLen = s.size(), wLen = words[0].size();\\n        fill(memo[0], memo[sLen - 1] + wLen, -1);\\n        for (auto &word: words) {\\n            for (int i = 0; i < wLen; i++) {\\n                charMap[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        return dfs() % modVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "String Matching",
                    "Combinatorics"
                ],
                "code": "```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long memo[1000][1000];\\n    int charMap[1000][26] = {}, sLen, wLen;\\n    string s;\\n    long long dfs(int sPos = 0, int wordPos = 0) {\\n        // base case: out of boundaries\\n        if (sPos == sLen) return 1;\\n        if (wordPos == wLen) return 0;\\n        // base case: been here already\\n        if (memo[sPos][wordPos] != -1) return memo[sPos][wordPos];\\n        // general case\\n        memo[sPos][wordPos] = (charMap[wordPos][s[sPos] - \\'a\\'] * dfs(sPos + 1, wordPos + 1) + dfs(sPos, wordPos + 1)) % modVal;\\n        return memo[sPos][wordPos];\\n    }\\npublic:\\n    int numWays(vector<string> &words, string &target) {\\n        // populating class variables\\n        swap(target, s);\\n        sLen = s.size(), wLen = words[0].size();\\n        fill(memo[0], memo[999] + 1000, -1);\\n        for (auto &word: words) {\\n            for (int i = 0; i < wLen; i++) {\\n                charMap[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        return dfs() % modVal;\\n    }\\n};\\n```\n```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long memo[1000][1000];\\n    int charMap[1000][26] = {}, sLen, wLen;\\n    string s;\\n    long long dfs(int sPos = 0, int wordPos = 0) {\\n        // base case: done parsing\\n        if (sPos == sLen) return 1;\\n        // base case: not enough characters left\\n        if (wLen - wordPos < sLen - sPos) return 0;\\n        // support variables\\n        long long &res = memo[sPos][wordPos];\\n        // base case: been here already\\n        if (res != -1) return res;\\n        // general case\\n        res = charMap[wordPos][s[sPos] - \\'a\\'] * dfs(sPos + 1, wordPos + 1) + dfs(sPos, wordPos + 1);\\n        if (res >= modVal) res %= modVal;\\n        return res;\\n    }\\npublic:\\n    int numWays(vector<string> &words, string &target) {\\n        // populating class variables\\n        swap(target, s);\\n        sLen = s.size(), wLen = words[0].size();\\n        fill(memo[0], memo[sLen - 1] + wLen, -1);\\n        for (auto &word: words) {\\n            for (int i = 0; i < wLen; i++) {\\n                charMap[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        return dfs() % modVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426000,
                "title": "python-top-down",
                "content": "# Approach\\nIf characters match, dfs by incrementing both word_ind and target_ind. Otherwise, we inexplicitly increment only the word_ind. This means we should cache our results because the same pairing (word_ind, target_ind) may be accessed multiple times.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Let M = len(words), N = len(words[0]), T = len(target). We have N * T dp states. It costs M * N time to compute the counts. So we have O(M * N + T * N)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: It costs M * N for the counts. Max recursive call stack is T. So we have O(M * N + T)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \\n        MOD = 10 ** 9 + 7\\n        count = [defaultdict(int) for _ in range(len(words[0]))]\\n\\n        for i in range(len(words)):\\n            for j in range(len(words[i])):\\n                count[j][words[i][j]] += 1\\n        \\n        @cache\\n        def dfs(word_ind, target_ind):\\n\\n            if target_ind >= len(target):\\n                return 1\\n\\n            if word_ind >= len(words[0]):\\n                return 0\\n            \\n            ans = 0\\n            for i in range(word_ind, len(words[0])):\\n\\n                if (len(words[0]) - i) < len(target) - target_ind: break\\n\\n                matches = count[i][target[target_ind]]\\n\\n                if matches > 0:\\n                    ans += (matches * dfs(i + 1, target_ind + 1))\\n\\n            return ans\\n\\n        return dfs(0, 0) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \\n        MOD = 10 ** 9 + 7\\n        count = [defaultdict(int) for _ in range(len(words[0]))]\\n\\n        for i in range(len(words)):\\n            for j in range(len(words[i])):\\n                count[j][words[i][j]] += 1\\n        \\n        @cache\\n        def dfs(word_ind, target_ind):\\n\\n            if target_ind >= len(target):\\n                return 1\\n\\n            if word_ind >= len(words[0]):\\n                return 0\\n            \\n            ans = 0\\n            for i in range(word_ind, len(words[0])):\\n\\n                if (len(words[0]) - i) < len(target) - target_ind: break\\n\\n                matches = count[i][target[target_ind]]\\n\\n                if matches > 0:\\n                    ans += (matches * dfs(i + 1, target_ind + 1))\\n\\n            return ans\\n\\n        return dfs(0, 0) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425960,
                "title": "python3-pure-brute-force-path-enumeration-dfs-dp-top-down-and-bottom-up",
                "content": "I suck at LeetCode and I think Im plateauing at this point, but if don\\'t play the algorithms games like everybody else I\\'ll never be ready for the next job interview. So lets play and try to try to have fun puliing our hair out while we do it >.<\\n\\n#### Approach 1, Pure Brute Force, DFS With Path Enumeration (TLE)\\n* Bascially this problem just wants the number of paths. The words have all the same length and we can move from one char in a word to another char in a different word, so long as the chars we take make a prefix of the target.\\n* We are free to start at any index on any word in, and try to make the path\\n* We use DFS to try to find a path that allows us make a target, at any point we can take this current char if it matches, and advance this pointer. Or we move on to the next startigin position\\n* Variables ```start_pos``` marks the index of the starting position in and words\\n* ``pos_in_target``` is our pointer to the current char in ```target```\\n* ```path``` is the our path of chars\\n* we increment when we have valid path and abandon our search if we run out of chars to take\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\t\\n        num_words = len(words)\\n        N = len(words[0])\\n        M = len(target)\\n        self.ways = 0\\n        mod = 10**9 + 7\\n        \\n        def rec(start_pos, pos_in_target,path):\\n            #got to the end and have made target, abandon path and increment\\n            if path == target:\\n                self.ways += 1\\n                self.ways %= mod\\n                return\\n            #no more chacters to use, all words have the same size\\n            if start_pos == N:\\n                return\\n            \\n            #loop over words\\n            for other_word in range(num_words):\\n                #loop over positions\\n                for next_pos in range(start_pos,N): #from the starting position to the size of words \\n                    if words[other_word][next_pos] == target[pos_in_target]:\\n                        #recurse\\n                        rec(next_pos + 1, pos_in_target + 1, path+words[other_word][next_pos])\\n        \\n        rec(0,0,\"\")\\n        return self.ways % mod\\n```\\n\\n#### Approach 2, Memoize String states as pointers (TLE)\\n* If you imagine the recursion tree at this point, the answer to a subproblem is at a node, and the answer to this node is just sum of all the nodes below it\\n* instead of searching all the way down to the leaves, lets return a value at the leaves instead\\n* base cases now are return 1, when we have complted a path, or zero when we cant complete a path\\n* in the recursive case, we just loop over all words and positions and sum them all up\\n* Unforutnaley LC hates us this week, and decided to give us TLE on this problem\\n* Why? Given the input constraints for the problem the recursive function takes O(N*N)\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        num_words = len(words)\\n        N = len(words[0])\\n        M = len(target)\\n        memo = {}\\n        mod = 10**9 + 7\\n        \\n        def dp(start_pos, pos_in_target,):\\n            #got to the end and have made target, abandon path and increment\\n            if pos_in_target == M:\\n                return 1\\n            #no more chacters to use, all words have the same size\\n            if start_pos == N:\\n                return 0\\n            #retreive\\n            if (start_pos,pos_in_target) in memo:\\n                return memo[(start_pos,pos_in_target)]\\n            \\n            #answer for this tree is sum of all other states\\n            num_ways = 0\\n            #loop over words\\n            for other_word in range(num_words):\\n                #loop over positions\\n                for next_pos in range(start_pos,N): #from the starting position to the size of words \\n                    if words[other_word][next_pos] == target[pos_in_target]:\\n                        #recurse\\n                        num_ways += dp(next_pos + 1, pos_in_target + 1)\\n                        num_ways %= mod\\n            \\n            #cache\\n            memo[(start_pos,pos_in_target)] = num_ways\\n            return num_ways\\n        \\n        return dp(0,0)\\n    \\n```\\n\\n#### Approach 3, Optomized DP, Top Down w/ Memo (AC)\\n* Unforutnaley LC hates us this week, and decided to give us TLE on this problem\\n* Why? Given the input constraints for the problem the recursive function takes O(N\\\\*N)\\n* I\\'ve seen several dp hard problems in LC where we wouldn\\'t get TLE on a recursive function that takes (N squared time)\\n* We need to try to reduce the search space for the counting the number of ways\\n* We pre process words to get some kind of count object, lets call it ```count_chars```\\n* This gives us the frequency of this character for this current column\\n* if we knew the number of ways given by ```dp(start_pos+1,pos_in_target+1)```, then we multiply this by the number of times we see ```target[pos_in_target]``` at ```start_pos```\\n* If we don\\'t see ```target[pos_in_target]``` in the ```count_chars```, then we just move on to the next ```start_pos``` (push dp)\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        num_words = len(words)\\n        N = len(words[0])\\n        M = len(target)\\n        memo = {}\\n        mod = 10**9 + 7\\n        \\n        #pre process data by counting the counts for each char at each column j\\n        count_chars = Counter() \\n        for word in words:\\n            for col,ch in enumerate(word):\\n                count_chars[(col,ch)] += 1\\n        \\n        \\n        def dp(start_pos, pos_in_target,):\\n            #got to the end and have made target, abandon path and increment\\n            if pos_in_target == M:\\n                return 1\\n            #no more chacters to use, all words have the same size\\n            if start_pos == N:\\n                return 0\\n            #retreive\\n            if (start_pos,pos_in_target) in memo:\\n                return memo[(start_pos,pos_in_target)]\\n            \\n            #skip this current word\\'s index\\n            num_ways = dp(start_pos+1,pos_in_target)\\n            #get counts by multiplying multiplicity of next answer\\n            curr_char = target[pos_in_target]\\n            #to this current number of ways we try to increment by the number of ways we can make a path from start_pos to start_pos + 1\\n            num_ways += dp(start_pos+1,pos_in_target+1)*count_chars[(start_pos,curr_char)]\\n            num_ways %= mod\\n            \\n            #cache\\n            memo[(start_pos,pos_in_target)] = num_ways\\n            return num_ways\\n        \\n        return dp(0,0) % mod\\n```\\n\\n#### Appraoch 4, Bottom Up\\n* Just translate from top down\\n* Fill in base cases first, then start from the states just before the base case (so we can grab states correctly)\\n* Note, I don\\'t get fancy trying to play code golf with the bottom up solutions, its more imporant that I can actually translate the solution into its topological sorted order\\n\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        \\'\\'\\'\\n        bottom up\\n        \\'\\'\\'\\n        #do brute force first\\n        num_words = len(words)\\n        N = len(words[0])\\n        M = len(target)\\n        memo = {}\\n        mod = 10**9 + 7\\n        \\n        #pre process data by counting the counts for each char at each column j\\n        count_chars = Counter() \\n        for word in words:\\n            for col,ch in enumerate(word):\\n                count_chars[(col,ch)] += 1\\n        \\n        dp = [[0]*(M+1) for _ in range(N+1)]\\n        \\n        #fill in base cases\\n        for start_pos in range(N+1):\\n            for pos_in_target in range(M+1):\\n                if pos_in_target == M:\\n                    dp[start_pos][pos_in_target] = 1\\n        \\n        \\n        for start_pos in range(N-1,-1,-1):\\n            for pos_in_target in range(M-1, -1,-1):\\n                #skip this current word\\'s index\\n                num_ways = dp[start_pos+1][pos_in_target]\\n                #get counts by multiplying multiplicity of next answer\\n                curr_char = target[pos_in_target]\\n                #to this current number of ways we try to increment by the number of ways we can make a path from start_pos to start_pos + 1\\n                num_ways += dp[start_pos+1][pos_in_target+1]*count_chars[(start_pos,curr_char)]\\n                num_ways %= mod\\n                \\n                dp[start_pos][pos_in_target] = num_ways\\n        \\n        return dp[0][0] % mod\\n```\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```start_pos```\n``` is our pointer to the current char in ```\n```\\n* ```\n``` is the our path of chars\\n* we increment when we have valid path and abandon our search if we run out of chars to take\\n\\n```\n```\\n\\n#### Approach 2, Memoize String states as pointers (TLE)\\n* If you imagine the recursion tree at this point, the answer to a subproblem is at a node, and the answer to this node is just sum of all the nodes below it\\n* instead of searching all the way down to the leaves, lets return a value at the leaves instead\\n* base cases now are return 1, when we have complted a path, or zero when we cant complete a path\\n* in the recursive case, we just loop over all words and positions and sum them all up\\n* Unforutnaley LC hates us this week, and decided to give us TLE on this problem\\n* Why? Given the input constraints for the problem the recursive function takes O(N*N)\\n```\n```\\n\\n#### Approach 3, Optomized DP, Top Down w/ Memo (AC)\\n* Unforutnaley LC hates us this week, and decided to give us TLE on this problem\\n* Why? Given the input constraints for the problem the recursive function takes O(N\\\\*N)\\n* I\\'ve seen several dp hard problems in LC where we wouldn\\'t get TLE on a recursive function that takes (N squared time)\\n* We need to try to reduce the search space for the counting the number of ways\\n* We pre process words to get some kind of count object, lets call it ```\n```\\n* This gives us the frequency of this character for this current column\\n* if we knew the number of ways given by ```\n```, then we multiply this by the number of times we see ```\n``` at ```\n```\\n* If we don\\'t see ```\n``` in the ```\n```, then we just move on to the next ```\n``` (push dp)\\n\\n```\n```\\n\\n#### Appraoch 4, Bottom Up\\n* Just translate from top down\\n* Fill in base cases first, then start from the states just before the base case (so we can grab states correctly)\\n* Note, I don\\'t get fancy trying to play code golf with the bottom up solutions, its more imporant that I can actually translate the solution into its topological sorted order\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3425019,
                "title": "python-simple-math-with-memo",
                "content": "We have 2 options:\\n1. we make up target with current word index\\n2. we does not\\n\\nBy that, we can create the formula by recursion, then optimize the time complexity by caching the result\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        counter = [[0]*26 for _ in range(len(words[0]))]\\n        for word in words:\\n            for i in range(len(word)):\\n                counter[i][ord(word[i])-ord(\\'a\\')] += 1\\n        \\n        @lru_cache(None)\\n        def num_ways(word_idx, target_idx):\\n            if target_idx == len(target):\\n                return 1\\n            elif word_idx == len(counter):\\n                return 0\\n            else:\\n                res = 0\\n                curr = ord(target[target_idx]) - ord(\\'a\\')\\n                if counter[word_idx][curr] > 0:\\n                    res += counter[word_idx][curr] * num_ways(word_idx+1, target_idx+1)\\n                res += num_ways(word_idx+1, target_idx)\\n                return res % (10**9+7)\\n\\n        return num_ways(0,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        counter = [[0]*26 for _ in range(len(words[0]))]\\n        for word in words:\\n            for i in range(len(word)):\\n                counter[i][ord(word[i])-ord(\\'a\\')] += 1\\n        \\n        @lru_cache(None)\\n        def num_ways(word_idx, target_idx):\\n            if target_idx == len(target):\\n                return 1\\n            elif word_idx == len(counter):\\n                return 0\\n            else:\\n                res = 0\\n                curr = ord(target[target_idx]) - ord(\\'a\\')\\n                if counter[word_idx][curr] > 0:\\n                    res += counter[word_idx][curr] * num_ways(word_idx+1, target_idx+1)\\n                res += num_ways(word_idx+1, target_idx)\\n                return res % (10**9+7)\\n\\n        return num_ways(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424926,
                "title": "dynamic-programming-c-solution",
                "content": "# Short Advice\\nI was writing out an explanation, but Leetcode crashed and deleted all my work, so I will only include this one point of advice.\\n\\nDo not forget to loop through the vector `words` BY REFERENCE:\\n`for(string& s : words)`\\n\\nIf you forget the \\'**&**\\', you will get **TLE**. Happy Coding!!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int len = words[0].length();\\n        int t_len = target.length();\\n        int mod = 1000000007;\\n        vector<vector<int>> charsAtIndex(len,vector<int>(26,0));\\n        for(int i = 0; i < len; i++){\\n            for(string& s : words)\\n            {\\n                charsAtIndex[i][s[i]-\\'a\\']++;\\n            }\\n        }\\n        vector<vector<int>> dp(len+1, vector<int>(t_len+1,0));\\n        for(int i = 0; i < len+1; i++)\\n        {\\n            dp[i][t_len] = 1;\\n        }\\n\\n        for(int i = t_len-1; i>=0; i--){\\n            for(int j = len-(t_len-i); j>=i; j--)\\n            {\\n                long long val = charsAtIndex[j][target[i]-\\'a\\'];\\n                dp[j][i] = ((int)(val*dp[j+1][i+1]%mod) + dp[j+1][i])%mod;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int len = words[0].length();\\n        int t_len = target.length();\\n        int mod = 1000000007;\\n        vector<vector<int>> charsAtIndex(len,vector<int>(26,0));\\n        for(int i = 0; i < len; i++){\\n            for(string& s : words)\\n            {\\n                charsAtIndex[i][s[i]-\\'a\\']++;\\n            }\\n        }\\n        vector<vector<int>> dp(len+1, vector<int>(t_len+1,0));\\n        for(int i = 0; i < len+1; i++)\\n        {\\n            dp[i][t_len] = 1;\\n        }\\n\\n        for(int i = t_len-1; i>=0; i--){\\n            for(int j = len-(t_len-i); j>=i; j--)\\n            {\\n                long long val = charsAtIndex[j][target[i]-\\'a\\'];\\n                dp[j][i] = ((int)(val*dp[j+1][i+1]%mod) + dp[j+1][i])%mod;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424903,
                "title": "c-dp-recursion-memoization-tabulation-space-optimization",
                "content": "# Approach : Recursion\\n\\n# Complexity\\n- Time complexity: $$O(m*n*2^k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    long long func(vector<vector<int>> &cnt, vector<vector<int>> &dp, string targ, int i, int j) {\\n        if(j==targ.length())\\n            return 1;\\n        \\n        if(i==cnt.size())\\n            return 0;\\n\\n        if(dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long pick = 0, not_pick = 0;\\n        if(cnt[i][targ[j]-\\'a\\']) {\\n            long long curr = cnt[i][targ[j]-\\'a\\'] % mod;\\n            long long next = func(cnt, dp, targ, i+1, j+1) % mod;\\n            pick = (curr * next) % mod;\\n        }\\n        \\n        not_pick = func(cnt, dp, targ, i+1, j) % mod;\\n        return dp[i][j] = (pick + not_pick) % mod;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> dp(m, vector<int> (k, -1));\\n        vector<vector<int>> cnt(m, vector<int> (26));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cnt[i][words[j][i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return func(cnt, dp, target, 0, 0);\\n    }\\n};\\n```\\n\\n----------------------------------------------------------------\\n\\n# Approach : Recursion + Memoization\\n\\n# Complexity\\n- Time complexity: $$O(m*n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    long long func(vector<vector<int>> &cnt, vector<vector<int>> &dp, string targ, int i, int j) {\\n        if(j==targ.length())\\n            return 1;\\n        \\n        if(i==cnt.size())\\n            return 0;\\n\\n        if(dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long pick = 0, not_pick = 0;\\n        not_pick = func(cnt, dp, targ, i+1, j) % mod;\\n        \\n        if(cnt[i][targ[j]-\\'a\\']) {\\n            long long curr = cnt[i][targ[j]-\\'a\\'] % mod;\\n            long long next = func(cnt, dp, targ, i+1, j+1) % mod;\\n            pick = (curr * next) % mod;\\n        }\\n        \\n        return dp[i][j] = (pick + not_pick) % mod;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> dp(m, vector<int> (k, -1));\\n        vector<vector<int>> cnt(m, vector<int> (26));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cnt[i][words[j][i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return func(cnt, dp, target, 0, 0);\\n    }\\n};\\n```\\n\\n----------------------------------------------------------------\\n\\n# Approach : Tabulation\\n\\n# Complexity\\n- Time complexity: $$O(m*k)$$\\n\\n- Space complexity: $$O(m*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> cnt(m, vector<int>(26));\\n        vector<vector<long long>> dp(m + 1, vector<long long>(k + 1, 0));\\n        int mod = 1e9 + 7;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = m; i >= 0; i--) {\\n            for (int j = k; j >= 0; j--) {\\n                if (j == k) {\\n                    dp[i][j] = 1;\\n                } else if (i == m) {\\n                    dp[i][j] = 0;\\n                } else {\\n                    long long not_pick = dp[i + 1][j] % mod;\\n                    long long pick = 0;\\n                    if (cnt[i][target[j] - \\'a\\']) {\\n                        long long curr = cnt[i][target[j] - \\'a\\'] % mod;\\n                        long long next = dp[i + 1][j + 1] % mod;\\n                        pick = (curr * next) % mod;\\n                    }\\n                    dp[i][j] = (pick + not_pick) % mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n----------------------------------------------------------------\\n\\n# Approach : Tabulation + Space-Optimization\\n\\n# Complexity\\n- Time complexity: $$O(m*k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> cnt(m, vector<int>(26));\\n        vector<long long> dp(k + 1, 0);\\n        int mod = 1e9 + 7;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        dp[k] = 1;\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j <= k; j++) {\\n                long long not_pick = dp[j] % mod;\\n                long long pick = 0;\\n                if (j < k && cnt[i][target[j] - \\'a\\']) {\\n                    long long curr = cnt[i][target[j] - \\'a\\'] % mod;\\n                    long long next = dp[j + 1] % mod;\\n                    pick = (curr * next) % mod;\\n                }\\n                dp[j] = (pick + not_pick) % mod;\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    long long func(vector<vector<int>> &cnt, vector<vector<int>> &dp, string targ, int i, int j) {\\n        if(j==targ.length())\\n            return 1;\\n        \\n        if(i==cnt.size())\\n            return 0;\\n\\n        if(dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long pick = 0, not_pick = 0;\\n        if(cnt[i][targ[j]-\\'a\\']) {\\n            long long curr = cnt[i][targ[j]-\\'a\\'] % mod;\\n            long long next = func(cnt, dp, targ, i+1, j+1) % mod;\\n            pick = (curr * next) % mod;\\n        }\\n        \\n        not_pick = func(cnt, dp, targ, i+1, j) % mod;\\n        return dp[i][j] = (pick + not_pick) % mod;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> dp(m, vector<int> (k, -1));\\n        vector<vector<int>> cnt(m, vector<int> (26));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cnt[i][words[j][i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return func(cnt, dp, target, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    long long func(vector<vector<int>> &cnt, vector<vector<int>> &dp, string targ, int i, int j) {\\n        if(j==targ.length())\\n            return 1;\\n        \\n        if(i==cnt.size())\\n            return 0;\\n\\n        if(dp[i][j] != -1) \\n            return dp[i][j];\\n\\n        long long pick = 0, not_pick = 0;\\n        not_pick = func(cnt, dp, targ, i+1, j) % mod;\\n        \\n        if(cnt[i][targ[j]-\\'a\\']) {\\n            long long curr = cnt[i][targ[j]-\\'a\\'] % mod;\\n            long long next = func(cnt, dp, targ, i+1, j+1) % mod;\\n            pick = (curr * next) % mod;\\n        }\\n        \\n        return dp[i][j] = (pick + not_pick) % mod;\\n    }\\n\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> dp(m, vector<int> (k, -1));\\n        vector<vector<int>> cnt(m, vector<int> (26));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cnt[i][words[j][i]-\\'a\\']++;\\n            }\\n        }\\n\\n        return func(cnt, dp, target, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> cnt(m, vector<int>(26));\\n        vector<vector<long long>> dp(m + 1, vector<long long>(k + 1, 0));\\n        int mod = 1e9 + 7;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = m; i >= 0; i--) {\\n            for (int j = k; j >= 0; j--) {\\n                if (j == k) {\\n                    dp[i][j] = 1;\\n                } else if (i == m) {\\n                    dp[i][j] = 0;\\n                } else {\\n                    long long not_pick = dp[i + 1][j] % mod;\\n                    long long pick = 0;\\n                    if (cnt[i][target[j] - \\'a\\']) {\\n                        long long curr = cnt[i][target[j] - \\'a\\'] % mod;\\n                        long long next = dp[i + 1][j + 1] % mod;\\n                        pick = (curr * next) % mod;\\n                    }\\n                    dp[i][j] = (pick + not_pick) % mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numWays(vector<string>& words, string target) {\\n        int m = words[0].length();\\n        int n = words.size();\\n        int k = target.length();\\n        vector<vector<int>> cnt(m, vector<int>(26));\\n        vector<long long> dp(k + 1, 0);\\n        int mod = 1e9 + 7;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                cnt[i][words[j][i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        dp[k] = 1;\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j <= k; j++) {\\n                long long not_pick = dp[j] % mod;\\n                long long pick = 0;\\n                if (j < k && cnt[i][target[j] - \\'a\\']) {\\n                    long long curr = cnt[i][target[j] - \\'a\\'] % mod;\\n                    long long next = dp[j + 1] % mod;\\n                    pick = (curr * next) % mod;\\n                }\\n                dp[j] = (pick + not_pick) % mod;\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424883,
                "title": "o-n-m-o-n-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem we are given a list of strings of the same length `words` and a string `target`, we want to return `the number of ways` to form `target` from `words`. Since the answer may be too large, return it modulo 109 + 7.\\n\\nTo form target using the givens words, we have a few rule restrictions and it is as follows:\\n\\n- target should be formed from left to right.\\n\\n- To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\\n\\n- Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\n- Repeat the process until you form the string target.\\n\\n## Explanation\\n\\nWe want to form the target word with each word in words array character by character.\\n\\nFor each `character` in target, we must use a `new indices character` for each `word` in  words array, when trying to find the `next character` in target.\\n\\nHowever, once we have `chosen` a character from our current `word` in our words array to form a character in our target, we can `no longer use` all characters from the left of it and this restriction holds for all other `word`. \\n\\nThus, we should start `far left` as possible so that all other characters will not be affected by our chosen character. \\n\\nTo avoid `TLE`, we should `precompute` the count of each character at each position and see if each character in each index position among all of the `word` in words array have our target character  \\n\\n###  Code\\n\\n**Python**\\n\\n```\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        n = len(target)\\n        \\n        m = len(words[0])\\n        \\n        mod =  10 ** 9 + 7\\n        \\n        pre_compute = [{} for _ in range(m)]\\n        \\n        for word in words:\\n            for index, char in enumerate(word):\\n                pre_compute[index][char] = pre_compute[index].get(char, 0) + 1\\n\\n        dp = [[0] * m for _ in range(n)]\\n                \\n        for index, char in enumerate(target):\\n            for word_index in range(m):\\n                if index == 0:\\n                    if word_index != 0:\\n                         dp[index][word_index] = dp[index][word_index - 1] + pre_compute[word_index].get(char, 0) \\n\\n                    else: \\n                        dp[index][word_index] = pre_compute[0].get(char, 0)\\n                        \\n                elif index <= word_index:  \\n                    dp[index][word_index] = (dp[index][word_index - 1] + dp[index - 1][word_index - 1] * pre_compute[word_index].get(char,0)) % mod\\n                    \\n        return dp[-1][-1]\\n```\\n\\n**JavaScript**\\n\\n```\\nvar numWays = function(words, target) {\\n    \\n    const n = target.length\\n    const m = words[0].length\\n    const mod = Math.pow(10, 9) + 7;\\n    const dp = Array(m+1).fill([]).map(() => Array(n+1).fill(-1))\\n\\n    let preCompute = []\\n\\n    for(let index = 0; index < m; index++) { \\n        preCompute.push(new Map())  \\n        for(const word of words) {\\n            const char = word[index];\\n            preCompute[index] = preCompute[index].set(char, (preCompute[index].get(char) || 0) + 1);\\n        }\\n    }\\n    \\n    \\n    for(let target_index = n; target_index >= 0; target_index--){\\n        for(let word_index = m; word_index >= 0; word_index--){\\n            if(m - word_index < n - target_index){\\n                dp[word_index][target_index] = 0;\\n            }\\n            else if(target_index === n){\\n                dp[word_index][target_index] = 1;\\n            }\\n            else {\\n                const strCount = preCompute[word_index].get(target[target_index]) ?? 0; \\n                dp[word_index][target_index] = (strCount * dp[word_index+1][target_index+1] + dp[word_index+1][target_index]) % mod;\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n      \\n}\\n```\\n\\n#### Time Complexity: O(n*m)\\n\\n#### Space Complexity: O(n)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def numWays(self, words: List[str], target: str) -> int:\\n\\n        n = len(target)\\n        \\n        m = len(words[0])\\n        \\n        mod =  10 ** 9 + 7\\n        \\n        pre_compute = [{} for _ in range(m)]\\n        \\n        for word in words:\\n            for index, char in enumerate(word):\\n                pre_compute[index][char] = pre_compute[index].get(char, 0) + 1\\n\\n        dp = [[0] * m for _ in range(n)]\\n                \\n        for index, char in enumerate(target):\\n            for word_index in range(m):\\n                if index == 0:\\n                    if word_index != 0:\\n                         dp[index][word_index] = dp[index][word_index - 1] + pre_compute[word_index].get(char, 0) \\n\\n                    else: \\n                        dp[index][word_index] = pre_compute[0].get(char, 0)\\n                        \\n                elif index <= word_index:  \\n                    dp[index][word_index] = (dp[index][word_index - 1] + dp[index - 1][word_index - 1] * pre_compute[word_index].get(char,0)) % mod\\n                    \\n        return dp[-1][-1]\\n```\n```\\nvar numWays = function(words, target) {\\n    \\n    const n = target.length\\n    const m = words[0].length\\n    const mod = Math.pow(10, 9) + 7;\\n    const dp = Array(m+1).fill([]).map(() => Array(n+1).fill(-1))\\n\\n    let preCompute = []\\n\\n    for(let index = 0; index < m; index++) { \\n        preCompute.push(new Map())  \\n        for(const word of words) {\\n            const char = word[index];\\n            preCompute[index] = preCompute[index].set(char, (preCompute[index].get(char) || 0) + 1);\\n        }\\n    }\\n    \\n    \\n    for(let target_index = n; target_index >= 0; target_index--){\\n        for(let word_index = m; word_index >= 0; word_index--){\\n            if(m - word_index < n - target_index){\\n                dp[word_index][target_index] = 0;\\n            }\\n            else if(target_index === n){\\n                dp[word_index][target_index] = 1;\\n            }\\n            else {\\n                const strCount = preCompute[word_index].get(target[target_index]) ?? 0; \\n                dp[word_index][target_index] = (strCount * dp[word_index+1][target_index+1] + dp[word_index+1][target_index]) % mod;\\n            }\\n        }\\n    }\\n    return dp[0][0];\\n      \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3424876,
                "title": "java-routine-backtracking-memoization-method-for-peasant-brain-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe good news is that every word in String[] words is same in length and truncated. We can imagine two scanning from left to right: one of them is made upon each word in words, from index 0 to index words[0].length(); the other is made upon String target. At each step, we want to check if we can have a match. Now it becomes clear that this is an either-or/take-drop binary selection problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing backtracking, we can write recursion in a more plain-word style with good stack structure for function calls and returns. We notice in the code that there are two variables among the parameters of backtracking function signature, therefore we add a 2D memoization array to hold solutions that are already calculated. The rest can be simple and straightforward.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(MN)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(MN)$$\\n# Code\\n```\\nclass Solution {\\n    private final int MOD = (int) (1e9 + 7);\\n\\n    public int numWays(String[] words, String target) {\\n        int L = words[0].length(); // the length of each word in String[] words \\n        int m = words.length;\\n        int n = target.length();\\n        int[][] memo = new int[L][n];\\n        for (int[] mem : memo) {\\n            Arrays.fill(mem, -1);\\n        }\\n\\n        Map<Character, Integer>[] indexToLetters = new Map[L];\\n        for (int i = 0; i < L; i++) {\\n            indexToLetters[i] = new HashMap<Character, Integer>();\\n            for (int j = 0; j < m; j++) {\\n                char ch = words[j].charAt(i);\\n                indexToLetters[i].put(ch, indexToLetters[i].getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        return backtracking(0, indexToLetters, 0, target, memo);\\n    }\\n\\n    private int backtracking(int i, Map<Character, Integer>[] indexToLetters, int j, String target, int[][] memo) {\\n        if (j == target.length()) {\\n            return 1;\\n        } else if (i == indexToLetters.length) {\\n            return 0;\\n        } else if (memo[i][j] >= 0) {\\n            return memo[i][j];\\n        }\\n\\n        // check if i-th indexToLetters set contains target.charAt(j)\\n        // if yes, there are two choices: pick it, or skip for now\\n        // if no, you can only skip to search for i + 1-th set in indexToLetters\\n        long take = 0, skip = 0;\\n        if (indexToLetters[i].containsKey(target.charAt(j))) {\\n            long count = indexToLetters[i].get(target.charAt(j));\\n            take = count * backtracking(i + 1, indexToLetters, j + 1, target, memo);\\n        }\\n        skip = backtracking(i + 1, indexToLetters, j, target, memo);\\n\\n        return memo[i][j] = (int) ((take + skip) % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int MOD = (int) (1e9 + 7);\\n\\n    public int numWays(String[] words, String target) {\\n        int L = words[0].length(); // the length of each word in String[] words \\n        int m = words.length;\\n        int n = target.length();\\n        int[][] memo = new int[L][n];\\n        for (int[] mem : memo) {\\n            Arrays.fill(mem, -1);\\n        }\\n\\n        Map<Character, Integer>[] indexToLetters = new Map[L];\\n        for (int i = 0; i < L; i++) {\\n            indexToLetters[i] = new HashMap<Character, Integer>();\\n            for (int j = 0; j < m; j++) {\\n                char ch = words[j].charAt(i);\\n                indexToLetters[i].put(ch, indexToLetters[i].getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        return backtracking(0, indexToLetters, 0, target, memo);\\n    }\\n\\n    private int backtracking(int i, Map<Character, Integer>[] indexToLetters, int j, String target, int[][] memo) {\\n        if (j == target.length()) {\\n            return 1;\\n        } else if (i == indexToLetters.length) {\\n            return 0;\\n        } else if (memo[i][j] >= 0) {\\n            return memo[i][j];\\n        }\\n\\n        // check if i-th indexToLetters set contains target.charAt(j)\\n        // if yes, there are two choices: pick it, or skip for now\\n        // if no, you can only skip to search for i + 1-th set in indexToLetters\\n        long take = 0, skip = 0;\\n        if (indexToLetters[i].containsKey(target.charAt(j))) {\\n            long count = indexToLetters[i].get(target.charAt(j));\\n            take = count * backtracking(i + 1, indexToLetters, j + 1, target, memo);\\n        }\\n        skip = backtracking(i + 1, indexToLetters, j, target, memo);\\n\\n        return memo[i][j] = (int) ((take + skip) % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424851,
                "title": "9-lines-of-code-s-99-22-faster-m-82-35",
                "content": "# Code\\n```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        gap = len(words[0]) - len(target) + 1\\n        \\n        words = [Counter(x) for x in zip(*words)]\\n\\n        dp = [1] * gap + [0]\\n\\n        for i, c in enumerate(target):\\n            for k in range(gap):\\n                dp[k] = dp[k - 1] + dp[k] * words[i + k][c]\\n        \\n        return dp[-2] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numWays(self, words: List[str], target: str) -> int:\\n        gap = len(words[0]) - len(target) + 1\\n        \\n        words = [Counter(x) for x in zip(*words)]\\n\\n        dp = [1] * gap + [0]\\n\\n        for i, c in enumerate(target):\\n            for k in range(gap):\\n                dp[k] = dp[k - 1] + dp[k] * words[i + k][c]\\n        \\n        return dp[-2] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424841,
                "title": "dp-solution-in-js-with-comments-and-explanation-of-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to use DP (as you always do when you have to return an answer %1000000007). So we want to construct some sort of DP array (or matrix). \\nImage if you only have one word. Than you could for each index store how many ways you could get to that letter (you can only go from left to right). Since we have multiple words, we can make an array of hashMaps where every hashMap represents one index and in it we store the count of all the letters at that index. Now we can use our hashMapArray instead of our one word. \\n# Approach\\nsee code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnot the best probably. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnot so hot either\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  //construct DP matrix\\n  const dp = new Array(target.length).fill(undefined)\\n  dp.forEach((el, i )=> {\\n    dp[i] = new Array(words[0].length).fill(0)\\n  })\\n\\n  // construct array of hashMaps of letterCounts per index\\n  let hashMapArray = new Array(words[0].length).fill()\\n  hashMapArray = hashMapArray.map((map, index) => {\\n    map = new Map()\\n    words.forEach(word => {\\n      let char = word[index]\\n      if (map.has(char)) map.set(char, map.get(char) + 1)\\n      else map.set(char, 1)\\n    })\\n    return map\\n  })\\n\\n  // set first value of target in dp[0]\\n  hashMapArray.forEach((map, i) => {\\n    if (map.has(target[0])) dp[0][i] = map.get(target[0])\\n  })\\n\\n  // for Each letter in target, go through the hashMapArray and check if the letter is presnt. \\n  // If so, multiply the sum of the ways to get the previous subString from target with ways to get newest letter.\\n  // be sure to add \"% 1000000007\" here, to prevent overflow issues \\n  target.split(\\'\\').forEach((letter, index) => {\\n    if (index === 0) return\\n    hashMapArray.forEach((map, i) => {\\n      if (!map.has(letter)) return \\n      let combinations = 0\\n      for (let j = 0; j < i; j++) {\\n        combinations += dp[index-1][j]\\n      }\\n      dp[index][i] = combinations * map.get(letter) % 1000000007\\n    })\\n  })\\n  \\n  return dp[dp.length-1].reduce((acc,curr) => curr += acc, 0) % 1000000007\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} target\\n * @return {number}\\n */\\nvar numWays = function(words, target) {\\n  //construct DP matrix\\n  const dp = new Array(target.length).fill(undefined)\\n  dp.forEach((el, i )=> {\\n    dp[i] = new Array(words[0].length).fill(0)\\n  })\\n\\n  // construct array of hashMaps of letterCounts per index\\n  let hashMapArray = new Array(words[0].length).fill()\\n  hashMapArray = hashMapArray.map((map, index) => {\\n    map = new Map()\\n    words.forEach(word => {\\n      let char = word[index]\\n      if (map.has(char)) map.set(char, map.get(char) + 1)\\n      else map.set(char, 1)\\n    })\\n    return map\\n  })\\n\\n  // set first value of target in dp[0]\\n  hashMapArray.forEach((map, i) => {\\n    if (map.has(target[0])) dp[0][i] = map.get(target[0])\\n  })\\n\\n  // for Each letter in target, go through the hashMapArray and check if the letter is presnt. \\n  // If so, multiply the sum of the ways to get the previous subString from target with ways to get newest letter.\\n  // be sure to add \"% 1000000007\" here, to prevent overflow issues \\n  target.split(\\'\\').forEach((letter, index) => {\\n    if (index === 0) return\\n    hashMapArray.forEach((map, i) => {\\n      if (!map.has(letter)) return \\n      let combinations = 0\\n      for (let j = 0; j < i; j++) {\\n        combinations += dp[index-1][j]\\n      }\\n      dp[index][i] = combinations * map.get(letter) % 1000000007\\n    })\\n  })\\n  \\n  return dp[dp.length-1].reduce((acc,curr) => curr += acc, 0) % 1000000007\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424820,
                "title": "simple-memoization-code-java",
                "content": "\\n# Code\\n```\\n    class Solution {\\n        private HashMap<Integer, HashMap<Character, Integer>> map;\\n        static final int MOD = (int) (1e9 + 7);\\n        Long dp[][];\\n\\n        public int numWays(String[] words, String target) {\\n            map = new HashMap<>();\\n            dp = new Long[1001][1001];\\n           \\n            /**\\n             * Count the occurrences of a character at the index \\n             */\\n            for (int i = 0; i < words.length; i++) {\\n                for (int j = 0; j < words[i].length(); j++) {\\n                    map.putIfAbsent(j, new HashMap<>());\\n                    if (map.get(j).get(words[i].charAt(j)) == null) {\\n                        map.get(j).put(words[i].charAt(j), 0);\\n                    }\\n                    map.get(j).put(words[i].charAt(j), map.get(j).get(words[i].charAt(j)) + 1);\\n                }\\n            }\\n            return (int) solve(words, target, 0, 0);\\n\\n        }\\n\\n        private long solve(String[] words, String target, int i, int k) {\\n            if (k >= target.length()) {\\n                return 1;\\n            }\\n            if (i >= words[0].length()) return 0;\\n\\n            if (dp[i][k] != null) return dp[i][k];\\n            long count = map.get(i).get(target.charAt(k)) == null ? 0 : map.get(i).get(target.charAt(k));\\n            //Skip the current element at the string and move to the next index\\n            dp[i][k] = solve(words, target, i + 1, k);\\n            dp[i][k] = (dp[i][k] % MOD + (count % MOD * solve(words, target, i + 1, k + 1) % MOD) % MOD) % MOD;\\n\\n            return dp[i][k];\\n\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    class Solution {\\n        private HashMap<Integer, HashMap<Character, Integer>> map;\\n        static final int MOD = (int) (1e9 + 7);\\n        Long dp[][];\\n\\n        public int numWays(String[] words, String target) {\\n            map = new HashMap<>();\\n            dp = new Long[1001][1001];\\n           \\n            /**\\n             * Count the occurrences of a character at the index \\n             */\\n            for (int i = 0; i < words.length; i++) {\\n                for (int j = 0; j < words[i].length(); j++) {\\n                    map.putIfAbsent(j, new HashMap<>());\\n                    if (map.get(j).get(words[i].charAt(j)) == null) {\\n                        map.get(j).put(words[i].charAt(j), 0);\\n                    }\\n                    map.get(j).put(words[i].charAt(j), map.get(j).get(words[i].charAt(j)) + 1);\\n                }\\n            }\\n            return (int) solve(words, target, 0, 0);\\n\\n        }\\n\\n        private long solve(String[] words, String target, int i, int k) {\\n            if (k >= target.length()) {\\n                return 1;\\n            }\\n            if (i >= words[0].length()) return 0;\\n\\n            if (dp[i][k] != null) return dp[i][k];\\n            long count = map.get(i).get(target.charAt(k)) == null ? 0 : map.get(i).get(target.charAt(k));\\n            //Skip the current element at the string and move to the next index\\n            dp[i][k] = solve(words, target, i + 1, k);\\n            dp[i][k] = (dp[i][k] % MOD + (count % MOD * solve(words, target, i + 1, k + 1) % MOD) % MOD) % MOD;\\n\\n            return dp[i][k];\\n\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424801,
                "title": "dp-beginners-friendly-solution",
                "content": "# Intuition\\nConsider a 2D dp, and the key is to figure out the meaning of i and j.\\n\\n**Row: i = the i-th char of the target String\\nCol: j = first j-th chars of all words in the dictionary**\\n\\n# Approach\\nLet\\'s take a closer look into the case:\\nwords = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\\n\\nFirst, we store the counts of character in each column:\\nfor the 1st column, [\\'a\\': 1, \\'b\\': 1, \\'c\\': 1]\\nfor the 2nd column, [\\'a\\': 1, \\'b\\': 1, \\'c\\': 1]\\nfor the 3rd column, [\\'a\\': 0, \\'b\\': 1, \\'c\\': 2]\\nfor the 4th column, [\\'a\\': 2, \\'b\\': 1, \\'c\\': 0]\\n\\nif any words[i][j] == target[j]\\n  dp[i][j] = dp[i][j - 1] + (matched count) * dp[i - 1][j - 1]\\nelse dp[i][j] = dp[i][j - 1]\\n\\n       0 1 2 3 4\\n    0  0 0 0 0 0 \\n    1  0 1 2 2 4\\n    2  0 0 1 3 5 \\n    3  0 0 0 0 6\\n\\nFor example i = 2, we consider the last character \"b\" of substring \"ab\" in \"aba\".\\n\\nFirst when j = i, where the 2nd column has \\'b\\' counted as 1, which means there is only one way to form \"ab\" using the first two columns of the dictionary.\\n\\nNow let\\'s move to j = i + 1, using the dictionary of the first three columns. The 3rd column has \\'b\\' counted as 1, and **considering there are 2 ways to form \"a\" in \"ab\" by using the first two columns of the dictionary** which is represented by dp[1][2], so now we have 1 * 2 = 2.\\n\\nFinally we add up the value from previous column dp[i][j - 1], we have dp[2][3] = 3. This is **because there is still dp[i][j - 1] ways to form \"ab\" by using j - 1 columns in the dictionary**.\\n\\n# Complexity\\n- Time complexity:\\n  O (n * m) where n = max(words.length, target.length), m = words[i].length\\n\\n- Space complexity:\\n  O (n * m) where n = max(words.length, target.length), m = words[i].length\\n\\n# Code\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int n = words.length, m = words[0].length();\\n\\n        // First, we store the counts of character in each column\\n        HashMap<Integer, HashMap<Character, Integer>> freq = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            freq.put(i + 1, new HashMap<>());\\n            for (int j = 0; j < n; j++) {\\n                char c = words[j].charAt(i);\\n                freq.get(i + 1).merge(c, 1, Integer::sum);\\n            }\\n        }\\n\\n        /**\\n          create a 2d dp,\\n          row: i = the i-th char of the target String\\n          col: j = first j-th chars of all words in the dictionary\\n        */\\n        long[][] dp = new long[target.length() + 1][m + 1];\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = i; j < dp[0].length; j++) {\\n                char c = target.charAt(i - 1);\\n                if (freq.get(j).containsKey(c)) {\\n                    dp[i][j] = dp[i][j - 1] \\n                        + freq.get(j).get(c) * (dp[i - 1][j - 1] == 0 && i == 1 ? 1 : dp[i - 1][j - 1]);\\n                } else dp[i][j] = dp[i][j - 1];\\n                dp[i][j] %= 1_000_000_007;\\n            }\\n        }\\n        return (int)dp[target.length()][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n        int n = words.length, m = words[0].length();\\n\\n        // First, we store the counts of character in each column\\n        HashMap<Integer, HashMap<Character, Integer>> freq = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            freq.put(i + 1, new HashMap<>());\\n            for (int j = 0; j < n; j++) {\\n                char c = words[j].charAt(i);\\n                freq.get(i + 1).merge(c, 1, Integer::sum);\\n            }\\n        }\\n\\n        /**\\n          create a 2d dp,\\n          row: i = the i-th char of the target String\\n          col: j = first j-th chars of all words in the dictionary\\n        */\\n        long[][] dp = new long[target.length() + 1][m + 1];\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = i; j < dp[0].length; j++) {\\n                char c = target.charAt(i - 1);\\n                if (freq.get(j).containsKey(c)) {\\n                    dp[i][j] = dp[i][j - 1] \\n                        + freq.get(j).get(c) * (dp[i - 1][j - 1] == 0 && i == 1 ? 1 : dp[i - 1][j - 1]);\\n                } else dp[i][j] = dp[i][j - 1];\\n                dp[i][j] %= 1_000_000_007;\\n            }\\n        }\\n        return (int)dp[target.length()][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424800,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n\\n        int n=target.length();\\n        long mod = (long)1e9 + 7, res[]=new long[n+1];\\n        res[0]=1;\\n        for(int i=0; i<words[0].length(); i++) {\\n            int[] count = new int[26];\\n            //count of each char at index i for all words\\n            for(String w:words)\\n                count[w.charAt(i)-\\'a\\']++;\\n            //dp first j+1 chars = dp first j chars * new char count\\n            //after addition it can spill so we do mod operation 2 times.\\n            for(int j=n-1; j>=0; j--)\\n                res[j+1] += res[j]*count[target.charAt(j)-\\'a\\']%mod;\\n        }\\n        return (int)(res[n]%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numWays(String[] words, String target) {\\n\\n        int n=target.length();\\n        long mod = (long)1e9 + 7, res[]=new long[n+1];\\n        res[0]=1;\\n        for(int i=0; i<words[0].length(); i++) {\\n            int[] count = new int[26];\\n            //count of each char at index i for all words\\n            for(String w:words)\\n                count[w.charAt(i)-\\'a\\']++;\\n            //dp first j+1 chars = dp first j chars * new char count\\n            //after addition it can spill so we do mod operation 2 times.\\n            for(int j=n-1; j>=0; j--)\\n                res[j+1] += res[j]*count[target.charAt(j)-\\'a\\']%mod;\\n        }\\n        return (int)(res[n]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864601,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865062,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864815,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864621,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864932,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865028,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864801,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864930,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864712,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865127,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864601,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865062,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864815,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864621,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864932,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865028,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864801,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864930,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864712,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1865127,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "As expected , Leetcode fu**ed up my beautiful Sunday morning\\uD83D\\uDE14 with a hard problem.\\n\\n\\nBtw best of luck for today\\'s contest :)"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "This is the hardest I have come across so far in my one month of continuous journey on Leetcode."
                    },
                    {
                        "username": "Saurabhsinghchauhan",
                        "content": "Same Bro\\n"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nSuppose we have taken some characters $words[i][x]$ from indices $0 \\le x < k$, and made up to $target[0...j-1]$. Now we can take from indices $k \\le x < words[i].length$ to make the rest of $target[j...]$. Let's denote this by $f(k, j)$.\n\n# Hint 2\nWe have a choice to take or skip current index $k$. Skipping means we are still left to make same $target[j...]$, thereby calling $f(k+1,j)$. However, while taking, we can take $words[i][k]$ only if it matches with $target[j]$. So, for every $0 \\le i < words.length$, check $words[i][k]==target[j]$, and if true take it. We will be left to make $target[j+1...]$, calling $f(k+1,j+1)$ for every valid $i$.\n\n# Hint 3\nFor every valid $i$, we are calling same $f(k+1,j+1)$. We could have calculated and stored beforehand, number of those indices $i$, for which $words[i][k]==target[j]$, so that we could just multiply $count(i) * f(k+1,j+1)$.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "Thanks for the tip. However I couldn\\'t quite get my head around it, This is the toughest I\\'ve come across so far."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After getting two hard problems in two days,\\nMe to my inner-self : Haara hua na mujhko samjhe, mujhe to haraya gya hai."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Two hard problems in a row for a weekend, well done leetcode curators, you weekend destroyers."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Failed on testcase 85/89\\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) [@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@anuraagbarde](/anuraagbarde) I have posted a detailed solution on how to fix this [MySolution](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422284/from-tle-to-accepted-best-explanation-guaranteed/)"
                    },
                    {
                        "username": "anuraagbarde",
                        "content": "+1 \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\n\\nhow to fix this???"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@vasiliyfedotov](/vasiliyfedotov) Might be related to optimisation which can be done using prefix sum."
                    },
                    {
                        "username": "sourashis140",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vasiliyfedotov",
                        "content": "Same. Time limit, despite that complexity is same as in editorial :( "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me 4 hours to write the top-down solution by myself. I\\'m in tears now T_T"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Took me 3h to fail the top-down and get sutck on TLE, and another hour to switch to bottom-up and finally get it. For some reason, it was easier for me to see the logic that way (although it is usually the contrary)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@nat1902](/nat1902) Tried to write the bottom-up one but no success today. I\\'ll give it another try some days later."
                    },
                    {
                        "username": "nat1902",
                        "content": "At least, you can figure out the solution."
                    },
                    {
                        "username": "dev-null0",
                        "content": "I hate these hard questions. You solve the issue, it works fine, but then you have ridiculous test cases that no matter what optimizations you do it'll get TLE..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@Mirn](/Mirn) These problems become easy after regular practice.It is not that hard and there are many people that can solve this problem in 5-10 minutes"
                    },
                    {
                        "username": "Mirn",
                        "content": "Moreover, it is necessary to solve in a couple of hours from scratch such algorithms that have been developed by a team of eminent scientists and mathematicians for months. \"After all, everyone is smarter than a team of top-world class eminent scientists\" - probably the one who arranges an algorithmic interview thinks so that."
                    },
                    {
                        "username": "halfengineer",
                        "content": "another take it or not take it question"
                    },
                    {
                        "username": "vnk01",
                        "content": "The hardest part for me is fixing that SUPER ANNOYING overflow"
                    },
                    {
                        "username": "Jaiff",
                        "content": "Took me an hour. But was satisfying to solve. \\nHint: 1st try to come up with a recursive solution. It will give you TLE but also hope. Then simply memoize it (It will still give TLE). Finally, optimize by keeping a count of each character in each column and try to use this for getting an optimized solution. (It will still give TLE on 88/89). Then either you look at someone\\'s solution (not recommended) or just push a bit more."
                    }
                ]
            },
            {
                "id": 1864918,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1865375,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1864917,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1865673,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1865260,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1864933,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1864713,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1718515,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1999131,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1986082,
                "content": [
                    {
                        "username": "KalimuthuZluri",
                        "content": "In the first example combination 3,4 are same as 1,2 then why are we taking that into account?\\ncan some one explain this?"
                    },
                    {
                        "username": "user7029FW",
                        "content": "See this line of description- \"Notice that you can use multiple characters from the same string in words provided the conditions above are met.\"\n\nSo, 3&4 use acca-bbbb-acca; and 1&2 use acca-bbbb-caca\n\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")"
                    },
                    {
                        "username": "namandt",
                        "content": "Wow, Able to get upto 79/89 with recursion and memo.\\nNow just for last 10 TC need to change the whole approach!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "pain :) "
                    },
                    {
                        "username": "Zefick",
                        "content": "Yet another \"coin change\" problem."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Tip for those who TLE at 85/89 using Python. \\nIf you are passing string to the recursive function, use index instead. e.g., target[1:] would incur copy initialization when calling function, which would consume huge time, leading to TLE."
                    },
                    {
                        "username": "ikorpse",
                        "content": "will never learn how to do `modulo 10^9 + 7` from the first attempt"
                    },
                    {
                        "username": "chiahung_95",
                        "content": "This is a tough weekend..."
                    },
                    {
                        "username": "Finesse",
                        "content": "A `Hash Map` tag should also be used for this problem because a hash map should be used to optimize the solution significantly:\\n\\nWithout a hash map:\\n```python3\\ndef countCharInWords(words: List[str], char: str, index: int) -> int:\\n  count = 0\\n  for word in words:\\n    if word[index] == char:\\n      count += 1\\n  return count\\n```\\n\\nWith a hash map:\\n```python3\\ndef precache(words: List[str]):\\n  charCountByIndex = [None] * len(words[0])\\n  for i in range(0, len(words[0])):\\n    charCountByIndex[i] = {}\\n    for word in words:\\n      charCountByIndex[i][word[i]] = charCountByIndex[i].get(word[i], 0) + 1\\n  return charCountByIndex\\n\\ndef countCharInWords(cache, char: str, index: int) -> int:\\n  return cache[index].get(char, 0)\\n```"
                    },
                    {
                        "username": "cswartzell",
                        "content": " charCountByIndex = [collections.Counter(zipt) for zipt in list(zip(*words))]\n\nzip(*list) inverts a 2d matrix. Yeah yeah \"Your not allowed to use common, built in language features in an interview, even if you clearly understand and can explain them and how you would implement them from primitives for some reason\". I'm a little tired of the \"please reinvent the wheel for me\" attitude. It sucks that this is how interviews are. "
                    },
                    {
                        "username": "preetam_meena",
                        "content": "just signed up and gave a impossible one by my current standard, i don\\'t even understand the whole question"
                    },
                    {
                        "username": "SimardeepSingh1450",
                        "content": "what the f**k is 90th test-case can't even see it?(Gives TLE) Ran 89/90"
                    }
                ]
            },
            {
                "id": 1970827,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1903545,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1866936,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865806,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865776,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865773,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865605,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865570,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865477,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865305,
                "content": [
                    {
                        "username": "RedHessian",
                        "content": "Lmao no precomputation of characters + hashmap for memoization instead of a 2D-array gave me a better TLE (79/90) than otherwise (59/90)"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I don\\'t want to demoralize anyone but Leetcode marks many medium level problems as hard,this one is one of them."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I did it. Did this dp hard ques by myself without any hints. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@shivasaineelam](/shivasaineelam) tle on 74th testcase\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "class Solution {\\npublic:\\nint val=1e9+7;\\n    int f(vector<string>&words,string& target,int i,int j,vector<vector<int>>&dp){\\n         if(j==target.size())return 1;\\n        if(i==words[0].size())return 0;\\n       \\n        int count=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        for(auto k:words){\\n            for(int m=i;m<k.size();m++){\\n                if(k[m]==target[j]){\\n                    count+=f(words,target,m+1,j+1,dp);\\n                    count=(count%val);\\n                }\\n            }\\n        }\\n        return dp[i][j]=count%val;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        vector<vector<int>>dp(words[0].size(),vector<int>(target.size(),-1));\\n\\n        return f(words,target,0,0,dp);\\n        \\n    }\\n};\\nwhat should i do please help\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I spent hours trying to optimize my code, confused why I couldn\\'t solve this problem. I had been so proud initially because I thought I had the algorithm correct, but just kept getting TLE. Well, after staring at my code for a very long time, I learned that my only error was I forgot a \\'&\\'. I didn\\'t loop through `words` by reference and everything imploded. I wasted so much time for such a simple error, but I can\\'t help but laugh at myself for this."
                    },
                    {
                        "username": "aliam",
                        "content": "Anyone know how to solve the TLE from testcase 59/89? I am using dfs with memoization (precomputing the word count at each index)"
                    },
                    {
                        "username": "aliam",
                        "content": "My code (Kotlin):\\n\\n```\\nclass Solution {\\n    fun numWays(words: Array<String>, target: String): Int {\\n        val mod = (1E9+7).toLong()\\n        val m = words[0].length\\n        val n = target.length\\n        \\n        val count = Array(m){IntArray(26)}\\n        for (w in words) {\\n            for ((i, c) in w.withIndex()) {\\n                count[i][c - \\'a\\'] += 1\\n            }\\n        }\\n\\n        val dp = Array(n){LongArray(m)}\\n\\n        fun dfs(i: Int, k: Int): Long {\\n            if (i == n)\\n                return 1L\\n            if (k == m)\\n                return 0L\\n            if (dp[i][k] != 0L)\\n                return dp[i][k]\\n\\n            val c = target[i]\\n            dp[i][k] = dfs(i, k + 1)\\n            if(count[k][c - \\'a\\'] != 0)\\n                dp[i][k] += count[k][c - \\'a\\'] * dfs(i + 1, k + 1)\\n\\n            return dp[i][k] % mod\\n        }\\n\\n        return (dfs(0, 0)).toInt()\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "All those hard DP problems are starting to pay off, this one only took me one our and my only error was that I didn\\'t remember to do modules 1000000007. (Tip, you have to do that as early as you can to prevent overflow/loss of precision errors.). A few months ago, I would have never been able to do this on my own. \\uD83D\\uDE01 Thanks LeetCode and everyOne in the discussion sections with the helpful hints on all the problems!"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "the question is less horrifying than it\\'s description seems ! don\\'t fall for it guys "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "\\'twas pretty horrifying to me"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "Thank you all for discussing , just went through this  and I was able to solve the question."
                    },
                    {
                        "username": "burhanuddinmerchant",
                        "content": "Why does this code give TLE????\n\n ```\nclass Solution {\npublic:\n    int MOD = 1000000007;\n    int helper(vector<vector<long long>>& count, string &target, int w,int t,vector<vector<long long>> &dp){\n        if(dp[w][t]) return dp[w][t];\n        if(t==target.size()) return 1;\n        if(w==count.size()) return 0;\n        long long int cnt = helper(count,target,w+1,t,dp);\n        if(count[w][target[t]-'a']) cnt = (cnt+helper(count,target,w+1,t+1,dp)*count[w][target[t]-'a'])%MOD;\n        return dp[w][t] = cnt;\n    }\n    int numWays(vector<string>& words, string target) {\n        vector<vector<long long>> dp(words[0].size()+1,vector<long long>(target.size()+1,0));\n        vector<vector<long long>> count(words[0].size(),vector<long long>(26,0));\n        for(int i=0;i<words[0].size();i++)\n            for(int j=0;j<words.size();j++)\n                count[i][words[j][i]-'a']++;\n        return helper(count,target,0,0,dp)%MOD;\n    }\n    \n};\n```"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Initialization of dp matrix with 0 is wrong. 0 is a possible answer for numWays(), because the character that is present in target, might not be present in words[] at all. Initialization of memoization dp matrix should always be a number which is not possible to achieve as an answer, and which can be treated as \"invalid\" while checking memoization condition. So, initialize dp with -1 as -1 ways are not possible, and check for dp[][] != -1 in above function."
                    },
                    {
                        "username": "jorgophool",
                        "content": "I also faced TLE on 85/89. I was able to optimize it by computing the prefix sum array of the newly computed dp row, and using it for further computations."
                    }
                ]
            },
            {
                "id": 1865251,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1865116,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1865100,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1865009,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1864953,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1864653,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1864619,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1683058,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1865586,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            },
            {
                "id": 1865181,
                "content": [
                    {
                        "username": "wangchenmeng09",
                        "content": "You might think the \"frequency array\" mentioned in the hints is the DP array you are gonna use. This is a misconception. You\\'ll need to create a 2-D DP matrix IN ADDITION TO this frequency array. I\\'ve spent hours on this."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "can\\'t even figure out brute force"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The beautiful weekend has been destroyed :("
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I can not make TLE to AC..."
                    },
                    {
                        "username": "_drigger",
                        "content": "my streak is definitely going to break \\uD83D\\uDE13"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I am confused in the 2nd example .can someone  explain me better ?"
                    },
                    {
                        "username": "vetor",
                        "content": "Oh god,2 hard questions in a row\\uD83E\\uDD72"
                    },
                    {
                        "username": "Melizza",
                        "content": "I was very confused in beginning why all the solutions calculated the frequency based each word string\\'s indexes, then noticed that I missed the requirement of:\\n\\n> Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\\n\\nSo I am wondering what would be the solution if there is no restriction on \"kth character\" if we are at the next word? -> such as all the words are one string as long as 0 <= i < j < n?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be different problem. This problem doesnt restrict you from using the same string repeatedly, you just have to use later characters. If instead you could use any char from a given string, but each string only once, youd be inverting the requirements. This would be an easier problem (How many strings contain the first char * how many remaining strings less the first contain the second character...)"
                    },
                    {
                        "username": "yadavharsha50",
                        "content": "My accepted memoization solution. No extra freq calculation required\\n\\n\\n    \\n    public int numWays(String[] words, String target) {\\n        Integer dp[][]=new Integer[words[0].length()][target.length()];\\n        return solve(words,target,0,0,dp);\\n    }\\n    public int solve(String words[], String target, int j, int k,Integer dp[][]){\\n        if(k==target.length()){\\n            return 1;\\n        }\\n        if( j>=words[0].length() || (words[0].length()-j)<(target.length()-k)){\\n            return 0;\\n        }\\n\\n        if(dp[j][k]!=null) return dp[j][k];\\n        int MOD=1000000007;\\n        long take=0;\\n        for(int x=0;x<words.length;x++){\\n            if(words[x].charAt(j)==target.charAt(k)){\\n                take+=solve(words,target,j+1,k+1,dp);\\n                take%=MOD;\\n            } \\n        }\\n        long notTake=solve(words,target,j+1,k,dp);\\n        notTake%=MOD;\\n        return dp[j][k]=(int)(take+notTake)%MOD;\\n    }"
                    },
                    {
                        "username": "Shivamagarwal2510",
                        "content": "`int solve(vector<string>& words, string& target, int curr, int tar, vector<vector<int>>& dp, vector<vector<long long int>>& mp){\\n        if(tar==target.size()){\\n            return 1;\\n        }\\n        if(curr>=words[0].size()){\\n            return 0;\\n        }\\n        if(dp[curr][tar]!=-1) return dp[curr][tar];\\n        long long int sum = 0;\\n        sum+=(mp[curr][tar]*solve(words, target, curr+1, tar+1, dp, mp))%1000000007;\\n\\n        sum+=solve(words, target, curr+1, tar, dp, mp)%1000000007;\\n        return dp[curr][tar] = sum%1000000007;\\n    }\\n    int numWays(vector<string>& words, string target) {\\n        int n = words[0].size(), m = target.size();\\n        vector<vector<int>> dp(words[0].size()+1, vector<int>(target.size()+1, -1));\\n        vector<vector<long long int>> mp(n, vector<long long int> (m, 0));\\n        for(int i = 0; i<words[0].size(); i++){\\n            for(int j = 0; j<target.size(); j++){\\n                long long int count = 0;\\n                for(int k=0; k<words.size(); k++){\\n                    if(words[k][i]==target[j]){\\n                        count++;\\n                    }\\n                }\\n                mp[i][j] = count;\\n            }\\n        }\\n\\n        return solve(words, target, 0, 0, dp, mp);\\n    }`   this code is passing only 85 out of 89 testcases. Why is it so?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Array With Elements Not Equal to Average of Neighbors",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of <strong>distinct</strong> integers. You want to rearrange the elements in the array such that every element in the rearranged array is <strong>not</strong> equal to the <strong>average</strong> of its neighbors.</p>\n\n<p>More formally, the rearranged array should have the property such that for every <code>i</code> in the range <code>1 &lt;= i &lt; nums.length - 1</code>, <code>(nums[i-1] + nums[i+1]) / 2</code> is <strong>not</strong> equal to <code>nums[i]</code>.</p>\n\n<p>Return <em><strong>any</strong> rearrangement of </em><code>nums</code><em> that meets the requirements</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> [1,2,4,5,3]\n<strong>Explanation:</strong>\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,2,0,9,7]\n<strong>Output:</strong> [9,7,6,2,0]\n<strong>Explanation:</strong>\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1403946,
                "title": "c-2-approaches-simple-intuition-with-example-diagram",
                "content": "Similar Problem : Wiggle Sort I and II\\n\\n```\\n//Approach-1 (Using sorting O(nlogn))\\n/*\\n    If you make sure that\\n    nums[i-1] < nums[i] > nums[i+1]\\n    You are good to go.\\n    \\n    So, just sort the input and choose wisely to satisfy above condition.\\n    \\n    Example : \\n    [6,2,0,9,7]\\n    sort it : [0, 2, 6, 7, 9]\\n    \\n    result  : [0, _, 2, _, 6] - 1st loop (fill alternaltely)\\n    result  : [0, 7, 2, 9, 6] - 2nd loop (fill next larger numbers from nums to result in spaces left)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        vector<int> result(n);\\n        int j = 0;\\n        int i = 0;\\n        for(; i < n && j < n; i++, j += 2) //alternately fill so that you leave one space in between for large number\\n            result[j] = nums[i];\\n        \\n        \\n        j = 1;\\n        for(; i < n && j < n; i++, j += 2) //filter the large number in spaces between that we left above\\n            result[j] = nums[i];\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n\\n```\\n//Approach-2 (O(n) without sorting)\\n/*\\n\\tThere is a very simple approach to it as well.\\n\\t- Scan from left to right and fix the invalid triplets by swapping\\n\\t- Scan from right to left and fix the invalid triplets by swapping\\n\\n\\tNote : If you only do the first scanning and expect it to be a valid result, it\\'s not. It is not gauranteed.\\n\\t\\t\\t  Unfortunately the test cases are weak and only 1 test case fails if you do first scanning only \\n\\t\\t\\t  (i.e you will get 219 / 220 test cases passed.)\\n\\t\\t\\t  Example : {0, 1, 2, 3, 4, 5} -> Only doing 1st scan will fail here (See the image at the bottom to see dry run)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Move left to right and fix\\n        for (int i = 1; i < n - 1; i++) {\\n\\n            if (2*nums[i] == (nums[i-1] + nums[i+1]))\\n                swap(nums[i], nums[i+1]);\\n        }\\n        \\n        // Move right to left and fix\\n        for (int i = nums.size() - 2; i > 0; i--) {\\n\\n            if (2*nums[i] == (nums[i-1] + nums[i+1]))\\n                swap(nums[i], nums[i-1]);\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```\\n\\n1) First Scan\\n![image](https://assets.leetcode.com/users/images/84ee9e4a-cea7-4c45-9e28-7897ea194b6b_1629021757.1404152.jpeg)\\n\\n2) Second Scan\\n![image](https://assets.leetcode.com/users/images/07e71649-c3e3-4d31-90a4-cc2ebc4ce626_1629021781.8715415.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Approach-1 (Using sorting O(nlogn))\\n/*\\n    If you make sure that\\n    nums[i-1] < nums[i] > nums[i+1]\\n    You are good to go.\\n    \\n    So, just sort the input and choose wisely to satisfy above condition.\\n    \\n    Example : \\n    [6,2,0,9,7]\\n    sort it : [0, 2, 6, 7, 9]\\n    \\n    result  : [0, _, 2, _, 6] - 1st loop (fill alternaltely)\\n    result  : [0, 7, 2, 9, 6] - 2nd loop (fill next larger numbers from nums to result in spaces left)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        vector<int> result(n);\\n        int j = 0;\\n        int i = 0;\\n        for(; i < n && j < n; i++, j += 2) //alternately fill so that you leave one space in between for large number\\n            result[j] = nums[i];\\n        \\n        \\n        j = 1;\\n        for(; i < n && j < n; i++, j += 2) //filter the large number in spaces between that we left above\\n            result[j] = nums[i];\\n        \\n        return result;\\n    }\\n};\\n\\n```\n```\\n//Approach-2 (O(n) without sorting)\\n/*\\n\\tThere is a very simple approach to it as well.\\n\\t- Scan from left to right and fix the invalid triplets by swapping\\n\\t- Scan from right to left and fix the invalid triplets by swapping\\n\\n\\tNote : If you only do the first scanning and expect it to be a valid result, it\\'s not. It is not gauranteed.\\n\\t\\t\\t  Unfortunately the test cases are weak and only 1 test case fails if you do first scanning only \\n\\t\\t\\t  (i.e you will get 219 / 220 test cases passed.)\\n\\t\\t\\t  Example : {0, 1, 2, 3, 4, 5} -> Only doing 1st scan will fail here (See the image at the bottom to see dry run)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Move left to right and fix\\n        for (int i = 1; i < n - 1; i++) {\\n\\n            if (2*nums[i] == (nums[i-1] + nums[i+1]))\\n                swap(nums[i], nums[i+1]);\\n        }\\n        \\n        // Move right to left and fix\\n        for (int i = nums.size() - 2; i > 0; i--) {\\n\\n            if (2*nums[i] == (nums[i-1] + nums[i+1]))\\n                swap(nums[i], nums[i-1]);\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403927,
                "title": "java-c-python-easy-solution",
                "content": "# Solution 1\\nAll integers is distinct, use this condition.\\nSort and swap neighbours into small, big, small, big pattern\\nTime O(sort), Space O(sort)\\n\\n**Java**\\n```java\\n    public int[] rearrangeArray(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = 1; i < A.length; i += 2) {\\n            int tmp = A[i];\\n            A[i] = A[i - 1];\\n            A[i - 1] = tmp;\\n        }\\n        return A;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> rearrangeArray(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < A.size(); i += 2)\\n            swap(A[i], A[i - 1]);\\n        return A;\\n    }\\n```\\n**Python**\\n```py\\n    def rearrangeArray(self, A):\\n        A.sort()\\n        for i in xrange(1, len(A), 2):\\n            A[i], A[i - 1] = A[i - 1], A[i]\\n        return A\\n```\\n<br>\\n\\n# Solution 2\\nBasiclly it\\'s a way more weak problem than `Wiggle Sort`\\nSort A, then make the\\n`result = A[n/2], A[0], A[n/2+1], A[1], A[n/2+3], A[2], ...`\\n\\nTime O(sort), Space O(n)\\n\\n**Python**\\n```py\\n    def rearrangeArray(self, A):\\n        A.sort()\\n        n = len(A)\\n        A[::2], A[1::2] = A[n / 2:], A[:n / 2]\\n        return A\\n```\\n\\n# Solution 3\\nQuick select the median,\\nAnd apply the idea of solution 2.\\n\\nTime O(n) Space O(1)\\nAuthor @StefanPochmann in 324. Wiggle Sort II\\n\\n```cpp\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n\\n        // Index-rewiring.\\n        #define A(i) nums[(1+2*(i)) % (n|1)]\\n\\n        // 3-way-partition-to-wiggly in O(n) time with O(1) space.\\n        int i = 0, j = 0, k = n - 1;\\n        while (j <= k) {\\n            if (A(j) > mid)\\n                swap(A(i++), A(j++));\\n            else if (A(j) < mid)\\n                swap(A(j), A(k--));\\n            else\\n                j++;\\n        }\\n        return nums;\\n    }\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] rearrangeArray(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = 1; i < A.length; i += 2) {\\n            int tmp = A[i];\\n            A[i] = A[i - 1];\\n            A[i - 1] = tmp;\\n        }\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> rearrangeArray(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < A.size(); i += 2)\\n            swap(A[i], A[i - 1]);\\n        return A;\\n    }\\n```\n```py\\n    def rearrangeArray(self, A):\\n        A.sort()\\n        for i in xrange(1, len(A), 2):\\n            A[i], A[i - 1] = A[i - 1], A[i]\\n        return A\\n```\n```py\\n    def rearrangeArray(self, A):\\n        A.sort()\\n        n = len(A)\\n        A[::2], A[1::2] = A[n / 2:], A[:n / 2]\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1403975,
                "title": "c-o-nlogn-time-o-n-complexity-using-sorting-explanation-260-ms",
                "content": "// The initial approach in this question is sort the numbers and lets say sorted numbers are like\\n// a1,a2,a3,.......,an\\n// now a pattern like a1,an,a2,a(n-1),a3,...... would fulfill our requirement every time \\n// because there are only two set of neighbours possbile now\\n// 1. higher numbers, if both numbers are larger than current number then its not possible to achieve a average of that number.\\n// 2. lower numbers, if both numbers are smaller than the current number then also its not possible to achieve this average\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int smaller(0),larger(nums.size()-1);\\n        while(smaller<larger){\\n            ans.push_back(nums[smaller++]);// incr the left pointer to next minimum\\n            ans.push_back(nums[larger--]);// decr the right pointer to next maximum\\n        }\\n        if(nums.size()&1){// if array is odd lengthed then middle element has to be pushed also\\n            ans.push_back(nums[smaller]);// smaller=larger here\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int smaller(0),larger(nums.size()-1);\\n        while(smaller<larger){\\n            ans.push_back(nums[smaller++]);// incr the left pointer to next minimum\\n            ans.push_back(nums[larger--]);// decr the right pointer to next maximum\\n        }\\n        if(nums.size()&1){// if array is odd lengthed then middle element has to be pushed also\\n            ans.push_back(nums[smaller]);// smaller=larger here\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404319,
                "title": "time-o-n-and-space-o-1-in-single-pass-without-sort-4ms",
                "content": "Basically idea is to rearrage an array in alternate increasing decreasing sequence\\nIDIDIDI... or DIDIDIDI...\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        boolean a = nums[0]<nums[1];   //Using this boolean to decide the order of elements\\n        for(int i=1;i<nums.length-1;i++){\\n            if((a && nums[i]<nums[i+1]) || (!a && nums[i]>nums[i+1])){   //Swapping elements based on boolean \\'a\\' and current order of adjacent elements\\n                int t = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = t;\\n            }\\n            a=!a;    //Toggling the order of elements to increasing/decreasing at every iteration\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        boolean a = nums[0]<nums[1];   //Using this boolean to decide the order of elements\\n        for(int i=1;i<nums.length-1;i++){\\n            if((a && nums[i]<nums[i+1]) || (!a && nums[i]>nums[i+1])){   //Swapping elements based on boolean \\'a\\' and current order of adjacent elements\\n                int t = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = t;\\n            }\\n            a=!a;    //Toggling the order of elements to increasing/decreasing at every iteration\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404733,
                "title": "eliminate-increasing-decreasing-sequence",
                "content": "# JUST BREAK THE INCREASING OR DECREASING SEQUENCE AS IT\\'S THE CULPRIT*\\n# \\n  \\n#   The condition when any element is the average of it\\'s neighbours occurs in two cases only:\\n    \\n 1->  if `nums[i-1] < nums[i] < nums[i+1]`  ----> increasing sequence.\\n 2->  if `nums[i-1] > nums[i] > nums[i+1]`  ----> decreasing sequence.\\n\\n`Whenever we encounter any of above pattern we just swap(nums[i],nums[i+1]) ..... so that this    sequence breaks immediately`.\\n`By doing this we will come to a state where all elements gets into perfect order in just one pass only... `\\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t  \\n\\n# C++:\\n\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n\\t    for(int i = 1;i + 1 < nums.size(); i++){\\n            int x = nums[i - 1], y = nums[i], z = nums[i + 1];\\n            if( x < y and y < z  or x > y and y > z ) swap(nums[i], nums[i + 1]);\\n        }\\n        return nums;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "# JUST BREAK THE INCREASING OR DECREASING SEQUENCE AS IT\\'S THE CULPRIT*\\n# \\n  \\n#   The condition when any element is the average of it\\'s neighbours occurs in two cases only:\\n    \\n 1->  if `nums[i-1] < nums[i] < nums[i+1]`  ----> increasing sequence.\\n 2->  if `nums[i-1] > nums[i] > nums[i+1]`  ----> decreasing sequence.\\n\\n`Whenever we encounter any of above pattern we just swap(nums[i],nums[i+1]) ..... so that this    sequence breaks immediately`.\\n`By doing this we will come to a state where all elements gets into perfect order in just one pass only... `\\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t  \\n\\n# C++:\\n\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n\\t    for(int i = 1;i + 1 < nums.size(); i++){\\n            int x = nums[i - 1], y = nums[i], z = nums[i + 1];\\n            if( x < y and y < z  or x > y and y > z ) swap(nums[i], nums[i + 1]);\\n        }\\n        return nums;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1404389,
                "title": "bogosort",
                "content": "I did not want to spend too much time on this problem. Because all numbers are unique, chances of hitting the average are pretty low. \\n\\nSo we just shuffle our array until we get a good one. For arrays larger than 10 elements, you need maximum of two shuffless to pass all test cases.\\n\\n**C++**\\n```cpp\\nvector<int> rearrangeArray(vector<int>& n) {\\n    for (int i = 1; i < n.size() - 1; ++i)\\n        if (n[i] * 2 == n[i - 1] + n[i + 1]) {\\n            random_shuffle(begin(n), end(n));\\n            i = 0;\\n        }\\n    return n;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> rearrangeArray(vector<int>& n) {\\n    for (int i = 1; i < n.size() - 1; ++i)\\n        if (n[i] * 2 == n[i - 1] + n[i + 1]) {\\n            random_shuffle(begin(n), end(n));\\n            i = 0;\\n        }\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721761,
                "title": "easy-to-understand-javascript-solution-with-comments",
                "content": "The idea behind this solution is to use a combination of **small-big-small** and **big-small-big** to ensure the middle number can never be the average of its neighbours.\\n*Think: In (a, b, c) tuple, \\'b\\' can be average of \\'a\\' and \\'c\\' only if \\'b\\' lies in-between \\'a\\' and \\'c\\' in the number line.*\\n\\nWe sort the array in ascending order. We take 2 pointers left and right and alternately insert numbers from left end and right end of the sorted array to create our output array.\\n\\nOur output array will have the form of : **small, big, small, big, small, big, small, big, small...**\\nSo that upon selecting any 3 consecutive numbers, the middle can never be the average of other 2.\\n\\n```\\nlet rearrangeArray = function (nums){\\n  nums.sort((a, b) => a-b); // sorts array in ascending order  \\n  let result = [];\\n  let left = 0;\\n  let right = nums.length-1;  \\n  while(left < right){\\n    result.push(nums[left++]);\\n    result.push(nums[right--]);\\n  }  \\n  if(left == right) result.push(nums[left]); // In case array length is odd we only need to insert the middle element once.  \\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nlet rearrangeArray = function (nums){\\n  nums.sort((a, b) => a-b); // sorts array in ascending order  \\n  let result = [];\\n  let left = 0;\\n  let right = nums.length-1;  \\n  while(left < right){\\n    result.push(nums[left++]);\\n    result.push(nums[right--]);\\n  }  \\n  if(left == right) result.push(nums[left]); // In case array length is odd we only need to insert the middle element once.  \\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423584,
                "title": "c-two-simple-and-short-solutions-explained-3-lines-only",
                "content": "**Explanation:**\\nIf we want a number to never be an average of its neighbors, we should make sure that both neighbos are either smaller or larger than the middle number.\\nWe have several ways to do that, here are two of them:\\n**Solution I:**\\nFirst we sort the array.\\nThen we iterate through the array and fill the values in the result.\\nIn the first loop we start from 0 and fill every other cell, in the second loop we start from 1 and do the same.\\n**Example:** nums = [1,2,3,4,5]\\nAfter first step res = [1, x, 2, x, 3]\\nAfter second step res = [1, 4, 2, 5, 3].\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ptr = 0;\\n        \\n        vector<int> res(n);\\n        \\n        for (int i = 0; i < n; i+=2)\\n            res[i] = nums[ptr++];\\n        \\n        for (int j = 1; j < n; j += 2)\\n            res[j] = nums[ptr++];\\n        \\n        return res;\\n    }\\n};\\n```\\n**Solution II:**\\nSort the array.\\nThen, for every pair of numbers, swap them, so that the pattern will be -\\ninstead of [1,2,3,4,5] --> [2,1,4,3,5]\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n    \\n        for (int i = 0; i < nums.size()-1; i+=2) swap(nums[i], nums[i+1]);\\n        \\n        return nums;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ptr = 0;\\n        \\n        vector<int> res(n);\\n        \\n        for (int i = 0; i < n; i+=2)\\n            res[i] = nums[ptr++];\\n        \\n        for (int j = 1; j < n; j += 2)\\n            res[j] = nums[ptr++];\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n    \\n        for (int i = 0; i < nums.size()-1; i+=2) swap(nums[i], nums[i+1]);\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404417,
                "title": "java-greedy-easy-peasy",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n       Arrays.sort(nums);\\n\\t   // sort in wave format\\n        for(int i = 0;i<nums.length-1;i+=2){\\n            int temp = nums[i];\\n            nums[i] = nums[i+1];\\n            nums[i+1] = temp;\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n       Arrays.sort(nums);\\n\\t   // sort in wave format\\n        for(int i = 0;i<nums.length-1;i+=2){\\n            int temp = nums[i];\\n            nums[i] = nums[i+1];\\n            nums[i+1] = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1403948,
                "title": "java-alternating-order-o-nlogn",
                "content": "If we make an array with alternating numbers from lowest to highest, i.e \\n\\nConceptual example - Smallest1, largest1, smallest2, largest2.\\nReal example - 1, 5, 2, 4, 3\\n\\n\\nThen every number\\u2019s neighbor will produce an average strictly smaller or strictly larger than the current number\\n\\nThus, we can sort the array to get the order, and create the alternating sequence.\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        int l = 0;\\n        int r = n-1;\\n        \\n        int left = 0;\\n        int right = r;\\n        \\n        Arrays.sort(nums);\\n        boolean turn = true;\\n        for(int i=0; i<n; i++){\\n            if(turn){\\n                res[i] = nums[left];\\n                left ++;\\n            } else{\\n                res[i] = nums[right];\\n                right --;\\n            }\\n            turn = !turn;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        int l = 0;\\n        int r = n-1;\\n        \\n        int left = 0;\\n        int right = r;\\n        \\n        Arrays.sort(nums);\\n        boolean turn = true;\\n        for(int i=0; i<n; i++){\\n            if(turn){\\n                res[i] = nums[left];\\n                left ++;\\n            } else{\\n                res[i] = nums[right];\\n                right --;\\n            }\\n            turn = !turn;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446674,
                "title": "c-with-without-sorting-3-solutions",
                "content": "### **Logic: Right element < Middle element > left element**\\nStart with the raw unoptimised logic and optimise it \\n**Method 1: Sorting**\\n *Time: O(NlogN)\\nSpace: O(1)*\\n\\nBy making sure the middle element will be greater than the elements on the sides, the average will always be less than the middle element.\\n`nums[i-1] < nums[i] && nums[i] > nums[i+1]`\\n\\nSort the array, swap alternate elements.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i+=2)\\n        {\\n            swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n**Method 2: Two pass**\\n *Time: O(N+N) = O(N)\\nSpace: O(1)*\\nIterate the array from right to left, swap if average is equal to middle element. Do the same for left to right iteration.\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]*2==nums[i+1]+nums[i-1])\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        \\n        for(int i=nums.size()-2;i>0;i--)\\n        {\\n            if(nums[i]*2==nums[i+1]+nums[i-1])\\n            {\\n                swap(nums[i],nums[i-1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n **Method 3: Single pass**\\n  *Time: O(N)\\nSpace: O(1)*\\nIf we find an increasing pattern or a decreasing pattern => swap\\ni.e, swap `nums[i],nums[i+1] if nums[i-1] < nums[i] < nums[i+1] OR nums[i-1] > nums[i] > nums[i+1] `\\n ```\\n class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if((nums[i+1]>nums[i] && nums[i-1]<nums[i]) || (nums[i+1]<nums[i] && nums[i]<nums[i-1]))\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i+=2)\\n        {\\n            swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]*2==nums[i+1]+nums[i-1])\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        \\n        for(int i=nums.size()-2;i>0;i--)\\n        {\\n            if(nums[i]*2==nums[i+1]+nums[i-1])\\n            {\\n                swap(nums[i],nums[i-1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if((nums[i+1]>nums[i] && nums[i-1]<nums[i]) || (nums[i+1]<nums[i] && nums[i]<nums[i-1]))\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3100957,
                "title": "easy-to-understand-c-beats-100",
                "content": "# Intuition\\n    We are using two pointers approach in this solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to rearrange the array in such a way that every element will have both neighbours either greater than it or both smaller than it. This rearrangement will satisfy the condition: every element is not equal to the average of its neighbours.\\n\\nUse two variables .i.e y = 1, x = 0 for the 1st and 0th element respectively.\\nNow we can iterate over the array from the third element and check for the ith element, and if it satifies one of these two conditions:\\n1. (nums[i]<nums[y] && nums[y]<nums[x]\\n![a.jpeg](https://assets.leetcode.com/users/images/1e8547ce-3e54-44ae-968d-90bc7658448b_1674722259.241781.jpeg)\\n\\n\\n2. (nums[i]>nums[y] && nums[y]>nums[x])\\n![b.jpeg](https://assets.leetcode.com/users/images/5b79c8fe-cbe2-4e05-86f9-782ca0a3a6ee_1674722291.9645486.jpeg)\\n\\nif the ith element satisfies any of the above two conditions, then we have to swap yth element and the ith element.\\nAnd in each iteration we are increasing value of y and x by 1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int x= 0, y = 1;\\n        for(int i=2;i<nums.size();i++){\\n            if((nums[i]<nums[y] && nums[y]<nums[x])||\\n(nums[i]>nums[y] && nums[y]>nums[x])){\\n                int temp=nums[y];\\n                nums[y]=nums[i];\\n                nums[i]=temp;\\n            }\\n                y++;\\n                x++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int x= 0, y = 1;\\n        for(int i=2;i<nums.size();i++){\\n            if((nums[i]<nums[y] && nums[y]<nums[x])||\\n(nums[i]>nums[y] && nums[y]>nums[x])){\\n                int temp=nums[y];\\n                nums[y]=nums[i];\\n                nums[i]=temp;\\n            }\\n                y++;\\n                x++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426592,
                "title": "python-o-n-time-complexity-and-o-1-space-with-only-one-for-loop",
                "content": "- Loop over the array\\n- Check an element\\n\\t- if the current element with its **previous** element and the **next** element combine a decrement or increment. We will swap the current element and after element.\\n\\n\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums) -1):\\n            pre = nums[i-1]\\n            current = nums[i]\\n            next = nums[i+1]\\n            \\n            # If block will run when we meet 1 2 3 or 6 4 2\\n            if (pre < current < next) or (pre > current > next):\\n                # Swap next and current\\n                # For example: \\n                # 1 2 3 -> 1 3 2\\n                # 6 4 2 -> 6 2 4\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums) -1):\\n            pre = nums[i-1]\\n            current = nums[i]\\n            next = nums[i+1]\\n            \\n            # If block will run when we meet 1 2 3 or 6 4 2\\n            if (pre < current < next) or (pre > current > next):\\n                # Swap next and current\\n                # For example: \\n                # 1 2 3 -> 1 3 2\\n                # 6 4 2 -> 6 2 4\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404147,
                "title": "just-guess-lol-python",
                "content": "You can just shuffle nums and hope for the best:\\n``` import random\\n\\ndef is_okay(nums):\\n    for i in range(1, len(nums)-1):\\n        if 2 * nums[i] == nums[i-1] + nums[i+1]:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        while True:\\n            random.shuffle(nums)\\n            if is_okay(nums):\\n                return nums\\n```\\nWhy does this work? For simplicity let\\'s assume `n` is even; suppose `n == 2 * k`. Suppose without loss of generality that `nums` is sorted. We\\'ll bound the probability that a single shuffle is unacceptable by a quantity that approaches 1/2 as n goes to infinity. This proves that we expect guessing to work in `O(1)` many guesses for large `n`, meaning our approach has amortized time complexity `O(n)`.\\n\\nFor `0 <= i < n`, there are at most `min(i, n - i - 1)` many pairs `j` and `k` such that `nums[j] < nums[i] < nums[k]` and `2 * nums[i] == nums[j] + nums[k]`. Note that `sum([min(i, n - i - 1) for i in range(n)]) == (n / 2) * (n / 2 + 1)`.  For each such triple `i, j, k`, the probability of either `[nums[j], nums[i], nums[k]]` or `[nums[k], nums[i], nums[j]]` appearing as a subarray of the shuffled nums is `2 * (n - 2) / (n * (n-1) * (n-2)`, which equals `2 / (n * (n - 1)`. Putting this together using a union bound, we obtain that hte probability of shuffled `nums` not being acceptable is at most `(n / 2) * (n / 2 + 1) * 2 / (n * (n - 1)`, which equals `(n + 2) / (2 * (n - 1))`, which converges to 1/2 as n goes to infinity.",
                "solutionTags": [],
                "code": "``` import random\\n\\ndef is_okay(nums):\\n    for i in range(1, len(nums)-1):\\n        if 2 * nums[i] == nums[i-1] + nums[i+1]:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        while True:\\n            random.shuffle(nums)\\n            if is_okay(nums):\\n                return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403939,
                "title": "c-easy-to-understand-swapping",
                "content": "we will sort the array and swap the consequtive elements.\\n\\n    Observation:\\n              if we have\\n              x y z t    such that x<y<z<t     and we swap consecutive elements then we get\\n              y x t z       \\n              if we check   (y+t)/2  and (x+z)/2  for x and t respective.\\n              we will find that both the numbers are greater than the middle number so their average will \\n              always be greater than the number itself.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n//         sort the array.\\n        sort(nums.begin(),nums.end());\\n//         simply swap consecutive elements\\n        for(int i=0;i<nums.size()-1;i=i+2)\\n            swap(nums[i],nums[i+1]);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n//         sort the array.\\n        sort(nums.begin(),nums.end());\\n//         simply swap consecutive elements\\n        for(int i=0;i<nums.size()-1;i=i+2)\\n            swap(nums[i],nums[i+1]);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403928,
                "title": "c-sort-solution",
                "content": "\\n\\nsort the array: [1, 2, 3, ... ,n], and rearrange the array to be: [1, n/2 + 1, 2, n/2+2, 3, n/2 + 3,...n/2].\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(nums.size());\\n        for(int i = 0; i <= nums.size() / 2; i++) {\\n            if(i * 2 < nums.size())\\n                ans[i * 2] = nums[i];\\n            if(i * 2 + 1 < nums.size() && i + (nums.size() + 1) / 2 < nums.size())\\n                ans[i * 2 + 1] = nums[i + (nums.size() + 1) / 2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(nums.size());\\n        for(int i = 0; i <= nums.size() / 2; i++) {\\n            if(i * 2 < nums.size())\\n                ans[i * 2] = nums[i];\\n            if(i * 2 + 1 < nums.size() && i + (nums.size() + 1) / 2 < nums.size())\\n                ans[i * 2 + 1] = nums[i + (nums.size() + 1) / 2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661495,
                "title": "one-pass-greedy-solution-with-o-n-time-and-o-1-space-observation",
                "content": "# Intuition\\nAs we khow that for an element to not the average of its neighbouring elements,their is just a simple condition that both its neighbouring elements should be either greater than the current element or both should be smaller than the current element.\\n\\n# Approach\\nso we will loop through elements in the range [1 to len-2] elements because the border index 0 or len-1 dont have both either greater index or the smaller element to averaged out ... we will just check this simple condition ( min(nums[i+1],nums[i-1]) < nums[i] && max(nums[i+1],nums[i-1]) > nums[i] ) happen then we can say we could have a possibility that element at index \\'i\\' gets averaged out by the element at \\'i-1\\' and \\'i+1\\'. so we just elemination that possibility by swapping \\'ith\\' index with \\'i+1\\'th element.\\n\\n\\nExample :-\\n[4,6,8] here we can say that \\'6\\' is average of \\'4\\' and \\'8\\' so if we swap ith element(\\'6\\') with \\'i+1\\'th element(\\'8\\') so we can break the possibility of element being averaged out...\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n            if(min(nums[i+1],nums[i-1]) < nums[i] && max(nums[i+1],nums[i-1]) > nums[i]){\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n            if(min(nums[i+1],nums[i-1]) < nums[i] && max(nums[i+1],nums[i-1]) > nums[i]){\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985013,
                "title": "easy-c-solution-using-sorting",
                "content": "Simple cpp solution using sorting.\\nTime O(nLogn) and space O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        vector<int>ans;\\n        while(i<=j)\\n        {\\n            ans.push_back(nums[i]);\\n            if(i==j) break;\\n            ans.push_back(nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        vector<int>ans;\\n        while(i<=j)\\n        {\\n            ans.push_back(nums[i]);\\n            if(i==j) break;\\n            ans.push_back(nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906639,
                "title": "java-solution-with-sorting",
                "content": "Time Complexity: O(nlogn).\\n**STEPS:**\\n1. Sort the nums array.\\n2. Use two pointer approach. Place one pointer at the beginning and one at the end.\\n3. Put the smaller values on the odd index and larger on the even index till start is less than end.\\n4. Break the loop, now start and end are pointing to the same index.\\n5. Check whether the size of the nums is odd, if it is then add the nums[start] into the resultant array. \\n6. Return the resultant array.  \\n\\n```\\n\\n```class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int start=0, end = nums.length-1;\\n        Arrays.sort(nums);\\n        int i=0;\\n        while(start<end)\\n        {\\n            ans[i] = nums[start];\\n            ans[++i] = nums[end];\\n            start++;\\n            end--;\\n            i+=1;\\n        }\\n        if(nums.length%2!=0)\\n            ans[i] = nums[start];\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404075,
                "title": "c-o-nlogn-2-liner-explanation-with-example",
                "content": "Target is to make\\n    nums[i-1] < nums[i] > nums[i+1] , for 1 <= i < nums.length - 1\\n\\n* eg: [1,2,3,5,4]\\n* sort: [1,2,3,4,5]\\n* swap  alternatives: [1,3,2,5,4]\\nIt works as the elements at even places (here 3 & 5) becomes bigger than both its neighbors.\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size()-1;i+=2)swap(nums[i],nums[i+1]);\\n        return nums;\\n    }\\n```\\nplease upvote  if it helped",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size()-1;i+=2)swap(nums[i],nums[i+1]);\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403956,
                "title": "simple-python-runtime-beats-97-3",
                "content": "```\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        while True:\\n            swaps = 0\\n            for i in range(1, n-1):\\n                if nums[i-1] + nums[i+1] == 2*nums[i]:\\n                    nums[i], nums[i+1] = nums[i+1], nums[i]\\n                    swaps += 1\\n                \\n            if swaps == 0:\\n                break\\n                \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        while True:\\n            swaps = 0\\n            for i in range(1, n-1):\\n                if nums[i-1] + nums[i+1] == 2*nums[i]:\\n                    nums[i], nums[i+1] = nums[i+1], nums[i]\\n                    swaps += 1\\n                \\n            if swaps == 0:\\n                break\\n                \\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3748826,
                "title": "greedy-sorting-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf arr[i] is equal to the average of its neighbors then of course one neighbor will be larger and one smaller.\\nFor Ex:-\\n**arr[i] = (arr[i-1]+arr[i+1])/2, then\\narr[i-1] < arr[i] < arr[i+1] or\\narr[i-1] > arr[i] > arr[i+1]**\\n\\nJust break this situation.\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j = 0;\\n        vector<int> ans(n,0);\\n        for(int i = 0;i<n;i+=2,j++) ans[i] = arr[j];\\n        for(int i = 1;i<n;i+=2,j++) ans[i] = arr[j];\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e4c493f3-ea55-4aae-bbeb-b2e45fd692c7_1689059007.441625.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size(),j = 0;\\n        vector<int> ans(n,0);\\n        for(int i = 0;i<n;i+=2,j++) ans[i] = arr[j];\\n        for(int i = 1;i<n;i+=2,j++) ans[i] = arr[j];\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102991,
                "title": "very-simple-solution-80-speed-and-80-memory",
                "content": "# Intuition\\nThis solution relies on the fact that average of 2 numbers is always between the range of those numbers, if we sort our array and then swap the higher boundary with the middle value then we can be sure that, there will be no such element\\n\\n# Approach\\n1. Sort an array, to make it more predictable\\n2. Create a window and iterate through whole array\\n3. Check if middle number is in between bigger numbers, if yes replace higher boundary with middle element\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) - Sorting\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc rearrangeArray(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\n\\tfor i := 1; i < len(nums)-1; i++ {\\n\\t\\tif nums[i-1] < nums[i] && nums[i] < nums[i+1] {\\n\\t\\t\\tnums[i], nums[i+1] = nums[i+1], nums[i]\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rearrangeArray(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\n\\tfor i := 1; i < len(nums)-1; i++ {\\n\\t\\tif nums[i-1] < nums[i] && nums[i] < nums[i+1] {\\n\\t\\t\\tnums[i], nums[i+1] = nums[i+1], nums[i]\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840789,
                "title": "c-easy-solution",
                "content": "Sort the array, then ensure you place the biggest numbers at odd index of the ans array. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n\\tvector<int> ans;  int j = 0;int k =0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n     if (i%2==0) {ans.push_back(nums[k]);k++;}\\n     else {ans.push_back(nums[nums.size()-1-j]);j++;}   \\n    }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n\\tvector<int> ans;  int j = 0;int k =0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n     if (i%2==0) {ans.push_back(nums[k]);k++;}",
                "codeTag": "Java"
            },
            {
                "id": 1670732,
                "title": "c-sorting-deque",
                "content": "```\\n// idea is simple just make the middle element less than its neighbours\\n//which can be achived by using deque \\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        deque<int> dq;\\n        \\n        for(int ele : nums){\\n            dq.push_back(ele);\\n        }\\n        \\n        bool flag = true;\\n        int i =0;\\n        \\n        while(!dq.empty()){\\n            if(flag){\\n                nums[i] = dq.front();\\n                dq.pop_front();\\n                i++;\\n            }\\n            else{\\n                  nums[i] = dq.back();\\n                  dq.pop_back();\\n                  i++;\\n            }\\n            \\n            flag = !flag;\\n        }\\n        \\n        return nums;\\n              \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        deque<int> dq;\\n        \\n        for(int ele : nums){\\n            dq.push_back(ele);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1557298,
                "title": "java-solution-sorting",
                "content": "\\tclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 1; i < nums.length-1; i+=2)\\n        {\\n            swap(nums, i, i+1);\\n        }\\n        \\n        return nums;\\n    }\\n    \\n    void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 1; i < nums.length-1; i+=2)\\n        {\\n            swap(nums, i, i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1491132,
                "title": "o-n-java-solution",
                "content": "The idea is to convert the array in increasing and decreaing sequence (IDID... or DIDI....). \\nConsider current i as I then i-1 and i+1 will be D. As i is greater than i-1 and i+1, average of i-1 and i+1 will always be less that i. Same will apply if i is D and i-1 and i+1 is I. In this case average of i-1 and i+1 will always be greater than i.\\n\\n```class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        boolean increasing = nums[1] > nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((increasing && nums[i+1] > nums[i]) || !increasing && nums[i+1] < nums[i]){\\n                swap(nums, i, i+1);\\n            }\\n            increasing = !increasing;\\n        }\\n        \\n        return nums;\\n    }\\n    \\n    private void swap(int[] arr, int x, int y){\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        boolean increasing = nums[1] > nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((increasing && nums[i+1] > nums[i]) || !increasing && nums[i+1] < nums[i]){\\n                swap(nums, i, i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1438173,
                "title": "c-sort-no-sort-both-solution-greedy",
                "content": "// SORT SOLUTION --> Greedy\\n```\\n  vector<int> rearrangeArray(vector<int>& a) \\n    {\\n       sort(a.begin(),a.end());   \\n       vector<int> b;\\n       for(int i=0;i<a.size()/2;i++)\\n       {\\n           b.push_back(a[i]);\\n           b.push_back(a[a.size()-i-1]);\\n       }\\n       if(a.size()%2==1)\\n       {\\n           b.push_back(a[a.size()/2]);\\n       }\\n       return b;\\n    }\\n```\\n// No SORT SOLUTION --> More Greedy\\n```\\n  vector<int> rearrangeArray(vector<int>& a) {\\n        \\n        int n=a.size();\\n        for (int i = 1; i < n; i += 2)\\n        {\\n            if (a[i - 1] > a[i]) \\n\\t\\t\\t{\\n                swap(a[i-1],a[i]);\\n\\t\\t\\t}\\n            if (i + 1 < n && a[i + 1] > a[i]) \\n\\t\\t\\t{\\n                swap(a[i+1],a[i]);\\n\\t\\t\\t}\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n  vector<int> rearrangeArray(vector<int>& a) \\n    {\\n       sort(a.begin(),a.end());   \\n       vector<int> b;\\n       for(int i=0;i<a.size()/2;i++)\\n       {\\n           b.push_back(a[i]);\\n           b.push_back(a[a.size()-i-1]);\\n       }\\n       if(a.size()%2==1)\\n       {\\n           b.push_back(a[a.size()/2]);\\n       }\\n       return b;\\n    }\\n```\n```\\n  vector<int> rearrangeArray(vector<int>& a) {\\n        \\n        int n=a.size();\\n        for (int i = 1; i < n; i += 2)\\n        {\\n            if (a[i - 1] > a[i]) \\n\\t\\t\\t{\\n                swap(a[i-1],a[i]);\\n\\t\\t\\t}\\n            if (i + 1 < n && a[i + 1] > a[i]) \\n\\t\\t\\t{\\n                swap(a[i+1],a[i]);\\n\\t\\t\\t}\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1412702,
                "title": "java-solution-easy-clean-and-concise-approach-using-sorting-43-ms",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] arr = new int[nums.length];\\n        int len = nums.length - 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = nums.length - 1;\\n        \\n        while(i < nums.length) {\\n        \\tarr[i] = nums[j];\\n        \\tj++;\\n        \\ti++;\\n        \\tif(i < nums.length) {\\n        \\t\\tarr[i] = nums[k];\\n        \\t\\ti++;\\n        \\t\\tk--;\\n        \\t}\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] arr = new int[nums.length];\\n        int len = nums.length - 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int k = nums.length - 1;\\n        \\n        while(i < nums.length) {\\n        \\tarr[i] = nums[j];\\n        \\tj++;\\n        \\ti++;\\n        \\tif(i < nums.length) {\\n        \\t\\tarr[i] = nums[k];\\n        \\t\\ti++;\\n        \\t\\tk--;\\n        \\t}\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404004,
                "title": "clean-intuitive-java-solution-two-pointer",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int [] result = new int[nums.length];\\n        int start = 0, end = nums.length-1, index =0;\\n        while(start<=end){\\n            result[index] = (index%2==0)?nums[start++]:nums[end--];\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int [] result = new int[nums.length];\\n        int start = 0, end = nums.length-1, index =0;\\n        while(start<=end){\\n            result[index] = (index%2==0)?nums[start++]:nums[end--];\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403990,
                "title": "c-construction-sorting",
                "content": "Intuition: Arrange the array in the forms of: `[small, big, small, big, small ...]`\\n\\nFirst sort the array, you will get something like: `[1,2,3,4,5,6]` (notice all elements are distinct).\\nThen you start putting the numbers from smallest to the biggest, first at odd position, then at even position.\\nThe procedures look like the following:\\n`ans = [0, 0, 0, 0, 0, 0]`\\n`ans = [1, 0, 2, 0, 3, 0]`\\n`ans = [1, 4, 2, 5, 3, 6]`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        int j = 0, n = nums.size();\\n        for (int i = 0; i < n; i+=2) {\\n            nums[i] = arr[j++];\\n        }\\n        for (int i = 1; i < n; i+=2) {\\n            nums[i] = arr[j++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        int j = 0, n = nums.size();\\n        for (int i = 0; i < n; i+=2) {\\n            nums[i] = arr[j++];\\n        }\\n        for (int i = 1; i < n; i+=2) {\\n            nums[i] = arr[j++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403970,
                "title": "simplest-2-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& a1) {\\n         sort(a1.rbegin(),a1.rend());\\n         for(int i=0; i<a1.size()-1; i+=2) swap(a1[i],a1[i+1]); \\n         return a1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& a1) {\\n         sort(a1.rbegin(),a1.rend());\\n         for(int i=0; i<a1.size()-1; i+=2) swap(a1[i],a1[i+1]); \\n         return a1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403969,
                "title": "java-sort-one-pass-with-steps",
                "content": "**Steps:**\\n* Sort the array\\n* Rearrange elements in a zig zag increasing decreasing fashion such that :\\n\\t\\t`a < b > c < d > e < f`\\n* Return array\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 1;i< nums.length-1;i+=2){\\n            swap(nums,i,i+1);\\n        }\\n        return nums;\\n    }\\n    public void swap(int arr[],int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 1;i< nums.length-1;i+=2){\\n            swap(nums,i,i+1);\\n        }\\n        return nums;\\n    }\\n    public void swap(int arr[],int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403963,
                "title": "swap-only",
                "content": "```class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        for (int i = 1; i < n; i += 2){\\n            if (arr[i - 1] > arr[i]) \\n                swap(arr[i-1],arr[i]);\\n            if (i + 1 < n && arr[i + 1] > arr[i]) \\n                swap(arr[i+1],arr[i]);\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        for (int i = 1; i < n; i += 2){\\n            if (arr[i - 1] > arr[i]) \\n                swap(arr[i-1],arr[i]);\\n            if (i + 1 < n && arr[i + 1] > arr[i]) \\n                swap(arr[i+1],arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3797806,
                "title": "it-s-so-simple-but-realized-it-after-several-failed-attempts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni thought it can easily be done by either circular linked list or queue, but the time complexity was in terms of n^2, then i thought the only task we have to do is swapping then why not directly swap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere i am directly swapping the terms which do not satisfy the condition\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ndon\\'t know\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        int temp;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==(nums[i-1]+nums[i+1])/2)\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n                if(i>=2) i=i-2;\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        int temp;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(nums[i]==(nums[i-1]+nums[i+1])/2)\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=temp;\\n                if(i>=2) i=i-2;\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614159,
                "title": "priority-queue-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSame as wiggle-sort -(2) problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a max heap and alternatively store elements in even indices and then odd indices\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$ - for the heap\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        for(int i=1;i<n;i+=2){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        for(int i=0;i<n;i+=2){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        for(int i=1;i<n;i+=2){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        for(int i=0;i<n;i+=2){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564860,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1]) || (nums[i-1]>nums[i] && nums[i]>nums[i+1]))\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1]) || (nums[i-1]>nums[i] && nums[i]>nums[i+1]))\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379219,
                "title": "easy-c-solution-using-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector <int> lst;\\n        sort(nums.begin(),nums.end());\\n        int i=1,ln=nums.size();\\n        while(i<ln){\\n            lst.push_back(nums[i]);\\n            lst.push_back(nums[i-1]);\\n            i+=2;\\n        }\\n        if(ln!=lst.size()) lst.push_back(nums[ln-1]);\\n        return lst;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector <int> lst;\\n        sort(nums.begin(),nums.end());\\n        int i=1,ln=nums.size();\\n        while(i<ln){\\n            lst.push_back(nums[i]);\\n            lst.push_back(nums[i-1]);\\n            i+=2;\\n        }\\n        if(ln!=lst.size()) lst.push_back(nums[ln-1]);\\n        return lst;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366740,
                "title": "java-easy-recursive-solution",
                "content": "## Approach\\nSort the array \\nKeep on changing the array untill the desired array is made\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        boolean ch=false;\\n        while(ch==false)\\n        {\\n            r(nums);\\n            ch=check(nums);\\n        }\\n        return nums;\\n    }\\n    public void r(int[] nums)\\n    {\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if((double)((nums[i-1]+nums[i+1])*1.0/2)==nums[i]*1.0)\\n            {\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n            }\\n        }\\n        //return nums;\\n    }\\n    public boolean check(int[] nums)\\n    {\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if((double)((nums[i-1]+nums[i+1])*1.0/2)==nums[i]*1.0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        boolean ch=false;\\n        while(ch==false)\\n        {\\n            r(nums);\\n            ch=check(nums);\\n        }\\n        return nums;\\n    }\\n    public void r(int[] nums)\\n    {\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if((double)((nums[i-1]+nums[i+1])*1.0/2)==nums[i]*1.0)\\n            {\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n            }\\n        }\\n        //return nums;\\n    }\\n    public boolean check(int[] nums)\\n    {\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if((double)((nums[i-1]+nums[i+1])*1.0/2)==nums[i]*1.0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193499,
                "title": "swap-one-loop-python-3",
                "content": "# Intuition\\nI found it a very mathematical based question rather than using an algorithm for this. Though there are various sorting algorithm but you can solve it using normal swaps.\\nkeep your window of size 3 and check is the window is sorted in any manner (reverse included) it is so then swap any two elements and move forward. You will get you ans ;)\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        while left < len(nums) - 2:\\n            if nums[left: left + 3] == sorted(nums[left: left + 3]) or nums[left: left + 3] == sorted(nums[left: left + 3], reverse= True):\\n                nums[left + 1], nums[left + 2] = nums[left + 2], nums[left + 1]\\n            left += 1\\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        while left < len(nums) - 2:\\n            if nums[left: left + 3] == sorted(nums[left: left + 3]) or nums[left: left + 3] == sorted(nums[left: left + 3], reverse= True):\\n                nums[left + 1], nums[left + 2] = nums[left + 2], nums[left + 1]\\n            left += 1\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925974,
                "title": "100-0ms-easy-o-n-proof",
                "content": "# upvote pls\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/d1853702-ae1d-49f4-995d-021c21f63a77_1671380488.9694905.png)\\n\\n\\n\\n# Code\\n```\\n// class Solution {\\n//     public int[] rearrangeArray(int[] nums) {\\n//         Arrays.sort(nums);\\n//         for(int i=1;i<nums.length;i+=2){\\n//             var v=nums[i];\\n//             nums[i]=nums[i-1];\\n//             nums[i-1]=v;\\n//         }return nums;\\n//     }\\n// }\\n\\n\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int len = nums.length;\\n        if(len == 3 && nums[0]+nums[2] == 2*nums[1]) return new int[] {nums[0], nums[2], nums[1]};\\n        for(int i = 1; i<len-2; i++) {\\n            if(nums[i]*2 == nums[i+1]+nums[i-1]) {\\n                int tmp = nums[i+1];\\n                nums[i+1] = nums[i+2];\\n                nums[i+2] = tmp;\\n            }\\n        }\\n        if(nums[len-2]*2 == nums[len-1]+nums[len-3]){\\n            int tmp = nums[len-1];\\n            nums[len-1] = nums[0];\\n            nums[0] = tmp;\\n            if(nums[1]*2 == nums[0]+nums[2]){\\n                int tmpe = nums[1];\\n                nums[1] = nums[0];\\n                nums[0] = tmpe;\\n            }\\n            return nums;\\n        } else return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n// class Solution {\\n//     public int[] rearrangeArray(int[] nums) {\\n//         Arrays.sort(nums);\\n//         for(int i=1;i<nums.length;i+=2){\\n//             var v=nums[i];\\n//             nums[i]=nums[i-1];\\n//             nums[i-1]=v;\\n//         }return nums;\\n//     }\\n// }\\n\\n\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int len = nums.length;\\n        if(len == 3 && nums[0]+nums[2] == 2*nums[1]) return new int[] {nums[0], nums[2], nums[1]};\\n        for(int i = 1; i<len-2; i++) {\\n            if(nums[i]*2 == nums[i+1]+nums[i-1]) {\\n                int tmp = nums[i+1];\\n                nums[i+1] = nums[i+2];\\n                nums[i+2] = tmp;\\n            }\\n        }\\n        if(nums[len-2]*2 == nums[len-1]+nums[len-3]){\\n            int tmp = nums[len-1];\\n            nums[len-1] = nums[0];\\n            nums[0] = tmp;\\n            if(nums[1]*2 == nums[0]+nums[2]){\\n                int tmpe = nums[1];\\n                nums[1] = nums[0];\\n                nums[0] = tmpe;\\n            }\\n            return nums;\\n        } else return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780423,
                "title": "python-easy-solution",
                "content": "The only way the average of the neighbors can give us the number is if one of them is greater and the other is smaller than the middle number.\\n\\nTo make the number different from the average of its neighbors, we just have to first sort the array and then take one number from the start then from the end. If we do the same process by picking a number from the front then from the end we can achieve what we want.  \\n\\n\\n```class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        start, end = 0, len(nums)-1\\n        answer = []\\n        \\n        while start <= end:\\n            answer.append(nums[start])\\n            answer.append(nums[end])\\n            start+=1\\n            end-=1\\n        if len(nums) %2 != 0:\\n            answer.pop()\\n        return answer\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        start, end = 0, len(nums)-1\\n        answer = []\\n        \\n        while start <= end:\\n            answer.append(nums[start])\\n            answer.append(nums[end])\\n            start+=1\\n            end-=1\\n        if len(nums) %2 != 0:\\n            answer.pop()\\n        return answer\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2657815,
                "title": "easy-best-solution-without-sorting-c-o-n-tc-o-1-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636927,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nlass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ptr = 0;\\n        \\n        vector<int> res(n);\\n        \\n        for (int i = 0; i < n; i+=2)\\n            res[i] = nums[ptr++];\\n        \\n        for (int j = 1; j < n; j += 2)\\n            res[j] = nums[ptr++];\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nlass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size(), ptr = 0;\\n        \\n        vector<int> res(n);\\n        \\n        for (int i = 0; i < n; i+=2)\\n            res[i] = nums[ptr++];\\n        \\n        for (int j = 1; j < n; j += 2)\\n            res[j] = nums[ptr++];\\n        \\n        return res;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2605259,
                "title": "c-just-check-for-increasing-decreasing-pattern-easy",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1]) || (nums[i-1]>nums[i] && nums[i]>nums[i+1]))\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nSUPPORT FROM YOUR SIDE",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1]) || (nums[i-1]>nums[i] && nums[i]>nums[i+1]))\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290944,
                "title": "python-simple-approach-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # Algorithm: Time = O(n); Space = O(1); Algo Credits @bangoc\\n        # 1. We don\\'t want any ascending or descending patterns among \\n        #    3 consequtive elements, so we need to break them by swapping\\n        # 2. Get the 3 elements, (prev, cur, nxt)\\n        # 3. If these three are in ascending or descending order\\n        #    i,e. prev < cur < nxt or prev > cur > nxt\\n        #    then swap the cur and nxt elements\\n        # 4. Repeat this for entire array\\n\\n        def swap(l, r):\\n            nums[l], nums[r] = nums[r], nums[l]\\n            \\n        n = len(nums)\\n        for i in range(1, n-1):\\n            prev, cur, nxt = nums[i-1], nums[i], nums[i+1]\\n\\n            if prev < cur < nxt or prev > cur > nxt:\\n                swap(i+1, i)\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # Algorithm: Time = O(n); Space = O(1); Algo Credits @bangoc\\n        # 1. We don\\'t want any ascending or descending patterns among \\n        #    3 consequtive elements, so we need to break them by swapping\\n        # 2. Get the 3 elements, (prev, cur, nxt)\\n        # 3. If these three are in ascending or descending order\\n        #    i,e. prev < cur < nxt or prev > cur > nxt\\n        #    then swap the cur and nxt elements\\n        # 4. Repeat this for entire array\\n\\n        def swap(l, r):\\n            nums[l], nums[r] = nums[r], nums[l]\\n            \\n        n = len(nums)\\n        for i in range(1, n-1):\\n            prev, cur, nxt = nums[i-1], nums[i], nums[i+1]\\n\\n            if prev < cur < nxt or prev > cur > nxt:\\n                swap(i+1, i)\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275965,
                "title": "c-solution",
                "content": "```\\n  vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int j=0;\\n        \\n       vector<int>vt(n/2);\\n       \\n        int n1=vt.size();\\n        int n2=n-n1;\\n        vector<int>vt1(n2);\\n        for(int i=0;i<n1;i++){\\n            vt[i]=nums[j];\\n            j++;\\n        }\\n        \\n        for(int i=0;i<n2;i++){\\n            vt1[i]=nums[j];\\n            j++;\\n        }\\n        int k1=0;\\n        int k2=0;\\n       for(int i=0;i<n;i=i+2){\\n           nums[i]=vt1[k1];\\n           k1++;\\n         \\n       }\\n        int k=0;\\n        for(int i=1;i<n;i=i+2){\\n            nums[i]=vt[k];\\n            k++;\\n        }\\n        \\n    return nums;",
                "solutionTags": [],
                "code": "```\\n  vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int j=0;\\n        \\n       vector<int>vt(n/2);\\n       \\n        int n1=vt.size();\\n        int n2=n-n1;\\n        vector<int>vt1(n2);\\n        for(int i=0;i<n1;i++){\\n            vt[i]=nums[j];\\n            j++;\\n        }\\n        \\n        for(int i=0;i<n2;i++){\\n            vt1[i]=nums[j];\\n            j++;\\n        }\\n        int k1=0;\\n        int k2=0;\\n       for(int i=0;i<n;i=i+2){\\n           nums[i]=vt1[k1];\\n           k1++;\\n         \\n       }\\n        int k=0;\\n        for(int i=1;i<n;i=i+2){\\n            nums[i]=vt[k];\\n            k++;\\n        }\\n        \\n    return nums;",
                "codeTag": "Unknown"
            },
            {
                "id": 2101854,
                "title": "java-short-and-simple-solution",
                "content": "The aim is to arrange the array such that the ```avg(nums[i-1],nums[i+1]) != nums[i]```.\\n\\nOne way to make it possible is to make every ```nums[i]``` \\n\\n\\tgreater than both ```nums[i+1]``` and ```nums[i-1]``` Or smaller than both ```nums[i+1]``` and ```nums[i-1]```.\\n\\nbecause in both the situations ```avg(nums[i-1],nums[i+1])``` will not be equal to ```nums[i]```.\\n\\nTo achieve this Sort the ```nums```array in increasing order, then add alternate greater and smaller element into ```ans``` array. i.e add one element from back and one element from front.\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.sort(nums);\\n\\n        for(int i=0,j=nums.length-1,k=0;i<=j;k++){\\n            ans[k] = (k&1)==0?nums[j--]:nums[i++];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```avg(nums[i-1],nums[i+1]) != nums[i]```\n```nums[i]```\n```nums[i+1]```\n```nums[i-1]```\n```nums[i+1]```\n```nums[i-1]```\n```avg(nums[i-1],nums[i+1])```\n```nums[i]```\n```nums```\n```ans```\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.sort(nums);\\n\\n        for(int i=0,j=nums.length-1,k=0;i<=j;k++){\\n            ans[k] = (k&1)==0?nums[j--]:nums[i++];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424001,
                "title": "can-someone-explain-to-me-why-the-second-example-needs-to-be-rearranged",
                "content": "![image](https://assets.leetcode.com/users/images/4663e4bf-62e3-4be8-aebb-fa50ea710dd9_1629830781.4632318.png)\\n\\n```\\nnums = [6,2,0,9,7]\\n```\\nIsn\\'t this one already valid? Am I missing something?\\n",
                "solutionTags": [],
                "code": "```\\nnums = [6,2,0,9,7]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423554,
                "title": "fastest-shortest-java-code",
                "content": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i+1<nums.length;i++){\\n            int x = nums[i];\\n            nums[i] = nums[i+1];\\n            nums[i+1] = x;\\n            i++;\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i+1<nums.length;i++){\\n            int x = nums[i];\\n            nums[i] = nums[i+1];\\n            nums[i+1] = x;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1417063,
                "title": "python-one-pass-o-n-wiggle-sort",
                "content": "def rearrangeArray(self, nums):\\n        \\n        \\n        for i in range(len(nums) - 1):\\n            \\n            if i%2 == 0 and nums[i] < nums[i + 1]:\\n                \\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n            \\n            \\n            if i%2 == 1 and nums[i] > nums[i + 1]:\\n                \\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n                \\n                \\n        return nums",
                "solutionTags": [],
                "code": "def rearrangeArray(self, nums):\\n        \\n        \\n        for i in range(len(nums) - 1):\\n            \\n            if i%2 == 0 and nums[i] < nums[i + 1]:\\n                \\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n            \\n            \\n            if i%2 == 1 and nums[i] > nums[i + 1]:\\n                \\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n                \\n                \\n        return nums",
                "codeTag": "Python3"
            },
            {
                "id": 1415816,
                "title": "python3-solution",
                "content": "always make sure that for any index i, nums[i - 1] < nums[i] > nums[i - 1] will hold\\nif len(nums) is even, example: [0, 1, 2, 3, 4, 5] -- > [0, 4, 2, 3, 1, 5] ([low, high, low, high, low, high])\\nif len(nums) is odd, example: [0, 1, 2, 3, 4] --> [0, 4, 2, 3, 1] ([low, high, low, high, low])\\nwe just need to set the different start index of j and keep stride of i and j as 2. the algorithm can easily be implemented. \\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        ans = []\\n        n = len(nums)\\n        if n % 2 == 0:\\n            i, j = 1, len(nums) - 2\\n            while i <= j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 2\\n                j -= 2\\n        else:\\n            i, j = 1, len(nums) - 1\\n            while i <= j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 2\\n                j -= 2\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        ans = []\\n        n = len(nums)\\n        if n % 2 == 0:\\n            i, j = 1, len(nums) - 2\\n            while i <= j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 2\\n                j -= 2\\n        else:\\n            i, j = 1, len(nums) - 1\\n            while i <= j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 2\\n                j -= 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412716,
                "title": "0-n-0-1-c-solution",
                "content": "\"\"\"\\nfor (int i = 1; i < nums.size()-1; ++i) {\\n            if ((nums[i-1] < nums[i] && nums[i] < nums[i+1]) || (nums[i-1] > nums[i] && nums[i] > nums[i+1])) \\n                swap(nums[i], nums[i+1]); \\n        }\\n        return nums; \\n\\t\\t\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nfor (int i = 1; i < nums.size()-1; ++i) {\\n            if ((nums[i-1] < nums[i] && nums[i] < nums[i+1]) || (nums[i-1] > nums[i] && nums[i] > nums[i+1])) \\n                swap(nums[i], nums[i+1]); \\n        }\\n        return nums; \\n\\t\\t\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1411200,
                "title": "java-solution-faster-than-96-36-o-n-complexity",
                "content": "Strictly increasing or decreasing elements are creating averages, so whenever \\ntwo consecutive increasing or decreasings are found, swaped one of them.\\nNOTE: input array is getting changed otherwise an array using copyOfRange(0,n) has to \\nbe created to store the result.\\n```\\npublic int[] rearrangeArray(int[] nums) {\\n\\n\\tfor(int i=1 ; i<nums.length-1 ; i++){\\n\\t\\tint a = nums[i-1];\\n\\t\\tint b = nums[i];\\n\\t\\tint c = nums[i+1];\\n\\t\\tif(a<b && b<c || a>b && b>c)\\n\\t\\t\\tswap(nums,i,i+1);\\n\\t}\\n\\treturn nums;\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "Strictly increasing or decreasing elements are creating averages, so whenever \\ntwo consecutive increasing or decreasings are found, swaped one of them.\\nNOTE: input array is getting changed otherwise an array using copyOfRange(0,n) has to \\nbe created to store the result.\\n```\\npublic int[] rearrangeArray(int[] nums) {\\n\\n\\tfor(int i=1 ; i<nums.length-1 ; i++){\\n\\t\\tint a = nums[i-1];\\n\\t\\tint b = nums[i];\\n\\t\\tint c = nums[i+1];\\n\\t\\tif(a<b && b<c || a>b && b>c)\\n\\t\\t\\tswap(nums,i,i+1);\\n\\t}\\n\\treturn nums;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1409640,
                "title": "java-2-ms-faster-than-99-68-and-better-than-98-17-memory-usage",
                "content": "We loop through the array until we find an element that is the average of its neighbors. If it\\'s not at the end yet, then we just swap the right most element with the element after it. If the element is at the end, then we check for its average with previous elements until we find an element that is not the average of its neighbors and swap it with the left most element.\\n\\n**Space Complexity:** O(1)\\n**Time Complexity:** I actually have no idea, could anyone tell me? I feel like most of the time it will be O(N) but i\\'m not too sure.\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        for(int i = 1; i+1 < nums.length; i++)\\n            \\n            if(nums[i] * 2 == nums[i-1] + nums[i+1]) {\\n                \\n                int a = nums[i+1];\\n                \\n                if(i+2 < nums.length) {\\n                    nums[i+1] = nums[i+2];\\n                    nums[i+2] = a;\\n                }\\n                \\n                else {\\n                    if(nums[2] == nums[i+1]) {\\n                        nums[i+1] = nums[1];\\n                        nums[1] = a;\\n                    }\\n                    else\\n                        for(int j = 1; j+1 < nums.length; j++)\\n\\n                            if(nums[j] * 2 != nums[i+1] + nums[j+1]) {\\n                                nums[i+1] = nums[j-1];\\n                                nums[j-1] = a;\\n                                break;\\n                            }\\n                    \\n                }\\n                \\n            }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        for(int i = 1; i+1 < nums.length; i++)\\n            \\n            if(nums[i] * 2 == nums[i-1] + nums[i+1]) {\\n                \\n                int a = nums[i+1];\\n                \\n                if(i+2 < nums.length) {\\n                    nums[i+1] = nums[i+2];\\n                    nums[i+2] = a;\\n                }\\n                \\n                else {\\n                    if(nums[2] == nums[i+1]) {\\n                        nums[i+1] = nums[1];\\n                        nums[1] = a;\\n                    }\\n                    else\\n                        for(int j = 1; j+1 < nums.length; j++)\\n\\n                            if(nums[j] * 2 != nums[i+1] + nums[j+1]) {\\n                                nums[i+1] = nums[j-1];\\n                                nums[j-1] = a;\\n                                break;\\n                            }\\n                    \\n                }\\n                \\n            }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405940,
                "title": "simple-solution",
                "content": "```\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0, n = nums.length, j = n-1, k =0, res[] = new int[n];\\n        boolean alt = true;\\n        while(k < n) {\\n            res[k++] = alt ? nums[i++] : nums[j--];\\n            alt = !alt;\\n        }\\n        return res;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0, n = nums.length, j = n-1, k =0, res[] = new int[n];\\n        boolean alt = true;\\n        while(k < n) {\\n            res[k++] = alt ? nums[i++] : nums[j--];\\n            alt = !alt;\\n        }\\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1405695,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for(int i=2;i<nums.size();i++) {\\n            if((nums[i-2]<nums[i-1] && nums[i-1]<nums[i]) || (nums[i-2]>nums[i-1] && nums[i-1]>nums[i])) {\\n                swap(nums[i-1], nums[i]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nThis is a greedy based solution, and not only does this ensure that averages are not met, it also ensures that any 3 element sequence is either a peak or valley. [big, small, big] or [small, big, small].\\n\\nProof: Any numbers mentioned here refer to the rank of an element rather than the actual number. So imagine a 3 element sequence of numbers which is sorted [2,3,4], we will disturb such sorting by creating a peak.. [2,4,3], now chances are that we get a number smaller than 3 in the next go.. imagine we get 1. Then the 3 element sequence [4,3,1] is sorted, we convert this into a valley [4,1,3]. Here we would be worried that swapping out that 3 would disturb the peak created earlier, but on careful observation we see that any such swap will make the slopes of the peak/valley even steeper and that is not an issue.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for(int i=2;i<nums.size();i++) {\\n            if((nums[i-2]<nums[i-1] && nums[i-1]<nums[i]) || (nums[i-2]>nums[i-1] && nums[i-1]>nums[i])) {\\n                swap(nums[i-1], nums[i]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404868,
                "title": "kotlin-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        nums.sort()\\n        val halfSize = (nums.size + 1) / 2\\n        return IntArray(nums.size) {\\n            if (it % 2 == 0) {\\n                nums[it / 2]\\n            } else {\\n                nums[halfSize + it / 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        nums.sort()\\n        val halfSize = (nums.size + 1) / 2\\n        return IntArray(nums.size) {\\n            if (it % 2 == 0) {\\n                nums[it / 2]\\n            } else {\\n                nums[halfSize + it / 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404422,
                "title": "c-sorting-explaination",
                "content": "Suppose that a<b and not exist c ( a<c<b)\\n--> (a+b)/2 != c . This is the main idea \\n\\nThere are 2 steps to implement\\n1. sort array\\n2. insert the second half of the sorted array  into the first half\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(nums.size());\\n        int n = nums.size();\\n        int j = 0;\\n        for(int i = 0; i < (n+1)/2; i++) {\\n            ans[j] = nums[i];\\n            j+=2;\\n        }\\n        j = 1;\\n        for(int i = (n+1)/2; i < n; i++) {\\n            ans[j] = nums[i];\\n            j+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(nums.size());\\n        int n = nums.size();\\n        int j = 0;\\n        for(int i = 0; i < (n+1)/2; i++) {\\n            ans[j] = nums[i];\\n            j+=2;\\n        }\\n        j = 1;\\n        for(int i = (n+1)/2; i < n; i++) {\\n            ans[j] = nums[i];\\n            j+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404200,
                "title": "java-sort-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int arr[]=new int[nums.length];\\n        int i=0;\\n        int k=0;\\n        int j=nums.length-1;\\n        while(i<nums.length){\\n            if(i%2==1){\\n                arr[i]=nums[j];\\n                j--;\\n            }\\n            else{\\n                arr[i]=nums[k];\\n                k++;\\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int arr[]=new int[nums.length];\\n        int i=0;\\n        int k=0;\\n        int j=nums.length-1;\\n        while(i<nums.length){\\n            if(i%2==1){\\n                arr[i]=nums[j];\\n                j--;\\n            }\\n            else{\\n                arr[i]=nums[k];\\n                k++;\\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404184,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(0,len(nums)-1,2):\\n            nums[i],nums[i+1]=nums[i+1],nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(0,len(nums)-1,2):\\n            nums[i],nums[i+1]=nums[i+1],nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404140,
                "title": "my-initially-wrong-approach-and-the-corrected-version",
                "content": "The below solution failed the 220th testcase alone. \\nWhat was the problem? \\nWhen nums was [0,1,2,3,4] the output was [0,2,1,3,4= ] works fine. \\nBut when nums = [0,1,2,3,4,5] the output was [0,2,1,3,5,4]. See there again occurs a conflict -> (1+5/2) = 3\\nHence repeat the swap operation again. After that nums = [0,2,1,5,3,4]\\n**WRONG APPROACH**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            if(avg == double(nums[i])) \\n                swap(nums[i] , nums[i+1]); \\n        }\\n        return nums; \\n    }\\n};\\n```\\n**CORRECT APPROACH**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            cout<<nums[i]<<\" \"<<avg<<\"\\\\n\";\\n            if(avg == double(nums[i])) {\\n                swap(nums[i] , nums[i+1]);              \\n            }\\n        }\\n       for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            if(avg == double(nums[i])) \\n                swap(nums[i] , nums[i+1]);              \\n        }   \\n        \\n        for(int i=0;i<nums.size();i++)\\n            cout<<nums[i]<<\" \";\\n        \\n        return nums; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            if(avg == double(nums[i])) \\n                swap(nums[i] , nums[i+1]); \\n        }\\n        return nums; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            cout<<nums[i]<<\" \"<<avg<<\"\\\\n\";\\n            if(avg == double(nums[i])) {\\n                swap(nums[i] , nums[i+1]);              \\n            }\\n        }\\n       for(int i=1;i<n-1;i++){\\n            double avg = (nums[i-1]+nums[i+1])/2;\\n            if(avg == double(nums[i])) \\n                swap(nums[i] , nums[i+1]);              \\n        }   \\n        \\n        for(int i=0;i<nums.size();i++)\\n            cout<<nums[i]<<\" \";\\n        \\n        return nums; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1404118,
                "title": "python-straightforward-solution",
                "content": "1. First sort the list, for num on odd indices, switch it with the next one element.\\n2.  By doing this way, we have a_i > a_(i-1), a_i > a_(i+1), therefore a_i > (a_(i-1) + a_(i+1))/2 for all odd indices and a_i < (a_(i-1) + a_(i+1))/2 for all even indices. \\n\\n```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        for i in range(1, len(nums), 2):\\n            if i != len(nums)-1:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n            \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        for i in range(1, len(nums), 2):\\n            if i != len(nums)-1:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404109,
                "title": "c-4-lines",
                "content": "```\\n\\n```public:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i;\\n        for(i=0;i<nums.size()-1;i=i+2)\\n        {\\n            swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404098,
                "title": "java-random-shuffle",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] array) {\\n        while(true) {\\n            int index = 0;\\n            Random random = new Random();\\n            for (int i = array.length - 1; i > 0; i--)\\n            {\\n                index = random.nextInt(i + 1);\\n                if (index != i)\\n                {\\n                    array[index] ^= array[i];\\n                    array[i] ^= array[index];\\n                    array[index] ^= array[i];\\n                }\\n            }\\n            boolean flag = true;\\n            for (int i = 0; i + 2 < array.length; i++) {\\n                if (array[i + 1] * 2 == array[i] + array[i + 2]) {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if (flag) return array;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] array) {\\n        while(true) {\\n            int index = 0;\\n            Random random = new Random();\\n            for (int i = array.length - 1; i > 0; i--)\\n            {\\n                index = random.nextInt(i + 1);\\n                if (index != i)\\n                {\\n                    array[index] ^= array[i];\\n                    array[i] ^= array[index];\\n                    array[index] ^= array[i];\\n                }\\n            }\\n            boolean flag = true;\\n            for (int i = 0; i + 2 < array.length; i++) {\\n                if (array[i + 1] * 2 == array[i] + array[i + 2]) {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if (flag) return array;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404040,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(nums.size())/2;\\n        int k=0;\\n        vector<int>ans(nums.size());\\n        while(i<(nums.size())/2 && j<nums.size())\\n        {\\n            ans[k]=nums[j];\\n            ans[k+1]=nums[i];\\n            j++;\\n            k+=2;\\n            i++;\\n        }\\n        if(nums.size()%2==1)\\n        {\\n            ans[nums.size()-1]=nums[nums.size()-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=(nums.size())/2;\\n        int k=0;\\n        vector<int>ans(nums.size());\\n        while(i<(nums.size())/2 && j<nums.size())\\n        {\\n            ans[k]=nums[j];\\n            ans[k+1]=nums[i];\\n            j++;\\n            k+=2;\\n            i++;\\n        }\\n        if(nums.size()%2==1)\\n        {\\n            ans[nums.size()-1]=nums[nums.size()-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404029,
                "title": "around-8-10-lines-java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);                          //sort the array\\n        ArrayList<Integer> aux = new ArrayList<>();              \\n        for(int i = 0; i < n; i++) {\\n            aux.add(nums[i]);                      // add nums to new aux array\\n        }\\n        int j = 0, k = 0, flag = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(flag == 0) {\\n                nums[i] = aux.get(j);            // add back aux to nums array in alternate acending order element.\\n                j++;\\n                flag = 1;\\n            }else {\\n                nums[i] = aux.get(n - 1- k);    // add back aux to nums array in alternate decending order element.\\n                k++;\\n                flag = 0;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);                          //sort the array\\n        ArrayList<Integer> aux = new ArrayList<>();              \\n        for(int i = 0; i < n; i++) {\\n            aux.add(nums[i]);                      // add nums to new aux array\\n        }\\n        int j = 0, k = 0, flag = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(flag == 0) {\\n                nums[i] = aux.get(j);            // add back aux to nums array in alternate acending order element.\\n                j++;\\n                flag = 1;\\n            }else {\\n                nums[i] = aux.get(n - 1- k);    // add back aux to nums array in alternate decending order element.\\n                k++;\\n                flag = 0;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404026,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "\\n\\nvoid swap(vector<int>&nums,int i,int j)\\n{\\n        \\n\\t\\tint temp=nums[j];\\n        nums[j]=nums[i];\\n        nums[i]=temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        int i=1;\\n         while(i<nums.size()-1)\\n         {\\n             int sum=nums[i-1]+nums[i+1];\\n             if(sum%2==0 && nums[i]==sum/2)\\n             {\\n                 swap(nums,i,i+1);\\n                 if(i>1)\\n                 {\\n                     i=i-1;\\n                 }\\n             }\\n             else\\n             {\\n                 i=i+1;\\n             }\\n         }\\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "\\n\\nvoid swap(vector<int>&nums,int i,int j)\\n{\\n        \\n\\t\\tint temp=nums[j];\\n        nums[j]=nums[i];\\n        nums[i]=temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        int i=1;\\n         while(i<nums.size()-1)\\n         {\\n             int sum=nums[i-1]+nums[i+1];\\n             if(sum%2==0 && nums[i]==sum/2)\\n             {\\n                 swap(nums,i,i+1);\\n                 if(i>1)\\n                 {\\n                     i=i-1;\\n                 }\\n             }\\n             else\\n             {\\n                 i=i+1;\\n             }\\n         }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1404009,
                "title": "c-1968-array-with-elements-not-equal-to-average-of-neighbors",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for (int i = 1; i < nums.size()-1; ++i) \\n            if ((nums[i-1] < nums[i] && nums[i] < nums[i+1]) || (nums[i-1] > nums[i] && nums[i] > nums[i+1])) \\n                swap(nums[i], nums[i+1]); \\n        return nums; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for (int i = 1; i < nums.size()-1; ++i) \\n            if ((nums[i-1] < nums[i] && nums[i] < nums[i+1]) || (nums[i-1] > nums[i] && nums[i] > nums[i+1])) \\n                swap(nums[i], nums[i+1]); \\n        return nums; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403992,
                "title": "java-solution",
                "content": "```\\npublic int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] result = new int[nums.length];\\n        for(int i = 0; i<nums.length-1; i+=2){\\n            result[i] = nums[i+1];\\n        }\\n        \\n        for(int i = 1; i<nums.length; i+=2){\\n            result[i] = nums[i-1];\\n        }\\n        \\n        if(nums.length%2 != 0){\\n            result[nums.length-1] = nums[nums.length-1];\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] result = new int[nums.length];\\n        for(int i = 0; i<nums.length-1; i+=2){\\n            result[i] = nums[i+1];\\n        }\\n        \\n        for(int i = 1; i<nums.length; i+=2){\\n            result[i] = nums[i-1];\\n        }\\n        \\n        if(nums.length%2 != 0){\\n            result[nums.length-1] = nums[nums.length-1];\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403944,
                "title": "java-create-wiggle-array",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int i : nums) {\\n            pq.add(i);\\n        }\\n        for (int i = 0; i < nums.length; i += 2) {\\n            res[i] = pq.poll();\\n        }\\n        for (int i = 1; i < nums.length; i += 2) {\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int i : nums) {\\n            pq.add(i);\\n        }\\n        for (int i = 0; i < nums.length; i += 2) {\\n            res[i] = pq.poll();\\n        }\\n        for (int i = 1; i < nums.length; i += 2) {\\n            res[i] = pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403923,
                "title": "python3-wave-sort",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # make every element either greater or less than its neighbors\\n        # to do that we just need to swap every pair of elements in sorted array\\n        # [1, 2, 3, 4, 5] => (1 <=> 2; 3 <=> 4) => [2, 1, 4, 3, 5] \\n        nums.sort()\\n        for i in range(1, len(nums), 2):\\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # make every element either greater or less than its neighbors\\n        # to do that we just need to swap every pair of elements in sorted array\\n        # [1, 2, 3, 4, 5] => (1 <=> 2; 3 <=> 4) => [2, 1, 4, 3, 5] \\n        nums.sort()\\n        for i in range(1, len(nums), 2):\\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403918,
                "title": "c-mathematical-explanation-sorting-easy-approach",
                "content": "```\\nExplanation : Sort the complete vector. Now place the alternate numbers from the sorted vector sequentially in the new vector.\\n\\nThe intution behind the approach is : \\n\\navg(a,b) <= max(a,b)\\n\\nSo if we place the elements alternatively, we are sure that we are placing the larger element between two smaller elements and hence, the answer !!!\\n\\nPlease upvote if you like the approach. Discussions are always welcome :-)\\n\\n\\n/**\\n * @author      : archit\\n * @GitHub      : archit-1997\\n * @Email       : architsingh456@gmail.com\\n * @file        : arrayWithElementsNotEqualToAverageOfNeighbours.cpp\\n * @created     : Sunday Aug 15, 2021 08:14:32 IST\\n */\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n);\\n        sort(nums.begin(),nums.end());\\n        //fill the even indices first\\n        int index=0;\\n        for(int i=0;i<n;i+=2)\\n            ans[i]=nums[index++];\\n        //now fill the odd indices\\n        for(int i=1;i<n;i+=2)\\n            ans[i]=nums[index++];\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nExplanation : Sort the complete vector. Now place the alternate numbers from the sorted vector sequentially in the new vector.\\n\\nThe intution behind the approach is : \\n\\navg(a,b) <= max(a,b)\\n\\nSo if we place the elements alternatively, we are sure that we are placing the larger element between two smaller elements and hence, the answer !!!\\n\\nPlease upvote if you like the approach. Discussions are always welcome :-)\\n\\n\\n/**\\n * @author      : archit\\n * @GitHub      : archit-1997\\n * @Email       : architsingh456@gmail.com\\n * @file        : arrayWithElementsNotEqualToAverageOfNeighbours.cpp\\n * @created     : Sunday Aug 15, 2021 08:14:32 IST\\n */\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n);\\n        sort(nums.begin(),nums.end());\\n        //fill the even indices first\\n        int index=0;\\n        for(int i=0;i<n;i+=2)\\n            ans[i]=nums[index++];\\n        //now fill the odd indices\\n        for(int i=1;i<n;i+=2)\\n            ans[i]=nums[index++];\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4097755,
                "title": "python-two-pointers-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # Time --> O(n)\\n        # Space --> O(1) as output as is not counted\\n\\n        # Logic:\\n        # First, sort the list, then use two-pointer concept, keep two pointers, left and right.\\n        # left = 0 and right = len(nums)-1\\n        # Place the elements alternatively, so that the output array will have elements of left and right alternatively\\n        # With this, the average of two consecutive left elements can\\'t be equals to the right element.\\n\\n\\n        nums.sort() # sort the list\\n        left,right = 0, len(nums)-1 # using two pointers\\n        result = [] # output list\\n        while left <= right:\\n            # if left pointer == right pointer, then only append once\\n            if left == right:\\n                result.append(nums[left])\\n                left += 1\\n                right -= 1\\n            else:\\n                # else append left and right in this order and shift the pointers\\n                result.append(nums[left])\\n                left += 1\\n                result.append(nums[right])\\n                right -= 1\\n        return result # returning the result\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # Time --> O(n)\\n        # Space --> O(1) as output as is not counted\\n\\n        # Logic:\\n        # First, sort the list, then use two-pointer concept, keep two pointers, left and right.\\n        # left = 0 and right = len(nums)-1\\n        # Place the elements alternatively, so that the output array will have elements of left and right alternatively\\n        # With this, the average of two consecutive left elements can\\'t be equals to the right element.\\n\\n\\n        nums.sort() # sort the list\\n        left,right = 0, len(nums)-1 # using two pointers\\n        result = [] # output list\\n        while left <= right:\\n            # if left pointer == right pointer, then only append once\\n            if left == right:\\n                result.append(nums[left])\\n                left += 1\\n                right -= 1\\n            else:\\n                # else append left and right in this order and shift the pointers\\n                result.append(nums[left])\\n                left += 1\\n                result.append(nums[right])\\n                right -= 1\\n        return result # returning the result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088675,
                "title": "java-91-faster-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        while (!isCorrect(nums)) {\\n            for (int i = 1; i < nums.length - 1; i++) {\\n                if (nums[i] == (nums[i - 1] + nums[i + 1]) / 2.0) {\\n                    int t = nums[i];\\n                    nums[i] = nums[i - 1];\\n                    nums[i - 1] = t;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n\\n    private boolean isCorrect(int[] nums) {\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (nums[i] == (nums[i - 1] + nums[i + 1]) / 2.0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        while (!isCorrect(nums)) {\\n            for (int i = 1; i < nums.length - 1; i++) {\\n                if (nums[i] == (nums[i - 1] + nums[i + 1]) / 2.0) {\\n                    int t = nums[i];\\n                    nums[i] = nums[i - 1];\\n                    nums[i - 1] = t;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n\\n    private boolean isCorrect(int[] nums) {\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (nums[i] == (nums[i - 1] + nums[i + 1]) / 2.0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069718,
                "title": "wiggle-sort-linear-time-constant-space-fast-c-solution-easy",
                "content": "Wiggle sort is a problem where arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= \\u2026..\\n```\\nclass Solution {\\n   public:\\n    vector<int> rearrangeArray(vector<int>& nums)\\n    {\\n\\t\\t// # solution to wiggle sort will work here\\n        // # as the numbers are distinct and average\\n        // # of 2 smaller or 2 larger ints than x\\n        // # cannot be equal to x\\n        // * O(n) time O(1) space\\n        for (int i = 0; i < size(nums); i += 2) {\\n            if (i > 0 and nums[i - 1] > nums[i])\\n                swap(nums[i], nums[i - 1]);\\n            if (i < size(nums) - 1 and nums[i] < nums[i + 1])\\n                swap(nums[i], nums[i + 1]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    vector<int> rearrangeArray(vector<int>& nums)\\n    {\\n\\t\\t// # solution to wiggle sort will work here\\n        // # as the numbers are distinct and average\\n        // # of 2 smaller or 2 larger ints than x\\n        // # cannot be equal to x\\n        // * O(n) time O(1) space\\n        for (int i = 0; i < size(nums); i += 2) {\\n            if (i > 0 and nums[i - 1] > nums[i])\\n                swap(nums[i], nums[i - 1]);\\n            if (i < size(nums) - 1 and nums[i] < nums[i + 1])\\n                swap(nums[i], nums[i + 1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062765,
                "title": "clean-and-simple-o-n-and-o-1-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        #Time - O(N) and space - O(1)\\n        # This is in place replacement\\n        # Step 1: Even place i has to be less than i-1\\n        # Step 2: odd place i has to be greater than i-1\\n        # Step 1 and 2 can be interchanged\\n        for i in range(len(nums)):\\n            if i%2:\\n                if nums[i]>nums[i-1]:\\n                    nums[i], nums[i-1] = nums[i-1], nums[i]\\n            else:\\n                if nums[i]<nums[i-1]:\\n                    nums[i], nums[i-1] = nums[i-1], nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        #Time - O(N) and space - O(1)\\n        # This is in place replacement\\n        # Step 1: Even place i has to be less than i-1\\n        # Step 2: odd place i has to be greater than i-1\\n        # Step 1 and 2 can be interchanged\\n        for i in range(len(nums)):\\n            if i%2:\\n                if nums[i]>nums[i-1]:\\n                    nums[i], nums[i-1] = nums[i-1], nums[i]\\n            else:\\n                if nums[i]<nums[i-1]:\\n                    nums[i], nums[i-1] = nums[i-1], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041144,
                "title": "rearrange-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int temp;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]==(nums[i-1]+nums[i+1])/2){\\n               temp=nums[i];\\n               nums[i]=nums[i+1];\\n               nums[i+1]=temp;\\n               if(i>=2)\\n               i=i-2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int temp;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]==(nums[i-1]+nums[i+1])/2){\\n               temp=nums[i];\\n               nums[i]=nums[i+1];\\n               nums[i+1]=temp;\\n               if(i>=2)\\n               i=i-2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036375,
                "title": "just-follow-the-hint-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin() , nums.end());\\n\\n        int mid = nums.size()/2;\\n        queue<int>q1;\\n        for(int i=0;i<mid;i++)\\n        {\\n            q1.push(nums[i]);\\n        }    \\n        queue<int>q2;\\n        for(int i = nums.size()-1 ; i >=0 ; i--)\\n        {\\n            q2.push(nums[i]);\\n        }\\n\\n        int idx = 0;\\n        bool flag = true;\\n        while(idx < nums.size())\\n        {\\n            if(flag == true)\\n            {\\n                if(q1.size() > 0)\\n                {\\n                  nums[idx] = q1.front();\\n                  q1.pop();\\n                }\\n                else if(q2.size() > 0)\\n                {\\n                    nums[idx] = q2.front();\\n                    q2.pop();\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(q2.size() > 0)\\n                {\\n                  nums[idx] = q2.front();\\n                  q2.pop();\\n                }\\n                else if(q1.size() > 0)\\n                {\\n                    nums[idx] = q1.front();\\n                    q1.pop();\\n                }\\n            }\\n            idx++;\\n            flag = !flag;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin() , nums.end());\\n\\n        int mid = nums.size()/2;\\n        queue<int>q1;\\n        for(int i=0;i<mid;i++)\\n        {\\n            q1.push(nums[i]);\\n        }    \\n        queue<int>q2;\\n        for(int i = nums.size()-1 ; i >=0 ; i--)\\n        {\\n            q2.push(nums[i]);\\n        }\\n\\n        int idx = 0;\\n        bool flag = true;\\n        while(idx < nums.size())\\n        {\\n            if(flag == true)\\n            {\\n                if(q1.size() > 0)\\n                {\\n                  nums[idx] = q1.front();\\n                  q1.pop();\\n                }\\n                else if(q2.size() > 0)\\n                {\\n                    nums[idx] = q2.front();\\n                    q2.pop();\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(q2.size() > 0)\\n                {\\n                  nums[idx] = q2.front();\\n                  q2.pop();\\n                }\\n                else if(q1.size() > 0)\\n                {\\n                    nums[idx] = q1.front();\\n                    q1.pop();\\n                }\\n            }\\n            idx++;\\n            flag = !flag;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023630,
                "title": "python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        # swap adjacent elements\\n        for i in range(1, len(nums) - 1, 2):\\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n\\n\\n        return nums\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        # swap adjacent elements\\n        for i in range(1, len(nums) - 1, 2):\\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n\\n\\n        return nums\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023278,
                "title": "runtime-beats-96-02-and-memory-beats-91-34-easy-to-understand-solution-time-o-n-space-o-1",
                "content": "# Intuition\\nStart scanning from the left, swap the invalid triplets and then check the triplet just before the currently swapped.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize two pointers, i and j, to traverse the nums vector and track positions to potentially rearrange elements.\\n\\nIterate through nums, and for each element nums[i], calculate the expected value a as the average of its adjacent elements nums[i-1] and nums[i+1].\\n\\nIf nums[i] matches a and there\\'s an element nums[j] further in the array that doesn\\'t match a, swap nums[i] and nums[j] to rearrange. Reset j to the end of the array, and continue checking.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n->The main loop iterates through the elements of the input vector nums.\\n->Inside the loop, there are some basic arithmetic operations (addition and division), conditional statements, and swaps.\\n->The while loop continues until i becomes greater than or equal to nums.size() - 1.\\n\\nSince the main loop iterates through the elements of nums, and each iteration involves constant time operations, the overall time complexity of the code is **O(n)**\\n\\n- Space complexity:\\nThe space complexity of this code is primarily determined by the input vector nums, as the code performs in-place rearrangement and does not use any additional data structures that scale with the input size. Therefore, the space complexity is **O(1)**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 1;\\n        int j = nums.size()- 1;\\n        while(i<nums.size()-1){\\n            int a = (nums[i-1]+nums[i+1])/2;\\n            if(nums[i] == a & j>i){\\n                if(nums[j]!=a){\\n                    int temp = nums[j];\\n                    nums[j]=nums[i];\\n                    nums[i]=temp;\\n                    j = nums.size()-1;\\n                    i = i>1?i-1:i;\\n                }else{\\n                    j--;\\n                }\\n            }else{\\n                i++;\\n            }\\n        }return nums;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 1;\\n        int j = nums.size()- 1;\\n        while(i<nums.size()-1){\\n            int a = (nums[i-1]+nums[i+1])/2;\\n            if(nums[i] == a & j>i){\\n                if(nums[j]!=a){\\n                    int temp = nums[j];\\n                    nums[j]=nums[i];\\n                    nums[i]=temp;\\n                    j = nums.size()-1;\\n                    i = i>1?i-1:i;\\n                }else{\\n                    j--;\\n                }\\n            }else{\\n                i++;\\n            }\\n        }return nums;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937319,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func rearrangeArray(_ nums: [Int]) -> [Int] {\\n        var ans = [Int]()\\n        var sortedNums = nums.sorted {\\n            $0 < $1\\n        }\\n        let numsLength = nums.count\\n\\n        var start = 0\\n        var end = numsLength - 1\\n\\n        while start <= end {\\n            if start == end {\\n                ans.append(sortedNums[start])\\n                break\\n            }\\n\\n            ans.append(sortedNums[start])\\n            ans.append(sortedNums[end])\\n            start = start + 1\\n            end = end - 1\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rearrangeArray(_ nums: [Int]) -> [Int] {\\n        var ans = [Int]()\\n        var sortedNums = nums.sorted {\\n            $0 < $1\\n        }\\n        let numsLength = nums.count\\n\\n        var start = 0\\n        var end = numsLength - 1\\n\\n        while start <= end {\\n            if start == end {\\n                ans.append(sortedNums[start])\\n                break\\n            }\\n\\n            ans.append(sortedNums[start])\\n            ans.append(sortedNums[end])\\n            start = start + 1\\n            end = end - 1\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921830,
                "title": "easy-python-solution-memory-time-100",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        n=len(nums)\\n        for i in range(1,n-1):\\n            if(nums[i-1]<nums[i]<nums[i+1] or nums[i-1]>nums[i]>nums[i+1]):\\n                nums[i],nums[i+1]=nums[i+1],nums[i]\\n        return nums\\n```\\nPLEASE UPVOTE :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        n=len(nums)\\n        for i in range(1,n-1):\\n            if(nums[i-1]<nums[i]<nums[i+1] or nums[i-1]>nums[i]>nums[i+1]):\\n                nums[i],nums[i+1]=nums[i+1],nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907513,
                "title": "o-n-solution-by-just-swaping-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif 2 * a[i] = a[i-1] + a[i+1]\\nthen swaping i with i+1 can solve the situation because\\n 2*[i+1] != a[i-1] + a[i]\\n\\nthen when swaped might change swapped done before so decrement your i by 1 and change if swaping here caused any disturbance behind.\\nelse increment i \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nsingle pass;\\ni decrements only if 2 continuous swaps\\nfaster than 92% solutions.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for(int i = 1 ; i <nums.size()-1 ;){\\n            if(2*nums[i] == nums[i-1]+nums[i+1]){\\n                swap(nums[i],nums[i+1]);\\n                if(i>1) i-- ;\\n                else i++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        for(int i = 1 ; i <nums.size()-1 ;){\\n            if(2*nums[i] == nums[i-1]+nums[i+1]){\\n                swap(nums[i],nums[i+1]);\\n                if(i>1) i-- ;\\n                else i++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871820,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFIrstly sorting the list and then creating a new list as res[] , and keep appending numbers from the nums list using two pointers l(left) = 0 and r(right) = len(nums)-1 , where we keep appending elements sequentially, from left and then from right keeping a condition of l<=r, to stop the operation from going out of bound.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\nRuntime Beats 92.16%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nMemory Beats 53.55%\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n\\n        l , r = 0 , len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l+=1\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n\\n        l , r = 0 , len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l+=1\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855419,
                "title": "array-with-elements-not-equal-to-average-of-neighbors-c-explained-solution-100-faster",
                "content": "**Upvote If Found Helpful !!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is very easy and you just need to simulate the process in the problem. But how do we do this simulation. We will do 2 passes on complete array. First from left to right, then from right to left. When from left to right, check if for any index **i**, the condition is being violated. In such case, just swap **nums[i]** and **nums[i+1]**. Now we have arranged this properly from left to right but it might be possible to create some new discrepancies behind. To remove them, we do another pass from right to left and whenever condition is violated, we just swap **nums[i]** and **nums[i-1]**. The implementation of the above approach goes below : \\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size();\\n        for(int i = 1; i < n-1; i++){\\n            if((nums[i-1]+nums[i+1]) % 2 == 0){\\n                if((nums[i-1]+nums[i+1]) / 2 == nums[i]){\\n                    swap(nums[i],nums[i+1]);\\n                }\\n            }\\n        }\\n        for(int i = n-2; i > 0; i--){\\n            if((nums[i-1]+nums[i+1]) % 2 == 0){\\n                if((nums[i-1]+nums[i+1]) / 2 == nums[i]){\\n                    swap(nums[i],nums[i-1]);\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n![Screenshot from 2023-08-03 04-54-15.png](https://assets.leetcode.com/users/images/28190150-9a6c-4edd-8c78-8a4d80c1668e_1691018661.2456274.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size();\\n        for(int i = 1; i < n-1; i++){\\n            if((nums[i-1]+nums[i+1]) % 2 == 0){\\n                if((nums[i-1]+nums[i+1]) / 2 == nums[i]){\\n                    swap(nums[i],nums[i+1]);\\n                }\\n            }\\n        }\\n        for(int i = n-2; i > 0; i--){\\n            if((nums[i-1]+nums[i+1]) % 2 == 0){\\n                if((nums[i-1]+nums[i+1]) / 2 == nums[i]){\\n                    swap(nums[i],nums[i-1]);\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854696,
                "title": "easy-java-sol-using-sorting-and-swapping-of-elements-in-place",
                "content": "# Intuition\\nDistort the sorted array. \\n\\n# Approach\\n1. Sort the array. \\n2. Swap the elements and increase the i by i+2.\\n3. Return the array\\n\\n# Complexity\\n- Time complexity:\\nTC - O(nlogn) + O(n)\\n\\n- Space complexity:\\nTC - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<n; i+=2){\\n\\n            if(i+1<n){\\n                int temp = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = temp;\\n            }\\n        }\\n\\n        return nums;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<n; i+=2){\\n\\n            if(i+1<n){\\n                int temp = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = temp;\\n            }\\n        }\\n\\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827124,
                "title": "python-o-nlogn-solution-in-place",
                "content": "\\n# Approach\\n- We first transform the list to get the highest chances of elements being neighbors\\' average. Sorting the list helps achieve this probability\\n- We take the numbers in pairs and swap the elements until the end of the list\\nNOTE: We swap regardless of whether the element is the average of its neighbors\\n\\n**Rationale:**\\n- Any number at an odd index `i` was originally at an even index `i-1` before the swap, and since the list is sorted, it is guaranteed to be smaller than its neighbors at indices `i-1` and `i+1`. Thus, it cannot be equal to the average of its neighbors, which would be larger\\n\\n- Similarly, any number at an even index `i` was originally at an odd index `i+1` before the swap, and since the array is sorted, it is guaranteed to be larger than its neighbors at indices `i-1` and `i+1`. Thus, it cannot be equal to the average of its neighbors, which would be smaller\\n\\n \\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(0, len(nums)-1, 2):\\n            nums[i], nums[i+1] = nums[i+1], nums[i]\\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(0, len(nums)-1, 2):\\n            nums[i], nums[i+1] = nums[i+1], nums[i]\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782457,
                "title": "o-n-log-n-solution-with-reasoning",
                "content": "# Approach\\nAn average of two distinct numbers is always greater than the minimum of the two numbers and less than the maximum of the two numbers i.e. it sits exactly in the middle of the two numbers. Therefore to avoid the neighbors of an element resulting in tht element being the average we need to make those neighbors either both larger than the element or both smaller than the element. By sorting `nums` we can build up the `rearranged` array by alternating whether we select a larger or smaller element to place at a given index so ensuring that each elements neighbors will either both be larger or both be smaller i.e. `[large, small, large, small, large, small]`.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) where n is the number of elements in `nums`\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func rearrangeArray(_ nums: [Int]) -> [Int] {\\n        let nums = nums.sorted()\\n        \\n        var rearranged = [Int]()\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        \\n        for i in 0..<nums.count {\\n            let num: Int\\n            if i % 2 == 0 {\\n                num = nums[left]\\n                left += 1\\n            } else {\\n                num = nums[right]\\n                right -= 1\\n            }\\n            \\n            rearranged.append(num)\\n        }\\n        \\n        return rearranged\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rearrangeArray(_ nums: [Int]) -> [Int] {\\n        let nums = nums.sorted()\\n        \\n        var rearranged = [Int]()\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        \\n        for i in 0..<nums.count {\\n            let num: Int\\n            if i % 2 == 0 {\\n                num = nums[left]\\n                left += 1\\n            } else {\\n                num = nums[right]\\n                right -= 1\\n            }\\n            \\n            rearranged.append(num)\\n        }\\n        \\n        return rearranged\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778004,
                "title": "python-3-solution-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        l = len(nums)\\n        i = 0\\n        j = l // 2 if l % 2 == 0 else (l // 2) + 1\\n\\n        arr = [None] * l\\n        k = 0\\n\\n        while k < l:\\n            arr[k] = nums[i]\\n\\n            if k + 1 < l:\\n                arr[k + 1] = nums[j]\\n\\n            i += 1\\n            j += 1\\n            k += 2\\n\\n\\n        return arr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        l = len(nums)\\n        i = 0\\n        j = l // 2 if l % 2 == 0 else (l // 2) + 1\\n\\n        arr = [None] * l\\n        k = 0\\n\\n        while k < l:\\n            arr[k] = nums[i]\\n\\n            if k + 1 < l:\\n                arr[k + 1] = nums[j]\\n\\n            i += 1\\n            j += 1\\n            k += 2\\n\\n\\n        return arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766302,
                "title": "use-wiggle-sort",
                "content": "# Intuition\\nI had no intuition just saw a discussion post saying wiggle sort and i used it. ended up getting a solution beating 90% of solutions.\\n\\n# Approach\\nUSE WIGGLE SORT\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        nums.sort()\\n\\n        for i in range(1,len(nums)-1,2):\\n            nums[i],nums[i+1]=nums[i+1],nums[i]\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rearrangeArray(self, nums):\\n        nums.sort()\\n\\n        for i in range(1,len(nums)-1,2):\\n            nums[i],nums[i+1]=nums[i+1],nums[i]\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756899,
                "title": "c-o-nlogn-just-wiggle-sort-the-input-array",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n=nums.size(), i=0, k=0;\\n        auto it=nums.begin();\\n        while(i++<n/2) it++;\\n        vector<int> a= {it, nums.end()};\\n        vector<int> b= {nums.begin(), it};\\n        i=0;\\n        while(i<a.size() && i<b.size()) {\\n            nums[k++]=a[i];\\n            nums[k++]=b[i];\\n            i++;\\n        }\\n        while(i<a.size()) {\\n            nums[k++]=a[i];\\n            i++;\\n        }\\n        while(i<b.size()) {\\n            nums[k++]=b[i];\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n=nums.size(), i=0, k=0;\\n        auto it=nums.begin();\\n        while(i++<n/2) it++;\\n        vector<int> a= {it, nums.end()};\\n        vector<int> b= {nums.begin(), it};\\n        i=0;\\n        while(i<a.size() && i<b.size()) {\\n            nums[k++]=a[i];\\n            nums[k++]=b[i];\\n            i++;\\n        }\\n        while(i<a.size()) {\\n            nums[k++]=a[i];\\n            i++;\\n        }\\n        while(i<b.size()) {\\n            nums[k++]=b[i];\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754327,
                "title": "c-most-easies-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754325,
                "title": "c-most-easies-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754323,
                "title": "c-most-easies-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < nums.size() - 1; i += 2) {\\n            swap(nums[i], nums[i + 1]);\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751174,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAverage of two numbers lies in between those two numbers. So sort the array and alternately swap numbers so that a number is either greater than or equal to or lesser than equal both of its neighbours. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i<nums.size()-1; i++)\\n        {\\n            if(i&1)\\n            {\\n                swap(nums[i], nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i<nums.size()-1; i++)\\n        {\\n            if(i&1)\\n            {\\n                swap(nums[i], nums[i+1]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735119,
                "title": "simple-solution-using-java",
                "content": "\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0, j=nums.length-1;\\n        int ans [] = new int [nums.length];\\n        for(int k=0; k<nums.length; k++){\\n            if(k%2 != 0)    ans[k] = nums[j--];\\n            else    ans[k] = nums[i++];\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0, j=nums.length-1;\\n        int ans [] = new int [nums.length];\\n        for(int k=0; k<nums.length; k++){\\n            if(k%2 != 0)    ans[k] = nums[j--];\\n            else    ans[k] = nums[i++];\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734091,
                "title": "python-medium-o-n",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        l, r = 1, N - 1\\n\\n\\n        while l < r:\\n            while (nums[l + 1] + nums[l - 1]) / 2 == nums[l]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n       \\n\\n            \\n            l += 1\\n\\n        l, r = 0, N - 2\\n\\n        while l < r:\\n            while (nums[r + 1] + nums[r - 1]) / 2 == nums[r]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n            \\n            r -= 1\\n\\n\\n        l, r = 1, N - 1\\n\\n\\n        while l < r:\\n            while (nums[l + 1] + nums[l - 1]) / 2 == nums[l]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n       \\n\\n            \\n            l += 1\\n\\n\\n\\n        return nums\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        l, r = 1, N - 1\\n\\n\\n        while l < r:\\n            while (nums[l + 1] + nums[l - 1]) / 2 == nums[l]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n       \\n\\n            \\n            l += 1\\n\\n        l, r = 0, N - 2\\n\\n        while l < r:\\n            while (nums[r + 1] + nums[r - 1]) / 2 == nums[r]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n            \\n            r -= 1\\n\\n\\n        l, r = 1, N - 1\\n\\n\\n        while l < r:\\n            while (nums[l + 1] + nums[l - 1]) / 2 == nums[l]:\\n                nums[l], nums[r] = nums[r], nums[l]\\n       \\n\\n            \\n            l += 1\\n\\n\\n\\n        return nums\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731461,
                "title": "easy-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: (nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       vector<int> ans;\\n       sort(nums.begin(),nums.end());\\n       int i = 0;\\n       int j = nums.size()-1;\\n\\n       while(i<=j)\\n       {\\n           ans.push_back(nums[i]);\\n           if(i!=j)\\n           ans.push_back(nums[j]);\\n           i++;\\n           j--;\\n\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       vector<int> ans;\\n       sort(nums.begin(),nums.end());\\n       int i = 0;\\n       int j = nums.size()-1;\\n\\n       while(i<=j)\\n       {\\n           ans.push_back(nums[i]);\\n           if(i!=j)\\n           ans.push_back(nums[j]);\\n           i++;\\n           j--;\\n\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715169,
                "title": "o-n-time-o-1-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn element nums[i] is the average of its neighbours (nums[i-1], nums[i+1]) if:\\n- nums[i-1] < nums[i] < nums[i+1]\\n- nums[i-1] > nums[i] > nums[i+1]\\n\\nTraverse the array and swap (nums[i], nums[i+1]) if you encounter any of the above cases.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- traverse the array starting from the second position. \\n    - if there\\'s an increasing sequence (nums[i-1] < nums[i] < nums[i+1]) or decreasing sequence (nums[i-1] > nums[i] > nums[i+1]), swap nums[i] and nums[i+1]\\n- return the array\\n\\n# Complexity\\n- Time complexity: O(traversal) \\u2192 O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums) - 1) :\\n            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]:\\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums) - 1) :\\n            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]:\\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702953,
                "title": "time-complexity-o-nlogn-space-complexity-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]: \\n        nums.sort()\\n        res = []\\n\\n        l,r = 0,len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l+=1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n        return res\\n\\n# time complexity -- O(NlogN)\\n# space complexity -- O(N)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]: \\n        nums.sort()\\n        res = []\\n\\n        l,r = 0,len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l+=1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n        return res\\n\\n# time complexity -- O(NlogN)\\n# space complexity -- O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696399,
                "title": "important-concept-c-implementation",
                "content": "**Approach: Try to Put the Elements smaller than the median of the array at the odd indices**\\nOne more useful observation :- Sort the array and iterate from i=0 to i<size at an interval of 1. The number of elements smaller than the median will be size of the array/2. \\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> res(n);\\n        int j=1;\\n        for(int i=0;i<n/2;i++){\\n            res[j]=nums[i];\\n            j+=2;\\n        }\\n        j=0;\\n        for(int i=n/2;i<n;i++){\\n            res[j]=nums[i];\\n            j+=2;\\n        }\\n        return res;\\n    }\\n};\\n```\\nCan be Further optimized as :-\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> res(n);\\n        int i=0;\\n        int j=0;\\n        for(;i<n && j<n;i++,j+=2)\\n            res[j]=nums[i];\\n        j=1;\\n        for(;i<n && j<n;i++,j+=2)\\n            res[j]=nums[i];\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> res(n);\\n        int j=1;\\n        for(int i=0;i<n/2;i++){\\n            res[j]=nums[i];\\n            j+=2;\\n        }\\n        j=0;\\n        for(int i=n/2;i<n;i++){\\n            res[j]=nums[i];\\n            j+=2;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> res(n);\\n        int i=0;\\n        int j=0;\\n        for(;i<n && j<n;i++,j+=2)\\n            res[j]=nums[i];\\n        j=1;\\n        for(;i<n && j<n;i++,j+=2)\\n            res[j]=nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695164,
                "title": "java-math-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        for(int i = 1;i<nums.length-1;i++){\\n            if(Math.min(nums[i-1], nums[i+1]) < nums[i] && Math.max(nums[i-1], nums[i+1]) > nums[i]){\\n                int temp = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        for(int i = 1;i<nums.length-1;i++){\\n            if(Math.min(nums[i-1], nums[i+1]) < nums[i] && Math.max(nums[i-1], nums[i+1]) > nums[i]){\\n                int temp = nums[i];\\n                nums[i] = nums[i+1];\\n                nums[i+1] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688106,
                "title": "c-constructive-algo",
                "content": "\\tvector<int> rearrangeArray(vector<int>& v) {\\n\\t\\tint n=v.size();\\n        \\n        vector<int> ret(n);\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int it = n-1;\\n        for(int i=0;i<n;i+=2){\\n            ret[i] = v[it]; it--; \\n        }\\n        \\n        for(int i=1;i<n;i+=2){\\n            ret[i] = v[it]; it--;\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "\\tvector<int> rearrangeArray(vector<int>& v) {\\n\\t\\tint n=v.size();\\n        \\n        vector<int> ret(n);\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int it = n-1;\\n        for(int i=0;i<n;i+=2){\\n            ret[i] = v[it]; it--; \\n        }\\n        \\n        for(int i=1;i<n;i+=2){\\n            ret[i] = v[it]; it--;\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3680322,
                "title": "c-easy-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nexample = [1,2,3,4,5];\\n1. Fisrt sort the nums array. \\n2. Make a vector \\'v\\' for storing the answer.\\n3. fill up v like [1,_ ,2, _,3]\\n4. now fill up greatest element like\\n5. [1,4,2,5,3] :- we got the answer :)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int>v(nums.size(), -1);\\n        sort(nums.begin(),nums.end());\\n        int s = 0;\\n        for(int i = 0; i < v.size(); i+=2)\\n        {\\n            v[i] = nums[s];\\n            s++;\\n        }\\n        for(int i = 1; i < v.size(); i+=2)\\n        {\\n            v[i] = nums[s];\\n            s++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int>v(nums.size(), -1);\\n        sort(nums.begin(),nums.end());\\n        int s = 0;\\n        for(int i = 0; i < v.size(); i+=2)\\n        {\\n            v[i] = nums[s];\\n            s++;\\n        }\\n        for(int i = 1; i < v.size(); i+=2)\\n        {\\n            v[i] = nums[s];\\n            s++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672016,
                "title": "c-swapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n    for(int i=1;i<nums.size()-1;i++){\\n        if((nums[i-1]<nums[i] and nums[i]<nums[i+1]) or (nums[i-1]>nums[i] and nums[i]>nums[i+1]))\\n        { swap(nums[i],nums[i+1]);}\\n    }   \\n    return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n    for(int i=1;i<nums.size()-1;i++){\\n        if((nums[i-1]<nums[i] and nums[i]<nums[i+1]) or (nums[i-1]>nums[i] and nums[i]>nums[i+1]))\\n        { swap(nums[i],nums[i+1]);}\\n    }   \\n    return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669138,
                "title": "wiggle-sort-simple-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n          for(int i = 1; i < nums.length; i++){\\n\\t\\t\\tif((i%2 == 1 && nums[i] < nums[i-1]) || (i%2 == 0 && nums[i] > nums[i-1])){\\n\\t\\t\\t\\tswap(nums, i, i-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nums;\\n    }\\n\\n\\t\\t  private static void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n          for(int i = 1; i < nums.length; i++){\\n\\t\\t\\tif((i%2 == 1 && nums[i] < nums[i-1]) || (i%2 == 0 && nums[i] > nums[i-1])){\\n\\t\\t\\t\\tswap(nums, i, i-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nums;\\n    }\\n\\n\\t\\t  private static void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667329,
                "title": "python-big-small-easy-solution",
                "content": "```py\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        # basically if left and right are greater or lower ur gucci.\\n        # so just do big,small,big,small,etc...\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        \\n        l,r = 0,n-1\\n        flag = True\\n        \\n        while len(res) != len(nums):\\n            if flag:\\n                res += [nums[l]]\\n                l+=1\\n            else:\\n                res += [nums[r]]\\n                r-=1\\n            \\n            flag = not flag\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        # basically if left and right are greater or lower ur gucci.\\n        # so just do big,small,big,small,etc...\\n        \\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        \\n        l,r = 0,n-1\\n        flag = True\\n        \\n        while len(res) != len(nums):\\n            if flag:\\n                res += [nums[l]]\\n                l+=1\\n            else:\\n                res += [nums[r]]\\n                r-=1\\n            \\n            flag = not flag\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638327,
                "title": "c-easy-using-sorting-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is my solution for the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            ans.push_back(nums[s++]);\\n            ans.push_back(nums[e--]);\\n        }\\n        if(nums.size()%2!=0){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            ans.push_back(nums[s++]);\\n            ans.push_back(nums[e--]);\\n        }\\n        if(nums.size()%2!=0){\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631583,
                "title": "easy-to-understand-java-solution-o-n-2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        int j =n-1;\\n        int k = 1;\\n        Arrays.sort(nums);\\n        int[] arr = new int[n];\\n        while(i <= n-1){\\n            arr[i] = nums[j];\\n            i += 2;\\n            j--;\\n        }\\n        i=0;\\n        while(k <= n-1){\\n            arr[k] = nums[i];\\n            k += 2;\\n            i++;\\n        }\\n        return arr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        int j =n-1;\\n        int k = 1;\\n        Arrays.sort(nums);\\n        int[] arr = new int[n];\\n        while(i <= n-1){\\n            arr[i] = nums[j];\\n            i += 2;\\n            j--;\\n        }\\n        i=0;\\n        while(k <= n-1){\\n            arr[k] = nums[i];\\n            k += 2;\\n            i++;\\n        }\\n        return arr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622569,
                "title": "break-monotonous-increase-decrease-among-i-1-i-i-1-time-o-n-space-o-1",
                "content": "class Solution(object):\\n    def rearrangeArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return nums\\n        \\n        for i in range(1,n-1):\\n            if nums[i-1] < nums[i] < nums[i+1]:\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n            elif nums[i-1] > nums[i] > nums[i+1]:\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n        \\n        return nums",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution(object):\\n    def rearrangeArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return nums\\n        \\n        for i in range(1,n-1):\\n            if nums[i-1] < nums[i] < nums[i+1]:\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n            elif nums[i-1] > nums[i] > nums[i+1]:\\n                nums[i+1], nums[i] = nums[i], nums[i+1]\\n        \\n        return nums",
                "codeTag": "Java"
            },
            {
                "id": 3602771,
                "title": "simplest-python-solution-ever",
                "content": "def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        1. do sort the array \\n        2. chnage the elem on odd postition with even postion why ?? lets take small example\\n        [10, 7 , 5 , 4 , 3]\\n        sort the array => [3,4,5,7,10]\\n        [_,x,_,x_] then swap every elem x with next elem to x \\n        [_,5,4,x,_]\\n        [_,5,4,10,7] => finally [3,5,4,10,7] by looking this we can say\\n        as its sorted its give you gaurntee that every for every elem x nebiours are less then to x that means always avg of nebours must be less then x \\n        \\'\\'\\'\\n        nums.sort()\\n        for i in range(1, len(nums)-1):\\n            if i%2==1:\\n                nums[i],nums[i+1]=nums[i+1], nums[i]\\n        return nums",
                "solutionTags": [],
                "code": "def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        1. do sort the array \\n        2. chnage the elem on odd postition with even postion why ?? lets take small example\\n        [10, 7 , 5 , 4 , 3]\\n        sort the array => [3,4,5,7,10]\\n        [_,x,_,x_] then swap every elem x with next elem to x \\n        [_,5,4,x,_]\\n        [_,5,4,10,7] => finally [3,5,4,10,7] by looking this we can say\\n        as its sorted its give you gaurntee that every for every elem x nebiours are less then to x that means always avg of nebours must be less then x \\n        \\'\\'\\'\\n        nums.sort()\\n        for i in range(1, len(nums)-1):\\n            if i%2==1:\\n                nums[i],nums[i+1]=nums[i+1], nums[i]\\n        return nums",
                "codeTag": "Python3"
            },
            {
                "id": 3598861,
                "title": "c-simple-using-hints",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] RearrangeArray(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        int medianIndex = nums.Length / 2;\\n        int[] ans = new int[nums.Length];\\n\\n        int i = 0;\\n        int ansIndex = 1;\\n\\n        while (i < medianIndex && ansIndex < ans.Length)\\n        {\\n            ans[ansIndex] = nums[i];\\n            ansIndex += 2;\\n            i += 1;\\n        }\\n\\n        i = medianIndex;\\n        ansIndex = 0;\\n\\n        while (i < nums.Length && ansIndex < ans.Length)\\n        {\\n            ans[ansIndex] = nums[i];\\n            ansIndex += 2;\\n            i += 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] RearrangeArray(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        int medianIndex = nums.Length / 2;\\n        int[] ans = new int[nums.Length];\\n\\n        int i = 0;\\n        int ansIndex = 1;\\n\\n        while (i < medianIndex && ansIndex < ans.Length)\\n        {\\n            ans[ansIndex] = nums[i];\\n            ansIndex += 2;\\n            i += 1;\\n        }\\n\\n        i = medianIndex;\\n        ansIndex = 0;\\n\\n        while (i < nums.Length && ansIndex < ans.Length)\\n        {\\n            ans[ansIndex] = nums[i];\\n            ansIndex += 2;\\n            i += 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570131,
                "title": "array-with-elements-not-equal-to-average-of-neighbors-o-n",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, a: List[int]) -> List[int]:\\n        while True:\\n            random.shuffle(a)\\n            for i in range(1, len(a)-1):\\n                if a[i] * 2 == a[i - 1] + a[i + 1]:\\n                    break\\n            else:\\n                return a\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, a: List[int]) -> List[int]:\\n        while True:\\n            random.shuffle(a)\\n            for i in range(1, len(a)-1):\\n                if a[i] * 2 == a[i - 1] + a[i + 1]:\\n                    break\\n            else:\\n                return a\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559739,
                "title": "apply-wiggle-sort-solution-o-n-time-o-1-space",
                "content": "# Intuition\\nWe need to rearrange the elements in the given array such that for every i:\\n\\nnums[i-1] < nums[i] if i is odd.\\nnums[i-1] > nums[i] if i is even.\\n\\n# Approach\\nTo solve this problem, we can go through the input array and compare adjacent elements. If the element at index i violates the given conditions, we swap it. So that both neighbors are bigger then number at odd positoin `(leftItem > i(odd) < rightItem)`.\\n`(leftItem < i(even) > rightItem)`\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the size of the array.\\n\\n- Space complexity:\\nO(1) because we are modifying the input array in place.\\n\\n# Code\\nPython\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            if i % 2 == 1:\\n                if nums[i] < nums[i - 1]:\\n                    nums[i - 1], nums[i] = nums[i], nums[i-1]\\n            if i % 2 == 0:\\n                if nums[i] > nums[i - 1]:\\n                    nums[i - 1], nums[i] = nums[i], nums[i-1]\\n        return nums\\n```\\nKotlin\\n```\\nclass Solution {\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size) {\\n            if (i % 2 == 1) {\\n                if (nums[i] < nums[i - 1]) {\\n                    nums[i - 1] = nums[i].also { nums[i] = nums[i - 1] }\\n                }\\n            } else {\\n                if (nums[i] > nums[i - 1]) {\\n                    nums[i - 1] = nums[i].also { nums[i] = nums[i - 1] }\\n                }\\n            }\\n        }\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            if i % 2 == 1:\\n                if nums[i] < nums[i - 1]:\\n                    nums[i - 1], nums[i] = nums[i], nums[i-1]\\n            if i % 2 == 0:\\n                if nums[i] > nums[i - 1]:\\n                    nums[i - 1], nums[i] = nums[i], nums[i-1]\\n        return nums\\n```\n```\\nclass Solution {\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size) {\\n            if (i % 2 == 1) {\\n                if (nums[i] < nums[i - 1]) {\\n                    nums[i - 1] = nums[i].also { nums[i] = nums[i - 1] }\\n                }\\n            } else {\\n                if (nums[i] > nums[i - 1]) {\\n                    nums[i - 1] = nums[i].also { nums[i] = nums[i - 1] }\\n                }\\n            }\\n        }\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535651,
                "title": "two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()  \\n        res = []\\n\\n\\n        l,r = 0,len(nums)-1\\n\\n        while l<=r:\\n            res.append(nums[l])\\n            l+=1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n\\n        return res\\n        # 1,5,2,4,3\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()  \\n        res = []\\n\\n\\n        l,r = 0,len(nums)-1\\n\\n        while l<=r:\\n            res.append(nums[l])\\n            l+=1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r-=1\\n\\n        return res\\n        # 1,5,2,4,3\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529041,
                "title": "o-n-o-1-most-efficient-simplest-solution-two-statements-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA zigzag array always satisfies the requirement of this question.\\nFor example:\\n$$^A \\\\searrow _B \\\\nearrow ^C \\\\searrow _D \\\\nearrow ...\\n$$\\nBecause `A > B` and `C > B`, we will have `A + C > 2B`.\\nSimilarly `B + D < 2C` so we will never get equality.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe dictate the array to be zigzag. Specifically it increases from index `0` to index `1`, then decreases from index `1` to index `2`, and so on.\\n\\nTo achieve this, we can simply check adjacent numbers and swap them if they do not follow the order. This will work thanks to the **uniqueness** of the numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> rearrangeArray(vector<int>& nums) {\\n    for (int i = 1; i < nums.size(); ++i) {\\n      if (nums[i - 1] < nums[i] != (i % 2 == 1)) {\\n        swap(nums[i - 1], nums[i]);\\n      }\\n    }\\n    return std::move(nums);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> rearrangeArray(vector<int>& nums) {\\n    for (int i = 1; i < nums.size(); ++i) {\\n      if (nums[i - 1] < nums[i] != (i % 2 == 1)) {\\n        swap(nums[i - 1], nums[i]);\\n      }\\n    }\\n    return std::move(nums);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514549,
                "title": "python-sort-and-pairwise-swap",
                "content": "```\\nInput:  1 2 3 4 5\\noutput: 1 3 2 5 4\\n```\\n\\nBasically the idea is: you have (3+5) / 2 = 4, now you swap `n[i]` with `n[i + 1]` which will never give you the same average value as with previous`n[i]` and `n[i + 1]` combo. Remember all the values are unique.\\n\\n**Proof why it works**\\nYou have a sorted sequence `a < b < c`. if you swap `b <-> c`, provided `b < c` you will have `a < c > b`. You cannot have an `avg(a, b) >= c` of two smaller than `c` numbers, provided `a < c` and `b < c`.\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        nums.sort()\\n        for i in reversed(range(1, N, 2)):\\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n        return nums\\n```\\nOR\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        N = len(nums) & ~1\\n        nums[1:N:2], nums[:N:2] = nums[:N:2], nums[1:N:2]\\n        return nums\\n```\\n\\n**O(N) with breakingdecreasing and increasing  triplets**\\nBased on above observation we can have a 1-pass solution by just breaking all `a < b < c` and `a > b > c` triplets.\\n```\\nclass Solution:\\n    def rearrangeArray(self, A: List[int]) -> List[int]:\\n        for i in range(1, len(A) - 1):\\n            if A[i - 1] < A[i] < A[i + 1] or A[i - 1] > A[i] > A[i + 1]:\\n                A[i], A[i + 1] = A[i + 1], A[i] \\n        return A\\n```\\n`A` because I am bored typing `nums`",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nInput:  1 2 3 4 5\\noutput: 1 3 2 5 4\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        nums.sort()\\n        for i in reversed(range(1, N, 2)):\\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n        return nums\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        N = len(nums) & ~1\\n        nums[1:N:2], nums[:N:2] = nums[:N:2], nums[1:N:2]\\n        return nums\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, A: List[int]) -> List[int]:\\n        for i in range(1, len(A) - 1):\\n            if A[i - 1] < A[i] < A[i + 1] or A[i - 1] > A[i] > A[i + 1]:\\n                A[i], A[i + 1] = A[i + 1], A[i] \\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514318,
                "title": "simple-two-pointer-approach",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo achieve this we need the following pattern to occur:\\n1. small,LARGE,small\\n2. LARGE,small,LARGE\\n\\nPairing the smallest and largest together will cause that ordering\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort\\n2. left pointer points to smallest and right pointer to largest\\n3. Take one from left and one from right\\n4. If there is an outstanding number just add it to the end\\n\\n# Complexity\\n- Time complexity: $O(nlgn)$ sorting time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ since we are not doing in place swaps and building out the result instead\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # keep the most distant numbers closest\\n        l=0\\n        r = len(nums)-1\\n        nums.sort()\\n        ans = []\\n        while l < r:\\n            ans.append(nums[l])\\n            ans.append(nums[r])\\n            l += 1\\n            r -= 1\\n        # uniqueness property\\n        if ans[-1] != nums[l]: ans.append(nums[l])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        # keep the most distant numbers closest\\n        l=0\\n        r = len(nums)-1\\n        nums.sort()\\n        ans = []\\n        while l < r:\\n            ans.append(nums[l])\\n            ans.append(nums[r])\\n            l += 1\\n            r -= 1\\n        # uniqueness property\\n        if ans[-1] != nums[l]: ans.append(nums[l])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3508402,
                "title": "java-solution-less-complex",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        if(nums.length<3 || nums==null) return nums;\\n\\n        Arrays.sort(nums);\\n        List<Integer> res = new ArrayList<>();\\n\\n        int l=0,r=nums.length-1;\\n\\n        while(res.size()!=nums.length){\\n            res.add(nums[l++]);\\n\\n            if(l<=r)\\n                res.add(nums[r--]);\\n        }\\n\\n        int[] intArray = res.stream().mapToInt(Integer::intValue).toArray();\\n        return intArray;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        if(nums.length<3 || nums==null) return nums;\\n\\n        Arrays.sort(nums);\\n        List<Integer> res = new ArrayList<>();\\n\\n        int l=0,r=nums.length-1;\\n\\n        while(res.size()!=nums.length){\\n            res.add(nums[l++]);\\n\\n            if(l<=r)\\n                res.add(nums[r--]);\\n        }\\n\\n        int[] intArray = res.stream().mapToInt(Integer::intValue).toArray();\\n        return intArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400898,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        sort(nums.begin(),nums.end());\\n        int k = 0;\\n        for(int i=0;i<n;i+=2)\\n        ans[i] = nums[k++];\\n        for(int i=1;i<n;i+=2)\\n        ans[i] = nums[k++];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        sort(nums.begin(),nums.end());\\n        int k = 0;\\n        for(int i=0;i<n;i+=2)\\n        ans[i] = nums[k++];\\n        for(int i=1;i<n;i+=2)\\n        ans[i] = nums[k++];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385951,
                "title": "sorting-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int i=0, j=nums.size()-1;\\n        int f=1;\\n        while(i<=j)\\n        {\\n            if(f) ans.push_back(nums[i++]);\\n            else ans.push_back(nums[j--]);\\n            f=1-f;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int i=0, j=nums.size()-1;\\n        int f=1;\\n        while(i<=j)\\n        {\\n            if(f) ans.push_back(nums[i++]);\\n            else ans.push_back(nums[j--]);\\n            f=1-f;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382674,
                "title": "simple-logic-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int en = n-1;\\n        vector<int>ans(n,0);\\n        int cnt = 0;\\n\\n        while(st<=en){\\n            if(flag==0){\\n                flag = 1;\\n                ans[cnt] = nums[st];\\n                st++;\\n                cnt++;\\n            }\\n            else{\\n                flag = 0;\\n                ans[cnt] = nums[en];\\n                cnt++;\\n                en--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int en = n-1;\\n        vector<int>ans(n,0);\\n        int cnt = 0;\\n\\n        while(st<=en){\\n            if(flag==0){\\n                flag = 1;\\n                ans[cnt] = nums[st];\\n                st++;\\n                cnt++;\\n            }\\n            else{\\n                flag = 0;\\n                ans[cnt] = nums[en];\\n                cnt++;\\n                en--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349264,
                "title": "two-pointers",
                "content": "- Time complexity: O(sort)\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        l, r = 0, len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l += 1\\n            if l <= r:\\n                res.append(nums[r])\\n                r -= 1\\n        return res \\n\\n```\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(1,len(nums), 2):\\n            nums[i], nums[i-1] = nums[i-1], nums[i]\\n        return nums \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        l, r = 0, len(nums)-1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l += 1\\n            if l <= r:\\n                res.append(nums[r])\\n                r -= 1\\n        return res \\n\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(1,len(nums), 2):\\n            nums[i], nums[i-1] = nums[i-1], nums[i]\\n        return nums \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331804,
                "title": "why-9999ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        size=int(len(nums)/2)\\n        for i in range(size):\\n            index=nums[0]\\n            nums.pop(0)\\n            nums.insert(size,index)\\n            size+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        size=int(len(nums)/2)\\n        for i in range(size):\\n            index=nums[0]\\n            nums.pop(0)\\n            nums.insert(size,index)\\n            size+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320042,
                "title": "python-o-nlogn-solution-by-sorting-the-array",
                "content": "### Approach\\n\\nAt its core, this approach is based on the fact that the average of two numbers can never be lower than the smallest of the two elements, nor higher than the largest of the two elements. \\n\\nThis means that if an element\\'s neighbors are both smaller than itself, then the average of those two neighbors will be smaller than the element in question. \\n\\nThe same is true for larger elements as well, though with the average being larger than the element in question. \\n\\nSo what we can do is go through the array and, in a sense, rearrange it into a series of peaks and valleys, that way ensuring that we meet the no average criteria.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        res = []\\n\\n        l,r = 0,len(nums) - 1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l += 1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n\\n        res = []\\n\\n        l,r = 0,len(nums) - 1\\n        while len(res) != len(nums):\\n            res.append(nums[l])\\n            l += 1\\n\\n            if l <= r:\\n                res.append(nums[r])\\n                r -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299873,
                "title": "two-pointers-rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn rearrange_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.sort();\\n        let mut res = vec![];\\n\\n        let (mut l, mut r) = (0, nums.len() - 1);\\n        // construct an array such that each element has neighbors\\n        // that are greater than or lesser than it\\n        // e.g. [1, 4, 2, 5, 3]\\n        while res.len() != nums.len() {\\n            res.push(nums[l]);\\n            l += 1;\\n            // avoid duplicates if odd number of elements\\n            if l <= r {\\n                res.push(nums[r]);\\n                r-= 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rearrange_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.sort();\\n        let mut res = vec![];\\n\\n        let (mut l, mut r) = (0, nums.len() - 1);\\n        // construct an array such that each element has neighbors\\n        // that are greater than or lesser than it\\n        // e.g. [1, 4, 2, 5, 3]\\n        while res.len() != nums.len() {\\n            res.push(nums[l]);\\n            l += 1;\\n            // avoid duplicates if odd number of elements\\n            if l <= r {\\n                res.push(nums[r]);\\n                r-= 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290796,
                "title": "c-simple-intuition-based-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l=0,r=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i&1)ans[i]=nums[r--];\\n            else ans[i]=nums[l++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l=0,r=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i&1)ans[i]=nums[r--];\\n            else ans[i]=nums[l++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284139,
                "title": "ts-easy-to-understand-solution",
                "content": "# Code\\n```\\nfunction rearrangeArray(nums: number[]): number[] {\\n    nums.sort(function(a: number, b: number): number {\\n        return a - b;\\n    });\\n    let result = [];\\n\\n    let i = 0;\\n    let j = nums.length - 1;\\n    // the order has to be: bigger, smaller, bigger, smaller and so on\\n    // for average to exist between two numbers average has to be in the non decreasing interval [a, b]\\n    // by generating the above interval we remove the possibility of there being an average between any two numbers\\n    while (i <= j) {\\n        if (result.length % 2 == 0) {\\n            result.push(nums[i]);\\n            i += 1;\\n        } else {\\n            result.push(nums[j]);\\n            j -= 1;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction rearrangeArray(nums: number[]): number[] {\\n    nums.sort(function(a: number, b: number): number {\\n        return a - b;\\n    });\\n    let result = [];\\n\\n    let i = 0;\\n    let j = nums.length - 1;\\n    // the order has to be: bigger, smaller, bigger, smaller and so on\\n    // for average to exist between two numbers average has to be in the non decreasing interval [a, b]\\n    // by generating the above interval we remove the possibility of there being an average between any two numbers\\n    while (i <= j) {\\n        if (result.length % 2 == 0) {\\n            result.push(nums[i]);\\n            i += 1;\\n        } else {\\n            result.push(nums[j]);\\n            j -= 1;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270073,
                "title": "pyrhon3-very-easy-solution",
                "content": "# Intuition\\n the problem very Quite similar to 324 copy and paste sol\\n\\n# Approach\\n    please upvote if its useful\\n\\n# Complexity\\n- Time complexity:\\n    O(N log N)\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        mid = (len(nums)+1)//2\\n        left , right = nums[:mid][::-1] , nums[mid:][::-1]\\n        l , r = 0 , 0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i] = left[l]\\n                l+=1\\n            else:\\n                nums[i] = right[r]\\n                r+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        mid = (len(nums)+1)//2\\n        left , right = nums[:mid][::-1] , nums[mid:][::-1]\\n        l , r = 0 , 0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i] = left[l]\\n                l+=1\\n            else:\\n                nums[i] = right[r]\\n                r+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246171,
                "title": "greedy-python-3",
                "content": "# Intuition\\nusing a greedy approach. We can start by sorting the input list in non-increasing order. Then, we can create a new list res of the same length as nums, and fill it with the largest and smallest elements of the sorted list alternately.\\n\\n# Approach\\nWe first sort the input list nums in non-increasing order using the sort method with the reverse=True argument. We then create a new list res of the same length as nums, initialized with None values. We then fill the even-indexed elements of res with the largest elements of nums starting from the middle of the sorted list, and fill the odd-indexed elements of res with the smallest elements of nums starting from the beginning of the sorted list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this implementation is O(nlogn) due to the sorting operation\\n\\n- Space complexity:\\nthe space complexity is O(n) to store the output list\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n\\n        # create a new list and fill it with the largest and smallest elements\\n        # of the sorted list alternately\\n        n = len(nums)\\n        res = [None] * n\\n        res[::2] = nums[n//2:]\\n        res[1::2] = nums[:n//2]\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n\\n        # create a new list and fill it with the largest and smallest elements\\n        # of the sorted list alternately\\n        n = len(nums)\\n        res = [None] * n\\n        res[::2] = nums[n//2:]\\n        res[1::2] = nums[:n//2]\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229446,
                "title": "time-complexity-o-logn-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n             \\n             sort(nums.begin(),nums.end());\\n             vector<int>v1;\\n             int i=0,j=nums.size()-1;\\n             while(i<j){\\n                    v1.emplace_back(nums[i]);\\n                    v1.emplace_back(nums[j]);\\n                    i++;\\n                    j--;\\n             }\\n             if(i==j) v1.emplace_back(nums[i]);\\n             return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n             \\n             sort(nums.begin(),nums.end());\\n             vector<int>v1;\\n             int i=0,j=nums.size()-1;\\n             while(i<j){\\n                    v1.emplace_back(nums[i]);\\n                    v1.emplace_back(nums[j]);\\n                    i++;\\n                    j--;\\n             }\\n             if(i==j) v1.emplace_back(nums[i]);\\n             return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215433,
                "title": "easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        int n=nums.size();\\n        int start=0;\\n        int end=n-1;\\n        while(1)\\n        {\\n            if(start>end)\\n            break;\\n            if(start==end)\\n            {\\n                ans.push_back(nums[start]);\\n                break;\\n            }\\n            ans.push_back(nums[start]);\\n            ans.push_back(nums[end]);\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        int n=nums.size();\\n        int start=0;\\n        int end=n-1;\\n        while(1)\\n        {\\n            if(start>end)\\n            break;\\n            if(start==end)\\n            {\\n                ans.push_back(nums[start]);\\n                break;\\n            }\\n            ans.push_back(nums[start]);\\n            ans.push_back(nums[end]);\\n            start++;\\n            end--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203989,
                "title": "c-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i <= (n - 1) / 2; ++ i) {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n - i - 1]);\\n        }\\n        if (n & 1) res.pop_back();\\n        return res;\\n    }\\n};  \\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i <= (n - 1) / 2; ++ i) {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n - i - 1]);\\n        }\\n        if (n & 1) res.pop_back();\\n        return res;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192855,
                "title": "c-o-n-without-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            int x=nums[i-1],y=nums[i],z=nums[i+1];\\n            if((x<y&&y<z)||(x>y&&y>z))\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) \\n    {\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            int x=nums[i-1],y=nums[i],z=nums[i+1];\\n            if((x<y&&y<z)||(x>y&&y>z))\\n            {\\n                swap(nums[i],nums[i+1]);\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186796,
                "title": "3-lines-scala-immutable-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def rearrangeArray(nums: Array[Int]): Array[Int] = {\\n    lazy val (t,d) = nums.sorted.splitAt(nums.size/2)\\n    lazy val x0 = (d zip t).flatMap{case (a,b) => List(a,b)}\\n    if(nums.size%2 == 0) x0 else x0 :+ (d.last)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def rearrangeArray(nums: Array[Int]): Array[Int] = {\\n    lazy val (t,d) = nums.sorted.splitAt(nums.size/2)\\n    lazy val x0 = (d zip t).flatMap{case (a,b) => List(a,b)}\\n    if(nums.size%2 == 0) x0 else x0 :+ (d.last)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3173252,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        Array.Sort(nums);\\n        double avg =0.0;\\n\\n        for(int i=1; i< nums.Length-1; i++)\\n        {\\n            avg = (nums[i-1] + nums[i+1]) / 2.0;\\n\\n            if(avg == (double) nums[i])\\n            {\\n                nums[i] = nums[i] + nums[i+1];\\n                nums[i+1] = nums[i] - nums[i+1];\\n                nums[i] = nums[i] - nums[i+1];\\n                if(i > 1)\\n                {\\n                    i-=2;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        Array.Sort(nums);\\n        double avg =0.0;\\n\\n        for(int i=1; i< nums.Length-1; i++)\\n        {\\n            avg = (nums[i-1] + nums[i+1]) / 2.0;\\n\\n            if(avg == (double) nums[i])\\n            {\\n                nums[i] = nums[i] + nums[i+1];\\n                nums[i+1] = nums[i] - nums[i+1];\\n                nums[i] = nums[i] - nums[i+1];\\n                if(i > 1)\\n                {\\n                    i-=2;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171761,
                "title": "same-as-wiggle-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> res (nums.size(),0); \\n        sort(nums.begin(),nums.end());\\n        int i = 0 , j = nums.size()-1;\\n        for(int k = 0; k<nums.size();k++){\\n            if(k%2==0)\\n            res[k] = nums[j--];\\n            else \\n            res[k]= nums[i++];\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> res (nums.size(),0); \\n        sort(nums.begin(),nums.end());\\n        int i = 0 , j = nums.size()-1;\\n        for(int k = 0; k<nums.size();k++){\\n            if(k%2==0)\\n            res[k] = nums[j--];\\n            else \\n            res[k]= nums[i++];\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164602,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        queue<int> q;\\n        for(auto i:nums){\\n            q.push(i);\\n        }\\n        for(int i=1;i<nums.size();i+=2){\\n            nums[i]=q.front();\\n            q.pop();\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            nums[i]=q.front();\\n            q.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        queue<int> q;\\n        for(auto i:nums){\\n            q.push(i);\\n        }\\n        for(int i=1;i<nums.size();i+=2){\\n            nums[i]=q.front();\\n            q.pop();\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            nums[i]=q.front();\\n            q.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156962,
                "title": "java-solution-using-two-pointers",
                "content": "# code\\n<h3>If this code was helpful like this :)</h3>\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j,k=0,n=nums.length;\\n        j=n-1;\\n        int arr[]=new int[n];\\n        while(k<n)\\n        {\\n            \\n            arr[k]=nums[j--];\\n            k+=2;\\n        }\\n        k=1;\\n        while(k<n)\\n        {\\n            arr[k]=nums[i++];\\n            k+=2;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j,k=0,n=nums.length;\\n        j=n-1;\\n        int arr[]=new int[n];\\n        while(k<n)\\n        {\\n            \\n            arr[k]=nums[j--];\\n            k+=2;\\n        }\\n        k=1;\\n        while(k<n)\\n        {\\n            arr[k]=nums[i++];\\n            k+=2;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123726,
                "title": "classic-two-pointer-question-sorting-first-the-array",
                "content": "# So basically what we need to do it place a large number between two small numbers or a small numer between two large numbers that way the averages will never be the same and to achive that sort the array first. Then take two pointers one at the smallest number at l=0 and the other at the largest number r=len(nums)-1 now we place l=0 index number and the r=len(nums)-1 index numner next to each other and we continue this pattern until l<=r however for an odd length array there would be a considiton when l==r that case we will be adding one extra number, to metigate that if l==r then just put any one index number either l or r to avoid dupliacte.\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = 0\\n        r = len(nums)-1\\n        res = []\\n        while l<=r:\\n            if l!=r:\\n                res.append(nums[l])\\n                res.append(nums[r])\\n            else:\\n                res.append(nums[l])\\n            l+=1\\n            r-=1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = 0\\n        r = len(nums)-1\\n        res = []\\n        while l<=r:\\n            if l!=r:\\n                res.append(nums[l])\\n                res.append(nums[r])\\n            else:\\n                res.append(nums[l])\\n            l+=1\\n            r-=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115095,
                "title": "rust-solution-o-n-t-o-1-s",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n    pub fn rearrange_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        let mut a = nums[0] < nums[1];\\n\\n        for i in 1..nums.len() - 1 {\\n            if (a && nums[i] < nums[i + 1]) || (!a && nums[i] > nums[i + 1]) {\\n                let t = nums[i];\\n                nums[i] = nums[i + 1];\\n                nums[i + 1] = t;\\n            }\\n            a = !a;\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rearrange_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        let mut a = nums[0] < nums[1];\\n\\n        for i in 1..nums.len() - 1 {\\n            if (a && nums[i] < nums[i + 1]) || (!a && nums[i] > nums[i + 1]) {\\n                let t = nums[i];\\n                nums[i] = nums[i + 1];\\n                nums[i + 1] = t;\\n            }\\n            a = !a;\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105789,
                "title": "java-simple-solution-using-sorting-and-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] ans = new int[n];\\n        int i = 0, j = n-1, k = 0;\\n        while(i<=j) {\\n            if(k<n)\\n                ans[k++] = nums[i++];\\n            if(k<n)\\n                ans[k++] = nums[j--];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] ans = new int[n];\\n        int i = 0, j = n-1, k = 0;\\n        while(i<=j) {\\n            if(k<n)\\n                ans[k++] = nums[i++];\\n            if(k<n)\\n                ans[k++] = nums[j--];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101241,
                "title": "easy-solution-0ms-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int x = 0, y = 1;\\n        for(int i = 2; i < nums.length; i++){\\n            if((nums[i] < nums[y] && nums[y] < nums[x]) \\n                || (nums[i] > nums[y] && nums[y] > nums[x])){\\n                    int temp = nums[y];\\n                    nums[y] = nums[i];\\n                    nums[i] = temp;\\n            }\\n            y++;\\n            x++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int x = 0, y = 1;\\n        for(int i = 2; i < nums.length; i++){\\n            if((nums[i] < nums[y] && nums[y] < nums[x]) \\n                || (nums[i] > nums[y] && nums[y] > nums[x])){\\n                    int temp = nums[y];\\n                    nums[y] = nums[i];\\n                    nums[i] = temp;\\n            }\\n            y++;\\n            x++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100130,
                "title": "simple-java-sort-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length - 1;\\n        int[] res = new int[nums.length];\\n        for (int k = 0; k < nums.length; k++) {\\n            if (k % 2 == 0) {\\n                res[k] = nums[j--];\\n            } else {\\n                res[k] = nums[i++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length - 1;\\n        int[] res = new int[nums.length];\\n        for (int k = 0; k < nums.length; k++) {\\n            if (k % 2 == 0) {\\n                res[k] = nums[j--];\\n            } else {\\n                res[k] = nums[i++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067096,
                "title": "rearrange-the-array-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n            nums.sort()\\n            for i in range(1, len(nums), 2):\\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n\\n            return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n            nums.sort()\\n            for i in range(1, len(nums), 2):\\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\\n\\n            return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042160,
                "title": "2-no-sorting-solutions",
                "content": "# Solution 1:\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i-1] < nums[i] < nums[i+1]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n\\n            elif nums[i+1] < nums[i] < nums[i-1]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n\\n        return nums\\n```\\n# Solution 2:\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        valid = False\\n\\n        while valid == False:\\n            valid = self.check(nums)\\n        \\n        return nums\\n    \\n    def check(self, nums):\\n        res = True\\n        for i in range(1, len(nums)-1):\\n            avg = (nums[i-1]+nums[i+1])/2\\n\\n            if avg == nums[i]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n                res = False\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i-1] < nums[i] < nums[i+1]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n\\n            elif nums[i+1] < nums[i] < nums[i-1]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n\\n        return nums\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        valid = False\\n\\n        while valid == False:\\n            valid = self.check(nums)\\n        \\n        return nums\\n    \\n    def check(self, nums):\\n        res = True\\n        for i in range(1, len(nums)-1):\\n            avg = (nums[i-1]+nums[i+1])/2\\n\\n            if avg == nums[i]:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n                res = False\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036009,
                "title": "python-down-and-up-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        res = []\\n        while i <= j:\\n            if i == j:\\n                res.append(nums[i])\\n                break\\n            res.append(nums[i])\\n            res.append(nums[j])\\n            i += 1\\n            j -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        res = []\\n        while i <= j:\\n            if i == j:\\n                res.append(nums[i])\\n                break\\n            res.append(nums[i])\\n            res.append(nums[j])\\n            i += 1\\n            j -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986301,
                "title": "ali",
                "content": "\\n# Explanation\\n<!-- Describe your approach to solving the problem. -->\\n\\n- input : 6,2,0,9,7\\n- sort  : 0,2,6,7,9\\n- we would replace last bigger numbers and make it in between numbers.\\n- to make it one big number , then one small number _ , 7, _ , 9 , _ \\n- select bigger numbers => (nums.Length / 2)\\n- then make pointer refers on the first bigger number\\n- int pointer = nums.Length / n; // 3\\n- the iterator should be increase by 2 every round\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        Array.Sort(nums);\\n\\n        int pointer = nums.Length - (nums.Length / 2);\\n\\n        for (int i = 1; i < nums.Length; i+=2)\\n        {\\n            int temp = nums[i];\\n            nums[i] = nums[pointer];\\n            nums[pointer++] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        Array.Sort(nums);\\n\\n        int pointer = nums.Length - (nums.Length / 2);\\n\\n        for (int i = 1; i < nums.Length; i+=2)\\n        {\\n            int temp = nums[i];\\n            nums[i] = nums[pointer];\\n            nums[pointer++] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985181,
                "title": "wiggle-sort",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n        i = j = k = None\\n        if n & 1:\\n            res.append(nums[n // 2])\\n            i = n // 2 - 1\\n            j = n // 2 + 1\\n            k = (n - 1) // 2\\n        else:\\n            i = n // 2 - 1\\n            j = n // 2\\n            k = n // 2\\n        for l in range(k):\\n            res.append(nums[i - l])\\n            res.append(nums[j + l])\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/3230cf42-354c-44d8-a867-abab49f25d75_1672653884.0438128.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n        i = j = k = None\\n        if n & 1:\\n            res.append(nums[n // 2])\\n            i = n // 2 - 1\\n            j = n // 2 + 1\\n            k = (n - 1) // 2\\n        else:\\n            i = n // 2 - 1\\n            j = n // 2\\n            k = n // 2\\n        for l in range(k):\\n            res.append(nums[i - l])\\n            res.append(nums[j + l])\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1796159,
                "content": [
                    {
                        "username": "A_R_C_H_E_R",
                        "content": "Try 280. Wiggle Sort. It is the same question, and will help you understand the O(n) approach"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@15o1](/15o1) wiggle sort 2 is not premium and same as this.\\ndiscussion on that question is still good despite hints for this question."
                    },
                    {
                        "username": "15o1",
                        "content": "That's premium question bro ;<\nWell tbh the hints are more than enough to solve the problem lol"
                    },
                    {
                        "username": "mrcrood",
                        "content": "Do wiggle Sort"
                    },
                    {
                        "username": "gangurisatya",
                        "content": "Hints really help.\\nEspecially the second one."
                    }
                ]
            },
            {
                "id": 1939716,
                "content": [
                    {
                        "username": "A_R_C_H_E_R",
                        "content": "Try 280. Wiggle Sort. It is the same question, and will help you understand the O(n) approach"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@15o1](/15o1) wiggle sort 2 is not premium and same as this.\\ndiscussion on that question is still good despite hints for this question."
                    },
                    {
                        "username": "15o1",
                        "content": "That's premium question bro ;<\nWell tbh the hints are more than enough to solve the problem lol"
                    },
                    {
                        "username": "mrcrood",
                        "content": "Do wiggle Sort"
                    },
                    {
                        "username": "gangurisatya",
                        "content": "Hints really help.\\nEspecially the second one."
                    }
                ]
            },
            {
                "id": 1917329,
                "content": [
                    {
                        "username": "A_R_C_H_E_R",
                        "content": "Try 280. Wiggle Sort. It is the same question, and will help you understand the O(n) approach"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@15o1](/15o1) wiggle sort 2 is not premium and same as this.\\ndiscussion on that question is still good despite hints for this question."
                    },
                    {
                        "username": "15o1",
                        "content": "That's premium question bro ;<\nWell tbh the hints are more than enough to solve the problem lol"
                    },
                    {
                        "username": "mrcrood",
                        "content": "Do wiggle Sort"
                    },
                    {
                        "username": "gangurisatya",
                        "content": "Hints really help.\\nEspecially the second one."
                    }
                ]
            }
        ]
    }
]