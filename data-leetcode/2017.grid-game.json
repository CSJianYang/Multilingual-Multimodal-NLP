[
    {
        "title": "Grid Game",
        "question_content": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\n&nbsp;\nExample 1:\n\nInput: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.\n\nExample 2:\n\nInput: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.\n\nExample 3:\n\nInput: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n\n&nbsp;\nConstraints:\n\n\tgrid.length == 2\n\tn == grid[r].length\n\t1 <= n <= 5 * 104\n\t1 <= grid[r][c] <= 105",
        "solutions": [
            {
                "id": 1486340,
                "title": "c-java-python-robot1-minimize-topsum-and-bottomsum-of-robot-2-picture-explained",
                "content": "**Idea**\\n- Please note that robot 1 and robot 2 can only move down once.\\n- There are total `n` possible paths of Robot 1. Each possible path of Robot 1, Robot 2 can only get one of following total points:\\n\\t- `topSum`:  If robot 2 moves on the top row.\\n\\t- `bottomSum`: If robot 2 moves on the bottom row.\\n\\t- It means, total points that Robot 2 can get = max(topSum, bottomSum).\\n- Finally, we need to choose one path among `n` paths of Robot 1 so that it can minimize total points of Robot 2.\\n\\n![image](https://assets.leetcode.com/users/images/0f8a75fd-0951-4788-874a-9f37f55e3024_1632636927.5096028.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/PTP2ukEe/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 5*10^4` is number of columns in the grid.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.\\n\\n---\\n**Questions & Answers**\\n**Question 1:** Why won\\'t this DP approach work? (from @avi_1950)\\n1. Firstly, I find the path which has the maximum points for Robot 1 then I make all its path cells as zeroes.\\n2. Then finding the path which has the maximum points for Robot 2?\\n\\n**Answer:** In this problem, Robot 1 need to minimize the maximum ponts which Robot 2 can get. If we do greedily by **finding the path which has the maximum points for Robot 1**, it\\'s not garantee that we can minimize points of Robot 2.\\nCan consider this testcase:\\n```\\n10 50 50 30\\n50 50 10 10\\n```\\nIf you find the maximum path for Robot 1 and set those cells into 0, then the path became:\\n```\\n00 00 00 00\\n50 50 10 00\\n```\\nThe Robot 2 can get maximum of **110 points**.\\n\\n----\\nBut if Robot 1 goes by this path:\\n```\\n00 00 50 30\\n50 00 00 00\\n```\\nThen Robot 2 can get maximum of **80 points**.",
                "solutionTags": [],
                "code": "```\\n10 50 50 30\\n50 50 10 10\\n```\n```\\n00 00 00 00\\n50 50 10 00\\n```\n```\\n00 00 50 30\\n50 00 00 00\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486288,
                "title": "prefix-suffix-sum",
                "content": "Since the robots cannot go up, we need to find the best point `i` for the first robot to go down. \\n\\nFor the second robot, we only have two choices - go down right away, or stay up till the end.\\n\\nFor a point `i`, the second robot can either collect `bottom = sum(grid[1][0] .. grid[1][i - 1])` if it goes down, or `top = sum(grid[0][i + 1] ... grid[0][n - 1])` otherwise.\\n\\nWe can compute those values using prefix/suffix sum in O(1), and then find the minimum of `max(top, bottom)`.\\n\\n> Note that the prefix/suffix sum can overflow int, so we need to use a 64-bit integer in C++ and Java.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def gridGame(self, g: List[List[int]]) -> int:\\n        top, bottom, res = sum(g[0]), 0, math.inf\\n        for g0, g1 in zip(g[0], g[1]):\\n            top -= g0\\n            res = min(res, max(top, bottom))\\n            bottom += g1\\n        return res\\n```\\n\\n**Java**\\n```java\\npublic long gridGame(int[][] g) {\\n    long top = Arrays.stream(g[0]).asLongStream().sum(), bottom = 0, res = Long.MAX_VALUE;\\n    for(int i = 0; i < g[0].length; ++i) {\\n        top -= g[0][i];\\n        res = Math.min(res, Math.max(top, bottom));\\n        bottom += g[1][i];\\n    }\\n    return res;        \\n}\\n```\\n\\n**C++**\\n```cpp\\nlong long gridGame(vector<vector<int>>& g) {\\n    long long top = accumulate(begin(g[0]), end(g[0]), 0ll), bottom = 0, res = LLONG_MAX;\\n    for(int i = 0; i < g[0].size(); ++i) {\\n        top -= g[0][i];\\n        res = min(res, max(top, bottom));\\n        bottom += g[1][i];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def gridGame(self, g: List[List[int]]) -> int:\\n        top, bottom, res = sum(g[0]), 0, math.inf\\n        for g0, g1 in zip(g[0], g[1]):\\n            top -= g0\\n            res = min(res, max(top, bottom))\\n            bottom += g1\\n        return res\\n```\n```java\\npublic long gridGame(int[][] g) {\\n    long top = Arrays.stream(g[0]).asLongStream().sum(), bottom = 0, res = Long.MAX_VALUE;\\n    for(int i = 0; i < g[0].length; ++i) {\\n        top -= g[0][i];\\n        res = Math.min(res, Math.max(top, bottom));\\n        bottom += g[1][i];\\n    }\\n    return res;        \\n}\\n```\n```cpp\\nlong long gridGame(vector<vector<int>>& g) {\\n    long long top = accumulate(begin(g[0]), end(g[0]), 0ll), bottom = 0, res = LLONG_MAX;\\n    for(int i = 0; i < g[0].size(); ++i) {\\n        top -= g[0][i];\\n        res = min(res, max(top, bottom));\\n        bottom += g[1][i];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486399,
                "title": "can-anyone-explain-one-of-the-lc-test-cases",
                "content": "Input:\\n\\n```\\n[[20,3,20,17,2,12,15,17,4,15],[20,10,13,14,15,5,2,3,14,3]]\\n```\\n\\nExpected Output: **63**\\n\\nI approached the problem with the greedy approach:\\n\\n1. First robot should remove maximum path points from [0,0] to [1,n-1].\\n2. Second Robot will get the next maximum path post first robot removes the maximum path points.\\n\\nUsing the above logic, the answer comes as **96**.\\n\\nIt would be great if anyone could help in this regard. Thanks.\\n\\n**Update:** As explained by @zeck008, the above mentioned approach is not always optimal since it is possible to reduce the points gathered by Robo2 even if Robo1 doesn\\'t achieve the maximum points path.\\n\\nLet\\'s take a simpler example:\\n\\n```\\n1 2 3 4\\n5 6 7 8\\n```\\n\\nIn the above example, according to greedy approach, Robo1 will take path 1 5 6 7 8. After that, the board will look like this:\\n\\n```\\n0 2 3 4\\n0 0 0 0\\n```\\n\\nIn this case, the points gathered by Robo2 is **9**.\\n\\nBut if you look closely, it is possible to reduce the Robo2\\'s points further.\\n\\nLet\\'s assume that Robo1 takes path: 1 2 6 7 8. After that, board will look something like this:\\n\\n```\\n0 0 3 4\\n5 0 0 0\\n```\\n\\nOn the above mentioned path, the maximum points that Robo2 can collect is **7**.\\n\\nSo, in this example, Robo1 will prefer 2nd path instead of 1st.\\n\\nHence, the most optimal path finding algorithm has to consider all the columns where Robo1 can switch to 2nd row and decide the optimal path accordingly.\\n\\nIn the above example, for all columns, the corresponding points gathered by Robo1 are as follows:\\n\\n```\\n(1+5+6+7+8) (1+2+6+7+8) (1+2+3+7+8) (1+2+3+4+8)\\n=> 27 24 21 18\\n```\\n\\nThe corresponding points gathered by Robo2 when Robo1 chooses a column for switching to 2nd row are:\\n```\\nmax(2+3+4, 0) max(3+4, 5) max(4, 5+6) max(0, 5+6+7)\\n=> 9 7 11 18\\n```\\n\\nHence, the answer comes out to be **7** (the minimum of the possible points that Robo2 can gather).",
                "solutionTags": [],
                "code": "```\\n[[20,3,20,17,2,12,15,17,4,15],[20,10,13,14,15,5,2,3,14,3]]\\n```\n```\\n1 2 3 4\\n5 6 7 8\\n```\n```\\n0 2 3 4\\n0 0 0 0\\n```\n```\\n0 0 3 4\\n5 0 0 0\\n```\n```\\n(1+5+6+7+8) (1+2+6+7+8) (1+2+3+7+8) (1+2+3+4+8)\\n=> 27 24 21 18\\n```\n```\\nmax(2+3+4, 0) max(3+4, 5) max(4, 5+6) max(0, 5+6+7)\\n=> 9 7 11 18\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486461,
                "title": "simple-c-solution-with-diagram-and-explanation-accepted",
                "content": "# Approach\\n\\n![image](https://assets.leetcode.com/users/images/50cec0b8-9d95-4ea9-823b-6ed83bbf2e8b_1632631825.0099034.png)\\n\\nThe above picture represents one of the path in a certain grid travelled by Robot 1.\\nwe can clearly see, that second robot can either collect the points left in row 0 after the turning point or the points left in row 1 before the turning point ,but not both. We can use **prefix sum** to get the points before and after turning points in O(1). Since, we don\\'t know which path of robot 1 will give us our req. ans, hence we\\'ll try all the paths and get our answer.\\n\\n# Code\\n\\n```\\n#define ll long long\\n\\nlong long gridGame(vector<vector<int>>& arr) {\\n        int n = arr[0].size();\\n        \\n\\t\\t//we make two prefix arrays to store prefix of row 0 and row 1\\n        ll pre1[n+1];\\n        ll pre2[n+1];\\n        \\n\\t\\t//filling the prefix arrays\\n        pre1[0] = arr[0][0] , pre2[0] = arr[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre1[i] = pre1[i-1] + arr[0][i];\\n            pre2[i] = pre2[i-1] + arr[1][i];\\n            // cout<<pre1[i]<<\" \";\\n        }\\n        \\n\\t\\t//var to store result\\n        ll res = LONG_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//we have 2 options\\n\\t\\t\\t// 1. to take the values in row 0 after the turning point\\n\\t\\t\\t//2. to take the values in row 1 before turning point\\n            ll op1 = pre1[n-1] - pre1[i];\\n            ll op2 = i==0 ? 0 : pre2[i-1];\\n            // cout<<op1<<\" \"<<op2<<\"\\\\n\";\\n\\t\\t\\t\\n\\t\\t\\t//the 2nd robot wants to take the best of two options avalable\\n\\t\\t\\t//so we take max of op1 and op2\\n\\t\\t\\t//but the first robot wants to minimize its score,\\n\\t\\t\\t//hence we take min\\n            res = min(res,max(op1,op2));\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n# Conclusions\\n**Time Complexity :** O(n)\\n**Space Complexity :** O(n)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n\\nlong long gridGame(vector<vector<int>>& arr) {\\n        int n = arr[0].size();\\n        \\n\\t\\t//we make two prefix arrays to store prefix of row 0 and row 1\\n        ll pre1[n+1];\\n        ll pre2[n+1];\\n        \\n\\t\\t//filling the prefix arrays\\n        pre1[0] = arr[0][0] , pre2[0] = arr[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre1[i] = pre1[i-1] + arr[0][i];\\n            pre2[i] = pre2[i-1] + arr[1][i];\\n            // cout<<pre1[i]<<\" \";\\n        }\\n        \\n\\t\\t//var to store result\\n        ll res = LONG_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//we have 2 options\\n\\t\\t\\t// 1. to take the values in row 0 after the turning point\\n\\t\\t\\t//2. to take the values in row 1 before turning point\\n            ll op1 = pre1[n-1] - pre1[i];\\n            ll op2 = i==0 ? 0 : pre2[i-1];\\n            // cout<<op1<<\" \"<<op2<<\"\\\\n\";\\n\\t\\t\\t\\n\\t\\t\\t//the 2nd robot wants to take the best of two options avalable\\n\\t\\t\\t//so we take max of op1 and op2\\n\\t\\t\\t//but the first robot wants to minimize its score,\\n\\t\\t\\t//hence we take min\\n            res = min(res,max(op1,op2));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1486409,
                "title": "visualize-it-and-it-will-be-easy-c-explained",
                "content": "![image](https://assets.leetcode.com/users/images/bb1930b6-1e5b-4940-bc82-c50f8a6168c4_1632630541.1424475.png)\\n\\nO(N) Space Complexity :\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<long long> pre1(n+1,0);\\n        vector<long long> pre2(n+1,0);\\n        long long s=0, ans=0;\\n        grid[0][0]=0; grid[1][n-1]=0; // Picked by First Robot\\n        for(int i=0;i<n;i++){\\n            pre1[i+1]=pre1[i]+grid[0][i];\\n            pre2[i+1]=pre2[i]+grid[1][i];\\n            s+=grid[0][i]; \\n        }\\n        for(int i=1;i<=n;i++){\\n            ans=max(min(s-pre1[i],pre2[i]),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nO(1) Space Complexity :\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        long long s=0,s1=0,s2=0, ans=0;\\n        grid[0][0]=0; grid[1][n-1]=0; // Picked by First Robot (Start & Destination)\\n        for(int i=0;i<n;i++)\\n            s+=grid[0][i]; \\n        for(int i=0;i<n;i++){\\n            s1+=grid[0][i], s2+=grid[1][i];\\n            ans=max(min(s-s1,s2),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if you like the Solution and ask your queries :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<long long> pre1(n+1,0);\\n        vector<long long> pre2(n+1,0);\\n        long long s=0, ans=0;\\n        grid[0][0]=0; grid[1][n-1]=0; // Picked by First Robot\\n        for(int i=0;i<n;i++){\\n            pre1[i+1]=pre1[i]+grid[0][i];\\n            pre2[i+1]=pre2[i]+grid[1][i];\\n            s+=grid[0][i]; \\n        }\\n        for(int i=1;i<=n;i++){\\n            ans=max(min(s-pre1[i],pre2[i]),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        long long s=0,s1=0,s2=0, ans=0;\\n        grid[0][0]=0; grid[1][n-1]=0; // Picked by First Robot (Start & Destination)\\n        for(int i=0;i<n;i++)\\n            s+=grid[0][i]; \\n        for(int i=0;i<n;i++){\\n            s1+=grid[0][i], s2+=grid[1][i];\\n            ans=max(min(s-s1,s2),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486343,
                "title": "prefix-and-suffix-sum-o-n-time-and-space",
                "content": "Let **green** line path be the **maximum sum path** in the grid which will be used by **firs robot** , so **second robot** can gain either **top red path** sum value of **bottom red path** sum. So we have to find the minimum value of max of such red paths .\\nWe calculate **prefix sum** for **first row** and **suffix sum** for second row.\\nAnd for each **i** from **0 to n-1** we find the **max( pref[ n-1 ] - pref[ i ] , suff[ 0 ] - suff[ i ] )** and the **min** of all **those n values** is our answer.\\n\\n![image](https://assets.leetcode.com/users/images/c5c0d35a-0286-4079-92e6-cf50262afae3_1632629010.7496464.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n=grid[0].size();\\n        vector<long long>pref(n),suff(n);\\n        \\n\\t\\t//pref sum of first row\\n        for(int i=0;i<n;++i){\\n            if(i==0)pref[i]=grid[0][i];\\n            else pref[i]=grid[0][i]+pref[i-1];\\n        }\\n        \\n\\t\\t//suffix sum of second row\\n        for(int i=n-1;i>=0;--i){\\n            if(i==n-1)suff[i]=grid[1][i];\\n            else suff[i]=grid[1][i]+suff[i+1];\\n        }\\n        \\n        long long ans=0,temp=0;\\n        for(int i=0;i<n;++i){\\n            if(i==0){\\n                ans=pref[n-1]-pref[0];\\n            }\\n            temp=max(pref[n-1]-pref[i],suff[0]-suff[i]);\\n\\t\\t\\t\\n            //ans stores the minimum of all \\'n\\' values that temp can have\\n            ans=min(ans,temp);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n=grid[0].size();\\n        vector<long long>pref(n),suff(n);\\n        \\n\\t\\t//pref sum of first row\\n        for(int i=0;i<n;++i){\\n            if(i==0)pref[i]=grid[0][i];\\n            else pref[i]=grid[0][i]+pref[i-1];\\n        }\\n        \\n\\t\\t//suffix sum of second row\\n        for(int i=n-1;i>=0;--i){\\n            if(i==n-1)suff[i]=grid[1][i];\\n            else suff[i]=grid[1][i]+suff[i+1];\\n        }\\n        \\n        long long ans=0,temp=0;\\n        for(int i=0;i<n;++i){\\n            if(i==0){\\n                ans=pref[n-1]-pref[0];\\n            }\\n            temp=max(pref[n-1]-pref[i],suff[0]-suff[i]);\\n\\t\\t\\t\\n            //ans stores the minimum of all \\'n\\' values that temp can have\\n            ans=min(ans,temp);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486330,
                "title": "java-python-3-prefix-and-suffix-sum-o-n-code-w-brief-explanation-and-analysis",
                "content": "Key observation: **Robot 2 can ONLY choose the lower left part or the upper right part of the the column that Rob 1 traversed.** Therefore, we compute the *max values* of the two parts when traversing the two-cell-columns from left and right. The mininum out of the afore-mentioned *max values* is the solution.\\n```java\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = IntStream.of(grid[0]).mapToLong(i -> i).sum();\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            upperRight -= grid[0][i];\\n            ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n            lowerLeft += grid[1][i];\\n        }\\n        return ans;\\n    }\\n```\\nPer **@aravinth3108**\\'s suggestion, the following code might be more friendly to the beginners:\\n\\n```java\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = 0;\\n        for (int cell : grid[0]) {\\n            upperRight += cell;\\n        }\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            upperRight -= grid[0][i];\\n            ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n            lowerLeft += grid[1][i];\\n        }\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n```python\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        upper_right, lower_left, ans = sum(grid[0]), 0, math.inf\\n        for upper, lower in zip(grid[0], grid[1]):\\n            upper_right -= upper\\n            ans = min(ans, max(upper_right, lower_left))\\n            lower_left += lower\\n        return ans\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = grid[0].length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = IntStream.of(grid[0]).mapToLong(i -> i).sum();\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            upperRight -= grid[0][i];\\n            ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n            lowerLeft += grid[1][i];\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = 0;\\n        for (int cell : grid[0]) {\\n            upperRight += cell;\\n        }\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            upperRight -= grid[0][i];\\n            ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n            lowerLeft += grid[1][i];\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        upper_right, lower_left, ans = sum(grid[0]), 0, math.inf\\n        for upper, lower in zip(grid[0], grid[1]):\\n            upper_right -= upper\\n            ans = min(ans, max(upper_right, lower_left))\\n            lower_left += lower\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1486280,
                "title": "c-simple-solution",
                "content": "Think when first bot needs to switch the row.\\nSuppose first bot switch the row in ith column, then maximum points collected by second bot is equal to max of sum of elements in the second row of grid(from 0th column to i-1th column) and sum of elements in the first row of the grid (from i+1th column to n-1th column). We can simply iterate i from 0 to n-1th (bot 1 switches the row in ith column) column and calculate the value of max points collected by bot 2 in each case. answer will be minimum of these.\\n\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=2;\\n        int n=grid[0].size();\\n        \\n        long long lsum=0, rsum=0;\\n        for(int i=n-1;i>-1;--i){\\n            rsum += grid[0][i];\\n        }\\n        \\n        long long ans= LLONG_MAX;\\n        for(int i=0;i<n;++i){\\n            rsum=rsum-grid[0][i];\\n            ans=min(ans, max(rsum, lsum));\\n            lsum=lsum+grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=2;\\n        int n=grid[0].size();\\n        \\n        long long lsum=0, rsum=0;\\n        for(int i=n-1;i>-1;--i){\\n            rsum += grid[0][i];\\n        }\\n        \\n        long long ans= LLONG_MAX;\\n        for(int i=0;i<n;++i){\\n            rsum=rsum-grid[0][i];\\n            ans=min(ans, max(rsum, lsum));\\n            lsum=lsum+grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536277,
                "title": "c-solution-explanation-with-diagram-o-1",
                "content": "The Basic idea of this problem is to think about index at which robot-1 change his line\\nIf we see all possible way of robot-1 \\n\\n![image](https://assets.leetcode.com/users/images/663f558b-ba6c-4cad-88c9-9d4b3d649039_1634987801.2539265.png)\\n\\nWe can clearly observe that robot-2 can collect points either from row-1 or from row-2\\nSo we will explore all possible path of robot-1 and will calculate points of robot-2\\n\\n\\'\\'\\'\\n    \\n\\tlong long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        \\n        long long first=0, second=0,res= LLONG_MAX;;\\n        for(int i=n-1;i>-1;--i){\\n            first += grid[0][i];\\n        }\\n        \\n\\n        for(int i=0;i<n;++i){\\n            first-=grid[0][i];\\n            res=min(res, max(first,second));\\n            second+=grid[1][i];\\n        }\\n        return res;\\n    }\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "The Basic idea of this problem is to think about index at which robot-1 change his line\\nIf we see all possible way of robot-1 \\n\\n![image](https://assets.leetcode.com/users/images/663f558b-ba6c-4cad-88c9-9d4b3d649039_1634987801.2539265.png)\\n\\nWe can clearly observe that robot-2 can collect points either from row-1 or from row-2\\nSo we will explore all possible path of robot-1 and will calculate points of robot-2\\n\\n\\'\\'\\'\\n    \\n\\tlong long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        \\n        long long first=0, second=0,res= LLONG_MAX;;\\n        for(int i=n-1;i>-1;--i){\\n            first += grid[0][i];\\n        }\\n        \\n\\n        for(int i=0;i<n;++i){\\n            first-=grid[0][i];\\n            res=min(res, max(first,second));\\n            second+=grid[1][i];\\n        }\\n        return res;\\n    }\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1518426,
                "title": "practice-dp-solution-that-would-work-if-a-wasn-t-an-a-hole",
                "content": "Note:  **Dynamic-Programming approach does not work for this problem.** The idea behind a DP approach is to let Robot A go first, get the highest score it can get and then reduce all the grid-cells it passed through to 0. Then let Robot B go and get the highest score it can get. (the code below) But the question wants Robot A to minimize B\\'s score; even if that means A itself doesn\\'t get the most optimal score. These posts ([link1](https://leetcode.com/problems/grid-game/discuss/1486340/C%2B%2BJavaPython-Robot1-Minimize-TopSum-and-BottomSum-of-Robot-2-Picture-Explained), [link2](https://leetcode.com/problems/grid-game/discuss/1486399/Can-anyone-explain-one-of-the-LC-Test-cases)) do a great job of  expaining the difference with edge cases.\\n\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        As = self.get_best_score_n_path(grid)\\n        A_path, A_score = As[0], As[1]\\n\\t\\t# now we have the path and score for robot A. We have to empty all the cells that A visited to get max score\\n        for cell in A_path:\\n            row,col = cell\\n            grid[row][col] = 0\\n        Bs = self.get_best_score_n_path(grid)\\n        return Bs[1]\\n        \\n    def get_best_score_n_path(self, grid):\\n        rl, cl = len(grid), len(grid[0])\\n        dp = [[[[(row,col)],grid[row][col]] for col in range(cl)] for row in range(rl)] \\n        # each cell in dp grid = [(row1,col1),(row2,col2)], score_till_now (i.e. path and score)\\n        for row in range(rl):\\n            for col in range(cl):\\n                if row > 0 and col > 0:\\n                    above_score = dp[row-1][col][1]\\n                    left_score = dp[row][col-1][1]\\n                    if above_score >= left_score:    # this leads to the optimal path\\n                        dp[row][col][1] = grid[row][col]+above_score\\n                        dp[row][col][0] += dp[row-1][col][0]\\n                    else:\\n                        dp[row][col][1] = grid[row][col]+left_score\\n                        dp[row][col][0] += dp[row][col-1][0]\\n                elif row > 0 and col == 0: # leftmost col\\n                    above_score = dp[row-1][col][1]\\n                    dp[row][col][1] = grid[row][col]+above_score\\n                    dp[row][col][0] += dp[row-1][col][0]\\n                elif row == 0 and col > 0: # topmost col\\n                    left_score = dp[row][col-1][1]\\n                    dp[row][col][1] = grid[row][col]+left_score\\n                    dp[row][col][0] += dp[row][col-1][0]\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "Note:  **Dynamic-Programming approach does not work for this problem.** The idea behind a DP approach is to let Robot A go first, get the highest score it can get and then reduce all the grid-cells it passed through to 0. Then let Robot B go and get the highest score it can get. (the code below) But the question wants Robot A to minimize B\\'s score; even if that means A itself doesn\\'t get the most optimal score. These posts ([link1](https://leetcode.com/problems/grid-game/discuss/1486340/C%2B%2BJavaPython-Robot1-Minimize-TopSum-and-BottomSum-of-Robot-2-Picture-Explained), [link2](https://leetcode.com/problems/grid-game/discuss/1486399/Can-anyone-explain-one-of-the-LC-Test-cases)) do a great job of  expaining the difference with edge cases.\\n\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        As = self.get_best_score_n_path(grid)\\n        A_path, A_score = As[0], As[1]\\n\\t\\t# now we have the path and score for robot A. We have to empty all the cells that A visited to get max score\\n        for cell in A_path:\\n            row,col = cell\\n            grid[row][col] = 0\\n        Bs = self.get_best_score_n_path(grid)\\n        return Bs[1]\\n        \\n    def get_best_score_n_path(self, grid):\\n        rl, cl = len(grid), len(grid[0])\\n        dp = [[[[(row,col)],grid[row][col]] for col in range(cl)] for row in range(rl)] \\n        # each cell in dp grid = [(row1,col1),(row2,col2)], score_till_now (i.e. path and score)\\n        for row in range(rl):\\n            for col in range(cl):\\n                if row > 0 and col > 0:\\n                    above_score = dp[row-1][col][1]\\n                    left_score = dp[row][col-1][1]\\n                    if above_score >= left_score:    # this leads to the optimal path\\n                        dp[row][col][1] = grid[row][col]+above_score\\n                        dp[row][col][0] += dp[row-1][col][0]\\n                    else:\\n                        dp[row][col][1] = grid[row][col]+left_score\\n                        dp[row][col][0] += dp[row][col-1][0]\\n                elif row > 0 and col == 0: # leftmost col\\n                    above_score = dp[row-1][col][1]\\n                    dp[row][col][1] = grid[row][col]+above_score\\n                    dp[row][col][0] += dp[row-1][col][0]\\n                elif row == 0 and col > 0: # topmost col\\n                    left_score = dp[row][col-1][1]\\n                    dp[row][col][1] = grid[row][col]+left_score\\n                    dp[row][col][0] += dp[row][col-1][0]\\n        return dp[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1488801,
                "title": "using-prefix-sum-and-suffix-sums",
                "content": "See the grid has only two rows , so we don\\'t have too many options as  the question says that we can only move to right or down:\\nlet\\'s take for example as the grid below:\\n|  1     |   50  |     200  |    60 |\\n|  40   |  100 |      70   |     3  |\\n\\nremember: we can move to down or right only, I don\\'t need to get the maxmum score but has to give opponent the minimum possible score\\n\\nIf I start first , then I can follow \\n1)the path 1->50->200->60->3,   which will make the opponent\\'s score 40+100+70 as we wants to maximise the score\\n2)the path 1->50->200->70->3,   now opponent can take either 60 or 40+100, as he wants to maximise the score , so he takes 140\\n3)the path 1->50->100->70->3, now opponent can take either 40 or 200+60, as he wants to maximise the score so he takes 260\\n4)the path 1->40->100->70->3, now opponent can take either 0 or 50+200+60, as he wants to maximise the score so he takes 310\\n, \\nnotice in the cases above 140 is the minimum possible maximum score I can give to the opponent if I play optimally\\n\\n\\nThis example was I think enough to explain the question, now come to the actual thing, \\n\\nwhat actually opponent gets, the opponent takes either some colomuns of below row or some columns of above row , which gives us an idea to use prefix and suffix sum techniques,\\n\\n\\nthe code is simple and understandable ( I suppose):\\nthe line: ans=min(ans,max(pre[i],suf[i+2])); means we are minimising the maximum possible sum that can be taken by the opponent\\n```\\n long long gridGame(vector<vector<int>>&grid){\\n        int n=grid[0].size();\\n        long long pre[n];\\n        pre[0]=grid[1][0];\\n        for(int i=1;i+1<n;i++){\\n            pre[i]=pre[i-1]+grid[1][i];\\n        }\\n        long long suf[n];\\n        suf[n-1]=grid[0][n-1];\\n        \\n        for(int i=n-2;i>=1;i--){\\n            suf[i]=suf[i+1]+grid[0][i];\\n        }\\n        long long ans=0;\\n        \\n        long long upper=0; \\n        for(int i=1;i<=n-1;i++){\\n         \\n            upper+=grid[0][i];\\n        }\\n \\n\\n        long long lower=0;\\n        for(int i=0;i<n-1;i++){\\n            lower+=grid[1][i];\\n        }\\n   \\n       ans=min(lower,upper);\\n          for(int i=0;i<n-2;i++){\\n            \\n            ans=min(ans,max(pre[i],suf[i+2]));\\n        }\\n        \\n        return ans;\\n        \\n }\\n ```\\n\\nIf something is confusing you can ask me in the comments",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n long long gridGame(vector<vector<int>>&grid){\\n        int n=grid[0].size();\\n        long long pre[n];\\n        pre[0]=grid[1][0];\\n        for(int i=1;i+1<n;i++){\\n            pre[i]=pre[i-1]+grid[1][i];\\n        }\\n        long long suf[n];\\n        suf[n-1]=grid[0][n-1];\\n        \\n        for(int i=n-2;i>=1;i--){\\n            suf[i]=suf[i+1]+grid[0][i];\\n        }\\n        long long ans=0;\\n        \\n        long long upper=0; \\n        for(int i=1;i<=n-1;i++){\\n         \\n            upper+=grid[0][i];\\n        }\\n \\n\\n        long long lower=0;\\n        for(int i=0;i<n-1;i++){\\n            lower+=grid[1][i];\\n        }\\n   \\n       ans=min(lower,upper);\\n          for(int i=0;i<n-2;i++){\\n            \\n            ans=min(ans,max(pre[i],suf[i+2]));\\n        }\\n        \\n        return ans;\\n        \\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486298,
                "title": "very-simple-linear-solution-with-full-explanation-and-diagram-prefix-sum",
                "content": "**Let Robot 1 be alice and robot 2 be bob. for more cleareance**\\n\\n![image](https://assets.leetcode.com/users/images/01d7d500-3912-46b7-a28f-a609573465f7_1632628049.3205893.png)\\n\\nThe path clearly separates the field into two independent pieces \\u2014 suffix of the first row and the prefix of the second row. Bob can\\'t grab the coins from both of them at once. However, he can grab either of them fully. So the optimal path for him will be one of these two options.\\n\\nYou can precalculate some prefix sums and become able to get the Bob\\'s score given the Alice\\'s path. Alice has m possibly paths, so you can iterate over them and choose the minimum answer.\\n\\nHowever, prefix sums are not required, since you can quickly recalculate both needed sums while iterating over the Alice\\'s column to go down in.\\n\\nOverall complexity: O(m) per testcase.\\n\\n**Java Solution**\\n```\\n public long gridGame(int[][] arr) {\\n            \\n     int m = arr[0].length;\\n        \\n         long[] pre1 = new long[m + 1];\\n        long[] pre2 = new long[m + 1];\\n        for (int i = 1; i <= m; i++) {\\n            pre1[i] = pre1[i - 1] + arr[0][i - 1];\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre2[i] = pre2[i - 1] + arr[1][i - 1];\\n        }\\n        long res = Long.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            res = Math.min(res, Math.max(pre1[m] - pre1[i + 1], pre2[i]));\\n        }\\n \\n      return res;  \\n \\n        \\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n public long gridGame(int[][] arr) {\\n            \\n     int m = arr[0].length;\\n        \\n         long[] pre1 = new long[m + 1];\\n        long[] pre2 = new long[m + 1];\\n        for (int i = 1; i <= m; i++) {\\n            pre1[i] = pre1[i - 1] + arr[0][i - 1];\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre2[i] = pre2[i - 1] + arr[1][i - 1];\\n        }\\n        long res = Long.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            res = Math.min(res, Math.max(pre1[m] - pre1[i + 1], pre2[i]));\\n        }\\n \\n      return res;  \\n \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486268,
                "title": "python-o-n-prefix-suffix-sum-with-explanation",
                "content": "Logic:\\n\\n* The constraints state that there are exactly 2 rows in the grid.\\n\\n* Therefore, player1 must go down in the grid at somepoint and only once. \\n\\n* Because Player1 must go down in the grid. If Player1 decides to go down at index i, this leaves all the indexes i+1 onwards open for the taking in the first row.\\n\\n * Conversely, if player1 goes down in the grid at point i, this will leave all the indexes from 0 to i-1 open for the taking on the second row (They cannot move left). \\n \\n * Therefore if we have an example where player1 decides to move downwards in the grid at index 5, we can calculate the max score of player2 as max(suffix[5], prefix[5]). Where the suffix is them choosing to take the remaining elements on the top row, and the prefix is them choosing to take the remaining elements left on the second row.\\n\\n---\\n\\nPopulate a prefix and a suffix array and then iterate through. Player2 will be attempting to take the max of the prefix/suffix sum at index i, and player1 will be attempting to minimize this amount for all the possibilities.\\n\\nHopefully the code makes it more clear.\\n\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        \\n        #Populate a suffix sum array\\n        suffix = [ele for ele in grid[0]]\\n        suffixSum = 0\\n        for i in range(len(suffix)-1,-1,-1):\\n            suffix[i] = suffixSum\\n            suffixSum += grid[0][i]\\n            \\n            \\n        #Populate a prefix sum array\\n        prefix = [ele for ele in grid[1]]\\n        prefixSum = 0\\n        for i in range(len(prefix)):\\n            prefix[i] = prefixSum\\n            prefixSum += grid[1][i] \\n            \\n        #Want the lowest of the worst-case scenerio.\\n        #Player 2 will attempt to pick the biggest of prefix[i] or suffix[i].\\n        #Player 1 will attempt to pick the case that will minimize this.\\n        lowest = float(\"inf\")\\n        for i in range(len(prefix)):\\n            lowest = min(lowest, max(prefix[i], suffix[i]))\\n            \\n        return lowest\\n```\\n\\nTime: O(N)\\nSpace: O(N)\\n\\nCan be optimized to O(1) with sliding count for prefix/suffix, no need for Prefix/Suffix array in that case.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        \\n        #Populate a suffix sum array\\n        suffix = [ele for ele in grid[0]]\\n        suffixSum = 0\\n        for i in range(len(suffix)-1,-1,-1):\\n            suffix[i] = suffixSum\\n            suffixSum += grid[0][i]\\n            \\n            \\n        #Populate a prefix sum array\\n        prefix = [ele for ele in grid[1]]\\n        prefixSum = 0\\n        for i in range(len(prefix)):\\n            prefix[i] = prefixSum\\n            prefixSum += grid[1][i] \\n            \\n        #Want the lowest of the worst-case scenerio.\\n        #Player 2 will attempt to pick the biggest of prefix[i] or suffix[i].\\n        #Player 1 will attempt to pick the case that will minimize this.\\n        lowest = float(\"inf\")\\n        for i in range(len(prefix)):\\n            lowest = min(lowest, max(prefix[i], suffix[i]))\\n            \\n        return lowest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495767,
                "title": "c-prefix-sum-approach",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.Why are we not able to use DP for max path sum from (0,0) --> (1,m-1) ?\\n* Since along with increasing Robot 1 points, we need to optimally reduce Robot 2 points also.\\n\\n2.If Robot 1 comes to 1st row, it cannot come to 0th row, so we need to find optimal index where Robot 1 can step down\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    ll int getMax(ll int a, ll int b){\\n        if(a>=b) return a;\\n        return b;\\n    }\\n    ll int getMin(ll int a, ll int b){\\n        if(a>b) return b;\\n        return a;\\n    }\\n    \\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        \\n        ll int pre[2][m]; // storing pre-sum for row 0 , and row 1\\n        pre[0][0]=grid[0][0], pre[1][0]=grid[1][0];\\n        for(int i=1;i<m;i++){\\n            pre[0][i]=pre[0][i-1]+grid[0][i];\\n            pre[1][i]=pre[1][i-1]+grid[1][i];\\n        }\\n        \\n        ll int ans=LLONG_MAX; // score of Robot 2 which Robot 1 wants to minimize\\n        for(int i=0;i<m;i++){ // i = index at which Robot 1 steps down\\n            ll int top=pre[0][m-1]-pre[0][i];\\n            ll int bottom=(i==0 ? 0:pre[1][i-1]);\\n            \\n            ans=getMin(ans,getMax(top,bottom));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    ll int getMax(ll int a, ll int b){\\n        if(a>=b) return a;\\n        return b;\\n    }\\n    ll int getMin(ll int a, ll int b){\\n        if(a>b) return b;\\n        return a;\\n    }\\n    \\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        \\n        ll int pre[2][m]; // storing pre-sum for row 0 , and row 1\\n        pre[0][0]=grid[0][0], pre[1][0]=grid[1][0];\\n        for(int i=1;i<m;i++){\\n            pre[0][i]=pre[0][i-1]+grid[0][i];\\n            pre[1][i]=pre[1][i-1]+grid[1][i];\\n        }\\n        \\n        ll int ans=LLONG_MAX; // score of Robot 2 which Robot 1 wants to minimize\\n        for(int i=0;i<m;i++){ // i = index at which Robot 1 steps down\\n            ll int top=pre[0][m-1]-pre[0][i];\\n            ll int bottom=(i==0 ? 0:pre[1][i-1]);\\n            \\n            ans=getMin(ans,getMax(top,bottom));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492424,
                "title": "javascript-10-lines-solution-85-88",
                "content": "Runtime: 112 ms, faster than 85.19% of JavaScript online submissions for Grid Game.\\nMemory Usage: 51 MB, less than 88.89% of JavaScript online submissions for Grid Game.\\n```\\nvar gridGame = function(grid) {\\n    let one = grid[0].reduce((a,b)=>a+b) - grid[0][0];\\n    let two = 0;\\n    let res = one;\\n    for(let i = 1; i < grid[0].length; i++){\\n        one-=grid[0][i];\\n        two+=grid[1][i-1];\\n        res = Math.min(res, Math.max(one,two));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar gridGame = function(grid) {\\n    let one = grid[0].reduce((a,b)=>a+b) - grid[0][0];\\n    let two = 0;\\n    let res = one;\\n    for(let i = 1; i < grid[0].length; i++){\\n        one-=grid[0][i];\\n        two+=grid[1][i-1];\\n        res = Math.min(res, Math.max(one,two));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486986,
                "title": "prefix-sum-idea-thought-process-c",
                "content": "First of all, the problem is not like this that if player A chooses max points then player B will choose min points (This is wrong)\\nNote : Main motive is not to maximize the player A points but to minimize the player B points and yes both are different. The Difference is as shown in below figure :\\n\\n![](https://assets.leetcode.com/users/images/50cec0b8-9d95-4ea9-823b-6ed83bbf2e8b_1632631825.0099034.png)\\n\\n[[20 3 20 17 2 12 15 17 4 15],[20 10 13 14 15 5 2 3 14 3]]\\nAs per the given example to achieve max points player A chooses that path(choosing maximum sum path), what if player A has chosen other path something like shown in the figure (try other paths once)\\nThen player B will be left with only two choices either to select down left part or up right path (as there are only two possible paths right and down) .\\nSo the optimal path of player A for above example is \\n\\n[[0     0    0     0    0  12  15  17   4   15]  [20  10  13   14   0   0    0    0    0   0]]\\n               \\nnow the only paths left for player B is either bottom left or top right now as he plays optimally he will choose top right which gives his sum as 63.\\n\\n\\nHint : Prefix may help to solve the problem.\\n\\n\\nCode :\\n``` \\nlong long gridGame(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<long long>up(m,0);            // to store prefix sum of upper row\\n        vector<long long>down(m,0);       // to store prefix sum of lower row\\n\\n        up[m-1]=grid[0][m-1];\\n        down[0]=grid[1][0];\\n\\n        for(int i=m-2;i>=0;i--){\\n            up[i]=up[i+1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            down[i]=down[i-1]+grid[1][i];\\n        }\\n\\n        long long ans=LLONG_MAX;\\n        for(int i=0;i+2<m;i++){\\n            long long temp=max(down[i],up[i+2]);      // player B wants to choose maximum of both paths\\n            ans=min(ans,temp);                                   // But player A forces B to choose only minimum path\\n        }\\n\\n        long long temp=up[1];\\n        ans=min(ans,temp);\\n        temp=down[m-2];\\n        ans=min(ans,temp);\\n        return ans;\\n    }\\n\\n```\\n\\n\\nNote : The method of choosing maximum path may work if there is a chance of moving in all directions.\\nFeel free to mention any doubts and do upvote if it helps :)",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "``` \\nlong long gridGame(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<long long>up(m,0);            // to store prefix sum of upper row\\n        vector<long long>down(m,0);       // to store prefix sum of lower row\\n\\n        up[m-1]=grid[0][m-1];\\n        down[0]=grid[1][0];\\n\\n        for(int i=m-2;i>=0;i--){\\n            up[i]=up[i+1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            down[i]=down[i-1]+grid[1][i];\\n        }\\n\\n        long long ans=LLONG_MAX;\\n        for(int i=0;i+2<m;i++){\\n            long long temp=max(down[i],up[i+2]);      // player B wants to choose maximum of both paths\\n            ans=min(ans,temp);                                   // But player A forces B to choose only minimum path\\n        }\\n\\n        long long temp=up[1];\\n        ans=min(ans,temp);\\n        temp=down[m-2];\\n        ans=min(ans,temp);\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486349,
                "title": "python-easy",
                "content": "```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        \\n        top, bottom = grid\\n        top_sum = sum(top)\\n        bottom_sum = 0\\n        res = float(\\'inf\\')\\n        \\n        for i in range(len(top)):\\n            top_sum -= top[i]\\n            res = min(res, max(top_sum, bottom_sum))\\n            bottom_sum += bottom[i]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        \\n        top, bottom = grid\\n        top_sum = sum(top)\\n        bottom_sum = 0\\n        res = float(\\'inf\\')\\n        \\n        for i in range(len(top)):\\n            top_sum -= top[i]\\n            res = min(res, max(top_sum, bottom_sum))\\n            bottom_sum += bottom[i]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486339,
                "title": "why-is-dfs-not-working",
                "content": "For test case: ```[[19,8,1,11,12],[17,6,1,1,7]]```. From DFS, I think \\n```\\n0  0  0 0 0 \\n17 6  1 1 0 \\n```\\nis the optimal solution for the first robot, so the second robot can get 25 points. But the OJ keeps telling me 23 is the correct solution. I have no clue...any help will be great. Thanks in advance!",
                "solutionTags": [],
                "code": "```[[19,8,1,11,12],[17,6,1,1,7]]```\n```\\n0  0  0 0 0 \\n17 6  1 1 0 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784706,
                "title": "java-o-n-faster-than-96-01",
                "content": "# Approach\\nCalculate postfix sum for first row and prefix sum for second row and then use it as a guid for first robot to find the optimal path then store the index where first robot changes its path from first row to second row and then we can calculate the optimal way of robot two. \\n    Read the code for better understanding.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n\\n        if(grid[0].length == 1)\\n            return 0;\\n\\n        long[] postfix = new long[grid[0].length];\\n        long[] prefix = new long[grid[1].length];\\n        \\n        postfix[grid[0].length - 1] = grid[0][grid[0].length - 1];\\n\\n        for(int i = grid[0].length - 2; i >= 0; i--)\\n            postfix[i] = postfix[i+1]+grid[0][i];\\n\\n        prefix[0] = grid[1][0];\\n\\n        for(int i = 1; i < grid[0].length; i++)\\n            prefix[i] = prefix[i-1] + grid[1][i];\\n\\n        int index = 0;\\n\\n        for(int i = 0; i < grid[0].length; i++){\\n            if(i == grid[0].length - 1){\\n                index = i;\\n                break;\\n            }\\n            if(postfix[i+1] < prefix[i]){\\n                index = i;\\n                break;    \\n            }\\n        }\\n\\n        if(index == grid[0].length - 1)\\n            return prefix[index-1];\\n\\n        if(index == 0)\\n            return postfix[index+1];\\n\\n        return Math.max(postfix[index+1], prefix[index-1]);\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n\\n        if(grid[0].length == 1)\\n            return 0;\\n\\n        long[] postfix = new long[grid[0].length];\\n        long[] prefix = new long[grid[1].length];\\n        \\n        postfix[grid[0].length - 1] = grid[0][grid[0].length - 1];\\n\\n        for(int i = grid[0].length - 2; i >= 0; i--)\\n            postfix[i] = postfix[i+1]+grid[0][i];\\n\\n        prefix[0] = grid[1][0];\\n\\n        for(int i = 1; i < grid[0].length; i++)\\n            prefix[i] = prefix[i-1] + grid[1][i];\\n\\n        int index = 0;\\n\\n        for(int i = 0; i < grid[0].length; i++){\\n            if(i == grid[0].length - 1){\\n                index = i;\\n                break;\\n            }\\n            if(postfix[i+1] < prefix[i]){\\n                index = i;\\n                break;    \\n            }\\n        }\\n\\n        if(index == grid[0].length - 1)\\n            return prefix[index-1];\\n\\n        if(index == 0)\\n            return postfix[index+1];\\n\\n        return Math.max(postfix[index+1], prefix[index-1]);\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652636,
                "title": "c-single-pass-constant-space-solution-100-time-72ms-100-space",
                "content": "This was really an outstanding problem, since it led me to think in more than a way.\\n\\nLike probably many others, I started writing code that was maximising what robot1 would have harvested, assuming that would have led to robot2 taking only the smallest leftovers that way, but I was wrong (and unnecessarily convoluted).\\n\\nTurns out that the core part of this problem is, as I initially figured out correctly, to find where we go down, from the first to the second row.\\n\\nFrom there, we can assume that robot2 can either take all the cells left on the upper right part of the grid from where we went down with the robot1 or the lower left part of it.\\n\\nIn other words, we will always end up with something like this:\\n\\n```cpp\\n  0   1   2  ... i-2 i-1   i i+1 i+2  ... n-2 n-1   n\\n r1  r1  r1  ...  r1  r1  r1  p1  p1  ...  p1  p1  p1\\n p2  p2  p2  ...  p2  p2  r1  r1  r1  ...  r1  r1  r1\\n```\\nIn other words, for index `i`, we will have to pick the best move for robot2 among the sum of all the `p1` values of the first possibile option in the top right sector versus the sum of all the values `p2` from the second optionin the bottom left sector.\\n\\nWe might be tempted to go for a dynamic programming solution, storing all the prefix and suffix sums we might find this way in the upper and lower rows, but if we notice that we are just using each one of them at a time to both find our result and generate the next, all that we really need is two variables.\\n\\nWith this in mind, we can easily proceed to turn the idea into code, starting with a few support variables (all `long`, to avoid overflow, but not `long long` as in the unnecessary signature of the function, since we will never get such large values, given the constraints):\\n* `up` will be the sum of all the elements in the upper row right of `i`, initially set to be the sum of all the elements in `grid[0]` but the first (I know, this technically makes my solution not really a single pass, but cut me some slack);\\n* `down` will be the sum of all the elements in the lower row left of `i`, initially set to be `0`;\\n* `res`, initially set to be `up`.\\n\\nWe will then parse all the elements in `grid` starting from the second with `i` (initialised with the matching index `1`, since we already did the very first case while initialising our values) and:\\n* decrease `up` by the value of the matching cell in the upper row, `grid[0][i]`;\\n* increase `down` by the value of the previous cell in the lower row, `grid[1][i - 1]`;\\n* find the best option for robot2 (`max(up, down)`) and then take the minimum between that and the current value of `res`, since robot1 plays an adverse game and wants to reduce that.\\n\\nOnce done, we can `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        // support variables\\n        long up = accumulate(begin(grid[0]) + 1, end(grid[0]), 0l), down = 0, res = up;\\n        // turning grid into its incremental sum equivalent from the right\\n        for (int i = 1, lmt = grid[0].size(); i < len; i++) {\\n            up -= grid[0][i], down += grid[1][i - 1];\\n            res = min(res, max(up, down));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/8b5dadb2-1fba-4758-a4d8-86335e32cf39_1640695529.6240926.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\n  0   1   2  ... i-2 i-1   i i+1 i+2  ... n-2 n-1   n\\n r1  r1  r1  ...  r1  r1  r1  p1  p1  ...  p1  p1  p1\\n p2  p2  p2  ...  p2  p2  r1  r1  r1  ...  r1  r1  r1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        // support variables\\n        long up = accumulate(begin(grid[0]) + 1, end(grid[0]), 0l), down = 0, res = up;\\n        // turning grid into its incremental sum equivalent from the right\\n        for (int i = 1, lmt = grid[0].size(); i < len; i++) {\\n            up -= grid[0][i], down += grid[1][i - 1];\\n            res = min(res, max(up, down));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490210,
                "title": "python-3-one-line-faster-than-99",
                "content": "# Explanation\\n\\nTake the example:\\n```\\n[[1,2,3,4],\\n [5,6,7,8]]\\n```\\nThen we want to return the smallest of the largest paths of:\\n```\\n[[0,2,3,4],\\n [0,0,0,0]]\\n,\\n[[0,0,3,4],\\n [5,0,0,0]]\\n,\\n[[0,0,0,4],\\n [5,6,0,0]]\\n,\\n[[0,0,0,0],\\n [5,6,7,0]]\\n```\\n\\nThat\\'s to say, for each of the above, we want to take the max of the sums of the two arrays, and return the min of these results.\\n\\nWhich is:\\n```\\nA[0] = [1,2,3,4]\\nA[1] = [5,6,7,8]\\n\\nmin(\\n  max(sum([2,3,4]), sum([]))\\n  max(sum([3,4]), sum([5]))\\n  max(sum([4]), sum([5,6]))\\n  max(sum([]), sum([5,6,7]))\\n)\\n```\\n\\nSo then we just need to produce:\\n * `(2+3+4, 3+4, 4, 0)`\\n * `(0, 5, 5+6, 5+6+7)`\\n\\nWe can do this in O(n) time and O(1) space by using `accumulate` twice:\\n* `map(sub, repeat(sum(A[0])), accumulate(A[0]))`\\n\\t* produces `(10-1, 10-1-2, 10-1-2-3, 10-1-2-3-4)` == `(2+3+4, 3+4, 4, 0)`\\n\\t* alternately, we could instead have: `islice(accumulate(A[0], sub, initial=sum(A)), 1, None)`, which might be slightly faster\\n* `accumulate(A[1], initial=0)`\\n\\t* produces `(0, 5, 5+6, 5+6+7, 5+6+7+8)` \\n\\t* This will produce an extra value, but we don\\'t care, because `map` will ignore it\\n\\nSo then we max each pair of values produced by these two, then min all the results.\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n\\n# Code\\n\\n```\\nclass Solution:\\n  def gridGame(self, A: List[List[int]]) -> int:\\n    return min(map(max, accumulate(A[1], initial=0), map(sub, repeat(sum(A[0])), accumulate(A[0]))))\\n```\\n\\nAnd damn, it\\'s fast...\\n\\n![image](https://assets.leetcode.com/users/images/c642e21d-0486-4555-8d26-6100128fcf6f_1632783569.0710473.png)\\n",
                "solutionTags": [],
                "code": "```\\n[[1,2,3,4],\\n [5,6,7,8]]\\n```\n```\\n[[0,2,3,4],\\n [0,0,0,0]]\\n,\\n[[0,0,3,4],\\n [5,0,0,0]]\\n,\\n[[0,0,0,4],\\n [5,6,0,0]]\\n,\\n[[0,0,0,0],\\n [5,6,7,0]]\\n```\n```\\nA[0] = [1,2,3,4]\\nA[1] = [5,6,7,8]\\n\\nmin(\\n  max(sum([2,3,4]), sum([]))\\n  max(sum([3,4]), sum([5]))\\n  max(sum([4]), sum([5,6]))\\n  max(sum([]), sum([5,6,7]))\\n)\\n```\n```\\nclass Solution:\\n  def gridGame(self, A: List[List[int]]) -> int:\\n    return min(map(max, accumulate(A[1], initial=0), map(sub, repeat(sum(A[0])), accumulate(A[0]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487710,
                "title": "java-simple-solution-prefix-sum",
                "content": "**107 / 107 test cases passed.\\nStatus: Accepted\\nRuntime: 4 ms\\nMemory Usage: 54.1 MB**\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long preRow1[] = new long[n];\\n        long preRow2[] = new long[n];\\n        \\n        preRow1[0] = grid[0][0];\\n        preRow2[0] = grid[1][0];\\n        \\n        for(int i = 1;i<n;i++){\\n            preRow1[i] += (long)preRow1[i-1] + (long)grid[0][i];\\n            preRow2[i] += (long)preRow2[i-1] + (long)grid[1][i];\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i = 0;i<n;i++){\\n            long top = preRow1[n-1] - preRow1[i];\\n            long bottom = i == 0 ? 0 : preRow2[i-1];\\n            long temp = Math.max(top,bottom);\\n            res = Math.min(res,temp);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long preRow1[] = new long[n];\\n        long preRow2[] = new long[n];\\n        \\n        preRow1[0] = grid[0][0];\\n        preRow2[0] = grid[1][0];\\n        \\n        for(int i = 1;i<n;i++){\\n            preRow1[i] += (long)preRow1[i-1] + (long)grid[0][i];\\n            preRow2[i] += (long)preRow2[i-1] + (long)grid[1][i];\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i = 0;i<n;i++){\\n            long top = preRow1[n-1] - preRow1[i];\\n            long bottom = i == 0 ? 0 : preRow2[i-1];\\n            long temp = Math.max(top,bottom);\\n            res = Math.min(res,temp);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486276,
                "title": "c-prefix-sum-o-n-solution",
                "content": "![image](https://assets.leetcode.com/users/images/13386394-d6b2-43fb-a7d5-abf7bd2d1d44_1632628567.9631703.png)\\nWe know that the first person will go down only one time, so for every time he go down, we just need to find `max(blueSum, greenSum)` and get the minimum answer from all these maximum number.\\n\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& _grid) {\\n        long long n = _grid[0].size();\\n        vector<vector<long long> > grid(2, vector<long long>(n));\\n        for(int i = 0; i < n; i++) {\\n            grid[0][i] = _grid[0][i];\\n            grid[1][i] = _grid[1][i];\\n        }\\n        long long ans = 1e18;\\n        for(int i = 1; i < n; i++) {\\n            grid[0][i] += grid[0][i - 1];\\n            grid[1][i] += grid[1][i - 1];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            ans = min(ans, max(grid[0].back() - grid[0][i], i > 0 ? grid[1][i - 1] : 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& _grid) {\\n        long long n = _grid[0].size();\\n        vector<vector<long long> > grid(2, vector<long long>(n));\\n        for(int i = 0; i < n; i++) {\\n            grid[0][i] = _grid[0][i];\\n            grid[1][i] = _grid[1][i];\\n        }\\n        long long ans = 1e18;\\n        for(int i = 1; i < n; i++) {\\n            grid[0][i] += grid[0][i - 1];\\n            grid[1][i] += grid[1][i - 1];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            ans = min(ans, max(grid[0].back() - grid[0][i], i > 0 ? grid[1][i - 1] : 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486273,
                "title": "c-prefix-sum-o-n-space",
                "content": "\\n![image](https://assets.leetcode.com/users/images/682c0a5a-d9b7-4267-b958-b6e9896cf270_1632630031.2033598.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        vector<int> a,b;\\n        long long n=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back(grid[0][i]);\\n            b.push_back(grid[1][i]);\\n        }\\n        long long suma=accumulate(a.begin(),a.end(),0ll);\\n        long long sumb=accumulate(b.begin(),b.end(),0ll);\\n        vector<long long> left(n),right(n);\\n        left[0]=a[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=left[i-1]+a[i];\\n        right[n-1]=b[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=right[i+1]+b[i];\\n        long long score=LONG_MAX;\\n        long long t;\\n        for(int i=0;i<n;i++)\\n        {\\n            t=max(suma-left[i],sumb-right[i]);\\n            score=min(score,(long long)t);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        vector<int> a,b;\\n        long long n=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back(grid[0][i]);\\n            b.push_back(grid[1][i]);\\n        }\\n        long long suma=accumulate(a.begin(),a.end(),0ll);\\n        long long sumb=accumulate(b.begin(),b.end(),0ll);\\n        vector<long long> left(n),right(n);\\n        left[0]=a[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=left[i-1]+a[i];\\n        right[n-1]=b[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=right[i+1]+b[i];\\n        long long score=LONG_MAX;\\n        long long t;\\n        for(int i=0;i<n;i++)\\n        {\\n            t=max(suma-left[i],sumb-right[i]);\\n            score=min(score,(long long)t);\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977921,
                "title": "prefix-sum-easy-c-image-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**Which path robot-1 will choose to minimize the score of robot-2..?**\\n\\n![image.png](https://assets.leetcode.com/users/images/7bfb2840-863e-4925-acf2-0f2edf43ef60_1693336099.0986753.png)\\nAs we can see path-4 will reduce the score of robot-2.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& mat) {\\n\\n        long long n = mat[0].size(),ans = LONG_MAX;\\n        long long row0 = 0,row1 = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        { \\n            row0+=mat[0][i];\\n            row1+=mat[1][i]; \\n        }\\n        row0+=mat[1][n-1];\\n        row1-=mat[1][n-1];\\n\\n        long long score = 0,sum0 = 0,sum1 = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            long long c1 = sum1;\\n            long long c2 = row0-sum0-mat[1][n-1]-mat[0][i];\\n            long long score = max(c1,c2);\\n            ans = min(ans,score);\\n            sum0+=mat[0][i];\\n            sum1+=mat[1][i];\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n[]()![upvote.jpg](https://assets.leetcode.com/users/images/f8e48ae0-803a-460c-8359-0984d008c536_1693336343.284094.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& mat) {\\n\\n        long long n = mat[0].size(),ans = LONG_MAX;\\n        long long row0 = 0,row1 = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        { \\n            row0+=mat[0][i];\\n            row1+=mat[1][i]; \\n        }\\n        row0+=mat[1][n-1];\\n        row1-=mat[1][n-1];\\n\\n        long long score = 0,sum0 = 0,sum1 = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            long long c1 = sum1;\\n            long long c2 = row0-sum0-mat[1][n-1]-mat[0][i];\\n            long long score = max(c1,c2);\\n            ans = min(ans,score);\\n            sum0+=mat[0][i];\\n            sum1+=mat[1][i];\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541953,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long prev[]=new long[n];\\n        long suf[] = new long[n];\\n        for(int i = 1;i<n;i++)\\n            prev[i]=prev[i-1]+grid[0][i];\\n        for(int i =n-2;i>=0;i--)\\n            suf[i]=grid[1][i]+suf[i+1];\\n        long ans=Math.min(prev[n-1],suf[0]);\\n        for(int i=1;i<n-1;i++){\\n            long cur=Math.max(prev[n-1]-prev[i],suf[0]-suf[i]);\\n            if(cur>0)\\n            ans=Math.min(ans,cur);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long prev[]=new long[n];\\n        long suf[] = new long[n];\\n        for(int i = 1;i<n;i++)\\n            prev[i]=prev[i-1]+grid[0][i];\\n        for(int i =n-2;i>=0;i--)\\n            suf[i]=grid[1][i]+suf[i+1];\\n        long ans=Math.min(prev[n-1],suf[0]);\\n        for(int i=1;i<n-1;i++){\\n            long cur=Math.max(prev[n-1]-prev[i],suf[0]-suf[i]);\\n            if(cur>0)\\n            ans=Math.min(ans,cur);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490236,
                "title": "c-o-n-time-with-comments-super-easy-explanation",
                "content": "Hey ! I know we all at first thought of greedy algo approach, But we dont need that here. So according to the question it is given that the robots can only move forward or they may switch to below row (but they cant go up). now consider a situation where robot 1 switches the row at ith position i.e. from grid[0][i] to grid[1][i], alright? now  after this the robot 2 can have ---- maximum sum of elements in the row 1 ( from 0 to i-1 ) ----- OR max sum of elements in row 0 (from i+1 to n-1) where n is num of columns. It is so because all the elements through which robot 1 will go will become zero, thats why we just need the max of the two sums (sums obtained from robot 2 traversal). I am sure you have got the basic idea, please refer to the below code to understand further!\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        long long row_sum = 0, col_sum = 0, final_ans = LLONG_MAX;  //as the return value should be long long.\\n        \\n        int n = grid[0].size();     //this is the number of elements in row 0. (of the matrix)\\n        \\n        //so first of all we will calculate the total sum of the 0th row of the matrix\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            \\n            row_sum += grid[0][i];              \\n        }\\n        \\n        // now we will calculate our ans using below loop\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            \\n            row_sum -= grid[0][i];        //here \"i\" is the position where the 1st robot will switch to below row (row 0 to row 1)\\n            \\n            final_ans = min(final_ans, max(row_sum, col_sum));           //calculating ans accordingly in every iteration\\n            \\n            col_sum += grid[1][i];      // updating the column sum\\n        }\\n        \\n        //after the above loop completes, we have our final ans ! \\n        \\n        return final_ans;      //other than this, for a better understanding, I suggest you to trace the program with a pen and paper ! :)\\n        \\n        \\n    }\\n};\\n```\\n\\nPlease UPVOTE if you liked it. THANKS!! ;D",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        long long row_sum = 0, col_sum = 0, final_ans = LLONG_MAX;  //as the return value should be long long.\\n        \\n        int n = grid[0].size();     //this is the number of elements in row 0. (of the matrix)\\n        \\n        //so first of all we will calculate the total sum of the 0th row of the matrix\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            \\n            row_sum += grid[0][i];              \\n        }\\n        \\n        // now we will calculate our ans using below loop\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            \\n            row_sum -= grid[0][i];        //here \"i\" is the position where the 1st robot will switch to below row (row 0 to row 1)\\n            \\n            final_ans = min(final_ans, max(row_sum, col_sum));           //calculating ans accordingly in every iteration\\n            \\n            col_sum += grid[1][i];      // updating the column sum\\n        }\\n        \\n        //after the above loop completes, we have our final ans ! \\n        \\n        return final_ans;      //other than this, for a better understanding, I suggest you to trace the program with a pen and paper ! :)\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488755,
                "title": "easy-to-understand-o-n-verbose",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] g) {\\n        int n = g[0].length;\\n        \\n        long[] f = new long[n]; f[0] = g[0][0];\\n        long[] s = new long[n]; s[n-1] = g[1][n-1];\\n\\n        for(int i = 1; i < n; ++i) f[i] = f[i-1] + g[0][i];\\n        for(int i = n-2; i >= 0; --i) s[i] = s[i+1] + g[1][i];\\n        \\n        long ans = Math.min(f[n-1], s[0]);\\n        for(int i = 0; i < n; ++i) ans = Math.min(Math.max(f[n-1] - f[i], s[0] - s[i]), ans);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] g) {\\n        int n = g[0].length;\\n        \\n        long[] f = new long[n]; f[0] = g[0][0];\\n        long[] s = new long[n]; s[n-1] = g[1][n-1];\\n\\n        for(int i = 1; i < n; ++i) f[i] = f[i-1] + g[0][i];\\n        for(int i = n-2; i >= 0; --i) s[i] = s[i+1] + g[1][i];\\n        \\n        long ans = Math.min(f[n-1], s[0]);\\n        for(int i = 0; i < n; ++i) ans = Math.min(Math.max(f[n-1] - f[i], s[0] - s[i]), ans);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487192,
                "title": "clean-javascript-solution-with-explanation-prefix-sum",
                "content": "### Approach\\n------------\\n\\nKey Takeways from the problem statement:\\n* Robots can move down only once as they can move down and right and there are only 2 rows\\n* First Robot doesn\\'t necessarily has to get the maximum sum, it has to minimise the second robot\\'s sum\\n\\nProcess\\n* As the robots have to reach the second row at the end so there has to be a down step from any of the first row cells, so we need to find the most optimum point to move down for the first robot\\n* For achieving the above we need to get the future sum from each point going from right to left for 2nd row (as this is what we will travel to reach the right bottom corner) and left to right for 1st row ( as we have travelled this much)\\n* Then for finding the most optimum solution we need to find the index where we get the local maxima but global minima of the second robot\\'s value\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar gridGame = function(grid) {\\n    \\n    let cols = grid[0].length, ans = Infinity;\\n    let res = Array(2).fill().map(_=>Array(cols).fill(0));\\n    \\n    //PREFIX SUM FROM FROM LEFT TO RIGHT FOR 2ND ROW\\n    for(let j = 0;j<cols;j++)\\n        res[1][j] = j - 1 >=0 ? res[1][j - 1] + grid[1][j] : grid[1][j];\\n      \\n    //PREFIX SUM FROM FROM RIGHT TO LEFT FOR 1ST ROW\\n    for(let j = cols - 1;j >=0 ;j--)\\n        res[0][j] = j + 1 < cols ? res[0][j + 1] + grid[0][j] : grid[0][j];\\n    \\n    for(let j = 0;j<cols;j++){\\n        let rightTop = j+1 < cols ? res[0][j + 1] : 0\\n        let leftBottom = j-1 >= 0 ? res[1][j-1] : 0\\n        ans = Math.min(Math.max(rightTop, leftBottom), ans);\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar gridGame = function(grid) {\\n    \\n    let cols = grid[0].length, ans = Infinity;\\n    let res = Array(2).fill().map(_=>Array(cols).fill(0));\\n    \\n    //PREFIX SUM FROM FROM LEFT TO RIGHT FOR 2ND ROW\\n    for(let j = 0;j<cols;j++)\\n        res[1][j] = j - 1 >=0 ? res[1][j - 1] + grid[1][j] : grid[1][j];\\n      \\n    //PREFIX SUM FROM FROM RIGHT TO LEFT FOR 1ST ROW\\n    for(let j = cols - 1;j >=0 ;j--)\\n        res[0][j] = j + 1 < cols ? res[0][j + 1] + grid[0][j] : grid[0][j];\\n    \\n    for(let j = 0;j<cols;j++){\\n        let rightTop = j+1 < cols ? res[0][j + 1] : 0\\n        let leftBottom = j-1 >= 0 ? res[1][j-1] : 0\\n        ans = Math.min(Math.max(rightTop, leftBottom), ans);\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042525,
                "title": "easy-solution-no-mess",
                "content": "what the 1st player wants??? minimum score of player 2\\n\\nwhat the 2nd player wants??? maximum score of player 2\\n\\nbased on this, we just need to find the switching point in the matrix of player1\\n\\nwe need to make sure that the switch will make the score of player 1 as max as possible\\n\\nrest the code can be understood easily\\n\\n# Code\\n```**Bold**\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        return util2(grid);\\n    }\\n    public long util2(int[][] grid){\\n\\t\\tlong suffix[] = new long[grid[0].length];\\n\\t\\tlong prefix[] = new long[grid[0].length];\\n\\t\\tsuffix[suffix.length-1] = grid[0][grid[0].length-1];\\n\\t\\tprefix[0] = grid[1][0];\\n\\t\\tfor(int i = 1;i<suffix.length;i++) {\\n\\t\\t\\tprefix[i] = grid[1][i]+prefix[i-1];\\n\\t\\t}\\n\\t\\tfor(int i = grid[0].length-2;i>=0;i--) {\\n\\t\\t\\tsuffix[i] = suffix[i+1]+grid[0][i];\\n\\t\\t}\\n\\t\\tlong result = Long.MAX_VALUE;\\n\\t\\tfor(int i = 0;i<prefix.length;i++) {\\n\\t\\t\\tlong current = Math.max((i-1>=0)?prefix[i-1]:0,(i+1<suffix.length)?suffix[i+1]:0);\\n\\t\\t\\tresult = Math.min(current,result);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```**Bold**\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        return util2(grid);\\n    }\\n    public long util2(int[][] grid){\\n\\t\\tlong suffix[] = new long[grid[0].length];\\n\\t\\tlong prefix[] = new long[grid[0].length];\\n\\t\\tsuffix[suffix.length-1] = grid[0][grid[0].length-1];\\n\\t\\tprefix[0] = grid[1][0];\\n\\t\\tfor(int i = 1;i<suffix.length;i++) {\\n\\t\\t\\tprefix[i] = grid[1][i]+prefix[i-1];\\n\\t\\t}\\n\\t\\tfor(int i = grid[0].length-2;i>=0;i--) {\\n\\t\\t\\tsuffix[i] = suffix[i+1]+grid[0][i];\\n\\t\\t}\\n\\t\\tlong result = Long.MAX_VALUE;\\n\\t\\tfor(int i = 0;i<prefix.length;i++) {\\n\\t\\t\\tlong current = Math.max((i-1>=0)?prefix[i-1]:0,(i+1<suffix.length)?suffix[i+1]:0);\\n\\t\\t\\tresult = Math.min(current,result);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979871,
                "title": "shortest-and-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n\\n        vector<long long>pre(m,grid[0][0]), post(m,grid[1][m-1]);\\n\\n        for(int i=1; i<m; i++) pre[i] = pre[i-1] + grid[0][i];\\n        for(int i=m-2; i>=0; i--) post[i] = post[i+1] + grid[1][i];\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int i=0; i<m; i++){\\n            ans = min(ans,max(post[0]-post[i],pre[m-1] - pre[i]));\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n\\n        vector<long long>pre(m,grid[0][0]), post(m,grid[1][m-1]);\\n\\n        for(int i=1; i<m; i++) pre[i] = pre[i-1] + grid[0][i];\\n        for(int i=m-2; i>=0; i--) post[i] = post[i+1] + grid[1][i];\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int i=0; i<m; i++){\\n            ans = min(ans,max(post[0]-post[i],pre[m-1] - pre[i]));\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976190,
                "title": "prefix-sum-explanation-c",
                "content": "# intitution\\nSince a robot can move in downward and rightward direction so the robot will want to move into the side which has more value.\\nAs he wants to gether the maximum amount. \\nHow to know what the future values can be ?\\nCan we use a prefix array to calculate the values.\\n\\nAt any point i;\\nthere will be two choices for the red robot:\\nEither go to the left or go down\\nHow to decide whether to go he will simply check for where he can the maximum values we can get it by calculating f[i]+s[n-1]-s[i-1];\\nwe will get the maximum value by this.\\n\\nBut the catch is that blue will try to minimize it so what next ? He will also try to guess what he can get at every step. \\nWE have to just use blues values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    vector<long long>f(n),s(n); //vector for storing prefix sum\\n    for(int i=0; i<n; i++){\\n        f[i]=grid[0][i];\\n        s[i]=grid[1][i];\\n    }\\n    for(int i=1; i<n; i++){\\n        f[i]+=f[i-1];\\n        s[i]+=s[i-1];\\n    }\\n    long long ans=LLONG_MAX;\\n    long long maxi=LLONG_MIN;\\n    int blue=0;\\n    int red=0;\\n    for(int i=0; i<n; i++){ //since robot can move down and right \\n//what are the options left for the blue robot if the red robot\\n//moves upto the right till index i in first row and then \\n//to right in second row. \\n        long long b1=f[n-1]-f[i]; //either it will get what the red \\n//has left in the first row or in the second row\\n//simply find the maximum of both and then the \\n//minimum of it globally.\\n        long long b2=(i-1>=0)?s[i-1]:0;\\n        maxi=max(b1,b2);\\n        ans=min(maxi,ans);\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    vector<long long>f(n),s(n); //vector for storing prefix sum\\n    for(int i=0; i<n; i++){\\n        f[i]=grid[0][i];\\n        s[i]=grid[1][i];\\n    }\\n    for(int i=1; i<n; i++){\\n        f[i]+=f[i-1];\\n        s[i]+=s[i-1];\\n    }\\n    long long ans=LLONG_MAX;\\n    long long maxi=LLONG_MIN;\\n    int blue=0;\\n    int red=0;\\n    for(int i=0; i<n; i++){ //since robot can move down and right \\n//what are the options left for the blue robot if the red robot\\n//moves upto the right till index i in first row and then \\n//to right in second row. \\n        long long b1=f[n-1]-f[i]; //either it will get what the red \\n//has left in the first row or in the second row\\n//simply find the maximum of both and then the \\n//minimum of it globally.\\n        long long b2=(i-1>=0)?s[i-1]:0;\\n        maxi=max(b1,b2);\\n        ans=min(maxi,ans);\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664288,
                "title": "beats-99-96-intution-approach-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the maximum points that can be collected by the second\\nrobot\\nthe first robot can reach the destination(1,grid.length-1) by collecting maximum points..so that the no of points collected by the second robot minimized\\nfor reaching the destination it may cross the 0th row may not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we need to find the suffix sum of 0th row\\nand prefix sum of the 1st row\\nafter that we need to find the crossing point \\n when suffix[index+1]<prefix[index] there robot can cross to maximize the score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC:O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC:O(n) n is the length of columns of grid\\nwe are uisng prefix array\\n\\n# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        \\n    \\n        int n=grid[0].length;\\n        if(n==1) return 0;\\n\\n         long prefix[] = new long[n];\\n         long suffix[] = new long[n];\\n\\n         suffix[n-1]=grid[0][n-1];\\n\\n         for(int i=n-2; i>=0; i--)\\n         {\\n             suffix[i]=suffix[i+1]+grid[0][i];\\n         }\\n\\n         prefix[0] = grid[1][0];\\n\\n         for(int i=1; i<n; i++)\\n          prefix[i]=prefix[i-1]+grid[1][i];\\n\\n        int shift=0;\\n          for(int i=0; i<n; i++)\\n          {\\n              if(i==n-1)\\n              {\\n                 shift=i;\\n                 break;\\n              }\\n\\n              if(suffix[i+1]<prefix[i])\\n              {\\n                  shift=i;\\n                  break;\\n              }\\n          }\\n\\n          if(shift==0)\\n          return suffix[shift+1];\\n\\n          if(shift==n-1) return prefix[shift-1];\\n\\n          long ans=Math.max(prefix[shift-1], suffix[shift+1]);\\n          return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        \\n    \\n        int n=grid[0].length;\\n        if(n==1) return 0;\\n\\n         long prefix[] = new long[n];\\n         long suffix[] = new long[n];\\n\\n         suffix[n-1]=grid[0][n-1];\\n\\n         for(int i=n-2; i>=0; i--)\\n         {\\n             suffix[i]=suffix[i+1]+grid[0][i];\\n         }\\n\\n         prefix[0] = grid[1][0];\\n\\n         for(int i=1; i<n; i++)\\n          prefix[i]=prefix[i-1]+grid[1][i];\\n\\n        int shift=0;\\n          for(int i=0; i<n; i++)\\n          {\\n              if(i==n-1)\\n              {\\n                 shift=i;\\n                 break;\\n              }\\n\\n              if(suffix[i+1]<prefix[i])\\n              {\\n                  shift=i;\\n                  break;\\n              }\\n          }\\n\\n          if(shift==0)\\n          return suffix[shift+1];\\n\\n          if(shift==n-1) return prefix[shift-1];\\n\\n          long ans=Math.max(prefix[shift-1], suffix[shift+1]);\\n          return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649313,
                "title": "linear-time-constant-space-96-beat-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466314,
                "title": "c-explained-and-commented",
                "content": "# Intuition\\nThe red player can make n different choices (he chooses when he goes from line 1 of grid to line 2 of grid) and will take the one with the minimum score for the blue player\\n\\nFor each play from the red player, the blue player has 2 choices: go to grid[1] directly or go to grid[1] at the last moment and will take the best one (those two choices are better than all other choices)\\n# Approach\\nBrute force approach where we enumerate all the 2*n different choices explained in \"Intuition\" and take the min of the max of each pair\\n\\n# Complexity\\n- Time complexity: O(n)   :   301ms\\n\\n- Space complexity: O(1)     : 16.5 MB\\n\\n# Code\\n```\\nlong long max(long long a,long long b) //return the max\\n{\\n    if(b<a){return a;}\\n    return b;\\n}\\nlong long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    long long sumdown = 0;\\n    long long sumup = 0;\\n    for(int i=0;i<gridColSize[0]-1;i++)\\n    {\\n        sumdown+=grid[1][i];\\n    }               //-> sumdown is now the sum of the array grid[1]\\n    long long ans = sumdown;\\n    //initially red player goes to grid[1] at the last moment\\n    for(int i=gridColSize[0]-1;i>0;i--)\\n    {   //at each iteration red player go to grid[1] one cell earlier\\n        if(max(sumdown,sumup)<ans){ans=max(sumdown,sumup);}\\n        sumup+=grid[0][i];\\n        sumdown-=grid[1][i-1];\\n    }\\n    if(sumup<ans){return sumup;} //the case where the answer is the whole up array\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long max(long long a,long long b) //return the max\\n{\\n    if(b<a){return a;}\\n    return b;\\n}\\nlong long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    long long sumdown = 0;\\n    long long sumup = 0;\\n    for(int i=0;i<gridColSize[0]-1;i++)\\n    {\\n        sumdown+=grid[1][i];\\n    }               //-> sumdown is now the sum of the array grid[1]\\n    long long ans = sumdown;\\n    //initially red player goes to grid[1] at the last moment\\n    for(int i=gridColSize[0]-1;i>0;i--)\\n    {   //at each iteration red player go to grid[1] one cell earlier\\n        if(max(sumdown,sumup)<ans){ans=max(sumdown,sumup);}\\n        sumup+=grid[0][i];\\n        sumdown-=grid[1][i-1];\\n    }\\n    if(sumup<ans){return sumup;} //the case where the answer is the whole up array\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754775,
                "title": "java-solution-o-n-time-o-1-space-faster-than-86",
                "content": "```java \\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long min=Long.MAX_VALUE;  // maxScore Collected by Robot2\\n        \\n        int m = grid[0].length;\\n        \\n        long t1=0;\\n        for(int x:grid[0])\\n           t1+=x;\\n        \\n        long s1=0;\\n        long s2=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            s1+=grid[0][i];\\n            long score = Math.max(t1-s1,s2);\\n            s2+=grid[1][i];\\n            if(score<min)\\n                min=score;\\n        }\\n        \\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public long gridGame(int[][] grid) {\\n        long min=Long.MAX_VALUE;  // maxScore Collected by Robot2\\n        \\n        int m = grid[0].length;\\n        \\n        long t1=0;\\n        for(int x:grid[0])\\n           t1+=x;\\n        \\n        long s1=0;\\n        long s2=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            s1+=grid[0][i];\\n            long score = Math.max(t1-s1,s2);\\n            s2+=grid[1][i];\\n            if(score<min)\\n                min=score;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2642310,
                "title": "c-easy-to-understand-step-by-step",
                "content": "# Accepted Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long topSum = accumulate(begin(grid[0]), end(grid[0]), 0LL), bottomSum = 0;\\n        long long ans = LLONG_MAX;\\n        for (int i = 0; i < grid[0].size(); ++i) {\\n            topSum -= grid[0][i];\\n            ans = min(ans, max(topSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long topSum = accumulate(begin(grid[0]), end(grid[0]), 0LL), bottomSum = 0;\\n        long long ans = LLONG_MAX;\\n        for (int i = 0; i < grid[0].size(); ++i) {\\n            topSum -= grid[0][i];\\n            ans = min(ans, max(topSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556577,
                "title": "time-o-n-space-o-1-c-easy-simple-prifix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int j,n = grid[0].size();\\n        long long int left = 0,right = 0;\\n            for(j = n-1; j >= 0; j--){\\n                right += grid[0][j];\\n            }\\n        long long int ans = LLONG_MAX;\\n        for(j = 0; j < n; j++){\\n            right -= grid[0][j];\\n            ans = min(ans,max(left,right));\\n            left += grid[1][j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int j,n = grid[0].size();\\n        long long int left = 0,right = 0;\\n            for(j = n-1; j >= 0; j--){\\n                right += grid[0][j];\\n            }\\n        long long int ans = LLONG_MAX;\\n        for(j = 0; j < n; j++){\\n            right -= grid[0][j];\\n            ans = min(ans,max(left,right));\\n            left += grid[1][j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027456,
                "title": "c-prefix-sum-on-both-side-simple-solution-with-explanation",
                "content": "Imagine first robot has `n` ways to go down when we have `2 x n` grid. So for each way, the second player have two ways to maximize its points. Our goal is to minimize the points that second player get, so we need to select a best time to go down that minimizes second player points even it selects the bigger points among the way the first player go down.\\n\\nSo for each way the first way go down, the second player have only two ways to reach its end to maximize the points\\n(1) go to right to the end then go down\\n(2) go down first then go to the end\\n\\nand we find that each two ways for second player to choose is related for different ways that the first player goes down.\\n\\nLet say an example:\\n\\n` v v v v v`\\n` v v v v v`\\n\\nthe first player go down at index = 0\\n` 0 v v v v`\\n` 0 0 0 0 0`\\n\\nthe first player go down at index = 1\\n` 0 0 v v v`\\n` v 0 0 0 0`\\n\\nthe first player go down at index = 2\\n` 0 0 0 v v`\\n` v v 0 0 0`\\n\\nthe first player go down at index = 3\\n` 0 0 0 0 v`\\n` v v v 0 0`\\n\\nthe first player go down at index = 4\\n` 0 0 0 0 0`\\n` v v v v 0`\\n\\nSo we know that points of each two ways  can be calculated in `O(1)` when we traverse `grid` if we use two prefix sum, one is from left at second row, the other one is from right at first row.\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        ll lsum = 0, rsum = accumulate(grid[0].begin(), grid[0].end(), (ll)0);\\n        ll res = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            rsum -= grid[0][i];\\n            res = min(res, max(lsum, rsum));\\n            lsum += grid[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        ll lsum = 0, rsum = accumulate(grid[0].begin(), grid[0].end(), (ll)0);\\n        ll res = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            rsum -= grid[0][i];\\n            res = min(res, max(lsum, rsum));\\n            lsum += grid[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933485,
                "title": "c-prefix-sum-intuitions-explained",
                "content": "# ****  // lsum will be calculating the sum in 1st row \\n#          rsum will be calculating the sum in 2nd row \\n#         \\n#          At any point , if for robot switched at ith column \\n#          then posssibilty of value for robot 2 is (i+1 th to n-1 in 1st row)\\n#          other possibility will be (i=0 , i-1th index in 2nd row) for robot 2\\n#          As robot wants to take maximum of these two possibility so take the maximum\\n#          of these two , robot2 wants to minimize his maximum , \\n#            res=min(res , max(possibility 1 , possibility 2))\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        ll lsum=0 , rsum=0;\\n        \\n        int n=grid[0].size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lsum+=grid[0][i]; // storing the sum value of 1st row\\n        }\\n\\t\\t\\n        long long res=LLONG_MAX; // Used in long long variable\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n             lsum-=grid[0][i];\\n            res = min(res , max(lsum , rsum));\\n            rsum+=grid[1][i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        ll lsum=0 , rsum=0;\\n        \\n        int n=grid[0].size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lsum+=grid[0][i]; // storing the sum value of 1st row\\n        }\\n\\t\\t\\n        long long res=LLONG_MAX; // Used in long long variable\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n             lsum-=grid[0][i];\\n            res = min(res , max(lsum , rsum));\\n            rsum+=grid[1][i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911658,
                "title": "java-prefix-suffix-sum-with-a-diagram",
                "content": "Greedy is wrong here becase robot can not go back up once it went down. \\n\\nWithout the loss of generality, we can picture it like this. And our goal to minimize the maximum of the two white blocks.\\n![image](https://assets.leetcode.com/users/images/609180db-4070-416c-a782-aeea3f77ee04_1649016337.7947361.png)\\n\\n```Java\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, sum = Arrays.stream(grid[0]).asLongStream().sum(), pre = 0;\\n        for (int i = 0; i < grid[0].length; i++){\\n            if (i > 0){\\n                pre += grid[1][i - 1]; // BOTTOM WHITE BLOCK\\n            }\\n            sum -= grid[0][i]; // TOP WHITE BLOCK\\n            ans = Math.min(ans, Math.max(sum, pre)); // MINIMIZE THE MAX OF THE TWO\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Suffix Array"
                ],
                "code": "```Java\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long ans = Long.MAX_VALUE, sum = Arrays.stream(grid[0]).asLongStream().sum(), pre = 0;\\n        for (int i = 0; i < grid[0].length; i++){\\n            if (i > 0){\\n                pre += grid[1][i - 1]; // BOTTOM WHITE BLOCK\\n            }\\n            sum -= grid[0][i]; // TOP WHITE BLOCK\\n            ans = Math.min(ans, Math.max(sum, pre)); // MINIMIZE THE MAX OF THE TWO\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663848,
                "title": "java-o-n-minmax",
                "content": "// for every path taken by robot 1 , robot 2 can take only two paths-\\n// 1. traverse through every element in row0 and then go down once to reach destination.(up variable in code)\\n//2. Go down on first row and then traverse through the row1 elements to reach destination.(down variable in code)\\n// If robot2 takes any other path it wont be able to optimize its points.\\n// Answer is just = min( for each path -max(up,down))\\n\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        long up =0,down =0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            down+=(long)grid[1][i];\\n        }\\n        long ans = Math.max(down,up);\\n        for(int i=n-1;i>0;i--)\\n        {\\n            up+=(long)grid[0][i];\\n            down -=(long)grid[1][i-1];\\n            ans = Math.min(ans,Math.max(up,down));\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long gridGame(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        long up =0,down =0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            down+=(long)grid[1][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1657863,
                "title": "c-prefix-sum-suffix-sum-minmax",
                "content": "```\\n/*\\nBest Explanation with Pictures:\\nhttps://leetcode.com/problems/grid-game/discuss/1486340/C%2B%2BJavaPython-Robot1-Minimize-TopSum-and-BottomSum-of-Robot-2-Picture-Explained\\n*/\\n\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n = grid[0].size();\\n        \\n        vector<ll> suffixSum(n,0); //suffix sum for the top row\\n        for(int i=n-2;i>=0;i--){\\n            // when player 1 moves down from grid[0][i]\\n            \\n            // top row sum for player 2 \\n            suffixSum[i+1] = grid[0][i+1] + (i+2 < n ? suffixSum[i+2] : 0);\\n        }\\n        \\n        \\n        vector<ll> prefixSum(n,0); //prefix sum for bottom row\\n        for(int i=1;i<n;i++){\\n            // when player 1 moves down at grid[1][i]\\n            \\n            //bottom row sum for player 2\\n            prefixSum[i-1] = grid[1][i-1] + (i-2>=0 ? prefixSum[i-2] : 0);\\n        }\\n        \\n        /*\\n        So now, \\n        - Player 1 has \\'n\\' possible paths, each corresponsing to when player 1 goes down.\\n        \\n        - Hence, if player 1 does down at \\'i\\', then the maximum path sum for player 2 = max(suffixSum[i+1], prefixSum[i-1])\\n        \\n        - Therefore, player1 chooses that \\'i\\' to go down, which minimize player 2\\'s maximum path sum \\n        */\\n        \\n        \\n        ll miniMaxPlayer2 = LLONG_MAX; \\n        \\n        for(int i=0;i<n;i++){\\n            // if player 1 chose to go down at position i\\n            \\n            // then the maximum path sum for player 2\\n            ll topSum = (i+1 < n ? suffixSum[i+1] : 0);\\n            ll bottomSum = (i-1 >=0 ? prefixSum[i-1] : 0);\\n            \\n            ll maxPathSumPlayer2 = max(topSum, bottomSum); \\n            \\n            // player1 chooses that \\'i\\' to go down, which minimize player 2\\'s maximum path sum \\n            miniMaxPlayer2 = min(miniMaxPlayer2, maxPathSumPlayer2);\\n        }\\n        \\n        \\n        return miniMaxPlayer2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBest Explanation with Pictures:\\nhttps://leetcode.com/problems/grid-game/discuss/1486340/C%2B%2BJavaPython-Robot1-Minimize-TopSum-and-BottomSum-of-Robot-2-Picture-Explained\\n*/\\n\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n = grid[0].size();\\n        \\n        vector<ll> suffixSum(n,0); //suffix sum for the top row\\n        for(int i=n-2;i>=0;i--){\\n            // when player 1 moves down from grid[0][i]\\n            \\n            // top row sum for player 2 \\n            suffixSum[i+1] = grid[0][i+1] + (i+2 < n ? suffixSum[i+2] : 0);\\n        }\\n        \\n        \\n        vector<ll> prefixSum(n,0); //prefix sum for bottom row\\n        for(int i=1;i<n;i++){\\n            // when player 1 moves down at grid[1][i]\\n            \\n            //bottom row sum for player 2\\n            prefixSum[i-1] = grid[1][i-1] + (i-2>=0 ? prefixSum[i-2] : 0);\\n        }\\n        \\n        /*\\n        So now, \\n        - Player 1 has \\'n\\' possible paths, each corresponsing to when player 1 goes down.\\n        \\n        - Hence, if player 1 does down at \\'i\\', then the maximum path sum for player 2 = max(suffixSum[i+1], prefixSum[i-1])\\n        \\n        - Therefore, player1 chooses that \\'i\\' to go down, which minimize player 2\\'s maximum path sum \\n        */\\n        \\n        \\n        ll miniMaxPlayer2 = LLONG_MAX; \\n        \\n        for(int i=0;i<n;i++){\\n            // if player 1 chose to go down at position i\\n            \\n            // then the maximum path sum for player 2\\n            ll topSum = (i+1 < n ? suffixSum[i+1] : 0);\\n            ll bottomSum = (i-1 >=0 ? prefixSum[i-1] : 0);\\n            \\n            ll maxPathSumPlayer2 = max(topSum, bottomSum); \\n            \\n            // player1 chooses that \\'i\\' to go down, which minimize player 2\\'s maximum path sum \\n            miniMaxPlayer2 = min(miniMaxPlayer2, maxPathSumPlayer2);\\n        }\\n        \\n        \\n        return miniMaxPlayer2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587214,
                "title": "runtime-152-ms-faster-than-83-54-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n       //use logic\\n        //we need to get a point where the robot makes it move to down\\n        //once it makes a downward move it has to travel straigt to get to the destination point\\n        int n=grid[0].size();\\n        if(n==1)\\n            return 0;\\n        long long res=0;\\n        //create prefix sum for row2\\n        long long sum=0;\\n        vector<vector<long long>> prefix(2,vector<long long>(n));\\n        prefix[0][0]=grid[0][0];\\n        prefix[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[0][i]=prefix[0][i-1]+ grid[0][i];\\n            prefix[1][i]=prefix[1][i-1]+ grid[1][i];\\n        }\\n       \\n       long long mini=prefix[0][n-1]-prefix[0][0];\\n        for(int j=1;j<n;j++)\\n        {\\n            mini=min(mini,max(prefix[1][j-1],prefix[0][n-1]-prefix[0][j]));\\n        }\\n        return mini;\\n       \\n        \\n        \\n        \\n            \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n       //use logic\\n        //we need to get a point where the robot makes it move to down\\n        //once it makes a downward move it has to travel straigt to get to the destination point\\n        int n=grid[0].size();\\n        if(n==1)\\n            return 0;\\n        long long res=0;\\n        //create prefix sum for row2\\n        long long sum=0;\\n        vector<vector<long long>> prefix(2,vector<long long>(n));\\n        prefix[0][0]=grid[0][0];\\n        prefix[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[0][i]=prefix[0][i-1]+ grid[0][i];\\n            prefix[1][i]=prefix[1][i-1]+ grid[1][i];\\n        }\\n       \\n       long long mini=prefix[0][n-1]-prefix[0][0];\\n        for(int j=1;j<n;j++)\\n        {\\n            mini=min(mini,max(prefix[1][j-1],prefix[0][n-1]-prefix[0][j]));\\n        }\\n        return mini;\\n       \\n        \\n        \\n        \\n            \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527006,
                "title": "prefix-and-suffix-sum-solution-using-java",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long[] pre_sum = new long[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            pre_sum[i] = grid[1][i];\\n            if(i>0){\\n                pre_sum[i] += pre_sum[i-1];\\n            }\\n        }\\n        \\n        \\n        long[] suffix_sum = new long[grid[0].length];\\n        for(int i=grid[0].length-1;i>=0;i--){\\n            suffix_sum[i] = grid[0][i];\\n            if(i<grid[0].length-1){\\n                suffix_sum[i] += suffix_sum[i+1];\\n            }        \\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<grid[0].length;i++){\\n            long pre_val = (i-1>=0)?pre_sum[i-1]:0;\\n            long suffix_val = (i+1<grid[0].length)?suffix_sum[i+1]:0;\\n            long temp = Math.max(pre_val, suffix_val);\\n            if(temp < res){\\n                res = temp;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long[] pre_sum = new long[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++){\\n            pre_sum[i] = grid[1][i];\\n            if(i>0){\\n                pre_sum[i] += pre_sum[i-1];\\n            }\\n        }\\n        \\n        \\n        long[] suffix_sum = new long[grid[0].length];\\n        for(int i=grid[0].length-1;i>=0;i--){\\n            suffix_sum[i] = grid[0][i];\\n            if(i<grid[0].length-1){\\n                suffix_sum[i] += suffix_sum[i+1];\\n            }        \\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<grid[0].length;i++){\\n            long pre_val = (i-1>=0)?pre_sum[i-1]:0;\\n            long suffix_val = (i+1<grid[0].length)?suffix_sum[i+1]:0;\\n            long temp = Math.max(pre_val, suffix_val);\\n            if(temp < res){\\n                res = temp;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523480,
                "title": "c-easy-logic-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n       //use logic\\n        //we need to get a point where the robot makes it move to down\\n        //once it makes a downward move it has to travel straigt to get to the destination point\\n        int n=grid[0].size();\\n        if(n==1)\\n            return 0;\\n        long long res=0;\\n        //create prefix sum for row2\\n        long long sum=0;\\n        vector<vector<long long>> prefix(2,vector<long long>(n));\\n        prefix[0][0]=grid[0][0];\\n        prefix[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[0][i]=prefix[0][i-1]+ grid[0][i];\\n            prefix[1][i]=prefix[1][i-1]+ grid[1][i];\\n        }\\n       \\n       long long mini=prefix[0][n-1]-prefix[0][0];\\n        for(int j=1;j<n;j++)\\n        {\\n            mini=min(mini,max(prefix[1][j-1],prefix[0][n-1]-prefix[0][j]));\\n        }\\n        return mini;\\n       \\n        \\n        \\n        \\n            \\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n       //use logic\\n        //we need to get a point where the robot makes it move to down\\n        //once it makes a downward move it has to travel straigt to get to the destination point\\n        int n=grid[0].size();\\n        if(n==1)\\n            return 0;\\n        long long res=0;\\n        //create prefix sum for row2\\n        long long sum=0;\\n        vector<vector<long long>> prefix(2,vector<long long>(n));\\n        prefix[0][0]=grid[0][0];\\n        prefix[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[0][i]=prefix[0][i-1]+ grid[0][i];\\n            prefix[1][i]=prefix[1][i-1]+ grid[1][i];\\n        }\\n       \\n       long long mini=prefix[0][n-1]-prefix[0][0];\\n        for(int j=1;j<n;j++)\\n        {\\n            mini=min(mini,max(prefix[1][j-1],prefix[0][n-1]-prefix[0][j]));\\n        }\\n        return mini;\\n       \\n        \\n        \\n        \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495364,
                "title": "java-easy-prefix-suffix-solution",
                "content": "```cpp\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long[] pre = new long[n+1];\\n        long[] suf = new long[n+1];\\n        \\n        long ans = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            suf[n-i-1] = suf[n-i]+grid[0][n-i-1];\\n            pre[i+1] = pre[i]+grid[1][i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans = Math.min(ans,Math.max(pre[i],suf[i+1]));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long[] pre = new long[n+1];\\n        long[] suf = new long[n+1];\\n        \\n        long ans = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            suf[n-i-1] = suf[n-i]+grid[0][n-i-1];\\n            pre[i+1] = pre[i]+grid[1][i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans = Math.min(ans,Math.max(pre[i],suf[i+1]));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491624,
                "title": "simple-prefix-sum-o-n-solution",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long ans=Long.MAX_VALUE;\\n        long[][] dp=new long[2][n];\\n        dp[0][0]=grid[0][0]*1L;\\n        dp[1][0]=grid[1][0]*1L;\\n        \\n        for(int i=0;i<2;i++){\\n            for(int c=1;c<n;c++)\\n                dp[i][c]=grid[i][c]+dp[i][c-1];\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            long temp=dp[0][n-1]-dp[0][k];\\n            if(k>0)\\n                temp=Math.max(dp[1][k-1], temp);\\n            ans=Math.min(temp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long ans=Long.MAX_VALUE;\\n        long[][] dp=new long[2][n];\\n        dp[0][0]=grid[0][0]*1L;\\n        dp[1][0]=grid[1][0]*1L;\\n        \\n        for(int i=0;i<2;i++){\\n            for(int c=1;c<n;c++)\\n                dp[i][c]=grid[i][c]+dp[i][c-1];\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            long temp=dp[0][n-1]-dp[0][k];\\n            if(k>0)\\n                temp=Math.max(dp[1][k-1], temp);\\n            ans=Math.min(temp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491525,
                "title": "easy-solution-because-there-only-two-floor",
                "content": "```\\nclass Solution {\\n/*\\n1 2 3 4 5\\na b c d e\\nf g h i j\\n\\u4E0D\\u7BA1robot1\\u4ECE\\u54EA\\u4E2A\\u4F4D\\u7F6E\\u4E0B\\u94BB\\uFF0C\\u90A3\\u4E48robot2\\u4E0D\\u662F\\u4ECE5\\u4E0B\\u94BB\\u5C31\\u662F\\u4ECE1\\u4E0B\\u94BB\\uFF0C\\nrobot2\\u8981\\u4E48\\u6536\\u96C6\\u7B2C\\u4E00\\u884C\\u5269\\u4E0B\\u7684\\uFF0C\\u8981\\u4E48\\u6536\\u96C6\\u7B2C\\u4E8C\\u884C\\u5269\\u4E0B\\u7684\\n\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u7EF4\\u62A4\\u4E00\\u4E2A\\u4ECE\\u53F3\\u5F80\\u5DE6(\\u7B2C\\u4E00\\u884C)\\u548C\\u4ECE\\u5DE6\\u5F80\\u53F3\\uFF08\\u7B2C\\u4E8C\\u884C\\uFF09\\u7684\\u7D2F\\u52A0\\u548C\\u6570\\u7EC4\\u5373\\u53EF\\uFF0C\\n\\u627E\\u51FA\\u80FD\\u8BA9robot2\\u6536\\u96C6\\u548C\\u6700\\u5C0F\\u7684\\u4E0B\\u94BB\\u70B9\\u5373\\u53EF\\n*/\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        // vec2dim2string(grid);\\n        vector<vector<long long>> dp(2, vector<long long>(grid[0].size(), 0));\\n        int length = grid[0].size();\\n        for (int i = 1; i < length; i++) {\\n            dp[1][i] = grid[1][i-1] + dp[1][i-1];\\n            dp[0][length - 1 - i] = grid[0][length - i] + dp[0][length  - i];\\n        }\\n        long long result = LLONG_MAX;\\n        // vec2dim2string(dp);\\n        for (int i = 0; i < dp[0].size(); i++) {\\n            result = min(result, max(dp[0][i], dp[1][i]));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n/*\\n1 2 3 4 5\\na b c d e\\nf g h i j\\n\\u4E0D\\u7BA1robot1\\u4ECE\\u54EA\\u4E2A\\u4F4D\\u7F6E\\u4E0B\\u94BB\\uFF0C\\u90A3\\u4E48robot2\\u4E0D\\u662F\\u4ECE5\\u4E0B\\u94BB\\u5C31\\u662F\\u4ECE1\\u4E0B\\u94BB\\uFF0C\\nrobot2\\u8981\\u4E48\\u6536\\u96C6\\u7B2C\\u4E00\\u884C\\u5269\\u4E0B\\u7684\\uFF0C\\u8981\\u4E48\\u6536\\u96C6\\u7B2C\\u4E8C\\u884C\\u5269\\u4E0B\\u7684\\n\\u6240\\u4EE5\\u53EA\\u9700\\u8981\\u7EF4\\u62A4\\u4E00\\u4E2A\\u4ECE\\u53F3\\u5F80\\u5DE6(\\u7B2C\\u4E00\\u884C)\\u548C\\u4ECE\\u5DE6\\u5F80\\u53F3\\uFF08\\u7B2C\\u4E8C\\u884C\\uFF09\\u7684\\u7D2F\\u52A0\\u548C\\u6570\\u7EC4\\u5373\\u53EF\\uFF0C\\n\\u627E\\u51FA\\u80FD\\u8BA9robot2\\u6536\\u96C6\\u548C\\u6700\\u5C0F\\u7684\\u4E0B\\u94BB\\u70B9\\u5373\\u53EF\\n*/\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        // vec2dim2string(grid);\\n        vector<vector<long long>> dp(2, vector<long long>(grid[0].size(), 0));\\n        int length = grid[0].size();\\n        for (int i = 1; i < length; i++) {\\n            dp[1][i] = grid[1][i-1] + dp[1][i-1];\\n            dp[0][length - 1 - i] = grid[0][length - i] + dp[0][length  - i];\\n        }\\n        long long result = LLONG_MAX;\\n        // vec2dim2string(dp);\\n        for (int i = 0; i < dp[0].size(); i++) {\\n            result = min(result, max(dp[0][i], dp[1][i]));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490573,
                "title": "c-o-n-time-using-only-prefix-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n    \\n        long long m=grid[0].size();\\n        long long a[m+1];\\n        long long b[m+1];\\n        \\n        vector<long long>ans;\\n        \\n        for(int i=0;i<m+1;i++)\\n        {\\n            b[i]=0;\\n            a[i]=0;\\n        }\\n        \\n        long long sum=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            sum+=grid[1][i];\\n            b[i]+=sum;\\n        }\\n        \\n         sum=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            sum+=grid[0][i];\\n            a[i]+=sum;\\n        }\\n        \\n        sum=INT_MIN;\\n        int maxx=INT_MIN;\\n        \\n        \\n        long long int minn=10000000000000000;\\n        for(int i=0;i<m;i++)\\n        {\\n                long long diff1=a[i+1];\\n                long long diff2=b[0]-b[i];\\n                sum=max(diff1,diff2);\\n                \\n                if(minn>sum)\\n                {\\n                    minn=sum;\\n                }\\n        }\\n    \\n        return minn;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n    \\n        long long m=grid[0].size();\\n        long long a[m+1];\\n        long long b[m+1];\\n        \\n        vector<long long>ans;\\n        \\n        for(int i=0;i<m+1;i++)\\n        {\\n            b[i]=0;\\n            a[i]=0;\\n        }\\n        \\n        long long sum=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            sum+=grid[1][i];\\n            b[i]+=sum;\\n        }\\n        \\n         sum=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            sum+=grid[0][i];\\n            a[i]+=sum;\\n        }\\n        \\n        sum=INT_MIN;\\n        int maxx=INT_MIN;\\n        \\n        \\n        long long int minn=10000000000000000;\\n        for(int i=0;i<m;i++)\\n        {\\n                long long diff1=a[i+1];\\n                long long diff2=b[0]-b[i];\\n                sum=max(diff1,diff2);\\n                \\n                if(minn>sum)\\n                {\\n                    minn=sum;\\n                }\\n        }\\n    \\n        return minn;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488110,
                "title": "linq-version",
                "content": "```c#\\npublic class Solution {\\n    public long GridGame(int[][] grid) => SuffixSums(grid[0]).Zip(PrefixSums(grid[1]), Math.Max).Min();\\n    private IEnumerable<long> SuffixSums(IEnumerable<int> enu) => PrefixSums(enu.Reverse()).Reverse();\\n    private IEnumerable<long> PrefixSums(IEnumerable<int> enu) {\\n        long acc = 0;\\n        foreach (int i in enu.Prepend(0).SkipLast(1))\\n            yield return acc += i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```c#\\npublic class Solution {\\n    public long GridGame(int[][] grid) => SuffixSums(grid[0]).Zip(PrefixSums(grid[1]), Math.Max).Min();\\n    private IEnumerable<long> SuffixSums(IEnumerable<int> enu) => PrefixSums(enu.Reverse()).Reverse();\\n    private IEnumerable<long> PrefixSums(IEnumerable<int> enu) {\\n        long acc = 0;\\n        foreach (int i in enu.Prepend(0).SkipLast(1))\\n            yield return acc += i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488070,
                "title": "2017-c-a-simple-explanation-with-hand-drawn-pictures",
                "content": "You don\\'t need to write a func to calculate optimal path & score for second robot, which will cause TLE.  \\n\\nAfter first Robot\\'s pass, the 2D array will have a \"Z-shape\" all zero path. The second Robot has actually only TWO options:\\n\\n1. Going down on `the first column`, score all non-zeros on the row Bottom;\\n2. Going down on `the last column` (rightmost), score all non-zeros on the row Top;\\n\\nAll other moves will have lower score than these two, obviously.\\n\\nThen the question is simplified: just go through the columns, to find the `column i` that minimize the bigger one of two `row sums` (blue area below).\\n\\n<img src=\"https://miro.medium.com/max/1400/1*nrzdTiRnDqs-Lv6_hBYSiA@2x.jpeg\" width=\"560\">\\n\\nIn other words, to minimize *max*(*sumRowTop*, *sumRowBottom*), you need to make *sumRowTop* and *sumRowBottom* as close as possible.\\n\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        long remainSumTop = accumulate(begin(grid[0])+1, end(grid[0]), 0l);\\n        long remainSumBottom = 0;\\n        long remainSum = max(remainSumTop, remainSumBottom);\\n        long minRemainSum = remainSum;\\n        for (int c = 1; c < n; c++) {\\n            remainSumTop -= grid[0][c];\\n            remainSumBottom += grid[1][c-1];\\n            remainSum = max(remainSumTop, remainSumBottom);\\n            if (remainSum < minRemainSum) {\\n                minRemainSum = remainSum;\\n            }\\n        }\\n        return minRemainSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        long remainSumTop = accumulate(begin(grid[0])+1, end(grid[0]), 0l);\\n        long remainSumBottom = 0;\\n        long remainSum = max(remainSumTop, remainSumBottom);\\n        long minRemainSum = remainSum;\\n        for (int c = 1; c < n; c++) {\\n            remainSumTop -= grid[0][c];\\n            remainSumBottom += grid[1][c-1];\\n            remainSum = max(remainSumTop, remainSumBottom);\\n            if (remainSum < minRemainSum) {\\n                minRemainSum = remainSum;\\n            }\\n        }\\n        return minRemainSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487567,
                "title": "o-n-simple-solution-using-prefix-sum",
                "content": "Approach :- first we made two array ,in first array b to store row \\'0\\' prefix sum from the end and in array a store row \\'1\\' prefix sum from begining . and now we traverse in a for loop in this we will see for every index maxium of b and a array and than find min fo resultant.\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long int n=grid[0].size(),sum=0,s=0,j,i,t,curr=1e18;\\n        long long int a[n],b[n];\\n        b[n-1]=grid[0][n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            b[i]=b[i+1]+grid[0][i];\\n        }\\n        a[0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            a[i]=a[i-1]+grid[1][i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n            {\\n                curr=min(curr,b[i+1]);\\n            }\\n            else if(i==n-1)\\n            {\\n                curr=min(curr,a[i-1]);\\n            }\\n            else\\n            {\\n                curr=min(curr,max(b[i+1],a[i-1]));\\n            }\\n        \\n        \\n        }\\n        return curr;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long int n=grid[0].size(),sum=0,s=0,j,i,t,curr=1e18;\\n        long long int a[n],b[n];\\n        b[n-1]=grid[0][n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            b[i]=b[i+1]+grid[0][i];\\n        }\\n        a[0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            a[i]=a[i-1]+grid[1][i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n            {\\n                curr=min(curr,b[i+1]);\\n            }\\n            else if(i==n-1)\\n            {\\n                curr=min(curr,a[i-1]);\\n            }\\n            else\\n            {\\n                curr=min(curr,max(b[i+1],a[i-1]));\\n            }\\n        \\n        \\n        }\\n        return curr;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487548,
                "title": "java-rudimentary-prefix-sums",
                "content": "```\\npublic long gridGame(int[][] grid) {\\n\\tint n= grid[0].length;\\n\\t// calculate prefix sums for both rows\\n\\tlong[] ps0= new long[n], ps1= new long[n]; \\n\\tps0[0]= grid[0][0];\\n\\tps1[0]= grid[1][0];\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tps0[i]= grid[0][i] + ps0[i-1];\\n\\t\\tps1[i]= grid[1][i] + ps1[i-1];\\n\\t}\\n\\t// find index i for which the bigger of the two values ps0[i+1..n-1] and ps1[0..i-1] is minimum\\n\\tlong ans= Long.MAX_VALUE;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tlong score= Math.max(ps0[n-1]-ps0[i], i==0 ? 0 : ps1[i-1]);\\n\\t\\tans= Math.min(ans, score);\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\npublic long gridGame(int[][] grid) {\\n\\tint n= grid[0].length;\\n\\t// calculate prefix sums for both rows\\n\\tlong[] ps0= new long[n], ps1= new long[n]; \\n\\tps0[0]= grid[0][0];\\n\\tps1[0]= grid[1][0];\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tps0[i]= grid[0][i] + ps0[i-1];\\n\\t\\tps1[i]= grid[1][i] + ps1[i-1];\\n\\t}\\n\\t// find index i for which the bigger of the two values ps0[i+1..n-1] and ps1[0..i-1] is minimum\\n\\tlong ans= Long.MAX_VALUE;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tlong score= Math.max(ps0[n-1]-ps0[i], i==0 ? 0 : ps1[i-1]);\\n\\t\\tans= Math.min(ans, score);\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1487484,
                "title": "can-someone-please-explain-why-this-logic-is-incorrect",
                "content": "It was a tricky question. I was wondering, why this solution is incorrect:\\ne.g., grid = [[20,3,20,17,2,12,15,17,4,15],[20,10,13,14,15,5,2,3,14,3]]\\n        Output = 96\\n        Expected = 63\\n\\nI\\'m trying to approach it in something like the \"largest increasing subsequence\" problem.\\n\\n```\\nfrom pprint import pprint\\n\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        N = len(grid[0])\\n        \\n        def util():\\n            dp = [[0] * N for _ in range(2)]\\n            for i in range(2):\\n                for j in range(N):\\n                    if i == 0:\\n                        if j == 0:\\n                            dp[i][j] = grid[i][j]\\n                        else:\\n                            dp[i][j] = grid[i][j] + dp[i][j-1]\\n                    else:\\n                        if j == 0:\\n                            dp[i][j] = grid[i][j] + dp[i-1][j]\\n                        else:\\n                            dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])\\n            # pprint(dp)\\n            return dp\\n        \\n        def traverse():\\n            r, c = 1, N-1\\n            path = []\\n            while r >= 0 and c >= 0:\\n                path.append((r, c))\\n                if r > 0 and (dp[r-1][c] >= dp[r][c-1] or c == 0):\\n                    r -= 1\\n                else:\\n                    c -= 1\\n            # print(path)\\n            return path\\n        \\n        dp = util()\\n        path = traverse()\\n        for r, c in path:\\n            grid[r][c] = 0\\n        # pprint(grid)\\n        \\n        dp = util()\\n        ans = dp[-1][-1]\\n        \\n        return ans\\n```\\n\\nAny help will be very much appreciated.",
                "solutionTags": [],
                "code": "```\\nfrom pprint import pprint\\n\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        N = len(grid[0])\\n        \\n        def util():\\n            dp = [[0] * N for _ in range(2)]\\n            for i in range(2):\\n                for j in range(N):\\n                    if i == 0:\\n                        if j == 0:\\n                            dp[i][j] = grid[i][j]\\n                        else:\\n                            dp[i][j] = grid[i][j] + dp[i][j-1]\\n                    else:\\n                        if j == 0:\\n                            dp[i][j] = grid[i][j] + dp[i-1][j]\\n                        else:\\n                            dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])\\n            # pprint(dp)\\n            return dp\\n        \\n        def traverse():\\n            r, c = 1, N-1\\n            path = []\\n            while r >= 0 and c >= 0:\\n                path.append((r, c))\\n                if r > 0 and (dp[r-1][c] >= dp[r][c-1] or c == 0):\\n                    r -= 1\\n                else:\\n                    c -= 1\\n            # print(path)\\n            return path\\n        \\n        dp = util()\\n        path = traverse()\\n        for r, c in path:\\n            grid[r][c] = 0\\n        # pprint(grid)\\n        \\n        dp = util()\\n        ans = dp[-1][-1]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486482,
                "title": "functional-kotlin-solution",
                "content": "(requires Kotlin v1.4)\\n```\\nfun gridGame(grid: Array<IntArray>) = grid[0].asSequence()\\n    .runningFold(grid[0].sumOf { it.toLong() }) { acc, num -> acc - num }\\n    .drop(1)\\n    .zip(grid[1].asSequence().runningFold(0L) { acc, num -> acc + num })\\n    .minOf { max(it.first, it.second) }\\n```",
                "solutionTags": [],
                "code": "```\\nfun gridGame(grid: Array<IntArray>) = grid[0].asSequence()\\n    .runningFold(grid[0].sumOf { it.toLong() }) { acc, num -> acc - num }\\n    .drop(1)\\n    .zip(grid[1].asSequence().runningFold(0L) { acc, num -> acc + num })\\n    .minOf { max(it.first, it.second) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486427,
                "title": "c-o-n-dp",
                "content": "Use two dp to record the prefix/suffix sum.\\nGet the maximum between dp1[i-1] and dp2[i+1] which means after Robot A went with optimal strategy, there are only two ways for Robot B. B needs to take the maximum.\\nres records the minimum of B\\'s maximum when A goes down at index i, \\n\\n```\\npublic class Solution {\\n    public long GridGame(int[][] grid) {\\n        long[] dp1 = new long[grid[0].Length];\\n        long[] dp2 = new long[grid[0].Length];\\n        int len = grid[0].Length;\\n        dp1[len-1] = grid[0][len-1];\\n        dp2[0] = grid[1][0];\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(len-1-i>1)\\n                dp1[len-1-i-1] = grid[0][len-1-i-1] + dp1[len-i-1];\\n            if(i>0&&i<len-1)\\n                dp2[i] = grid[1][i]+dp2[i-1];\\n        }\\n        long res = Math.Min((long)dp1[1], (long)dp2[len-2]);\\n        for(int i = 1; i < len-1; i++)\\n        {\\n            res = Math.Min((long)Math.Max((long)dp1[i+1]  ,(long)dp2[i-1]), res);\\n        }\\n        \\n        return res;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long GridGame(int[][] grid) {\\n        long[] dp1 = new long[grid[0].Length];\\n        long[] dp2 = new long[grid[0].Length];\\n        int len = grid[0].Length;\\n        dp1[len-1] = grid[0][len-1];\\n        dp2[0] = grid[1][0];\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(len-1-i>1)\\n                dp1[len-1-i-1] = grid[0][len-1-i-1] + dp1[len-i-1];\\n            if(i>0&&i<len-1)\\n                dp2[i] = grid[1][i]+dp2[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1486366,
                "title": "c-o-n-solution",
                "content": "\\n````\\nlong long gridGame(vector<vector<int>>& grid) {\\n        long long sRight = 0, sLeft = 0;\\n        \\n        for(int j = 1; j < grid[0].size(); j++){\\n            sRight += grid[0][j];\\n        }\\n        long long res = sRight;\\n        \\n        for(int j = 1; j < grid[0].size(); j++){\\n            sRight -= grid[0][j];\\n            sLeft += grid[1][j-1];\\n            res = min(res, max(sRight, sLeft));\\n        }\\n        \\n        return res;\\n    }\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nlong long gridGame(vector<vector<int>>& grid) {\\n        long long sRight = 0, sLeft = 0;\\n        \\n        for(int j = 1; j < grid[0].size(); j++){\\n            sRight += grid[0][j];\\n        }\\n        long long res = sRight;\\n        \\n        for(int j = 1; j < grid[0].size(); j++){\\n            sRight -= grid[0][j];\\n            sLeft += grid[1][j-1];\\n            res = min(res, max(sRight, sLeft));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486331,
                "title": "greedy-algo-in-python",
                "content": "Essentially checking left or right\\'s bigger value as you cut through one of the vertical line in the middle.\\n\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        left = 0\\n        right = sum(grid[0][1:m])\\n        res = right\\n        for j in range(1, m):\\n            left += grid[1][j - 1]\\n            right -= grid[0][j]\\n            temp_max = max(left, right)\\n            res = min(res, temp_max)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        left = 0\\n        right = sum(grid[0][1:m])\\n        res = right\\n        for j in range(1, m):\\n            left += grid[1][j - 1]\\n            right -= grid[0][j]\\n            temp_max = max(left, right)\\n            res = min(res, temp_max)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486321,
                "title": "python3-greedy",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/fa0bb65b4cb428452e2b4192ad53e56393b8fb8d) for solutions of weekly 260. \\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        ans = inf\\n        prefix = 0\\n        suffix = sum(grid[0])\\n        for i in range(len(grid[0])): \\n            suffix -= grid[0][i]\\n            ans = min(ans, max(prefix, suffix))\\n            prefix += grid[1][i]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        ans = inf\\n        prefix = 0\\n        suffix = sum(grid[0])\\n        for i in range(len(grid[0])): \\n            suffix -= grid[0][i]\\n            ans = min(ans, max(prefix, suffix))\\n            prefix += grid[1][i]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486304,
                "title": "prefix-and-suffix-sum-c",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if(n == 1) return 0;        // base case\\n        vector<ll> pre(n), suff(n);\\n        \\n        pre[0] = grid[1][0];\\n        for(int i = 1; i < n-1; i++)            // prefix sum for 2nd row\\n            pre[i] = pre[i-1] + grid[1][i];\\n        \\n        suff[n-1] = grid[0][n-1];\\n        for(int i = n-2; i > 0; i--)            // suffix sum for 1st row\\n            suff[i] = suff[i+1] + grid[0][i];\\n        \\n        ll ans = 1e12;\\n        for(int i = 0; i < n; i++) {\\n            ll temp;\\n            if(i == 0)\\n                temp = suff[i+1];\\n            else if(i== n-1)\\n                temp = pre[i-1];\\n            else\\n                temp = max(pre[i-1], suff[i+1]);  // take max of left sum and right sum because 2nd player need to maximise his score\\n            ans = min(ans, temp);   // take min of all possiblities because 1st  player need to minimize his opponent score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if(n == 1) return 0;        // base case\\n        vector<ll> pre(n), suff(n);\\n        \\n        pre[0] = grid[1][0];\\n        for(int i = 1; i < n-1; i++)            // prefix sum for 2nd row\\n            pre[i] = pre[i-1] + grid[1][i];\\n        \\n        suff[n-1] = grid[0][n-1];\\n        for(int i = n-2; i > 0; i--)            // suffix sum for 1st row\\n            suff[i] = suff[i+1] + grid[0][i];\\n        \\n        ll ans = 1e12;\\n        for(int i = 0; i < n; i++) {\\n            ll temp;\\n            if(i == 0)\\n                temp = suff[i+1];\\n            else if(i== n-1)\\n                temp = pre[i-1];\\n            else\\n                temp = max(pre[i-1], suff[i+1]);  // take max of left sum and right sum because 2nd player need to maximise his score\\n            ans = min(ans, temp);   // take min of all possiblities because 1st  player need to minimize his opponent score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486278,
                "title": "java-o-n-easy-solution-with-suffix-sum-10-ms",
                "content": "```\\n    public long gridGame(int[][] g) {\\n        if(g[0].length==1) return 0;\\n        int n = g[0].length;\\n        long grid[][] = new long[2][n];\\n        grid[0][n-1]=g[0][n-1];\\n        grid[1][n-1]=g[1][n-1];\\n        for(int i=grid[0].length-2;i>=0;i--){\\n            grid[0][i]=g[0][i]+grid[0][i+1];\\n            grid[1][i]=g[1][i]+grid[1][i+1];\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i>0 && i<n-1) res = Math.min(res,Math.max(grid[0][i+1],grid[1][0]-grid[1][i]));\\n            else if(i==0) res = Math.min(res,grid[0][i+1]);\\n            else res = Math.min(res,grid[1][0]-grid[1][i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long gridGame(int[][] g) {\\n        if(g[0].length==1) return 0;\\n        int n = g[0].length;\\n        long grid[][] = new long[2][n];\\n        grid[0][n-1]=g[0][n-1];\\n        grid[1][n-1]=g[1][n-1];\\n        for(int i=grid[0].length-2;i>=0;i--){\\n            grid[0][i]=g[0][i]+grid[0][i+1];\\n            grid[1][i]=g[1][i]+grid[1][i+1];\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i>0 && i<n-1) res = Math.min(res,Math.max(grid[0][i+1],grid[1][0]-grid[1][i]));\\n            else if(i==0) res = Math.min(res,grid[0][i+1]);\\n            else res = Math.min(res,grid[1][0]-grid[1][i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486277,
                "title": "java-prefix-sum-solution-with-explanation-and-example",
                "content": "```\\npublic long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long[][] preSum = new long[2][n];\\n        for(int i=0;i<2;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0) preSum[i][j]=grid[i][j];\\n                else preSum[i][j]=grid[i][j]+preSum[i][j-1];\\n            }\\n        }\\n        long min=Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min=Math.min(min,Math.max(preSum[0][n-1]-preSum[0][i], i-1<0?0:preSum[1][i-1]));\\n        }\\n        return min;\\n    }\\n```\\nmin-max question\\nexample: \\n1 45 7 9 20\\n2 4 6 8 909\\nWe need to find the index at which the first robot move down. \\nif the first robot moves down at 2nd, the grid would became\\n0 0 0 9 20\\n2 4 0 0 0\\nSo, the second robot only has two possible paths in which the second robot may gatter maximum points:\\n0->0->9->20->0\\n2->4->0->0->0\\nthe second robot wants larger value between the two paths, but the first robot wants the seond robot gatter min points, so the first robot would choose the pivot point that generate min points.",
                "solutionTags": [],
                "code": "```\\npublic long gridGame(int[][] grid) {\\n        int n = grid[0].length;\\n        long[][] preSum = new long[2][n];\\n        for(int i=0;i<2;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0) preSum[i][j]=grid[i][j];\\n                else preSum[i][j]=grid[i][j]+preSum[i][j-1];\\n            }\\n        }\\n        long min=Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min=Math.min(min,Math.max(preSum[0][n-1]-preSum[0][i], i-1<0?0:preSum[1][i-1]));\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486274,
                "title": "python-prefix-and-suffix-sums",
                "content": "The second robot will either collect all of the row up or down in optimal play. Then the first robot should minimize the max of row sums based on split point. We can efficiently compute remaining points using prefix and suffic sums.\\n\\n```python\\nclass Solution:\\n    def gridGame(self, A):\\n        n = len(A[0])\\n        \\n        up = A[0][:]\\n        for i in range(1, n):\\n            up[i] += up[i - 1]\\n            \\n        down = A[1][:]\\n        for i in range(n - 2, -1, -1):\\n            down[i] += down[i + 1]\\n        \\n        up_total = sum(A[0])\\n        down_total = sum(A[1])\\n        \\n        ans = math.inf\\n        for i in range(n):\\n            ans = min(ans, max(up_total - up[i], down_total - down[i]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def gridGame(self, A):\\n        n = len(A[0])\\n        \\n        up = A[0][:]\\n        for i in range(1, n):\\n            up[i] += up[i - 1]\\n            \\n        down = A[1][:]\\n        for i in range(n - 2, -1, -1):\\n            down[i] += down[i + 1]\\n        \\n        up_total = sum(A[0])\\n        down_total = sum(A[1])\\n        \\n        ans = math.inf\\n        for i in range(n):\\n            ans = min(ans, max(up_total - up[i], down_total - down[i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486272,
                "title": "easy-solution-o-n-time-o-1-space",
                "content": "```\\npublic class Solution\\n{\\n    public long GridGame(int[][] grid)\\n    {\\n        long max1 = 0;\\n        long max2 = 0;\\n        for (int i = 0; i < grid[1].Length - 1; i++)\\n            max2 += grid[1][i];\\n        \\n        long min = max2;\\n        for (int i = grid[0].Length - 2; i >= 0; i--)\\n        {\\n            max1 += grid[0][i + 1];\\n            max2 -= grid[1][i];\\n            min = Math.Min(min, Math.Max(max1, max2));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public long GridGame(int[][] grid)\\n    {\\n        long max1 = 0;\\n        long max2 = 0;\\n        for (int i = 0; i < grid[1].Length - 1; i++)\\n            max2 += grid[1][i];\\n        \\n        long min = max2;\\n        for (int i = grid[0].Length - 2; i >= 0; i--)\\n        {\\n            max1 += grid[0][i + 1];\\n            max2 -= grid[1][i];\\n            min = Math.Min(min, Math.Max(max1, max2));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486271,
                "title": "java-prefix-sum-explained",
                "content": "/*\\nVisualization:\\ninput:\\n        [2, 5, 4]\\n        [1, 5, 1]\\n        \\nprefix:\\n        [11, 9, 4]  <-\\n        [1,  6, 7]  ->\\n\\nmax:     9,  4, 6\\nmin of max: 4\\n        \\n*/\\n````\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        \\n    \\tint n = grid[0].length;\\n    \\t\\n    \\tlong pre[][] = new long[2][n];\\n    \\t\\n        // Compute prefix for bottom row from left to right\\n    \\tpre[1][0] = grid[1][0];\\n    \\tfor (int i = 1; i < n; ++i) {\\n    \\t\\tpre[1][i] += pre[1][i-1] + grid[1][i];\\n        }\\n    \\t\\n        // Compute prefix for top row from right to left\\n    \\tpre[0][n-1] = grid[0][n-1];\\n    \\tfor (int i = n - 2; i >= 0; --i) {\\n    \\t\\tpre[0][i] += pre[0][i + 1] + grid[0][i];\\n        }\\n    \\t\\n        // Compute second robot\\'s max points\\n    \\tlong min = Long.MAX_VALUE;\\n        // Each column is a possible threshold column where the firt robot must move downwards once and for all (why atleast once: because the destination row is below the starting row. Why atmost once: beacuse there are only 2 rows in total). So iterate all the column to check for threshold column\\n    \\tfor (int i = 0; i < n; ++i) {\\n    \\t\\tif (i == n - 1) {\\n                min = Math.min(min, pre[1][i - 1]); // just a boundary hadling of else part\\n            } else if (i == 0) {\\n                min = Math.min(min, pre[0][i + 1]); // just a boundary handling of else part\\n            } else {\\n                // CRUX: \\n                // - For current threshold, second robot can either take all points top-right of current or bottom-left of current. (why just top-right or bottom-right: because first robot would have collected the remaing part. Draw it out to visulaize better). It will choose the max of both.\\n                // - First robot tries to minimize this maximum points second robot could collect\\n                min = Math.min(min, Math.max(pre[0][i + 1], pre[1][i - 1]));    \\n            }\\n\\t\\t\\t\\t\\n    \\t}\\n        \\n    \\treturn min;\\n    }\\n}\\n````\\nIf you think this post is useful, I\\'m happy if you give a vote. Any questions or discussions are welcome! Thank a lot.",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        \\n    \\tint n = grid[0].length;\\n    \\t\\n    \\tlong pre[][] = new long[2][n];\\n    \\t\\n        // Compute prefix for bottom row from left to right\\n    \\tpre[1][0] = grid[1][0];\\n    \\tfor (int i = 1; i < n; ++i) {\\n    \\t\\tpre[1][i] += pre[1][i-1] + grid[1][i];\\n        }\\n    \\t\\n        // Compute prefix for top row from right to left\\n    \\tpre[0][n-1] = grid[0][n-1];\\n    \\tfor (int i = n - 2; i >= 0; --i) {\\n    \\t\\tpre[0][i] += pre[0][i + 1] + grid[0][i];\\n        }\\n    \\t\\n        // Compute second robot\\'s max points\\n    \\tlong min = Long.MAX_VALUE;\\n        // Each column is a possible threshold column where the firt robot must move downwards once and for all (why atleast once: because the destination row is below the starting row. Why atmost once: beacuse there are only 2 rows in total). So iterate all the column to check for threshold column\\n    \\tfor (int i = 0; i < n; ++i) {\\n    \\t\\tif (i == n - 1) {\\n                min = Math.min(min, pre[1][i - 1]); // just a boundary hadling of else part\\n            } else if (i == 0) {\\n                min = Math.min(min, pre[0][i + 1]); // just a boundary handling of else part\\n            } else {\\n                // CRUX: \\n                // - For current threshold, second robot can either take all points top-right of current or bottom-left of current. (why just top-right or bottom-right: because first robot would have collected the remaing part. Draw it out to visulaize better). It will choose the max of both.\\n                // - First robot tries to minimize this maximum points second robot could collect\\n                min = Math.min(min, Math.max(pre[0][i + 1], pre[1][i - 1]));    \\n            }\\n\\t\\t\\t\\t\\n    \\t}\\n        \\n    \\treturn min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486270,
                "title": "prefix-sum-o-n-with-explanation",
                "content": "Let\\'s assume the first robot move \"down\" at column `index = i`. Then the best choice for the second robot is either of the following two:\\n1. collect all remaining points `= suffix(grid[0][i + 1])` on the first row, then move \"down\" to (1, N - 1)\\n2. move \"down\" to (1, 0) then collect all remaining points `= prefix(grid[1][i - 1])` on the second row\\n\\nFor the first robot to minimize the points the 2nd robot can collect, it has to select a column `index = i`, which has minimal `max(prefix(grid[1][i - 1]), suffix(grid[0][i + 1]))`.\\n\\n**Time complexity**: `O(N)`\\n\\n**Java solution**\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        final int N = grid[0].length;\\n        // second[0][i] suffix first row; second[1][i] prefix 2nd row; not including i\\n        long[][] second = new long[2][N];\\n        for (int i = 1; i < N; i++) {\\n            second[1][i] = second[1][i - 1] + grid[1][i - 1];\\n        }\\n        for (int i = N - 2; i >= 0; i--) {\\n            second[0][i] = second[0][i + 1] + grid[0][i + 1];\\n        }\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            min = Math.min(min, Math.max(second[0][i], second[1][i]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        final int N = grid[0].length;\\n        // second[0][i] suffix first row; second[1][i] prefix 2nd row; not including i\\n        long[][] second = new long[2][N];\\n        for (int i = 1; i < N; i++) {\\n            second[1][i] = second[1][i - 1] + grid[1][i - 1];\\n        }\\n        for (int i = N - 2; i >= 0; i--) {\\n            second[0][i] = second[0][i + 1] + grid[0][i + 1];\\n        }\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            min = Math.min(min, Math.max(second[0][i], second[1][i]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089433,
                "title": "sliding-window-or-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        mPoints = float(\\'inf\\')\\n        p1 = sum(grid[0])\\n        p2= -grid[1][-1]\\n        for i in range(len(grid[0])):\\n            p1 -=grid[0][i]\\n            p2 += grid[1][i-1]\\n            mPoints = min(mPoints, max(p1, p2))\\n        return mPoints\\n            \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        mPoints = float(\\'inf\\')\\n        p1 = sum(grid[0])\\n        p2= -grid[1][-1]\\n        for i in range(len(grid[0])):\\n            p1 -=grid[0][i]\\n            p2 += grid[1][i-1]\\n            mPoints = min(mPoints, max(p1, p2))\\n        return mPoints\\n            \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080881,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        N = len(grid[0])\\n        pre1,pre2 = grid[0].copy(),grid[1].copy()\\n        for i in range(1,N):\\n            pre1[i] += pre1[i-1] \\n            pre2[i] += pre2[i-1] \\n        res = float(\\'inf\\')\\n        for i in range(N):\\n            top = pre1[-1]-pre1[i]\\n            bottom = pre2[i-1] if i>0 else 0\\n            second = max(top,bottom)\\n            res = min(res,second)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        N = len(grid[0])\\n        pre1,pre2 = grid[0].copy(),grid[1].copy()\\n        for i in range(1,N):\\n            pre1[i] += pre1[i-1] \\n            pre2[i] += pre2[i-1] \\n        res = float(\\'inf\\')\\n        for i in range(N):\\n            top = pre1[-1]-pre1[i]\\n            bottom = pre2[i-1] if i>0 else 0\\n            second = max(top,bottom)\\n            res = min(res,second)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014784,
                "title": "easy-c-solution-prefix-sum-approach-memory-beats-96",
                "content": "# Intuition\\nTo reach the rightmost corner robo-1 has to surely move down somewhere, so all the points in that path will be 0, so robo-2 can collect only those points which are ahead of that turn in the first row or before that turn in the second row, and out off all the turn robo-2 will get minimum.\\n\\n# Approach\\nCalculate the sum before the turn in the second and ahead of the turn in the first row, for all possible turns from 0 to n-1, we will choose the maximum of those two values, and out of all the max-values our ans will be minimun of those.\\n\\n# Complexity\\n- Time complexity:\\nO(n)-->Since we are iterating from 0 to n-1.\\n\\n- Space complexity:\\nO(1)-->Since we are using few variables each time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long r1 = 0;\\n        int n = grid[0].size();\\n        for (int i=0; i<n; i++) {\\n            r1+=grid[0][i];\\n        }\\n        r1+=grid[1][n-1];\\n        \\n\\n        long long s1 = 0, s2 = 0, score = 0, ans = LONG_MAX;\\n        for (int i=0; i<n; i++) {\\n            long long c1 = s2;\\n            long long c2 = r1 - s1 - grid[0][i] - grid[1][n-1];\\n            score = max(c1, c2);\\n            ans = min(ans, score);\\n            s1+=grid[0][i];\\n            s2+=grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long r1 = 0;\\n        int n = grid[0].size();\\n        for (int i=0; i<n; i++) {\\n            r1+=grid[0][i];\\n        }\\n        r1+=grid[1][n-1];\\n        \\n\\n        long long s1 = 0, s2 = 0, score = 0, ans = LONG_MAX;\\n        for (int i=0; i<n; i++) {\\n            long long c1 = s2;\\n            long long c2 = r1 - s1 - grid[0][i] - grid[1][n-1];\\n            score = max(c1, c2);\\n            ans = min(ans, score);\\n            s1+=grid[0][i];\\n            s2+=grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989266,
                "title": "c-implementation-with-explanation",
                "content": "**Key idea**\\n\\n`To minimize the points collected by the second robot` != `To maximize the points collected by the first robot`\\n\\nConsider the test case below.\\n\\n![image](https://assets.leetcode.com/users/images/e170a0db-7d13-43f2-8ef7-edd2a2f73cf6_1693585210.0103874.png)\\n\\nTo maximize the points collected by the first robot, the path is as belw with points 467.\\n\\n![image](https://assets.leetcode.com/users/images/c0062697-bbd2-467a-891c-195d26502f39_1693585239.1597202.png)\\n\\nAnd the points collected by the second robot will be 217.\\n\\n![image](https://assets.leetcode.com/users/images/a0b17473-da00-48ee-bc3b-df65382c1f86_1693585352.7696471.png)\\n\\nBut to minimize the points collected by the second robot, the path is as belw with points 409.\\n\\n![image](https://assets.leetcode.com/users/images/fe70615f-1c35-49c8-b0e7-bf04e0e1b9d5_1693585427.3560693.png)\\n\\nAnd the points collected by the second robot will be 145.\\n\\n![image](https://assets.leetcode.com/users/images/8f43ea32-42e8-44f5-a9a0-8dfeb0fc3b97_1693585444.9534647.png)\\n\\nBecause the robot can only move to the right or down, for every path that the first robot moves, only the tailing part of the 0th row (ex: 31,99) and the leading part of the 1st row (26,82,17,17,3) are left for the second robot.\\nTherefore, the question becomes to pick the large sum of these 2 parts and only keep the smallest one of all possible paths for the second robot.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize){\\n  long long sum_row0 = 0;\\n  long long sum_row1 = 0;\\n  long long ret_sum, curr_sum;\\n  \\n  for (int loop_idx=1; loop_idx<gridColSize[0]; loop_idx++) {\\n    sum_row0 += grid[0][loop_idx];\\n  }\\n  \\n  ret_sum = sum_row0;\\n  \\n  for (int loop_idx=1; loop_idx<gridColSize[0]; loop_idx++) {\\n    sum_row0 -= grid[0][loop_idx];\\n    sum_row1 += grid[1][loop_idx-1];\\n    curr_sum = (sum_row0 > sum_row1) ? sum_row0 : sum_row1;\\n    if (ret_sum > curr_sum) ret_sum = curr_sum;\\n  }\\n  \\n  return ret_sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize){\\n  long long sum_row0 = 0;\\n  long long sum_row1 = 0;\\n  long long ret_sum, curr_sum;\\n  \\n  for (int loop_idx=1; loop_idx<gridColSize[0]; loop_idx++) {\\n    sum_row0 += grid[0][loop_idx];\\n  }\\n  \\n  ret_sum = sum_row0;\\n  \\n  for (int loop_idx=1; loop_idx<gridColSize[0]; loop_idx++) {\\n    sum_row0 -= grid[0][loop_idx];\\n    sum_row1 += grid[1][loop_idx-1];\\n    curr_sum = (sum_row0 > sum_row1) ? sum_row0 : sum_row1;\\n    if (ret_sum > curr_sum) ret_sum = curr_sum;\\n  }\\n  \\n  return ret_sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985284,
                "title": "runtime-beats-84-41-prefix-sum-cpp",
                "content": "Runtime: 119 ms \\nMemory Usage: 62.8 MB\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        long long tmax = 0, sumc0 = 0, sumc1 = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sumc0 += grid[0][i];\\n        }\\n\\n        tmax = sumc0;\\n\\n        for (int i = 0; i < n; i++) {\\n            tmax = min(tmax, max(sumc0 - grid[0][i], sumc1)); \\n            sumc0 -= grid[0][i];\\n            sumc1 += grid[1][i];\\n        }\\n\\n        return tmax;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        long long tmax = 0, sumc0 = 0, sumc1 = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sumc0 += grid[0][i];\\n        }\\n\\n        tmax = sumc0;\\n\\n        for (int i = 0; i < n; i++) {\\n            tmax = min(tmax, max(sumc0 - grid[0][i], sumc1)); \\n            sumc0 -= grid[0][i];\\n            sumc1 += grid[1][i];\\n        }\\n\\n        return tmax;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981223,
                "title": "prefix-sum-c-solution-one-of-the-best-problems-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        ll top = 0;\\n        int n = grid[0].size();\\n        for(int i=0;i<n;i++)top+=(ll)grid[0][i];\\n\\n        ll ans = 1e12;\\n\\n        ll bottom = 0;\\n        for(int i=0;i<n;i++){\\n            top-=grid[0][i];\\n            ans =min(ans,max(top,bottom));\\n            bottom += grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        ll top = 0;\\n        int n = grid[0].size();\\n        for(int i=0;i<n;i++)top+=(ll)grid[0][i];\\n\\n        ll ans = 1e12;\\n\\n        ll bottom = 0;\\n        for(int i=0;i<n;i++){\\n            top-=grid[0][i];\\n            ans =min(ans,max(top,bottom));\\n            bottom += grid[1][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979933,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int n;\\n        n=grid[0].size();\\n\\n        vector<long long> sum1(n),sum2(n);\\n        sum1[0]=grid[0][0];\\n        sum2[0]=grid[1][0];\\n\\n        for(int i=1;i<grid[0].size();i++)\\n        {\\n            sum1[i]=sum1[i-1]+grid[0][i];\\n            sum2[i]=sum2[i-1]+grid[1][i];\\n        }\\n\\n        long long ans;\\n        ans=sum1[n-1]-sum1[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(max(sum1[n-1]-sum1[i],sum2[i-1])<ans)\\n            {\\n                ans=max(sum1[n-1]-sum1[i],sum2[i-1]);\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int n;\\n        n=grid[0].size();\\n\\n        vector<long long> sum1(n),sum2(n);\\n        sum1[0]=grid[0][0];\\n        sum2[0]=grid[1][0];\\n\\n        for(int i=1;i<grid[0].size();i++)\\n        {\\n            sum1[i]=sum1[i-1]+grid[0][i];\\n            sum2[i]=sum2[i-1]+grid[1][i];\\n        }\\n\\n        long long ans;\\n        ans=sum1[n-1]-sum1[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(max(sum1[n-1]-sum1[i],sum2[i-1])<ans)\\n            {\\n                ans=max(sum1[n-1]-sum1[i],sum2[i-1]);\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979795,
                "title": "prefix-sum-followed-by-max-min-c-p",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalcuate prefix sum for both row at each col and then calculate max of what Robot2 can get from remaining col at each row and then minimize it as possible moves taken by Robot1.\\n\\n# Complexity\\n- Time complexity: O(col) = O(grid[0].size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(col) = O(grid[0].size())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nFor those who like me thought oh this is a repeat DP problem i.e. I use DP to find the path maximizing robot 1\\'s score and then use DP to help find robot 2\\'s maximum score path. Then I\\'m done. Well not exactly... \\n\\nCan consider this testcase:\\n\\n10 50 50 30\\n50 50 10 10\\n\\nIf you find the maximum path for Robot 1 and set those cells into 0, then the path became:\\n\\n00 00 00 00\\n50 50 10 00\\n\\nThe Robot 2 can get a maximum of 110 points\\n\\nBut if Robot 1 goes by:\\n\\n00 00 50 30\\n50 00 00 00\\n\\nThen Robot 2 can get a maximum of 80 points.\\n*/\\n\\n/*\\n\\nThe first robot wants to minimize the number of points collected by the second robot; though the first robot have to take less value;\\nIn contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\\n\\n*/\\n    long long gridGame(vector<vector<int>>& grid) {\\n\\n        int col = grid[0].size();\\n        \\n        vector<long long> prefix0(col,0);   // changes done here \\'long long\\' instead of \\'int\\'\\n        vector<long long> prefix1(col,0);   // changes done here \\'long long\\' instead of \\'int\\'\\n\\n        prefix0[0]=grid[0][0];\\n        prefix1[0]=grid[1][0];\\n\\n        for(int i = 1; i<col; i++){\\n            prefix0[i]=grid[0][i]+prefix0[i-1];\\n            prefix1[i]=grid[1][i]+prefix1[i-1];\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for(int i = 0; i<col; i++){\\n            long long first = prefix0[col-1]-prefix0[i];\\n            long long second = i>0?prefix1[i-1]:0;\\n            ans=min(ans,max(first,second));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nFor those who like me thought oh this is a repeat DP problem i.e. I use DP to find the path maximizing robot 1\\'s score and then use DP to help find robot 2\\'s maximum score path. Then I\\'m done. Well not exactly... \\n\\nCan consider this testcase:\\n\\n10 50 50 30\\n50 50 10 10\\n\\nIf you find the maximum path for Robot 1 and set those cells into 0, then the path became:\\n\\n00 00 00 00\\n50 50 10 00\\n\\nThe Robot 2 can get a maximum of 110 points\\n\\nBut if Robot 1 goes by:\\n\\n00 00 50 30\\n50 00 00 00\\n\\nThen Robot 2 can get a maximum of 80 points.\\n*/\\n\\n/*\\n\\nThe first robot wants to minimize the number of points collected by the second robot; though the first robot have to take less value;\\nIn contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\\n\\n*/\\n    long long gridGame(vector<vector<int>>& grid) {\\n\\n        int col = grid[0].size();\\n        \\n        vector<long long> prefix0(col,0);   // changes done here \\'long long\\' instead of \\'int\\'\\n        vector<long long> prefix1(col,0);   // changes done here \\'long long\\' instead of \\'int\\'\\n\\n        prefix0[0]=grid[0][0];\\n        prefix1[0]=grid[1][0];\\n\\n        for(int i = 1; i<col; i++){\\n            prefix0[i]=grid[0][i]+prefix0[i-1];\\n            prefix1[i]=grid[1][i]+prefix1[i-1];\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for(int i = 0; i<col; i++){\\n            long long first = prefix0[col-1]-prefix0[i];\\n            long long second = i>0?prefix1[i-1]:0;\\n            ans=min(ans,max(first,second));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977937,
                "title": "c-prefix-sum-approach-explanation",
                "content": "# Approach\\nBecause the first robot minimizes the point gained by the second robot, we can choose a path that minimizes the point for the second robot. While the first robot is minimizing the point for the second robot, he maximizes its own point. \\n\\nLet\\'s consider an example. \\n```\\n    grid = | 2 | 5 | 4\\n           | 1 | 5 | 1\\n\\nIf robot 1 decides to move down to row 1, let\\' say, at index 1 (column), then\\nthe point that can be collectec by the second robot is \\nthe maximum of the sum of values of row 0 starting from index 2 to end \\nand the sum of values of row 1 starting from index 0 to index i. \\nmax(sum(grid[0][i + 1] ... grid[0][n - 1]),sum(grid[1][0] ... grid[1][i - 1]));\\n\\n```\\n\\nI have used <code>row0</code> and <code>row1</code> as prefix sum of row 0 and row 1. We can also use the grid itself as a prefix sum rather than separate arrays. \\n\\n# Code\\n```\\n\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vv<long long> row0(n + 1); // prefix sum array for row 1\\n        vv<long long> row1(n + 1); // prefix sum array for row 2\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            row0[i] = row0[i - 1] + grid[0][i - 1];\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            row1[i] = row1[i - 1] + grid[1][i - 1];\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            long long x = std::max(row0[n] - row0[i], row1[i - 1]);\\n            if(ans > x)\\n                ans = x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    grid = | 2 | 5 | 4\\n           | 1 | 5 | 1\\n\\nIf robot 1 decides to move down to row 1, let\\' say, at index 1 (column), then\\nthe point that can be collectec by the second robot is \\nthe maximum of the sum of values of row 0 starting from index 2 to end \\nand the sum of values of row 1 starting from index 0 to index i. \\nmax(sum(grid[0][i + 1] ... grid[0][n - 1]),sum(grid[1][0] ... grid[1][i - 1]));\\n\\n```\n```\\n\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vv<long long> row0(n + 1); // prefix sum array for row 1\\n        vv<long long> row1(n + 1); // prefix sum array for row 2\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            row0[i] = row0[i - 1] + grid[0][i - 1];\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            row1[i] = row1[i - 1] + grid[1][i - 1];\\n        }\\n\\n        long long ans = LLONG_MAX;\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            long long x = std::max(row0[n] - row0[i], row1[i - 1]);\\n            if(ans > x)\\n                ans = x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977845,
                "title": "typescript-prefix-sum-matrix-o-n-time-o-n-space",
                "content": "# Intuition\\nKey Takeways from the problem statement:\\n\\n- Robots can move down only once as they can move down and right and there are only 2 rows\\n\\n- First Robot `robot1` doesn\\'t have to get the maximum sum, it only has to minimise the second robot\\'s sum\\n\\n---\\n\\nwhen a path is created by `robot1` the two groups of cells seperated by the `robot1` path are the two possible point group that can be gotten by `robot2`, the max between this two is the point for `robot2` when `robot1` create the path\\n\\n---\\n\\n\\nGiven the grid below\\n\\n![image.png](https://assets.leetcode.com/users/images/1d2e86a9-b0b9-4e32-854f-7afb65959986_1693334581.0671263.png)\\n\\nwe get all the possible path for `robot1` and for each path we get the max point that `robot2` can get (which is the max between the groups seperated by the `robot1` path)\\n\\n---\\n\\n\\n### Path 1\\n![image.png](https://assets.leetcode.com/users/images/92daa6e3-ba79-456d-b01b-20d2022c1523_1693334762.1415944.png)\\nfor this path (red)  it only leaves one group (blue),\\n\\nred_path = `robot1` = 2 -> 1 -> 5 -> 1\\n\\ngroup1 = 5 + 4 = 9\\nmax path for `robot2` = max(9) = 9\\n\\n\\n---\\n\\n\\n### Path 2\\n![image.png](https://assets.leetcode.com/users/images/54a4ecab-316f-4104-a345-2a2d4a4ef2fe_1693334933.115393.png)\\nfor this path (red) it leaves 2 groups (blue amd green),\\n\\nred_path = `robot1` = 2 -> 5 -> 5 -> 1\\n\\ngroup1 = 4 \\ngroup2 = 1 \\nmax path for `robot2` = max(1,4) = 4\\n\\n---\\n\\n### Path 3\\n![image.png](https://assets.leetcode.com/users/images/afbb772f-4dd1-499a-9dbb-50735109e3e4_1693335000.3208792.png)\\nfor this path (red)  it only leaves one group (blue),\\n\\nred_path = `robot1` = 2 -> 5 -> 4 -> 1 \\n\\ngroup1 = 5 + 1 = 6  \\nmax path for `robot2` = max(6) = 6\\n\\n---\\n\\nThe problem says `robot1` moves to make path that would minimize the maximum score acquirable by `robot2`\\n\\nso `ans = min(...max_scores_of_robot2)` = `min(6,4,9)` = 9\\n\\n\\n# Approach\\nUsing prefix sum can get the sum for the top group and the bottom group created by the red path\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunction gridGame(grid: number[][]): number {\\n\\n    let prefixSums = new Array(grid[0].length + 1).fill(0)\\n    \\n    for(let i = grid[0].length-1; i >= 0; i--){\\n        prefixSums[i] = grid[0][i] + prefixSums[i+1]\\n    }\\n    \\n    let bottom = 0\\n    let minResult = Infinity\\n    for(let i = 0; i < grid[0].length;i++){\\n        let side = prefixSums[i+1]\\n        let robotTwoMax = Math.max(side, bottom)\\n        minResult = Math.min(minResult,robotTwoMax)\\n        bottom += grid[1][i]\\n    }\\n    return minResult\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nfunction gridGame(grid: number[][]): number {\\n\\n    let prefixSums = new Array(grid[0].length + 1).fill(0)\\n    \\n    for(let i = grid[0].length-1; i >= 0; i--){\\n        prefixSums[i] = grid[0][i] + prefixSums[i+1]\\n    }\\n    \\n    let bottom = 0\\n    let minResult = Infinity\\n    for(let i = 0; i < grid[0].length;i++){\\n        let side = prefixSums[i+1]\\n        let robotTwoMax = Math.max(side, bottom)\\n        minResult = Math.min(minResult,robotTwoMax)\\n        bottom += grid[1][i]\\n    }\\n    return minResult\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977106,
                "title": "best-c-soiution-beats-92",
                "content": "# Intuition\\nprefix sum\\n\\n# Approach\\nlets store the total sum of the upper row \\nnow when we move forward we are making the present cell value 0 \\nso for our second robot this value will not be in our answer so we subtract the value from our sum\\nnow lets check the prefix sum of second row at the same time .\\nbecause as soon as we get the lower prefix sum to be less than or equal to the value in the upper cell we move to the lower row .\\nand finaaly our ans will be the max of either left prefix sum or right suffix sum. as those two routes will be only possible for our second robot.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        long long left=0;\\n        long long right=0;\\n        long long ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            right=right+grid[0][i];\\n        }\\n        for(int i=0;i<m;i++){\\n            right=right-grid[0][i]; // suffix sum\\n            left=left+grid[1][i]; // prefix sum\\n            if(right<=left){  // condition for moving down\\n                 ans=max(left-grid[1][i],right);\\n                 break; // this is only way after this we can only move right side and not down or up\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int m=grid[0].size();\\n        long long left=0;\\n        long long right=0;\\n        long long ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            right=right+grid[0][i];\\n        }\\n        for(int i=0;i<m;i++){\\n            right=right-grid[0][i]; // suffix sum\\n            left=left+grid[1][i]; // prefix sum\\n            if(right<=left){  // condition for moving down\\n                 ans=max(left-grid[1][i],right);\\n                 break; // this is only way after this we can only move right side and not down or up\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976568,
                "title": "c-prefix-sum-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long int n = grid[0].size();\\n        vector<long long int> r1(n,-1);\\n        vector<long long int> l2(n,-1);\\n        \\n        // What I have done here is used a trick\\n        // Now since we can move only down and left and we have only 2 rows, we can choose one index and use that to\\n        // move down. Rest of the time we will just move rightward.\\n        // Also observe that for gaining max score the 2nd bot need to go down at either first index or at thwe last\\n        // index. If it goes down at any other index, it is losing points.\\n        // So for the top row we need sum of scores to it\\'s right to get the answer if the 2nd robot decides to go\\n        // down at the last index\\n        // So for the bottom row we need sum of scores to it\\'s left to get the answer if the 2nd robot decides to go\\n        // down at the first index\\n        // We use min-max here because the 2nd robot will choose the option which gives max score while the 1st robot\\n        // will take the option which gives min score of the 2nd robot \\n        \\n        long long int temp = 0;\\n        for(long long int i = n-1; i >= 0 ; i--)\\n        {\\n            r1[i] = temp;\\n            temp += grid[0][i];\\n        }\\n        temp = 0;\\n        for(long long int i = 0 ; i < n ; i++)\\n        {\\n            l2[i] = temp;\\n            temp += grid[1][i];\\n        }\\n        long long int ans = LLONG_MAX;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans = min(ans,max(l2[i],r1[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long int n = grid[0].size();\\n        vector<long long int> r1(n,-1);\\n        vector<long long int> l2(n,-1);\\n        \\n        // What I have done here is used a trick\\n        // Now since we can move only down and left and we have only 2 rows, we can choose one index and use that to\\n        // move down. Rest of the time we will just move rightward.\\n        // Also observe that for gaining max score the 2nd bot need to go down at either first index or at thwe last\\n        // index. If it goes down at any other index, it is losing points.\\n        // So for the top row we need sum of scores to it\\'s right to get the answer if the 2nd robot decides to go\\n        // down at the last index\\n        // So for the bottom row we need sum of scores to it\\'s left to get the answer if the 2nd robot decides to go\\n        // down at the first index\\n        // We use min-max here because the 2nd robot will choose the option which gives max score while the 1st robot\\n        // will take the option which gives min score of the 2nd robot \\n        \\n        long long int temp = 0;\\n        for(long long int i = n-1; i >= 0 ; i--)\\n        {\\n            r1[i] = temp;\\n            temp += grid[0][i];\\n        }\\n        temp = 0;\\n        for(long long int i = 0 ; i < n ; i++)\\n        {\\n            l2[i] = temp;\\n            temp += grid[1][i];\\n        }\\n        long long int ans = LLONG_MAX;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans = min(ans,max(l2[i],r1[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975285,
                "title": "using-prefix-sum",
                "content": "# Intuition\\nFor every index calculating maximum score second robot can achieve and returning minimum score among all the indices.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        s1, s2 = [grid[0][0]], [grid[1][0]]\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            s1.append(s1[-1] + grid[0][i])\\n            s2.append(s2[-1] + grid[1][i])\\n\\n        sec_robot_min = s1[-1] - s1[0]\\n        for i in range(1, n):\\n            sec_robot_min = min(sec_robot_min, max(s1[-1] - s1[i], s2[i-1]))\\n        return sec_robot_min \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        s1, s2 = [grid[0][0]], [grid[1][0]]\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            s1.append(s1[-1] + grid[0][i])\\n            s2.append(s2[-1] + grid[1][i])\\n\\n        sec_robot_min = s1[-1] - s1[0]\\n        for i in range(1, n):\\n            sec_robot_min = min(sec_robot_min, max(s1[-1] - s1[i], s2[i-1]))\\n        return sec_robot_min \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975120,
                "title": "best-approach-beats-almost-90-percent",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        ans = math.inf\\n        topSum = sum(grid[0])\\n        bottomSum = 0\\n\\n        for i in range(n):\\n            topSum -= grid[0][i]\\n            ans = min(ans, max(topSum, bottomSum))\\n            bottomSum += grid[1][i]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        ans = math.inf\\n        topSum = sum(grid[0])\\n        bottomSum = 0\\n\\n        for i in range(n):\\n            topSum -= grid[0][i]\\n            ans = min(ans, max(topSum, bottomSum))\\n            bottomSum += grid[1][i]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974188,
                "title": "prefix-and-suffix-concept-easy-to-understand-code-tc-o-n-sc-o-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int col = grid[0].size(); // number of columns in grid\\n        long long x = 0; // store second path sum for second robot\\n        long long ans = numeric_limits<long long>::max();\\n        long long sm = 0; // store first path sum for second robot\\n        sm = accumulate(grid[0].begin(), grid[0].end(), sm);\\n        for(int i = 0; i < col; ++i)\\n        {\\n            sm -= grid[0][i]; // sum of first path for second robot\\n            ans = min(ans, max(sm, x)); // update ans\\n            x += grid[1][i]; // sum of second path for second robot\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int col = grid[0].size(); // number of columns in grid\\n        long long x = 0; // store second path sum for second robot\\n        long long ans = numeric_limits<long long>::max();\\n        long long sm = 0; // store first path sum for second robot\\n        sm = accumulate(grid[0].begin(), grid[0].end(), sm);\\n        for(int i = 0; i < col; ++i)\\n        {\\n            sm -= grid[0][i]; // sum of first path for second robot\\n            ans = min(ans, max(sm, x)); // update ans\\n            x += grid[1][i]; // sum of second path for second robot\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973071,
                "title": "prefix-sum-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<long long>pref1(n),pref2(n);\\n        pref1[0]=grid[0][0];\\n        pref2[0]=grid[1][0];\\n        for(int i=1;i<grid[0].size();i++){\\n            pref1[i]=pref1[i-1]+grid[0][i];\\n            pref2[i]=pref2[i-1]+grid[1][i];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            long long top=pref1[n-1]-pref1[i];\\n            long long bottom= 0;\\n            if(i>0) bottom=pref2[i-1];\\n            long long p=max(top,bottom);\\n            ans=min(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<long long>pref1(n),pref2(n);\\n        pref1[0]=grid[0][0];\\n        pref2[0]=grid[1][0];\\n        for(int i=1;i<grid[0].size();i++){\\n            pref1[i]=pref1[i-1]+grid[0][i];\\n            pref2[i]=pref2[i-1]+grid[1][i];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            long long top=pref1[n-1]-pref1[i];\\n            long long bottom= 0;\\n            if(i>0) bottom=pref2[i-1];\\n            long long p=max(top,bottom);\\n            ans=min(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972466,
                "title": "c-prefix-sum",
                "content": "```\\n# define ll long long \\nclass Solution {\\npublic:\\n\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        \\n        ll s= 0 ,s1= 0 ; \\n        ll n = grid[0].size() ; \\n        vector<vector<ll>>pre(2 , vector<ll>(n , 0 )) ;\\n        \\n        for(int i= 0; i<n; i++ )\\n        {\\n            s+=grid[0][i] ;\\n            pre[0][i] = s; \\n            s1+=grid[1][i] ;\\n            pre[1][i] =s1  ;\\n        }\\n     ll ans = 1e18 ;\\n        for(int i =0 ; i<n ;i++ )\\n        {\\n            ll s = 0 ;\\n            if(i==0)\\n            {\\n                s = pre[0][n-1] - pre[0][0] ;\\n            }\\n            else if(i==n-1)\\n            {\\n                 s = pre[1][n-2] ;\\n            }\\n            else\\n            {\\n                s = max(pre[0][n-1] -pre[0][i] ,  pre[1][i-1]);\\n            }\\n            ans= min(ans , s ) ;\\n        }\\n            return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n# define ll long long \\nclass Solution {\\npublic:\\n\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        \\n        ll s= 0 ,s1= 0 ; \\n        ll n = grid[0].size() ; \\n        vector<vector<ll>>pre(2 , vector<ll>(n , 0 )) ;\\n        \\n        for(int i= 0; i<n; i++ )\\n        {\\n            s+=grid[0][i] ;\\n            pre[0][i] = s; \\n            s1+=grid[1][i] ;\\n            pre[1][i] =s1  ;\\n        }\\n     ll ans = 1e18 ;\\n        for(int i =0 ; i<n ;i++ )\\n        {\\n            ll s = 0 ;\\n            if(i==0)\\n            {\\n                s = pre[0][n-1] - pre[0][0] ;\\n            }\\n            else if(i==n-1)\\n            {\\n                 s = pre[1][n-2] ;\\n            }\\n            else\\n            {\\n                s = max(pre[0][n-1] -pre[0][i] ,  pre[1][i-1]);\\n            }\\n            ans= min(ans , s ) ;\\n        }\\n            return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954063,
                "title": "c-easy-choosing-one-column-to-switch-rows-shorter-than-your-mom-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2*n) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<vector<long long>> p(2,vector<long long>(n,0));\\n        for(int i =0;i<2;i++){\\n            long long s =0;\\n            for(int j=0;j<n;j++){\\n                s+=grid[i][j];\\n                p[i][j] = s;\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i =0;i<n;i++){\\n            long long l = i-1>=0?p[1][i-1]:0;\\n            long long r = p[0][n-1]-p[0][i];\\n            l = max(l,r);\\n            ans = min(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<vector<long long>> p(2,vector<long long>(n,0));\\n        for(int i =0;i<2;i++){\\n            long long s =0;\\n            for(int j=0;j<n;j++){\\n                s+=grid[i][j];\\n                p[i][j] = s;\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i =0;i<n;i++){\\n            long long l = i-1>=0?p[1][i-1]:0;\\n            long long r = p[0][n-1]-p[0][i];\\n            l = max(l,r);\\n            ans = min(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899657,
                "title": "best-c-o-n-solution",
                "content": "The Intuition should be to save the possible sum in an array and traverse the stored array one by one and check which is the best possible value.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        if(grid[0].size()==1);\\n        else{\\n            int n = grid[0].size();\\n            long long maxminimized, sum0=0, sum1=0;\\n            vector<long long>prefixSum0, prefixSum1;\\n            for(int i=0; i<n; i++){\\n                sum0 += grid[0][i];\\n                prefixSum0.push_back(sum0);\\n            }\\n            for(int i=0; i<n; i++){\\n                sum1 += grid[1][i];\\n                prefixSum1.push_back(sum1);\\n            }\\n            maxminimized = min(sum0 - prefixSum0[0],sum1 - grid[1][n-1]);\\n            for(int i=1; i<n-1; i++){\\n                sum0 = prefixSum0[n-1] - prefixSum0[i];\\n                sum1 = prefixSum1[i-1];\\n                maxminimized = min(maxminimized, max(sum0, sum1));\\n            }\\n            return maxminimized;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        if(grid[0].size()==1);\\n        else{\\n            int n = grid[0].size();\\n            long long maxminimized, sum0=0, sum1=0;\\n            vector<long long>prefixSum0, prefixSum1;\\n            for(int i=0; i<n; i++){\\n                sum0 += grid[0][i];\\n                prefixSum0.push_back(sum0);\\n            }\\n            for(int i=0; i<n; i++){\\n                sum1 += grid[1][i];\\n                prefixSum1.push_back(sum1);\\n            }\\n            maxminimized = min(sum0 - prefixSum0[0],sum1 - grid[1][n-1]);\\n            for(int i=1; i<n-1; i++){\\n                sum0 = prefixSum0[n-1] - prefixSum0[i];\\n                sum1 = prefixSum1[i-1];\\n                maxminimized = min(maxminimized, max(sum0, sum1));\\n            }\\n            return maxminimized;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691838,
                "title": "o-n-time-o-1-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRobot 1 can take n possible paths. Robot 2 can only move down (bottom row) or right (top row) of the column that robot 1 traversed and can collect the top row points or bottom row points.\\n\\nTake the max of the top and bottom row sum because robot 2 wants to maximize the points. Take the minimum of the max points because robot 1 wants to minimize the points.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- set result variable res=float infinity\\n- set bottom sum bottom=0 and top sum top=sum of top row\\n- traverse the value in grids 0 and 1\\n    - decrement the top sum\\n    - take min of the max of the top and bottom sum and update the res\\n    - increment the bottom sum\\n- return res\\n\\n# Complexity\\n- Time complexity: O(n)\\nn = size of grid 0\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        bottom, top = 0, sum(grid[0])\\n        for a, b in zip(grid[0], grid[1]):\\n            top -= a\\n            res = min(res, max(top, bottom))\\n            bottom += b\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        bottom, top = 0, sum(grid[0])\\n        for a, b in zip(grid[0], grid[1]):\\n            top -= a\\n            res = min(res, max(top, bottom))\\n            bottom += b\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597808,
                "title": "o-n-solution-with-idea-explained-alternate-description-of-solutions-explained-here",
                "content": "# Idea \\n\\nFrom all possible scenarios, make robot 2 pick the max value it can. However robot 1 ensures the situation offered to robot 2 is the one where maximum value is minimum.\\nExample Testcase : \\n10 50 50 30 \\n50 50 10 10\\nAssume Robot1 takes top left element and the entire 2nd row. Now robot 2 needs to find max value. Robot2 has to pick between {130,0}.\\nNow assume Robot1 where robot1 takes the entire top row and the last cell. Robot2 can then pick between {110,0}. Ask yourself. Which case should robot1 offer to robot2? It must be the second case.\\nRead further if understood.\\n\\n# How many such scenarios possible?\\n\\n1 : Two distinct\\n2 : n-2 general scenarios. \\n\\n1 : \\nScenario 1 : Where robot1 takes top left element and the entire 2nd row. Now robot 2 finds the max value.\\nScenario 2 : Where robot1 takes the entire top row and the last cell.\\nRobot 2 finds the max value. \\nRobot1 must compare these 2 scenarios and should offer the choice to robot2 where maximum is minimised.\\n2 : \\nNow, for the remaining n-2 scenarios. We need to see what are the max values robot2 can obtain. For any of these n-2 scenarios, robot2 can pick either the top right half of row1, or bottom left half of row2. (Actually it will pick entire row, but some cells will be made zero by robot1. See the examples given in testcases.) \\nEvaluate the max value possible, and compare with the minimum of the previous 2 scenarios, and keep track of it, and return the value of min as the answer.\\nFor the example testcase. the remaining two scenarios are\\n{80,50} and {100,30}.\\n\\nThe entire answer is min(scneario(1), scenario(2), scenario(3),...,scenario(n)}) This is calculated by robot1.\\nwhere scenario(i) = max(a1,a2) where this is the max value robot2 must take.\\n\\n# Conclusion\\n\\nRobot1 calculates all the possible pair of values robot 2 can choose from, and then picks the particular case where robot 2 picks the maximum from the pair which has the smallest max value among all the pairs.\\n\\n# Note\\n\\nYou can find the top right half of top row and bottom left half of bottom row in O(1) time using prefix sum.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        if(grid[0].size()==1);\\n        else{\\n            int n = grid[0].size();\\n            long long maxminimized, sum0=0, sum1=0;\\n            vector<long long>prefixSum0, prefixSum1;\\n            for(int i=0; i<n; i++){\\n                sum0 += grid[0][i];\\n                prefixSum0.push_back(sum0);\\n            }\\n            for(int i=0; i<n; i++){\\n                sum1 += grid[1][i];\\n                prefixSum1.push_back(sum1);\\n            }\\n            maxminimized = min(sum0 - prefixSum0[0],sum1 - grid[1][n-1]);\\n            for(int i=1; i<n-1; i++){\\n                sum0 = prefixSum0[n-1] - prefixSum0[i];\\n                sum1 = prefixSum1[i-1];\\n                maxminimized = min(maxminimized, max(sum0, sum1));\\n            }\\n            return maxminimized;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        if(grid[0].size()==1);\\n        else{\\n            int n = grid[0].size();\\n            long long maxminimized, sum0=0, sum1=0;\\n            vector<long long>prefixSum0, prefixSum1;\\n            for(int i=0; i<n; i++){\\n                sum0 += grid[0][i];\\n                prefixSum0.push_back(sum0);\\n            }\\n            for(int i=0; i<n; i++){\\n                sum1 += grid[1][i];\\n                prefixSum1.push_back(sum1);\\n            }\\n            maxminimized = min(sum0 - prefixSum0[0],sum1 - grid[1][n-1]);\\n            for(int i=1; i<n-1; i++){\\n                sum0 = prefixSum0[n-1] - prefixSum0[i];\\n                sum1 = prefixSum1[i-1];\\n                maxminimized = min(maxminimized, max(sum0, sum1));\\n            }\\n            return maxminimized;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509644,
                "title": "simple-and-fast-c-and-java-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# c++\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<vector<long long>> pre(2,vector<long long>(n));\\n        pre[0][0]=grid[0][0];\\n        pre[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++){\\n            pre[0][i]=grid[0][i]+pre[0][i-1];\\n            pre[1][i]=grid[1][i]+pre[1][i-1];\\n        }\\n        long long ans=pre[0][n-1]-pre[0][0];\\n        long long back=pre[0][n-1];\\n        for(int i=1;i<n;i++){\\n            ans=min(ans,max(pre[1][i-1],back-pre[0][i]));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long[][] pre=new long[2][n];\\n        pre[0][0]=grid[0][0];\\n        pre[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++){\\n            pre[0][i]=grid[0][i]+pre[0][i-1];\\n            pre[1][i]=grid[1][i]+pre[1][i-1];\\n        }\\n        long ans=pre[0][n-1]-pre[0][0];\\n        long back=pre[0][n-1];\\n        for(int i=1;i<n;i++){\\n            ans=Math.min(ans,Math.max(pre[1][i-1],back-pre[0][i]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        vector<vector<long long>> pre(2,vector<long long>(n));\\n        pre[0][0]=grid[0][0];\\n        pre[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++){\\n            pre[0][i]=grid[0][i]+pre[0][i-1];\\n            pre[1][i]=grid[1][i]+pre[1][i-1];\\n        }\\n        long long ans=pre[0][n-1]-pre[0][0];\\n        long long back=pre[0][n-1];\\n        for(int i=1;i<n;i++){\\n            ans=min(ans,max(pre[1][i-1],back-pre[0][i]));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long[][] pre=new long[2][n];\\n        pre[0][0]=grid[0][0];\\n        pre[1][0]=grid[1][0];\\n        for(int i=1;i<n;i++){\\n            pre[0][i]=grid[0][i]+pre[0][i-1];\\n            pre[1][i]=grid[1][i]+pre[1][i-1];\\n        }\\n        long ans=pre[0][n-1]-pre[0][0];\\n        long back=pre[0][n-1];\\n        for(int i=1;i<n;i++){\\n            ans=Math.min(ans,Math.max(pre[1][i-1],back-pre[0][i]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506199,
                "title": "prefix-sums",
                "content": "# Intuition\\nThe first robot leaves only two ways to collect score for the second one: \\n- the remaining right part of the top row\\n- the remaining left part of the bottom row\\n\\n# Approach\\nFor each possible turn point, compute how much is left from the top and bottom row. The score collected by the second robot will be the max of those two quantities.\\n\\nThe answer is the minimum score the second robot can obtain. \\n\\nTo compute how much is left from left from both rows, we rely on prefix sums.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n\\n        p1, p2 = [grid[0][0]], [grid[1][0]]\\n        for a, b in zip(grid[0][1:], grid[1][1:]):\\n            p1.append(p1[-1] + a)\\n            p2.append(p2[-1] + b)\\n        \\n        ans = float(\"inf\")\\n\\n        for i in range(len(grid[0])):\\n            right = p1[-1] - p1[i]\\n            left = p2[i] - grid[1][i]\\n            ans = min(ans, max(left, right))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n\\n        p1, p2 = [grid[0][0]], [grid[1][0]]\\n        for a, b in zip(grid[0][1:], grid[1][1:]):\\n            p1.append(p1[-1] + a)\\n            p2.append(p2[-1] + b)\\n        \\n        ans = float(\"inf\")\\n\\n        for i in range(len(grid[0])):\\n            right = p1[-1] - p1[i]\\n            left = p2[i] - grid[1][i]\\n            ans = min(ans, max(left, right))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480257,
                "title": "o-n-with-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\np1,p2 memorize the prefix sum of rows respectively.\\nNote that for robot 2, the optimal path is either bottom-left or upper-right to avoid the zeros as much as possible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        vector<long long> p1{0},p2{0};\\n        for(auto n:grid[0]) p1.emplace_back(p1.back()+n);\\n        for(auto n:grid[1]) p2.emplace_back(p2.back()+n);\\n        long long result=LLONG_MAX;\\n        for(int i=1;i<p1.size();i++){\\n            long long tmp=max(p2[i-1],p1.back()-p1[i]);\\n            //p1[0:i]=0,p1[i+1:]-=p1[i],p2[0:i-1]=p2[0:i-1],p2[i:]=p2[i-1]\\n            result=min(result,tmp);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        vector<long long> p1{0},p2{0};\\n        for(auto n:grid[0]) p1.emplace_back(p1.back()+n);\\n        for(auto n:grid[1]) p2.emplace_back(p2.back()+n);\\n        long long result=LLONG_MAX;\\n        for(int i=1;i<p1.size();i++){\\n            long long tmp=max(p2[i-1],p1.back()-p1[i]);\\n            //p1[0:i]=0,p1[i+1:]-=p1[i],p2[0:i-1]=p2[0:i-1],p2[i:]=p2[i-1]\\n            result=min(result,tmp);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416999,
                "title": "easy-way-c-prefix-sum-optimal-approach-grid-game",
                "content": "# Intuition\\nIt\\'s a prefix sum and suffix sum mixed problem.\\nand the first robot divivdes the upper and lower arrays into two parts.\\nso after the traversal of first robot we only have two parts left one is left part of second level and right one is right part of first level.\\nso we can check at every index at which we are getting the minimum sum as first robot is playing optimally so we will get the minimum points as possible.\\n\\n# Approach\\n1. Create a preSum array of size 2xN first we traverse the array from left to right and fill upper part.\\n2. then we traverse right to left to fill suffix sum of lower part.\\n3. then we declare a variable ans with max possible long value.\\n4. we traverse in presum array and check for both left out part assuming the first robot take a step down at this index.\\n5. So for upper right half we can calculate by preSum[0][n-1] - preSum[0][i] storing in right variable.\\n6. for lower left half we can calculate by preSum[1][0] - preSum[1][i] storing in left variable.\\n7. now we can update answer with min(ans,max(left,right)); means the maximum points we can obtaing from either left or right and considering the minimum for answer. \\n\\n# Complexity\\n- Time complexity:\\n2 traveral of array to compute preSum O(N) + O(N);\\n1 traveral to find optimal solution O(N);\\n\\ntotal O(N) + O(N) + O(N) = 3O(N) = O(N);\\n\\n**time Comlexity O(N)**\\n\\n- Space complexity:\\nused an extra array to store prefix Sum so O(2*N) = O(N);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<vector<long long>> presum(2,vector<long long>(n,0));\\n        long long sum = 0;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            sum += grid[1][i];\\n            presum[1][i] = sum;\\n        }\\n        sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            sum += grid[0][i];\\n            presum[0][i] = sum;\\n        }\\n\\n        long long maxSum = LONG_MAX;\\n        for(int i = 0;i<n;i++)\\n        {\\n            long long left = presum[1][0] - presum[1][i];\\n            long long right = presum[0][n-1] - presum[0][i];\\n\\n            maxSum = min(maxSum,max(left,right));\\n\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        vector<vector<long long>> presum(2,vector<long long>(n,0));\\n        long long sum = 0;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            sum += grid[1][i];\\n            presum[1][i] = sum;\\n        }\\n        sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            sum += grid[0][i];\\n            presum[0][i] = sum;\\n        }\\n\\n        long long maxSum = LONG_MAX;\\n        for(int i = 0;i<n;i++)\\n        {\\n            long long left = presum[1][0] - presum[1][i];\\n            long long right = presum[0][n-1] - presum[0][i];\\n\\n            maxSum = min(maxSum,max(left,right));\\n\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415751,
                "title": "96-runtime-and-97-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        result = float(\"inf\")\\n\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right -= a\\n            result = min(result,max(left,right))\\n\\n            left+=b\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        result = float(\"inf\")\\n\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right -= a\\n            result = min(result,max(left,right))\\n\\n            left+=b\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395301,
                "title": "c-golang-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if(n == 1) return 0;\\n        vector<long long> prefix(n);\\n        prefix[0] = grid[1][0];\\n        for(int i = 1; i < n; i++) prefix[i] += prefix[i - 1] + grid[1][i];\\n        long long sum = 0, ans = prefix[n - 2];\\n        for(int i = n - 1; i > 0; i--) {\\n            sum += grid[0][i];\\n            ans = min(ans, max(sum, (i > 1? prefix[i - 2]: 0)));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int64) int64 {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc gridGame(grid [][]int) int64 {\\n    var n int = len(grid[0])\\n    if n == 1 {return 0}\\n    prefix := make([]int64, n)\\n    prefix[0] = int64(grid[1][0])\\n    for i := 1; i < n; i++ {prefix[i] += prefix[i - 1] + int64(grid[1][i])}\\n    var sum, ans int64 = 0, prefix[n - 2]\\n    for i := n - 1; i > 0; i-- {\\n        sum += int64(grid[0][i])\\n        var val int64 = 0\\n        if i > 1 {val = prefix[i - 2]} \\n        ans = min(ans, max(sum, val));\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if(n == 1) return 0;\\n        vector<long long> prefix(n);\\n        prefix[0] = grid[1][0];\\n        for(int i = 1; i < n; i++) prefix[i] += prefix[i - 1] + grid[1][i];\\n        long long sum = 0, ans = prefix[n - 2];\\n        for(int i = n - 1; i > 0; i--) {\\n            sum += grid[0][i];\\n            ans = min(ans, max(sum, (i > 1? prefix[i - 2]: 0)));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int64) int64 {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc gridGame(grid [][]int) int64 {\\n    var n int = len(grid[0])\\n    if n == 1 {return 0}\\n    prefix := make([]int64, n)\\n    prefix[0] = int64(grid[1][0])\\n    for i := 1; i < n; i++ {prefix[i] += prefix[i - 1] + int64(grid[1][i])}\\n    var sum, ans int64 = 0, prefix[n - 2]\\n    for i := n - 1; i > 0; i-- {\\n        sum += int64(grid[0][i])\\n        var val int64 = 0\\n        if i > 1 {val = prefix[i - 2]} \\n        ans = min(ans, max(sum, val));\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384257,
                "title": "c-prefix-sum",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate prefix sum of top row and bottom row.\\nThen for each column, check what is the maximum score of second robot if the first robot decides to go down at that point. This is done by comparing the sum between top right with (n-1) - i and bottom left (i-1).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long GridGame(int[][] grid) {\\n        var n = grid[0].Length;\\n        var prefix1 = new long[n];\\n        var prefix2 = new long[n];\\n\\n        prefix1[0] = grid[0][0];\\n        prefix2[0] = grid[1][0];\\n        for (var i = 1; i < n; i++) {\\n            prefix1[i] = prefix1[i-1] + grid[0][i];\\n            prefix2[i] = prefix2[i-1] + grid[1][i];\\n        }\\n        var score = Int64.MaxValue;\\n        for (var i = 0; i < n; i++) {\\n            var topRight = prefix1[n-1] - prefix1[i];\\n            var botLeft = i == 0 ? 0 : prefix2[i-1];\\n            score = Math.Min(score, Math.Max(topRight, botLeft));\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public long GridGame(int[][] grid) {\\n        var n = grid[0].Length;\\n        var prefix1 = new long[n];\\n        var prefix2 = new long[n];\\n\\n        prefix1[0] = grid[0][0];\\n        prefix2[0] = grid[1][0];\\n        for (var i = 1; i < n; i++) {\\n            prefix1[i] = prefix1[i-1] + grid[0][i];\\n            prefix2[i] = prefix2[i-1] + grid[1][i];\\n        }\\n        var score = Int64.MaxValue;\\n        for (var i = 0; i < n; i++) {\\n            var topRight = prefix1[n-1] - prefix1[i];\\n            var botLeft = i == 0 ? 0 : prefix2[i-1];\\n            score = Math.Min(score, Math.Max(topRight, botLeft));\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382229,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n//neetcode video\\n//here the secondrobot can take either remaining top elements or remaining bottom elements only\\n//so we\\'ll keep prefix of top and bottom\\n\\nclass Solution {\\npublic:\\n     \\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int n=grid[0].size();\\n      vector<long long>ps1(n,0);\\n      vector<long long>ps2(n,0);\\n      ps1[0]=grid[0][0];\\n      ps2[0]=grid[1][0];\\n      for (int i=1;i<n;i++)\\n      {\\n         ps1[i]=ps1[i-1]+(long long)grid[0][i];\\n         ps2[i]=ps2[i-1]+(long long)grid[1][i];\\n      }\\n      long long ans=LLONG_MAX;\\n      for (int i=0;i<n;i++)\\n      {\\n         long long top=ps1[n-1]-ps1[i];\\n         long long bottom=0;\\n         if (i>0) bottom=ps2[i-1];\\n         long long secondRobot=0;\\n         if (top>bottom) secondRobot=top;\\n         else secondRobot=bottom;\\n         if (ans>secondRobot) ans=secondRobot;\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//neetcode video\\n//here the secondrobot can take either remaining top elements or remaining bottom elements only\\n//so we\\'ll keep prefix of top and bottom\\n\\nclass Solution {\\npublic:\\n     \\n    long long gridGame(vector<vector<int>>& grid) \\n    {\\n        int n=grid[0].size();\\n      vector<long long>ps1(n,0);\\n      vector<long long>ps2(n,0);\\n      ps1[0]=grid[0][0];\\n      ps2[0]=grid[1][0];\\n      for (int i=1;i<n;i++)\\n      {\\n         ps1[i]=ps1[i-1]+(long long)grid[0][i];\\n         ps2[i]=ps2[i-1]+(long long)grid[1][i];\\n      }\\n      long long ans=LLONG_MAX;\\n      for (int i=0;i<n;i++)\\n      {\\n         long long top=ps1[n-1]-ps1[i];\\n         long long bottom=0;\\n         if (i>0) bottom=ps2[i-1];\\n         long long secondRobot=0;\\n         if (top>bottom) secondRobot=top;\\n         else secondRobot=bottom;\\n         if (ans>secondRobot) ans=secondRobot;\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347220,
                "title": "prefix-reversed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n[0,5,4] i = 0, secondRobot = 9, res = 9\\n[0,0,0] \\n\\n[0,0,4] i = 1, secondRobot = 4, res = 4\\n[1,0,0]\\n\\n[0,0,0] i = 2, secondRobot = 6, res = 4\\n[1,5,0]\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func gridGame(_ grid: [[Int]]) -> Int {\\n        let N = grid[0].count\\n        \\n        var topPrefix = grid[0]\\n        var botPrefix = grid[1]\\n        \\n        for i in 1..<N {\\n            topPrefix[i] += topPrefix[i - 1]\\n            botPrefix[i] += botPrefix[i - 1]\\n        }\\n        \\n        var result = Int.max\\n        \\n        for i in 0..<N {\\n            let top = topPrefix.last! - topPrefix[i]\\n            let bottom = i > 0 ? botPrefix[i - 1] : 0\\n            let secondRobot = max(top, bottom)\\n            result = min(result, secondRobot)\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func gridGame(_ grid: [[Int]]) -> Int {\\n        let N = grid[0].count\\n        \\n        var topPrefix = grid[0]\\n        var botPrefix = grid[1]\\n        \\n        for i in 1..<N {\\n            topPrefix[i] += topPrefix[i - 1]\\n            botPrefix[i] += botPrefix[i - 1]\\n        }\\n        \\n        var result = Int.max\\n        \\n        for i in 0..<N {\\n            let top = topPrefix.last! - topPrefix[i]\\n            let bottom = i > 0 ? botPrefix[i - 1] : 0\\n            let secondRobot = max(top, bottom)\\n            result = min(result, secondRobot)\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317008,
                "title": "java-memoization-max",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] realGrid) {\\n        int n=realGrid[0].length;\\n        long[][] grid=new long[2][n];\\n        grid[0][n-1]=realGrid[0][n-1];\\n        for(int i=n-2; i>=0; i--){\\n            grid[0][i]=realGrid[0][i];\\n            grid[0][i]+=grid[0][i+1];\\n        }\\n        long belowSum=0;\\n        int i=0;\\n        for(; i<n-1; i++){\\n            if(belowSum+realGrid[1][i]>grid[0][i+1]){\\n                break;\\n            }\\n            belowSum+=realGrid[1][i];\\n        }\\n        return i==n-1?belowSum:Math.max(belowSum, grid[0][i+1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] realGrid) {\\n        int n=realGrid[0].length;\\n        long[][] grid=new long[2][n];\\n        grid[0][n-1]=realGrid[0][n-1];\\n        for(int i=n-2; i>=0; i--){\\n            grid[0][i]=realGrid[0][i];\\n            grid[0][i]+=grid[0][i+1];\\n        }\\n        long belowSum=0;\\n        int i=0;\\n        for(; i<n-1; i++){\\n            if(belowSum+realGrid[1][i]>grid[0][i+1]){\\n                break;\\n            }\\n            belowSum+=realGrid[1][i];\\n        }\\n        return i==n-1?belowSum:Math.max(belowSum, grid[0][i+1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286838,
                "title": "c-there-are-only-n-possibilities-for-robot-1",
                "content": "In the code I try all n possibilities and keep track of which one yielded the smallest.\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long sum = 0, bot = 0, ans;\\n        for (int i = 1; i < grid[0].size(); ++i)\\n            sum += grid[0][i];\\n        ans = sum;\\n        for (int i = 1; i < grid[0].size(); ++i){\\n            sum -= grid[0][i];\\n            bot += grid[1][i - 1];\\n            ans = min(ans, max(sum, bot));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long sum = 0, bot = 0, ans;\\n        for (int i = 1; i < grid[0].size(); ++i)\\n            sum += grid[0][i];\\n        ans = sum;\\n        for (int i = 1; i < grid[0].size(); ++i){\\n            sum -= grid[0][i];\\n            bot += grid[1][i - 1];\\n            ans = min(ans, max(sum, bot));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283800,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"math\"\\n)\\n\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc gridGame(grid [][]int) int64 {\\n\\tm, n := 2, len(grid[0])\\n\\ts := [2][]int{}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\ts[i] = make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\ts[i][j] = grid[i][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts[i][j] = s[i][j-1] + grid[i][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tres := math.MaxInt64\\n\\tfor j := 0; j < n; j++ {\\n\\t\\ttop := s[0][n-1] - s[0][j]\\n\\t\\tbottom := 0\\n        if j > 0 {\\n            bottom = s[1][j-1] \\n        }\\n\\t\\tres = min(res, max(top, bottom))\\n\\t}\\n\\treturn int64(res)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"math\"\\n)\\n\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc gridGame(grid [][]int) int64 {\\n\\tm, n := 2, len(grid[0])\\n\\ts := [2][]int{}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\ts[i] = make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\ts[i][j] = grid[i][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts[i][j] = s[i][j-1] + grid[i][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tres := math.MaxInt64\\n\\tfor j := 0; j < n; j++ {\\n\\t\\ttop := s[0][n-1] - s[0][j]\\n\\t\\tbottom := 0\\n        if j > 0 {\\n            bottom = s[1][j-1] \\n        }\\n\\t\\tres = min(res, max(top, bottom))\\n\\t}\\n\\treturn int64(res)\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3269936,
                "title": "grid-game-solution-time-o-n-space-o-1",
                "content": "# Intuition\\nSince the path of first robot must be of the shape\\n\\n![50cec0b8-9d95-4ea9-823b-6ed83bbf2e8b_1632631825.0099034.png](https://assets.leetcode.com/users/images/8e5530cd-e3db-4a1a-ba47-f16dde039a6b_1678215626.9098113.png)\\n\\nSo  the answer must be the suffix sum of upper row or the prefix sum of the lower row.\\n\\n# Approach\\n\\nTo find the solution we must first calculate the sum of upper row exluding the first element it will always be 0 for the second robot (first robot starts from that cell).\\n\\nNow we know that at some point to reach cell (1, n-1) first robot must change the row form upper to lower, so we iterate over all these possibilities i.e. form column 0 to n-1. Also we can calculate the suffix sum of upper row dynamically by subtracting the value of the current upper cell, and the prefix sum the lower row by adding the value of previous lower cell.\\n\\nAnswer for current iteration must the maximum of current iteration\\'s upper suffix sum and lower prefix sum and the final answer must be the minimum of all iterations answers.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& g) {\\n        int n = g[0].size();\\n        long long curr1 = 0, curr2 = 0, ans = 0;\\n        for(int i = 1; i < n; i++){\\n            curr1 += g[0][i];\\n        }\\n        ans = curr1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            curr2 += g[1][i-1];\\n            curr1 -= g[0][i];\\n            ans = min(ans, max(curr1, curr2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& g) {\\n        int n = g[0].size();\\n        long long curr1 = 0, curr2 = 0, ans = 0;\\n        for(int i = 1; i < n; i++){\\n            curr1 += g[0][i];\\n        }\\n        ans = curr1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            curr2 += g[1][i-1];\\n            curr1 -= g[0][i];\\n            ans = min(ans, max(curr1, curr2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268415,
                "title": "two-liner-java-code",
                "content": "```\\nclass Solution {\\n    long max = Long.MAX_VALUE;\\n    public long gridGame(int[][] board) {\\n        long sum[][] = new long[board.length][board[0].length];\\n        for(int i=0;i<2;i++) //calculating prefix sum\\n            for(int j=0;j<board[0].length;j++) {\\n                if(j==0) sum[i][0] = board[i][0];\\n                if(j!=0) sum[i][j] = board[i][j]+sum[i][j-1];\\n            }\\n        for(int i=0;i<board[0].length;i++) //just one line to find ans\\n            max=Math.min(max,Math.max((sum[0][sum[0].length-1]-sum[0][i]),i-1>=0?sum[1][i-1]:0));\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    long max = Long.MAX_VALUE;\\n    public long gridGame(int[][] board) {\\n        long sum[][] = new long[board.length][board[0].length];\\n        for(int i=0;i<2;i++) //calculating prefix sum\\n            for(int j=0;j<board[0].length;j++) {\\n                if(j==0) sum[i][0] = board[i][0];\\n                if(j!=0) sum[i][j] = board[i][j]+sum[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3268394,
                "title": "python3-2-simplest-solution-beats-90-users-with-and-without-extra-space",
                "content": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        prefixRow1,prefixRow2=[grid[0][0]],[grid[1][0]]\\n        C=len(grid[0])\\n        for i in range(1,C):\\n            prefixRow1.append(prefixRow1[-1]+grid[0][i])\\n        for i in range(1,C):\\n            prefixRow2.append(prefixRow2[-1]+grid[1][i])\\n        res=float(\\'infinity\\')\\n        for i in range(C):\\n            maxFromTopRow=prefixRow1[-1]-prefixRow1[i]\\n            maxFromBottomRow=prefixRow2[i-1] if i>0 else 0\\n            maxSecondRobotCanget=max(maxFromTopRow,maxFromBottomRow)\\n            res=min(res,maxSecondRobotCanget)\\n        return res\\n```\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        C=len(grid[0])\\n        topRowSum,bottomRowSum,res=sum(grid[0]),0,float(\\'infinity\\')\\n        for i in range(C):\\n            topRowSum-=grid[0][i]\\n            res=min(res,max(topRowSum,bottomRowSum))\\n            bottomRowSum+=grid[1][i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        prefixRow1,prefixRow2=[grid[0][0]],[grid[1][0]]\\n        C=len(grid[0])\\n        for i in range(1,C):\\n            prefixRow1.append(prefixRow1[-1]+grid[0][i])\\n        for i in range(1,C):\\n            prefixRow2.append(prefixRow2[-1]+grid[1][i])\\n        res=float(\\'infinity\\')\\n        for i in range(C):\\n            maxFromTopRow=prefixRow1[-1]-prefixRow1[i]\\n            maxFromBottomRow=prefixRow2[i-1] if i>0 else 0\\n            maxSecondRobotCanget=max(maxFromTopRow,maxFromBottomRow)\\n            res=min(res,maxSecondRobotCanget)\\n        return res\\n```\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        C=len(grid[0])\\n        topRowSum,bottomRowSum,res=sum(grid[0]),0,float(\\'infinity\\')\\n        for i in range(C):\\n            topRowSum-=grid[0][i]\\n            res=min(res,max(topRowSum,bottomRowSum))\\n            bottomRowSum+=grid[1][i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265422,
                "title": "python-prefix-suffix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def gridGame(self, G: List[List[int]]) -> int:\\n        bot_sum, top_sum, res = 0, sum(G[0]), math.inf\\n        for i in range(len(G[0])):\\n            top_sum -= G[0][i]\\n            res = min(res, max(top_sum, bot_sum))\\n            bot_sum += G[1][i]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, G: List[List[int]]) -> int:\\n        bot_sum, top_sum, res = 0, sum(G[0]), math.inf\\n        for i in range(len(G[0])):\\n            top_sum -= G[0][i]\\n            res = min(res, max(top_sum, bot_sum))\\n            bot_sum += G[1][i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242201,
                "title": "simple-and-concise-solution-prefix-sum-space-optimized",
                "content": "## Approach\\n\\n- We could use a greedy approach checking wheich would be the next best possible move for both Robot A and Robot B but I failed the test cases so it doesn\\'t work.\\n\\n- The trick is used to utilize **Prefix and Postfix Sums**. \\n\\n- Let the example i/p be [[2,5,4],[1,5,1]]. The path taken by the first robot to maximize its score is 2->5->5->1. The prefix sum is [2,7,11] and postfix sum is [7,6,1].\\n\\n- Now these cells that the Robot 1 has crossed becomes 0. So robot 2 will have a choice of going to the cells either on the bottom left or the top right.\\n\\n- For the Second Robot, we need to calculate the prefix sum of only the top right available cells and also prefix sum of the bottom left available cells. Then we compare and check which one is the **minimum** and return it.\\n\\n- We calculate the prefix sum of the top right and bottom left by subtracting the prefix sum of the entire row and the prefix sum of the available slots.\\n\\n- For figuring out the path taken by the first robot we will have to use Brute Force Approach.\\n\\n- **Point to Note** : The second robot can only start collecting from the index where Robot 1 stops.\\n\\n- TC is O(n) and SC is O(1).\\n\\n# Code\\n```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        result = float(\"inf\")\\n        left, right = 0, sum(grid[0])\\n\\n        for a, b in zip(grid[0], grid[1]):\\n            right -= a\\n            result = min(result, max(left, right))\\n            left += b\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        result = float(\"inf\")\\n        left, right = 0, sum(grid[0])\\n\\n        for a, b in zip(grid[0], grid[1]):\\n            right -= a\\n            result = min(result, max(left, right))\\n            left += b\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235530,
                "title": "easy-understanding-prefix-sum-solution-in-javascript",
                "content": "```\\nvar gridGame = function(grid) {\\n    let len = grid[0].length;\\n    let preRow1= [...grid[0]]\\n    let preRow2 = [...grid[1]]\\n    \\n    for(let i=1 ; i<len; i++){\\n        preRow1[i]+=preRow1[i-1];\\n        preRow2[i]+=preRow2[i-1];\\n    }\\n    let res = Infinity;\\n    \\n    for(let i=0 ; i< len; i++){\\n       let top = preRow1[len-1]- preRow1[i];\\n       let bottom = i > 0 ? preRow2[i-1] : 0;\\n       let second =  Math.max(top,bottom)\\n       res = Math.min(second,res)\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar gridGame = function(grid) {\\n    let len = grid[0].length;\\n    let preRow1= [...grid[0]]\\n    let preRow2 = [...grid[1]]\\n    \\n    for(let i=1 ; i<len; i++){\\n        preRow1[i]+=preRow1[i-1];\\n        preRow2[i]+=preRow2[i-1];\\n    }\\n    let res = Infinity;\\n    \\n    for(let i=0 ; i< len; i++){\\n       let top = preRow1[len-1]- preRow1[i];\\n       let bottom = i > 0 ? preRow2[i-1] : 0;\\n       let second =  Math.max(top,bottom)\\n       res = Math.min(second,res)\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3227725,
                "title": "using-two-prefix-arrays",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        using ll=long long;\\n        vector<ll>pre1(n+1),pre2(n+1);\\n        pre1[0]=grid[0][0];\\n        pre2[0]=grid[1][0];\\n        ll ans=LONG_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            pre1[i]=pre1[i-1]+grid[0][i];\\n             pre2[i]=pre2[i-1]+grid[1][i];\\n        }\\n        ll down=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll top=pre1[n-1]-pre1[i];\\n            if(i>0)\\n            down =pre2[i-1];\\n            ll maxi=max(top,down);\\n            ans=min(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        using ll=long long;\\n        vector<ll>pre1(n+1),pre2(n+1);\\n        pre1[0]=grid[0][0];\\n        pre2[0]=grid[1][0];\\n        ll ans=LONG_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            pre1[i]=pre1[i-1]+grid[0][i];\\n             pre2[i]=pre2[i-1]+grid[1][i];\\n        }\\n        ll down=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll top=pre1[n-1]-pre1[i];\\n            if(i>0)\\n            down =pre2[i-1];\\n            ll maxi=max(top,down);\\n            ans=min(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166271,
                "title": "c-language-memory-beats-100-time-only-beat-10-lol",
                "content": "#Explain mid= which columns 1strobot decide to go down(next row)\\nt1&b1= sum of points 1strobot can get from upper row&bottom row\\nt2&b2 is for second robot\\ndraw out a graph can find out that there is a turning point where the max points can get will change from top to bottom, that is the columns we should(return)\\ngridSize always =2 so i used it as top cap,bot is bottom cap for adjust value of(mid)\\n# Code\\n```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    bool top=false,btm=false;gridSize=0;\\n    long long t1=0,b1=0,t2=0,b2=0;int mid=(* gridColSize)/2,bot=0;\\n    gridSize=* gridColSize;\\n    while(1)\\n    {\\n        for(int i=mid+1;i<* gridColSize;i++)\\n        {\\n            t1+=grid[0][i];\\n        }\\n        for(int i=0;i<mid;i++)\\n        {\\n            b1+=grid[1][i];\\n        }if(t1==b1)return t1;\\n        if(b1>t1)\\n        {\\n            btm=true;\\n            t1=b1;\\n        }\\n        else top=true;\\n        for(int i=mid;i<* gridColSize;i++)\\n        {\\n            t2+=grid[0][i];\\n        }\\n        for(int i=0;i<mid-1;i++)\\n        {\\n            b2+=grid[1][i];\\n        }if(t2==b2)return t2;\\n        if(t2>b2&&btm==true)\\n        {   \\n            if(t2>t1)return t1;\\n            else return t2;\\n        }\\n        else if(t2>b2)\\n        {\\n                top=false;\\n                bot=mid;\\n                mid+=(gridSize-bot+1)/2;\\n        }\\n        else if(b2>t2)\\n        {\\n            btm=false;\\n            gridSize=mid;\\n            mid=(gridSize-bot+1)/2;\\n        }  \\n         t1=0;b1=0;t2=0;b2=0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    bool top=false,btm=false;gridSize=0;\\n    long long t1=0,b1=0,t2=0,b2=0;int mid=(* gridColSize)/2,bot=0;\\n    gridSize=* gridColSize;\\n    while(1)\\n    {\\n        for(int i=mid+1;i<* gridColSize;i++)\\n        {\\n            t1+=grid[0][i];\\n        }\\n        for(int i=0;i<mid;i++)\\n        {\\n            b1+=grid[1][i];\\n        }if(t1==b1)return t1;\\n        if(b1>t1)\\n        {\\n            btm=true;\\n            t1=b1;\\n        }\\n        else top=true;\\n        for(int i=mid;i<* gridColSize;i++)\\n        {\\n            t2+=grid[0][i];\\n        }\\n        for(int i=0;i<mid-1;i++)\\n        {\\n            b2+=grid[1][i];\\n        }if(t2==b2)return t2;\\n        if(t2>b2&&btm==true)\\n        {   \\n            if(t2>t1)return t1;\\n            else return t2;\\n        }\\n        else if(t2>b2)\\n        {\\n                top=false;\\n                bot=mid;\\n                mid+=(gridSize-bot+1)/2;\\n        }\\n        else if(b2>t2)\\n        {\\n            btm=false;\\n            gridSize=mid;\\n            mid=(gridSize-bot+1)/2;\\n        }  \\n         t1=0;b1=0;t2=0;b2=0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109930,
                "title": "python-o-n-iterate-index-that-cross-the-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce you go down you need to only go to right side\\nPrefix sum is the intuitive ideas\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        first_right = grid[0].copy() # pref_sum starting from right on first row\\n        second_left = grid[-1].copy() # pref_sum starting from left on second row\\n\\n        for i in range(1, len(grid[0])):\\n            second_left[i] += second_left[i-1]\\n\\n        for i in range(len(grid[0])-2, -1, -1):\\n            first_right[i] += first_right[i+1]\\n        \\n        ans = float(\"inf\")\\n        for cross_index in range(len(grid[0])):\\n            score = 0\\n            if cross_index+1 < len(grid[0]):\\n                score = max(score, first_right[cross_index+1])\\n\\n            if cross_index-1 >= 0:\\n                score = max(score, second_left[cross_index-1])\\n\\n            ans = min(ans, score)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        first_right = grid[0].copy() # pref_sum starting from right on first row\\n        second_left = grid[-1].copy() # pref_sum starting from left on second row\\n\\n        for i in range(1, len(grid[0])):\\n            second_left[i] += second_left[i-1]\\n\\n        for i in range(len(grid[0])-2, -1, -1):\\n            first_right[i] += first_right[i+1]\\n        \\n        ans = float(\"inf\")\\n        for cross_index in range(len(grid[0])):\\n            score = 0\\n            if cross_index+1 < len(grid[0]):\\n                score = max(score, first_right[cross_index+1])\\n\\n            if cross_index-1 >= 0:\\n                score = max(score, second_left[cross_index-1])\\n\\n            ans = min(ans, score)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060471,
                "title": "grid-game-simple-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long firstSum = Arrays.stream(grid[0]).asLongStream().sum(), bottomSum = 0;\\n        long ans = Long.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            firstSum -= grid[0][i];\\n            ans = Math.min(ans, Math.max(firstSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long firstSum = Arrays.stream(grid[0]).asLongStream().sum(), bottomSum = 0;\\n        long ans = Long.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; ++i) {\\n            firstSum -= grid[0][i];\\n            ans = Math.min(ans, Math.max(firstSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010392,
                "title": "easy-java-dp-solution",
                "content": "**Java Solution:**\\n\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long[][] dp = new long[2][n];\\n        dp[0][n-1] = grid[0][n-1];\\n        dp[1][0] = grid[1][0];\\n        for(int j=n-2; j>=0; --j) \\n            dp[0][j] = dp[0][j+1]+grid[0][j];\\n        for(int j=1; j<n; ++j) \\n            dp[1][j] = dp[1][j-1]+grid[1][j];\\n        long result = Long.MAX_VALUE;\\n        for(int i=0; i<n; ++i) \\n            result = Math.min(result, Math.max((i-1<0?0:dp[1][i-1]), (i+1>=n?0:dp[0][i+1])));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        long[][] dp = new long[2][n];\\n        dp[0][n-1] = grid[0][n-1];\\n        dp[1][0] = grid[1][0];\\n        for(int j=n-2; j>=0; --j) \\n            dp[0][j] = dp[0][j+1]+grid[0][j];\\n        for(int j=1; j<n; ++j) \\n            dp[1][j] = dp[1][j-1]+grid[1][j];\\n        long result = Long.MAX_VALUE;\\n        for(int i=0; i<n; ++i) \\n            result = Math.min(result, Math.max((i-1<0?0:dp[1][i-1]), (i+1>=n?0:dp[0][i+1])));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971404,
                "title": "c-o-n-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long max(long long A,long long B)\\n    {\\n        if(A<B) return B;\\n        else return A;\\n    }\\n    long long min(long long A,long long B)\\n    {\\n        if(A>B) return B;\\n        else return A;\\n    }\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        long long prefix[2][n];\\n        long long sum1=0,sum2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum1+=grid[0][i];\\n            sum2+=grid[1][i];\\n            prefix[0][i]=sum1;\\n            prefix[1][i]=sum2;\\n        }\\n        long long Min = LLONG_MAX;\\n        //trick is if R1 move down at ith index so we will divide grid in 2 parts\\n     //so R2 can have either right_top or left_bottom\\n    // so we want to minimize maximum of those 2\\n        for( int i=0;i<n;i++)\\n        {   \\n            long long right_top = sum1 - prefix[0][i];\\n            long long left_bottom = prefix[1][i] - grid[1][i];\\n            Min= min(Min,max(right_top,left_bottom));\\n            \\n        }\\n        return Min;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long max(long long A,long long B)\\n    {\\n        if(A<B) return B;\\n        else return A;\\n    }\\n    long long min(long long A,long long B)\\n    {\\n        if(A>B) return B;\\n        else return A;\\n    }\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        long long prefix[2][n];\\n        long long sum1=0,sum2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum1+=grid[0][i];\\n            sum2+=grid[1][i];\\n            prefix[0][i]=sum1;\\n            prefix[1][i]=sum2;\\n        }\\n        long long Min = LLONG_MAX;\\n        //trick is if R1 move down at ith index so we will divide grid in 2 parts\\n     //so R2 can have either right_top or left_bottom\\n    // so we want to minimize maximum of those 2\\n        for( int i=0;i<n;i++)\\n        {   \\n            long long right_top = sum1 - prefix[0][i];\\n            long long left_bottom = prefix[1][i] - grid[1][i];\\n            Min= min(Min,max(right_top,left_bottom));\\n            \\n        }\\n        return Min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969206,
                "title": "c-prefix-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public long GridGame(int[][] grid) {\\n        long n=grid[0].Length;\\n\\n        long[] row1=new long[n];\\n        long[] row2=new long[n];\\n\\n        grid[0].CopyTo(row1, 0);\\n        grid[1].CopyTo(row2, 0);\\n\\n        for(int i=1; i<n; i++){\\n            row1[i]+=row1[i-1];\\n            row2[i]+=row2[i-1];\\n        }\\n\\n        long res = Int64.MaxValue;\\n\\n        for(int i=0; i<n; i++){\\n            long top=row1[n-1]-row1[i];\\n            long bottom= i>0 ? row2[i-1] :0;\\n            long second=Math.Max(top, bottom);\\n            res=Math.Min(res, second);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public long GridGame(int[][] grid) {\\n        long n=grid[0].Length;\\n\\n        long[] row1=new long[n];\\n        long[] row2=new long[n];\\n\\n        grid[0].CopyTo(row1, 0);\\n        grid[1].CopyTo(row2, 0);\\n\\n        for(int i=1; i<n; i++){\\n            row1[i]+=row1[i-1];\\n            row2[i]+=row2[i-1];\\n        }\\n\\n        long res = Int64.MaxValue;\\n\\n        for(int i=0; i<n; i++){\\n            long top=row1[n-1]-row1[i];\\n            long bottom= i>0 ? row2[i-1] :0;\\n            long second=Math.Max(top, bottom);\\n            res=Math.Min(res, second);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957662,
                "title": "prefix-sum-o-n-better-than-69-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        return getOptimalSolution(generatePrefixArr(grid,grid[0].length),grid[0].length);\\n    }\\n\\n    private long[][] generatePrefixArr(int[][] grid, int n) {\\n        long[][] prefix = new long[2][n];\\n        prefix[0][0] = grid[0][0];\\n        prefix[1][0] = grid[0][0] + grid[1][0];\\n        for (int i=1; i<n; i++) {\\n            prefix[0][i] = prefix[0][i - 1] + grid[0][i];\\n            prefix[1][i] = prefix[1][i-1] + grid[1][i];\\n        }\\n        return prefix;\\n    }\\n\\n    private long getOptimalSolution(long[][] grid, int n) {\\n        long optimalSolution = Long.MAX_VALUE;\\n        for (int i=n-1; i>=0; i--) {\\n            long leftValue = i==0 ? 0 : grid[1][i-1] - grid[0][0];\\n            long rightValue = i==n-1 ? 0 : grid[0][n-1] - grid[0][i];\\n            optimalSolution = Math.min(optimalSolution,Math.max(leftValue,rightValue));\\n        }\\n        return optimalSolution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        return getOptimalSolution(generatePrefixArr(grid,grid[0].length),grid[0].length);\\n    }\\n\\n    private long[][] generatePrefixArr(int[][] grid, int n) {\\n        long[][] prefix = new long[2][n];\\n        prefix[0][0] = grid[0][0];\\n        prefix[1][0] = grid[0][0] + grid[1][0];\\n        for (int i=1; i<n; i++) {\\n            prefix[0][i] = prefix[0][i - 1] + grid[0][i];\\n            prefix[1][i] = prefix[1][i-1] + grid[1][i];\\n        }\\n        return prefix;\\n    }\\n\\n    private long getOptimalSolution(long[][] grid, int n) {\\n        long optimalSolution = Long.MAX_VALUE;\\n        for (int i=n-1; i>=0; i--) {\\n            long leftValue = i==0 ? 0 : grid[1][i-1] - grid[0][0];\\n            long rightValue = i==n-1 ? 0 : grid[0][n-1] - grid[0][i];\\n            optimalSolution = Math.min(optimalSolution,Math.max(leftValue,rightValue));\\n        }\\n        return optimalSolution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957373,
                "title": "prefix-sum-solution",
                "content": "# Intuition\\nJust calculate prefix sum for both rows and do some operations that minimize the sum of points that could be collected by the second robot.\\n\\n# Approach\\n- first we will calculate prefix sum for both rows\\n- we know that the first robot minimizes points that could be collected by the second robot.\\n- let\\'s say sum1 is the sum of points on the first row, and sum2 is the sum of points on the second row that could be collected by the second robot.\\n- Now, we just need to minimize max(sum1, sum2)\\n- if we can minimize, then the second robot will collect max(sum1, sum2) points\\n\\n# Complexity\\nif n is the length of the column in the gird\\n- Time complexity:\\nO(n) - we have to iterate through the gird\\n\\n- Space complexity:\\nO(n) - prefix sum storage\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        pref_sum = [[0], [0]]\\n        for i in range(2):\\n            for j in range(len(grid[i])):\\n                pref_sum[i].append(pref_sum[i][-1] + grid[i][j])\\n        \\n        ans = pref_sum[1][-1]\\n        for i in range(len(grid[0])):\\n            sum1 = pref_sum[0][-1] - pref_sum[0][i + 1]\\n            sum2 = pref_sum[1][i]\\n            if max(sum1, sum2) < ans:\\n                ans = max(sum1, sum2)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        pref_sum = [[0], [0]]\\n        for i in range(2):\\n            for j in range(len(grid[i])):\\n                pref_sum[i].append(pref_sum[i][-1] + grid[i][j])\\n        \\n        ans = pref_sum[1][-1]\\n        for i in range(len(grid[0])):\\n            sum1 = pref_sum[0][-1] - pref_sum[0][i + 1]\\n            sum2 = pref_sum[1][i]\\n            if max(sum1, sum2) < ans:\\n                ans = max(sum1, sum2)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945244,
                "title": "c",
                "content": "```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize){\\n    int n = *gridColSize;\\n    if(n == 1)\\n        return 0;\\n    long long* upper = malloc(n * sizeof(long long));\\n    long long* down = malloc(n * sizeof(long long));\\n    upper[n-1] = grid[0][n-1];\\n    for(int i = n-2; i >=0; i--){\\n        upper[i] = upper[i+1] + grid[0][i];\\n    }\\n    down[0] = grid[1][0];\\n    for(int i = 1; i < n; i++){\\n        down[i] = down[i-1] + grid[1][i];\\n    }\\n\\n    long long ans = upper[1];\\n    \\n    for(int i = 1; i < n-1; i++){\\n        ans = fmin(ans, fmax(upper[i+1], down[i-1]));\\n    }\\n    ans = fmin(ans , down[n-2]);\\n    free(upper);\\n    free(down);\\n\\n    return ans;\\n\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nlong long gridGame(int** grid, int gridSize, int* gridColSize){\\n    int n = *gridColSize;\\n    if(n == 1)\\n        return 0;\\n    long long* upper = malloc(n * sizeof(long long));\\n    long long* down = malloc(n * sizeof(long long));\\n    upper[n-1] = grid[0][n-1];\\n    for(int i = n-2; i >=0; i--){\\n        upper[i] = upper[i+1] + grid[0][i];\\n    }\\n    down[0] = grid[1][0];\\n    for(int i = 1; i < n; i++){\\n        down[i] = down[i-1] + grid[1][i];\\n    }\\n\\n    long long ans = upper[1];\\n    \\n    for(int i = 1; i < n-1; i++){\\n        ans = fmin(ans, fmax(upper[i+1], down[i-1]));\\n    }\\n    ans = fmin(ans , down[n-2]);\\n    free(upper);\\n    free(down);\\n\\n    return ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903080,
                "title": "prefix-sum-c-easy-to-understand-solution",
                "content": "# Approach\\nJust the simple prefix sum answer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n = grid[0].size();\\n\\n        long long top = 0;\\n        for(int i=0; i<n; i++){\\n            \\n            top += grid[0][i];\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n\\n        long long bottom = 0;\\n        for(int i=0; i<n; i++){\\n\\n            top -= grid[0][i];\\n            ans = min(ans, max(top, bottom));\\n            bottom += grid[1][i];          \\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        \\n        int n = grid[0].size();\\n\\n        long long top = 0;\\n        for(int i=0; i<n; i++){\\n            \\n            top += grid[0][i];\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n\\n        long long bottom = 0;\\n        for(int i=0; i<n; i++){\\n\\n            top -= grid[0][i];\\n            ans = min(ans, max(top, bottom));\\n            bottom += grid[1][i];          \\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895868,
                "title": "very-simple-python-o-n-time-o-1-space",
                "content": "\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        top_sum, top_counter, bottom_counter, mini = sum(grid[0]), 0, 0, float(\"inf\")\\n       \\n        for i in range(len(grid[0])): \\n            top_counter+= grid[0][i]\\n            mini = min(mini, max(top_sum-top_counter, bottom_counter))\\n            bottom_counter+=grid[1][i]\\n\\n        return mini\\n         \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        top_sum, top_counter, bottom_counter, mini = sum(grid[0]), 0, 0, float(\"inf\")\\n       \\n        for i in range(len(grid[0])): \\n            top_counter+= grid[0][i]\\n            mini = min(mini, max(top_sum-top_counter, bottom_counter))\\n            bottom_counter+=grid[1][i]\\n\\n        return mini\\n         \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871083,
                "title": "basic-practice-dp-or-just-partial-sums-python",
                "content": "1- A Solution Format\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        # 1. prep\\n        n = len(grid[0])\\n        pre, suf = [0] * n, [0] * n\\n        \\n        # 2. dp update / partial sums\\n        for i in range(1, n):\\n            pre[i] = pre[i-1] + grid[1][i-1]\\n        for i in range(n-2, -1, -1):\\n            suf[i] = suf[i+1] + grid[0][i+1]\\n        \\n        # 3. prepare the return\\n        return min(max(a, b) for a, b in zip(pre, suf))\\n```\\n2- Video Explanation: [Click Here](https://youtu.be/CkOBX0hGxw0;)\\n\\n3- Analysis and Summary\\n\\n```\\n1. Method: DP or just partial sums\\n\\nThis is a Follow-Up problem for 2483. Minimum Penalty for a Shop\\n\\n2. Observation and Analysis\\n\\nObservation: once the robot moves down, it can only move towards right.\\n\\nAssume the 1st robot moves down to second row at position (0, i)\\nfor some i where 0 <= i <= n-1.\\n\\nThen the 2nd robot has only two choices:\\n\\neither \\n\\ngo down to the 2nd row to collect all the remaining points in second row,\\nthat is sum(grid[1][:i])\\n\\nor\\n\\ngo along the 1st row to collect all the remaining points in first row, \\nthat is sum(grid[0][i+1:])\\n\\nThe maximal number of points for robot 2 is:\\n\\nmin(max(sum(grid[1][:i]), sum(grid[0][i+1:]))).\\n\\n3. Partial Sum / DP update, a walkthrough.\\n\\nTo carry out the above analysis in code, we just need to use partial sums\\n\\nWalkthrough Example-1\\n\\ngrid = [[2,5,4],\\n        [1,5,1]]\\n        \\npre[i] := sum for grid[1][:i], i.e., before index i\\nsuf[i] :=  sum for grid[0][i+1:], i.e., after index i\\n\\nUpdate rule:\\n\\n    pre[i] = pre[i-1] + grid[1][i-1]\\n    suf[i] = suf[i+1] + grid[0][i+1]\\n    \\npre = [0, 1, 6]\\nsuf = [9, 4, 0]\\n\\nmax(pre, suf) = [9, 4, 6]\\nTake min, we get 4.\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        # 1. prep\\n        n = len(grid[0])\\n        pre, suf = [0] * n, [0] * n\\n        \\n        # 2. dp update / partial sums\\n        for i in range(1, n):\\n            pre[i] = pre[i-1] + grid[1][i-1]\\n        for i in range(n-2, -1, -1):\\n            suf[i] = suf[i+1] + grid[0][i+1]\\n        \\n        # 3. prepare the return\\n        return min(max(a, b) for a, b in zip(pre, suf))\\n```\n```\\n1. Method: DP or just partial sums\\n\\nThis is a Follow-Up problem for 2483. Minimum Penalty for a Shop\\n\\n2. Observation and Analysis\\n\\nObservation: once the robot moves down, it can only move towards right.\\n\\nAssume the 1st robot moves down to second row at position (0, i)\\nfor some i where 0 <= i <= n-1.\\n\\nThen the 2nd robot has only two choices:\\n\\neither \\n\\ngo down to the 2nd row to collect all the remaining points in second row,\\nthat is sum(grid[1][:i])\\n\\nor\\n\\ngo along the 1st row to collect all the remaining points in first row, \\nthat is sum(grid[0][i+1:])\\n\\nThe maximal number of points for robot 2 is:\\n\\nmin(max(sum(grid[1][:i]), sum(grid[0][i+1:]))).\\n\\n3. Partial Sum / DP update, a walkthrough.\\n\\nTo carry out the above analysis in code, we just need to use partial sums\\n\\nWalkthrough Example-1\\n\\ngrid = [[2,5,4],\\n        [1,5,1]]\\n        \\npre[i] := sum for grid[1][:i], i.e., before index i\\nsuf[i] :=  sum for grid[0][i+1:], i.e., after index i\\n\\nUpdate rule:\\n\\n    pre[i] = pre[i-1] + grid[1][i-1]\\n    suf[i] = suf[i+1] + grid[0][i+1]\\n    \\npre = [0, 1, 6]\\nsuf = [9, 4, 0]\\n\\nmax(pre, suf) = [9, 4, 6]\\nTake min, we get 4.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843345,
                "title": "java-two-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int N = grid[0].length;\\n\\n        long[] prefixUp = new long[N];\\n        prefixUp[0] = grid[0][0];\\n        for(int i=1; i<N; i++) {\\n            prefixUp[i] = prefixUp[i-1] + grid[0][i];\\n        }\\n        \\n        long[] prefixDown = new long[N];\\n        prefixDown[0] = grid[1][0];\\n        for(int i=1; i<N; i++) {\\n            prefixDown[i] = prefixDown[i-1] + grid[1][i];\\n        }\\n\\n        long min = Long.MAX_VALUE;\\n        for(int i=0; i<N; i++) {\\n            long left = i-1 >= 0 ? prefixDown[i-1] : 0;\\n            long right = prefixUp[N-1] - prefixUp[i];\\n\\n            if(min > Math.max(left, right)) {\\n                min = Math.max(left, right);\\n            }\\n\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int N = grid[0].length;\\n\\n        long[] prefixUp = new long[N];\\n        prefixUp[0] = grid[0][0];\\n        for(int i=1; i<N; i++) {\\n            prefixUp[i] = prefixUp[i-1] + grid[0][i];\\n        }\\n        \\n        long[] prefixDown = new long[N];\\n        prefixDown[0] = grid[1][0];\\n        for(int i=1; i<N; i++) {\\n            prefixDown[i] = prefixDown[i-1] + grid[1][i];\\n        }\\n\\n        long min = Long.MAX_VALUE;\\n        for(int i=0; i<N; i++) {\\n            long left = i-1 >= 0 ? prefixDown[i-1] : 0;\\n            long right = prefixUp[N-1] - prefixUp[i];\\n\\n            if(min > Math.max(left, right)) {\\n                min = Math.max(left, right);\\n            }\\n\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840437,
                "title": "python-intuition-prefix-sum-diagrams-pictures-comments-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can iterate through the columns and calculate the top sum by `sum(grid[0][i+1:])` and the bottom sum by `sum(grid[1][:i-1])`. This works because the first robot cuts the board in half (since it can only go down once). We need to iterate through all of the columns because a greedy approach won\\'t work. (Explained below).\\n\\nFurthermore, we can optimize the above sums by realizing that for every iteration of the array, we can just subtract the index `i` in the top half/sum and add index `i` to the bottom half/sum. (With top half starting at sum of top row, and bottom half starting at 0). This thus makes it a ~~true~~ O(1) solution (except for the sum function bc I think that\\'s O(n) lol) for those calculations. Very cool problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/1ee526e0-864f-48f4-bce4-d7f31c22a357_1669155489.4892232.png)\\n\\n\\n\\n##### Stolen from the top post:\\nQuestion 1: Why won\\'t this DP approach work? (from @avi_1950)\\n\\nFirstly, I find the path which has the maximum points for Robot 1 then I make all its path cells as zeroes.\\nThen finding the path which has the maximum points for Robot 2?\\nAnswer: In this problem, Robot 1 need to minimize the maximum ponts which Robot 2 can get. If we do greedily by finding the path which has the maximum points for Robot 1, it\\'s not garantee that we can minimize points of Robot 2.\\nCan consider this testcase:\\n```\\n10 50 50 30\\n50 50 10 10\\n```\\nIf you find the maximum path for Robot 1 and set those cells into 0, then the path became:\\n\\n```\\n00 00 00 00\\n50 50 10 00\\n```\\nThe Robot 2 can get maximum of 110 points.\\n\\nBut if Robot 1 goes by this path:\\n\\n```\\n00 00 50 30\\n50 00 00 00\\n```\\nThen Robot 2 can get maximum of 80 points.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    # optimized prefix sum\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        ans = math.inf\\n        topSum = sum(grid[0])\\n        bottomSum = 0\\n\\n        for i in range(n):\\n            topSum -= grid[0][i]\\n            ans = min(ans, max(topSum, bottomSum))\\n            bottomSum += grid[1][i]\\n\\n        return ans\\n\\n    # neetcode\\'s prefix sum method\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        res = float(\\'inf\\') # max value\\n        prefixSum1 = [grid[0][0]]\\n        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly\\n        length = len(grid[0])\\n\\n        for i in range(1, length): # from 1 to end because we don\\'t want to deal with an out of bounds error\\n            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index\\n            prefixSum2.append(grid[1][i] + prefixSum2[i-1])\\n        for i in range(length): # so here we want to calculate the turning point of the first robot\\n            # calculate the values excluding the current index\\n            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)\\n            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.\\n            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab\\n            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1\\'s take and robot 2\\'s take per the properties.\\n        return res\\n\\n\\n\\n    # simple solution (runs out of time due to not storing the calculations)\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n\\n        # this is the simpler code but it doesn\\'t work because of a time limit problem. simply having the prefix sum\\'s already calculated makes this problem ultra efficient\\n        res = float(\\'inf\\') # max\\n        length = len(grid[0])\\n        for i in range(length): # check each index of the array\\n            # take the sum of everything after the index on the top row and before the index on the bottom row\\n            top = sum(grid[0][i+1:])\\n            bot = sum(grid[1][:i])\\n            current = max(top, bot) # max of robot 2\\'s take if robot 1 were to turn at this specific index\\n            res = min(res, current) # determines robot 2\\'s real take that would maximize robot 1\\'s take\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n10 50 50 30\\n50 50 10 10\\n```\n```\\n00 00 00 00\\n50 50 10 00\\n```\n```\\n00 00 50 30\\n50 00 00 00\\n```\n```python\\nclass Solution:\\n    # optimized prefix sum\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        ans = math.inf\\n        topSum = sum(grid[0])\\n        bottomSum = 0\\n\\n        for i in range(n):\\n            topSum -= grid[0][i]\\n            ans = min(ans, max(topSum, bottomSum))\\n            bottomSum += grid[1][i]\\n\\n        return ans\\n\\n    # neetcode\\'s prefix sum method\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        res = float(\\'inf\\') # max value\\n        prefixSum1 = [grid[0][0]]\\n        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly\\n        length = len(grid[0])\\n\\n        for i in range(1, length): # from 1 to end because we don\\'t want to deal with an out of bounds error\\n            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index\\n            prefixSum2.append(grid[1][i] + prefixSum2[i-1])\\n        for i in range(length): # so here we want to calculate the turning point of the first robot\\n            # calculate the values excluding the current index\\n            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)\\n            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.\\n            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab\\n            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1\\'s take and robot 2\\'s take per the properties.\\n        return res\\n\\n\\n\\n    # simple solution (runs out of time due to not storing the calculations)\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n\\n        # this is the simpler code but it doesn\\'t work because of a time limit problem. simply having the prefix sum\\'s already calculated makes this problem ultra efficient\\n        res = float(\\'inf\\') # max\\n        length = len(grid[0])\\n        for i in range(length): # check each index of the array\\n            # take the sum of everything after the index on the top row and before the index on the bottom row\\n            top = sum(grid[0][i+1:])\\n            bot = sum(grid[1][:i])\\n            current = max(top, bot) # max of robot 2\\'s take if robot 1 were to turn at this specific index\\n            res = min(res, current) # determines robot 2\\'s real take that would maximize robot 1\\'s take\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750267,
                "title": "java-s-most-optimized-solution-faster-than-100-of-submissions",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long up = 0, bottom = 0, max;\\n        for (int i = grid[0].length - 1; i >= 0; i--){\\n            up += grid[0][i];\\n        }\\n        long min = up;\\n        for (int i = 0; i < grid[0].length; i++){\\n            up -= grid[0][i];\\n            min = Math.min(min, Math.max(up, bottom));\\n            bottom += grid[1][i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        long up = 0, bottom = 0, max;\\n        for (int i = grid[0].length - 1; i >= 0; i--){\\n            up += grid[0][i];\\n        }\\n        long min = up;\\n        for (int i = 0; i < grid[0].length; i++){\\n            up -= grid[0][i];\\n            min = Math.min(min, Math.max(up, bottom));\\n            bottom += grid[1][i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733267,
                "title": "python-code-with-easy-approach-and-explanation-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        #Time: O(n)\\n        #Space: O(n)\\n        #Prefix sum to top line and postfix for bottom grid\\n        #we are taking the max of top or bottom and then do take minimum of it\\\\\\n        #reason being the first robot left us with minimum points only and thats how the solution will be optimized\\n        top,bottom,res= sum(grid[0]),0,float(\\'inf\\')\\n\\n        for t,b in zip(grid[0],grid[1]):\\n            top=top-t\\n            res=min(res,max(top,bottom))\\n            bottom=bottom+b\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        #Time: O(n)\\n        #Space: O(n)\\n        #Prefix sum to top line and postfix for bottom grid\\n        #we are taking the max of top or bottom and then do take minimum of it\\\\\\n        #reason being the first robot left us with minimum points only and thats how the solution will be optimized\\n        top,bottom,res= sum(grid[0]),0,float(\\'inf\\')\\n\\n        for t,b in zip(grid[0],grid[1]):\\n            top=top-t\\n            res=min(res,max(top,bottom))\\n            bottom=bottom+b\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704294,
                "title": "rust-solution-using-prefix-sum",
                "content": "```\\nimpl Solution {\\n    pub fn grid_game(grid: Vec<Vec<i32>>) -> i64 {\\n        let n = grid[0].len();\\n\\n        let mut memo1 = vec![0;n+1];\\n        let mut memo2 = vec![0;n+1];\\n        for i in 0..n {\\n            memo1[i+1] = memo1[i] + grid[0][i] as i64;\\n            memo2[i+1] = memo2[i] + grid[1][i] as i64;\\n        }\\n\\n        let mut result = i64::max_value();\\n        for i in 0..n {\\n            result = result.min(memo2[i].max(memo1[n] - memo1[i+1]));\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn grid_game(grid: Vec<Vec<i32>>) -> i64 {\\n        let n = grid[0].len();\\n\\n        let mut memo1 = vec![0;n+1];\\n        let mut memo2 = vec![0;n+1];\\n        for i in 0..n {\\n            memo1[i+1] = memo1[i] + grid[0][i] as i64;\\n            memo2[i+1] = memo2[i] + grid[1][i] as i64;\\n        }\\n\\n        let mut result = i64::max_value();\\n        for i in 0..n {\\n            result = result.min(memo2[i].max(memo1[n] - memo1[i+1]));\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2685630,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& a) {\\n        long long n = a[0].size();\\n        vector<long long> t(n,0);\\n        vector<long long> b(n,0);\\n        t[0] = a[0][0];\\n        for(long long i = 1;i<n;i++)\\n        {\\n            t[i] = t[i-1] + a[0][i];\\n        }\\n        \\n        b[n-1] = a[1][n-1];\\n        for(long long i = n-2;i>=0;i--)\\n        {\\n            b[i] = b[i+1] + a[1][i];\\n        }\\n        \\n        \\n        long long x = t[n-1];\\n        long long y = b[0];\\n        long long mn = 1e18;\\n        for(long long i = 0;i<n;i++)\\n        {\\n            long long p = x-t[i];\\n            long long q = y-b[i];\\n            \\n            long long w = max(p,q);\\n            mn = min(mn,w);\\n        }\\n        \\n        return mn;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& a) {\\n        long long n = a[0].size();\\n        vector<long long> t(n,0);\\n        vector<long long> b(n,0);\\n        t[0] = a[0][0];\\n        for(long long i = 1;i<n;i++)\\n        {\\n            t[i] = t[i-1] + a[0][i];\\n        }\\n        \\n        b[n-1] = a[1][n-1];\\n        for(long long i = n-2;i>=0;i--)\\n        {\\n            b[i] = b[i+1] + a[1][i];\\n        }\\n        \\n        \\n        long long x = t[n-1];\\n        long long y = b[0];\\n        long long mn = 1e18;\\n        for(long long i = 0;i<n;i++)\\n        {\\n            long long p = x-t[i];\\n            long long q = y-b[i];\\n            \\n            long long w = max(p,q);\\n            mn = min(mn,w);\\n        }\\n        \\n        return mn;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676759,
                "title": "javascript-prefix-suffix-sum-faster-than-100",
                "content": "```\\nvar gridGame = function(grid) {\\n    let top = grid[0].reduce((acc, num) => acc + num, 0);\\n    let bottom = 0;\\n    let res = Infinity;\\n    for(let i = 0; i < grid[0].length; i++) {\\n        top -= grid[0][i];\\n        res = Math.min(res, Math.max(top, bottom));\\n        bottom += grid[1][i];\\n    }\\n    return res;        \\n}\\n```\\n\\nRef - https://leetcode.com/problems/grid-game/discuss/1486288/PrefixSuffix-Sum",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar gridGame = function(grid) {\\n    let top = grid[0].reduce((acc, num) => acc + num, 0);\\n    let bottom = 0;\\n    let res = Infinity;\\n    for(let i = 0; i < grid[0].length; i++) {\\n        top -= grid[0][i];\\n        res = Math.min(res, Math.max(top, bottom));\\n        bottom += grid[1][i];\\n    }\\n    return res;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675702,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef gridGame(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tupper_right, lower_left, ans = sum(grid[0]), 0, math.inf\\n\\t\\t\\tfor upper, lower in zip(grid[0], grid[1]):\\n\\t\\t\\t\\tupper_right -= upper\\n\\t\\t\\t\\tans = min(ans, max(upper_right, lower_left))\\n\\t\\t\\t\\tlower_left += lower\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef gridGame(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tupper_right, lower_left, ans = sum(grid[0]), 0, math.inf\\n\\t\\t\\tfor upper, lower in zip(grid[0], grid[1]):\\n\\t\\t\\t\\tupper_right -= upper\\n\\t\\t\\t\\tans = min(ans, max(upper_right, lower_left))\\n\\t\\t\\t\\tlower_left += lower\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2675151,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& g) {\\n        long long sum0 = accumulate(begin(g[0]), end(g[0]), 0LL), sum1 = 0, res = LONG_MAX;\\n        for(int i = 0; i < g[0].size(); i++) {\\n            sum0 -= g[0][i];\\n            res = min(max(sum0, sum1), res);\\n            sum1 += g[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& g) {\\n        long long sum0 = accumulate(begin(g[0]), end(g[0]), 0LL), sum1 = 0, res = LONG_MAX;\\n        for(int i = 0; i < g[0].size(); i++) {\\n            sum0 -= g[0][i];\\n            res = min(max(sum0, sum1), res);\\n            sum1 += g[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618848,
                "title": "python-with-explaination-in-comments",
                "content": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        # The path can only goes down ONCE.\\n        # After Robot A\\'s walk, the grid became something like:\\n        #    0 0 0 0 a b c\\n        #    d e f 0 0 0 0\\n\\t\\t# Robot B can only walk in the similar way.\\n        # Then Robot B\\'s best choice is either to take all (a, b, c) or to take all (d, e, f), \\n\\t\\t# depending on sum(a,b,c) or sum(d,e,f) which is bigger.\\n\\t\\t# There is no other choice.\\n\\t\\t# So Robot A need to minimize the value of max(sum(a,b,c),sum(d,e,f)).\\n        \\n        N = len(grid[0])\\n        \\n        # Get sum at each column index\\n        sUp, sDown = 0, 0\\n        sumsUpRow = [0] * (N + 1)\\n        sumsDownRow = [0] * (N + 1)\\n        for c in range(N):\\n            sUp += grid[0][c]\\n            sumsUpRow[c + 1] = sUp\\n            sDown += grid[1][c]\\n            sumsDownRow[c + 1] = sDown\\n            \\n        # Find the minimum max choice of all column indexes for Robot B\\n        minMaxChoice = min(sumsUpRow[N], sumsDownRow[N])\\n        for c in range(N):\\n            maxUpRow = sumsUpRow[N] - sumsUpRow[c + 1]\\n            maxDownRow = sumsDownRow[c]\\n            maxChoice = max(maxUpRow, maxDownRow)\\n            minMaxChoice = min(minMaxChoice, maxChoice)\\n        return minMaxChoice\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        # The path can only goes down ONCE.\\n        # After Robot A\\'s walk, the grid became something like:\\n        #    0 0 0 0 a b c\\n        #    d e f 0 0 0 0\\n\\t\\t# Robot B can only walk in the similar way.\\n        # Then Robot B\\'s best choice is either to take all (a, b, c) or to take all (d, e, f), \\n\\t\\t# depending on sum(a,b,c) or sum(d,e,f) which is bigger.\\n\\t\\t# There is no other choice.\\n\\t\\t# So Robot A need to minimize the value of max(sum(a,b,c),sum(d,e,f)).\\n        \\n        N = len(grid[0])\\n        \\n        # Get sum at each column index\\n        sUp, sDown = 0, 0\\n        sumsUpRow = [0] * (N + 1)\\n        sumsDownRow = [0] * (N + 1)\\n        for c in range(N):\\n            sUp += grid[0][c]\\n            sumsUpRow[c + 1] = sUp\\n            sDown += grid[1][c]\\n            sumsDownRow[c + 1] = sDown\\n            \\n        # Find the minimum max choice of all column indexes for Robot B\\n        minMaxChoice = min(sumsUpRow[N], sumsDownRow[N])\\n        for c in range(N):\\n            maxUpRow = sumsUpRow[N] - sumsUpRow[c + 1]\\n            maxDownRow = sumsDownRow[c]\\n            maxChoice = max(maxUpRow, maxDownRow)\\n            minMaxChoice = min(minMaxChoice, maxChoice)\\n        return minMaxChoice\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607526,
                "title": "java-presum",
                "content": "```java\\n// TC : O(N)\\n// SC:  O(N)\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        // 1. use presum\\n        // 2. when the first robot turn down at index i, \\n        //    the max point the second robot can get will be the \\n        //    max(upPresum[n]-upPresum[i], sufPresum[i])\\n        \\n        int n = grid[0].length;\\n        long[] upPresum = new long[n+1];\\n        long[] downPresum = new long[n+1];\\n        \\n        for (int i = 1; i <= n; i ++) {\\n            upPresum[i] = upPresum[i-1] + grid[0][i-1];\\n            downPresum[i] = downPresum[i-1] + grid[1][i-1];\\n        }\\n        \\n        long minMax = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i ++) {\\n            long maxPoint = Math.max(upPresum[n]-upPresum[i+1], downPresum[i]);\\n            if (minMax >  maxPoint)\\n                minMax = maxPoint;\\n        }\\n        return minMax;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// TC : O(N)\\n// SC:  O(N)\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        // 1. use presum\\n        // 2. when the first robot turn down at index i, \\n        //    the max point the second robot can get will be the \\n        //    max(upPresum[n]-upPresum[i], sufPresum[i])\\n        \\n        int n = grid[0].length;\\n        long[] upPresum = new long[n+1];\\n        long[] downPresum = new long[n+1];\\n        \\n        for (int i = 1; i <= n; i ++) {\\n            upPresum[i] = upPresum[i-1] + grid[0][i-1];\\n            downPresum[i] = downPresum[i-1] + grid[1][i-1];\\n        }\\n        \\n        long minMax = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i ++) {\\n            long maxPoint = Math.max(upPresum[n]-upPresum[i+1], downPresum[i]);\\n            if (minMax >  maxPoint)\\n                minMax = maxPoint;\\n        }\\n        return minMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589507,
                "title": "swift-solution-with-time-o-n-optimised-approach",
                "content": "**OPTIMISED APPROACH:**\\nThe crux of this solution is that if we plot the result variable values it will have the outputs in a pattern either as\\n1. Increasing to Decreasing or\\n2. Decreasing to Increasing\\n\\nBut our answer will be the minimum number in the result variable outputs. Hence we can terminate the loop iteration if we find that the next result variable value is greater than the previous one. Hence the **break** statement. This cuts down further iterations in best case by 100% to 50%.\\n```\\nfunc gridGame(_ grid: [[Int]]) -> Int {\\n        let totalSumA = grid[0].reduce(0,+)\\n        var minNumber = totalSumA - grid[0][0]\\n        var sumA = 0\\n        var sumB = 0\\n        for aIndex in (0..<grid[0].count) {\\n            sumA += grid[0][aIndex]\\n            if aIndex - 1 >= 0 {\\n                sumB += grid[1][aIndex-1]\\n            }\\n            let result = (totalSumA - sumA) > sumB ? (totalSumA - sumA) : sumB\\n            if result <= minNumber {\\n                minNumber = result\\n            } else {\\n                break\\n            }\\n        }\\n        return minNumber\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array"
                ],
                "code": "```\\nfunc gridGame(_ grid: [[Int]]) -> Int {\\n        let totalSumA = grid[0].reduce(0,+)\\n        var minNumber = totalSumA - grid[0][0]\\n        var sumA = 0\\n        var sumB = 0\\n        for aIndex in (0..<grid[0].count) {\\n            sumA += grid[0][aIndex]\\n            if aIndex - 1 >= 0 {\\n                sumB += grid[1][aIndex-1]\\n            }\\n            let result = (totalSumA - sumA) > sumB ? (totalSumA - sumA) : sumB\\n            if result <= minNumber {\\n                minNumber = result\\n            } else {\\n                break\\n            }\\n        }\\n        return minNumber\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551768,
                "title": "why-is-my-answer-wrong-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long res = INT_MAX;\\n        int sum = 0;\\n        vector<vector<long long>> grid2;\\n        for(int i = 0; i < grid.size(); i++){\\n            vector<long long> temp;\\n            for(int j = 0; j < grid[0].size(); j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            grid2.push_back(temp);\\n        }\\n        for(int i = 0; i < grid2[0].size(); i++){//get prefix sums\\n            grid2[0][i] += sum;\\n            sum = grid2[0][i];\\n        }\\n        sum = 0;\\n        for(int i = grid2[0].size()-1; i >= 0; i--){\\n            grid2[1][i] += sum;\\n            sum = grid2[1][i];\\n        }\\n    \\n        for(int i = 0; i < grid2[0].size(); i++){//Try all ways of moving down\\n            long long right = grid2[0][grid2[0].size()-1] - grid2[0][i];\\n            long long down = grid2[1][0] - grid2[1][i];\\n            long long path = max(right, down);\\n            res = min(res, path);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```\\nIt fails on testcase 103/108\\n![image](https://assets.leetcode.com/users/images/12335846-8d5a-4429-9959-36c6a4e5bdec_1662689721.0734036.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        long long res = INT_MAX;\\n        int sum = 0;\\n        vector<vector<long long>> grid2;\\n        for(int i = 0; i < grid.size(); i++){\\n            vector<long long> temp;\\n            for(int j = 0; j < grid[0].size(); j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            grid2.push_back(temp);\\n        }\\n        for(int i = 0; i < grid2[0].size(); i++){//get prefix sums\\n            grid2[0][i] += sum;\\n            sum = grid2[0][i];\\n        }\\n        sum = 0;\\n        for(int i = grid2[0].size()-1; i >= 0; i--){\\n            grid2[1][i] += sum;\\n            sum = grid2[1][i];\\n        }\\n    \\n        for(int i = 0; i < grid2[0].size(); i++){//Try all ways of moving down\\n            long long right = grid2[0][grid2[0].size()-1] - grid2[0][i];\\n            long long down = grid2[1][0] - grid2[1][i];\\n            long long path = max(right, down);\\n            res = min(res, path);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549164,
                "title": "c-simple-solution-with-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        long long rightSum = 0;\\n\\n        for (int j = 0; j < N; ++j) {\\n            rightSum += grid[0][j];\\n        }\\n\\n        long long cur = 0;\\n        long long ans = LONG_LONG_MAX;\\n        long long leftSum = 0;\\n        for (int j = 0; j < N; ++j) {\\n            rightSum -= grid[0][j];\\n            if (j > 0) {\\n                leftSum += grid[1][j-1];\\n            }\\n            cur = max(rightSum, leftSum);\\n            if (ans > cur) {\\n                ans = cur;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        long long rightSum = 0;\\n\\n        for (int j = 0; j < N; ++j) {\\n            rightSum += grid[0][j];\\n        }\\n\\n        long long cur = 0;\\n        long long ans = LONG_LONG_MAX;\\n        long long leftSum = 0;\\n        for (int j = 0; j < N; ++j) {\\n            rightSum -= grid[0][j];\\n            if (j > 0) {\\n                leftSum += grid[1][j-1];\\n            }\\n            cur = max(rightSum, leftSum);\\n            if (ans > cur) {\\n                ans = cur;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495890,
                "title": "grid-game-c-solution",
                "content": "long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int sum=0;\\n        int start=0;\\n        int end=n-1;\\n        int top=0;\\n        int bottom=1;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        while(end>start){\\n            for(int i=start;i<=end;i++){\\n                 sum+=grid[top][i];\\n                if(i==end && i+end!=n-1)sum+=grid[bottom][i];\\n            }\\n            end--;\\n            maxi=max(maxi,sum);\\n        }\\n        end=n-1;\\n        sum=0;\\n        while(end>=start && bottom>=0){\\n            grid[bottom][end]=0;\\n            if(bottom==0)end--;\\n            grid[bottom][end-1]>grid[bottom-1][end]?end--:bottom--;\\n        }\\n        while(end>start){\\n            for(int i=start;i<=end;i++){\\n                 sum+=grid[top][i];\\n                if(i==end && i+end!=n-1)sum+=grid[bottom][i];\\n            }\\n            end--;\\n            top=0;\\n            ans=max(ans,sum);\\n        }\\n      \\n        return ans;\\n    }\\n};\\n\\nCan Someone tell me the error?",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "long long gridGame(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        int sum=0;\\n        int start=0;\\n        int end=n-1;\\n        int top=0;\\n        int bottom=1;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        while(end>start){\\n            for(int i=start;i<=end;i++){\\n                 sum+=grid[top][i];\\n                if(i==end && i+end!=n-1)sum+=grid[bottom][i];\\n            }\\n            end--;\\n            maxi=max(maxi,sum);\\n        }\\n        end=n-1;\\n        sum=0;\\n        while(end>=start && bottom>=0){\\n            grid[bottom][end]=0;\\n            if(bottom==0)end--;\\n            grid[bottom][end-1]>grid[bottom-1][end]?end--:bottom--;\\n        }\\n        while(end>start){\\n            for(int i=start;i<=end;i++){\\n                 sum+=grid[top][i];\\n                if(i==end && i+end!=n-1)sum+=grid[bottom][i];\\n            }\\n            end--;\\n            top=0;\\n            ans=max(ans,sum);\\n        }\\n      \\n        return ans;\\n    }\\n};\\n\\nCan Someone tell me the error?",
                "codeTag": "Unknown"
            },
            {
                "id": 2480582,
                "title": "typescript-solution",
                "content": "```\\nfunction gridGame(grid: number[][]): number {\\n    let topSum = 0;\\n    \\n    for(let i = 0; i < grid[0].length; i++) {\\n        topSum += grid[0][i];\\n    }\\n    \\n    let bottomSum = 0;\\n    let answer = Number.MAX_SAFE_INTEGER\\n    \\n    for (let i = 0; i < grid[0].length; i++) {\\n        topSum -= grid[0][i];\\n        answer = Math.min(answer, Math.max(topSum, bottomSum));\\n        bottomSum += grid[1][i];\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction gridGame(grid: number[][]): number {\\n    let topSum = 0;\\n    \\n    for(let i = 0; i < grid[0].length; i++) {\\n        topSum += grid[0][i];\\n    }\\n    \\n    let bottomSum = 0;\\n    let answer = Number.MAX_SAFE_INTEGER\\n    \\n    for (let i = 0; i < grid[0].length; i++) {\\n        topSum -= grid[0][i];\\n        answer = Math.min(answer, Math.max(topSum, bottomSum));\\n        bottomSum += grid[1][i];\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472498,
                "title": "why-is-this-going-wrong",
                "content": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    public long gridGame(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        long roboOne[][] = new long[m][n];\\n        long roboTwo[][] = new long[m][n];\\n        \\n        roboOne[0][0] = grid[0][0];\\n        grid[0][0] = 0;\\n        \\n        for(int i=1;i<m;i++)\\n            roboOne[i][0] = roboOne[i-1][0]+grid[i][0];\\n        \\n        for(int j=1;j<n;j++)\\n            roboOne[0][j] = roboOne[0][j-1]+grid[0][j];\\n        \\n        int i = 1;\\n        for(int j=1;j<n;j++)\\n           roboOne[i][j] = Math.max(roboOne[i-1][j], roboOne[i][j-1])+grid[i][j];\\n        \\n        grid[m-1][n-1] = 0;\\n        \\n        for(long robo[]:roboOne)\\n            System.out.println(Arrays.toString(robo));\\n        \\n        int r = m-1;\\n        int c = n-1;\\n        \\n        while(r!=0 || c!=0){\\n            grid[r][c] = 0;\\n            \\n            long top = valid(r-1,c)? roboOne[r-1][c] : Integer.MIN_VALUE;\\n            long left = valid(r,c-1)? roboOne[r][c-1] : Integer.MIN_VALUE;\\n            \\n            if(top>left)\\n                r--;\\n            else\\n                c--;\\n        }\\n        \\n        for(int g[]:grid)\\n            System.out.println(Arrays.toString(g));\\n        \\n        r = m-1;\\n        c = n-1;\\n        \\n        int answer = 0;\\n        \\n        while(r!=0 || c!=0){\\n            answer+=grid[r][c];\\n            \\n            long top = valid(r-1,c)? grid[r-1][c] : Integer.MIN_VALUE;\\n            long left = valid(r,c-1)? grid[r][c-1] : Integer.MIN_VALUE;\\n            \\n            if(top>left)\\n                r--;\\n            else\\n                c--;\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private boolean valid(int i,int j){\\n        return i>=0 && j>=0 && i<m && j<n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    public long gridGame(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        long roboOne[][] = new long[m][n];\\n        long roboTwo[][] = new long[m][n];\\n        \\n        roboOne[0][0] = grid[0][0];\\n        grid[0][0] = 0;\\n        \\n        for(int i=1;i<m;i++)\\n            roboOne[i][0] = roboOne[i-1][0]+grid[i][0];\\n        \\n        for(int j=1;j<n;j++)\\n            roboOne[0][j] = roboOne[0][j-1]+grid[0][j];\\n        \\n        int i = 1;\\n        for(int j=1;j<n;j++)\\n           roboOne[i][j] = Math.max(roboOne[i-1][j], roboOne[i][j-1])+grid[i][j];\\n        \\n        grid[m-1][n-1] = 0;\\n        \\n        for(long robo[]:roboOne)\\n            System.out.println(Arrays.toString(robo));\\n        \\n        int r = m-1;\\n        int c = n-1;\\n        \\n        while(r!=0 || c!=0){\\n            grid[r][c] = 0;\\n            \\n            long top = valid(r-1,c)? roboOne[r-1][c] : Integer.MIN_VALUE;\\n            long left = valid(r,c-1)? roboOne[r][c-1] : Integer.MIN_VALUE;\\n            \\n            if(top>left)\\n                r--;\\n            else\\n                c--;\\n        }\\n        \\n        for(int g[]:grid)\\n            System.out.println(Arrays.toString(g));\\n        \\n        r = m-1;\\n        c = n-1;\\n        \\n        int answer = 0;\\n        \\n        while(r!=0 || c!=0){\\n            answer+=grid[r][c];\\n            \\n            long top = valid(r-1,c)? grid[r-1][c] : Integer.MIN_VALUE;\\n            long left = valid(r,c-1)? grid[r][c-1] : Integer.MIN_VALUE;\\n            \\n            if(top>left)\\n                r--;\\n            else\\n                c--;\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private boolean valid(int i,int j){\\n        return i>=0 && j>=0 && i<m && j<n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441341,
                "title": "python-5-line-prefix-sum-solution",
                "content": "```\\ndef gridGame(self, grid: List[List[int]]) -> int:\\n\\tl1, l2 = grid\\n\\ts1, s2 = sum(l1), sum(l2)\\n\\tpsum1 = list(accumulate(l1))\\n\\tpsum2 = list(accumulate(l2[::-1]))[::-1]\\n\\treturn min(max(s1-a, s2-b) for a, b in zip(psum1, psum2))\\n```",
                "solutionTags": [],
                "code": "```\\ndef gridGame(self, grid: List[List[int]]) -> int:\\n\\tl1, l2 = grid\\n\\ts1, s2 = sum(l1), sum(l2)\\n\\tpsum1 = list(accumulate(l1))\\n\\tpsum2 = list(accumulate(l2[::-1]))[::-1]\\n\\treturn min(max(s1-a, s2-b) for a, b in zip(psum1, psum2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2357229,
                "title": "python-simple-prefix-sum",
                "content": "\\n    def gridGame(self, grid):\\n        n = len(grid[0])\\n        \\n        ans1, ans2, res = [grid[0][0]], [grid[1][-1]], float(\"inf\")\\n        \\n        for i in range(1,n):\\n            ans1.append(ans1[-1] + grid[0][i])\\n            ans2.append(ans2[-1] + grid[1][n-1-i])\\n            \\n        for i in range(n):\\n            res = min(res, max(ans1[-1] - ans1[i], ans2[-1] - ans2[n-1-i]))\\n            \\n        return res",
                "solutionTags": [],
                "code": "\\n    def gridGame(self, grid):\\n        n = len(grid[0])\\n        \\n        ans1, ans2, res = [grid[0][0]], [grid[1][-1]], float(\"inf\")\\n        \\n        for i in range(1,n):\\n            ans1.append(ans1[-1] + grid[0][i])\\n            ans2.append(ans2[-1] + grid[1][n-1-i])\\n            \\n        for i in range(n):\\n            res = min(res, max(ans1[-1] - ans1[i], ans2[-1] - ans2[n-1-i]))\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2319460,
                "title": "grid-game-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        \\n        long []upper=new long[n+2];\\n        long []lower=new long[n+2];\\n        \\n        for(int i=n;i>=1;i--){\\n            upper[i]=upper[i+1]+grid[0][i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            lower[i]=lower[i-1]+grid[1][i-1];\\n        }\\n        \\n        long ans=(long)Long.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            ans=Math.min(Math.max(upper[i+1],lower[i-1]),ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n        int n=grid[0].length;\\n        \\n        long []upper=new long[n+2];\\n        long []lower=new long[n+2];\\n        \\n        for(int i=n;i>=1;i--){\\n            upper[i]=upper[i+1]+grid[0][i-1];\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            lower[i]=lower[i-1]+grid[1][i-1];\\n        }\\n        \\n        long ans=(long)Long.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            ans=Math.min(Math.max(upper[i+1],lower[i-1]),ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236250,
                "title": "java-clean-code-prefix-sum",
                "content": "class Solution {\\n\\n    public long gridGame(int[][] grid) {\\n        long topSum = 0;\\n        for(int i=0;i<grid[0].length;i++)topSum+=grid[0][i];\\n        long bottomSum = 0;\\n        long ans = Long.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            topSum-= grid[0][i];\\n            ans = Math.min(ans, Math.max(topSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\n    public long gridGame(int[][] grid) {\\n        long topSum = 0;\\n        for(int i=0;i<grid[0].length;i++)topSum+=grid[0][i];\\n        long bottomSum = 0;\\n        long ans = Long.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            topSum-= grid[0][i];\\n            ans = Math.min(ans, Math.max(topSum, bottomSum));\\n            bottomSum += grid[1][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2228980,
                "title": "java-prefix-sum-comments-added",
                "content": "```\\n\\n/*\\n\\n1. here our main goal is to find i , from where robot_1 will go down . becuae once it is go down it can not go up again .\\nSo after that the only way will be go right\\n\\n0   1   2   3\\n2 , 5 , 4 , 6\\n1 , 5 , 1 , 3\\n\\n2. If R1 goes down at pos 1 , then R2 can take max point of (2 to 3 in 1st row , 0 to 0 in second row)\\nsame way if R1 goes down at pos 2 ,then R2 can take max point of (3 to 3 in 1st row , 0 to 1 in second row)\\n\\nR2 can not take both the 1st row and 2nd row remaining points .\\n\\n3. Hence if we want to calculate which will be best pos for i , then we have take min of these vlaues .\\n4. Becuase R1 will always tries to minimize the max point of R2 . \\n\\n5. Points in the row can be calculated in O(1) time by prefix sum .\\n\\n*/\\n\\n\\nclass Solution {\\n    \\n    public long gridGame(int[][] grid) {\\n        \\n        long res = Long.MAX_VALUE ;\\n        \\n        int length = grid[0].length ;\\n        long[] prefix_1 = new long[length] ; // prefix for row1\\n        long[] prefix_2 = new long[length] ; // prefix for row2\\n        \\n        prefix_1[0] = grid[0][0] ;\\n        prefix_2[0] = grid[1][0] ;\\n        \\n        for(int i=1 ; i<length ; i++){\\n            prefix_1[i] = prefix_1[i-1] + grid[0][i] ;\\n            prefix_2[i] = prefix_2[i-1] + grid[1][i] ;\\n        }\\n        \\n        // Check for all pos of i and find the best pos for i\\n        for(int i=0 ; i<length ; i++){\\n            \\n            long first_row_points = prefix_1[length-1] - prefix_1[i] ; // remaining points for first_row after R1\\n            long second_row_points = 0 ;\\n            if(i > 0){\\n                second_row_points = prefix_2[i-1] ; // // remaining points for first_row after R1\\n            }\\n\\n            long Total_cur_point = Math.max(first_row_points , second_row_points); // R2 can take any of these points , hence will take max of these two\\n            \\n            res = Math.min(res , Total_cur_point); // R1 will tries to minimize this max point\\n        }\\n        \\n        return res ;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\n\\n1. here our main goal is to find i , from where robot_1 will go down . becuae once it is go down it can not go up again .\\nSo after that the only way will be go right\\n\\n0   1   2   3\\n2 , 5 , 4 , 6\\n1 , 5 , 1 , 3\\n\\n2. If R1 goes down at pos 1 , then R2 can take max point of (2 to 3 in 1st row , 0 to 0 in second row)\\nsame way if R1 goes down at pos 2 ,then R2 can take max point of (3 to 3 in 1st row , 0 to 1 in second row)\\n\\nR2 can not take both the 1st row and 2nd row remaining points .\\n\\n3. Hence if we want to calculate which will be best pos for i , then we have take min of these vlaues .\\n4. Becuase R1 will always tries to minimize the max point of R2 . \\n\\n5. Points in the row can be calculated in O(1) time by prefix sum .\\n\\n*/\\n\\n\\nclass Solution {\\n    \\n    public long gridGame(int[][] grid) {\\n        \\n        long res = Long.MAX_VALUE ;\\n        \\n        int length = grid[0].length ;\\n        long[] prefix_1 = new long[length] ; // prefix for row1\\n        long[] prefix_2 = new long[length] ; // prefix for row2\\n        \\n        prefix_1[0] = grid[0][0] ;\\n        prefix_2[0] = grid[1][0] ;\\n        \\n        for(int i=1 ; i<length ; i++){\\n            prefix_1[i] = prefix_1[i-1] + grid[0][i] ;\\n            prefix_2[i] = prefix_2[i-1] + grid[1][i] ;\\n        }\\n        \\n        // Check for all pos of i and find the best pos for i\\n        for(int i=0 ; i<length ; i++){\\n            \\n            long first_row_points = prefix_1[length-1] - prefix_1[i] ; // remaining points for first_row after R1\\n            long second_row_points = 0 ;\\n            if(i > 0){\\n                second_row_points = prefix_2[i-1] ; // // remaining points for first_row after R1\\n            }\\n\\n            long Total_cur_point = Math.max(first_row_points , second_row_points); // R2 can take any of these points , hence will take max of these two\\n            \\n            res = Math.min(res , Total_cur_point); // R1 will tries to minimize this max point\\n        }\\n        \\n        return res ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198699,
                "title": "java-prefix-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) \\n    {\\n        int n=grid[0].length;\\n        \\n        if(n==1)\\n        return 0;\\n        \\n        long first_end[]=new long[n];\\n        long second_beg[]=new long[n];\\n        \\n        first_end[n-1]=grid[0][n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            first_end[i]=first_end[i+1]+grid[0][i];   \\n        }\\n        \\n        second_beg[0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            second_beg[i]=second_beg[i-1]+grid[1][i];   \\n        }\\n        \\n        long ans=Math.min(second_beg[n-2],first_end[1]);\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //if robot1 goes down\\n            long op1=first_end[i+1];\\n            long op2=second_beg[i-1];\\n            \\n            long max=Math.max(op1,op2);\\n            long min=Math.min(op1,op2);\\n            \\n            if(max<ans)\\n            {\\n                ans=max;\\n            }\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) \\n    {\\n        int n=grid[0].length;\\n        \\n        if(n==1)\\n        return 0;\\n        \\n        long first_end[]=new long[n];\\n        long second_beg[]=new long[n];\\n        \\n        first_end[n-1]=grid[0][n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            first_end[i]=first_end[i+1]+grid[0][i];   \\n        }\\n        \\n        second_beg[0]=grid[1][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            second_beg[i]=second_beg[i-1]+grid[1][i];   \\n        }\\n        \\n        long ans=Math.min(second_beg[n-2],first_end[1]);\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //if robot1 goes down\\n            long op1=first_end[i+1];\\n            long op2=second_beg[i-1];\\n            \\n            long max=Math.max(op1,op2);\\n            long min=Math.min(op1,op2);\\n            \\n            if(max<ans)\\n            {\\n                ans=max;\\n            }\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026831,
                "title": "java-using-prefix-sum-with-100-faster",
                "content": "\\n\\n        \\n        long t[]=new long[grid[0].length];\\n        long b[]=new long[t.length];\\n        long s1=0,s2=0;\\n        for(int i=0;i<t.length;i++)\\n        {\\n            s1+=grid[0][i];\\n            s2+=grid[1][t.length-i-1];\\n            b[t.length-i-1]=s2;\\n            t[i]=s1;\\n        }\\n        long min=Long.MAX_VALUE,max=0;\\n        for(int i=0;i<t.length;i++)\\n        {\\n           long tmp=t[i]+b[i];\\n           long x=0;\\n           if(i==0)\\n           {\\n                   x=t[t.length-1]-t[0];\\n           }\\n           else if(i==t.length-1)\\n           {\\n                   x=b[0]-b[i];\\n            }\\n            else\\n               {\\n                   x=Math.max(t[t.length-1]-t[i],b[0]-b[i]);\\n               }\\n               if(min>=x)\\n               {\\n                   max=tmp;\\n                   min=x;\\n               }\\n           \\n        }\\n        return min;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "\\n\\n        \\n        long t[]=new long[grid[0].length];\\n        long b[]=new long[t.length];\\n        long s1=0,s2=0;\\n        for(int i=0;i<t.length;i++)\\n        {\\n            s1+=grid[0][i];\\n            s2+=grid[1][t.length-i-1];\\n            b[t.length-i-1]=s2;\\n            t[i]=s1;\\n        }\\n        long min=Long.MAX_VALUE,max=0;\\n        for(int i=0;i<t.length;i++)\\n        {\\n           long tmp=t[i]+b[i];\\n           long x=0;\\n           if(i==0)\\n           {\\n                   x=t[t.length-1]-t[0];\\n           }\\n           else if(i==t.length-1)\\n           {\\n                   x=b[0]-b[i];\\n            }\\n            else\\n               {\\n                   x=Math.max(t[t.length-1]-t[i],b[0]-b[i]);\\n               }\\n               if(min>=x)\\n               {\\n                   max=tmp;\\n                   min=x;\\n               }\\n           \\n        }\\n        return min;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2005882,
                "title": "javascript-solution-prefix-sum",
                "content": "```\\nvar gridGame = function(grid) {\\n    const n = grid[0].length;\\n    \\n    let topTotSum = grid[0].reduce((acc, num) => acc + num, 0);\\n    let botTotSum = grid[1].reduce((acc, num) => acc + num, 0);\\n    \\n    let leftAccBotSum = 0;\\n    \\n    let bestSum = Math.min(topTotSum, botTotSum);\\n    \\n    for (let j = 0; j < n; ++j) {\\n        const topNum = grid[0][j];\\n        const botNum = grid[1][j];\\n        \\n        topTotSum -= topNum;\\n        \\n        const maxSum = Math.max(topTotSum, leftAccBotSum);\\n        \\n        bestSum = Math.min(bestSum, maxSum);\\n        \\n        leftAccBotSum += botNum;\\n    }\\n    \\n    return bestSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar gridGame = function(grid) {\\n    const n = grid[0].length;\\n    \\n    let topTotSum = grid[0].reduce((acc, num) => acc + num, 0);\\n    let botTotSum = grid[1].reduce((acc, num) => acc + num, 0);\\n    \\n    let leftAccBotSum = 0;\\n    \\n    let bestSum = Math.min(topTotSum, botTotSum);\\n    \\n    for (let j = 0; j < n; ++j) {\\n        const topNum = grid[0][j];\\n        const botNum = grid[1][j];\\n        \\n        topTotSum -= topNum;\\n        \\n        const maxSum = Math.max(topTotSum, leftAccBotSum);\\n        \\n        bestSum = Math.min(bestSum, maxSum);\\n        \\n        leftAccBotSum += botNum;\\n    }\\n    \\n    return bestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858752,
                "title": "python-simple-code",
                "content": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        bottom, top = 0, sum(grid[0][1:])\\n        best = top\\n        for i in range(1, len(grid[0])):\\n            bottom += grid[1][i-1]\\n            top -= grid[0][i]\\n            best = min(best, max(bottom, top))\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        bottom, top = 0, sum(grid[0][1:])\\n        best = top\\n        for i in range(1, len(grid[0])):\\n            bottom += grid[1][i-1]\\n            top -= grid[0][i]\\n            best = min(best, max(bottom, top))\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857724,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n      long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = 0;\\n            for (int i : grid[0]) {\\n                    upperRight += i;\\n                 }\\n            for (int i = 0; i < grid[0].length; ++i) {\\n                        upperRight -= grid[0][i];\\n                        ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n                        lowerLeft += grid[1][i];\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long gridGame(int[][] grid) {\\n      long ans = Long.MAX_VALUE, lowerLeft = 0, upperRight = 0;\\n            for (int i : grid[0]) {\\n                    upperRight += i;\\n                 }\\n            for (int i = 0; i < grid[0].length; ++i) {\\n                        upperRight -= grid[0][i];\\n                        ans = Math.min(ans, Math.max(upperRight, lowerLeft));\\n                        lowerLeft += grid[1][i];\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853041,
                "title": "o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if (n==1) return 0;\\n        long long sum1 = 0, sum2 = 0, ans=0;\\n        for(int i=1; i<n; i++) \\n            sum1+=grid[0][i];\\n        ans = sum1;\\n        for(int i=1; i<n; i++) \\n        {\\n            sum1 -= grid[0][i];\\n            sum2 += grid[1][i-1];\\n            if (sum2 > sum1)\\n            {\\n                ans = min(sum2, ans);\\n                break;\\n            }\\n            else\\n                ans = min(sum1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gridGame(vector<vector<int>>& grid) {\\n        int n = grid[0].size();\\n        if (n==1) return 0;\\n        long long sum1 = 0, sum2 = 0, ans=0;\\n        for(int i=1; i<n; i++) \\n            sum1+=grid[0][i];\\n        ans = sum1;\\n        for(int i=1; i<n; i++) \\n        {\\n            sum1 -= grid[0][i];\\n            sum2 += grid[1][i-1];\\n            if (sum2 > sum1)\\n            {\\n                ans = min(sum2, ans);\\n                break;\\n            }\\n            else\\n                ans = min(sum1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849281,
                "title": "python-easy-to-read-and-understand-prefix-sum",
                "content": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        top, bottom = sum(grid[0]), 0\\n        ans = float(\"inf\")\\n        \\n        for i in range(n):\\n            top -= grid[0][i]\\n            ans = min(ans, max(top, bottom))\\n            bottom += grid[1][i]\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        top, bottom = sum(grid[0]), 0\\n        ans = float(\"inf\")\\n        \\n        for i in range(n):\\n            top -= grid[0][i]\\n            ans = min(ans, max(top, bottom))\\n            bottom += grid[1][i]\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1838283,
                "title": "prefix-sum-and-suffix-sum",
                "content": "```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid[0])\\n        grid[0][0] = grid[1][-1] = 0\\n        upper = grid[0][-1:]\\n        for i in range(n - 2, -1, -1):\\n            upper.append(upper[-1] + grid[0][i])\\n        upper.reverse()\\n        lower = grid[1][:1]\\n        for point in grid[1][1:]:\\n            lower.append(lower[-1] + point)\\n        best = min(upper[0], lower[-1])\\n        for i in range(1, n - 1):\\n            best = min(best, max(upper[i + 1], lower[i - 1]))\\n        return best",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def gridGame(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid[0])\\n        grid[0][0] = grid[1][-1] = 0\\n        upper = grid[0][-1:]\\n        for i in range(n - 2, -1, -1):\\n            upper.append(upper[-1] + grid[0][i])\\n        upper.reverse()\\n        lower = grid[1][:1]\\n        for point in grid[1][1:]:\\n            lower.append(lower[-1] + point)\\n        best = min(upper[0], lower[-1])\\n        for i in range(1, n - 1):\\n            best = min(best, max(upper[i + 1], lower[i - 1]))\\n        return best",
                "codeTag": "Java"
            },
            {
                "id": 1824248,
                "title": "prefix-sum-minimize-opponent-s-maximum-possible-score",
                "content": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        top = [0]\\n        bottom = [0]\\n        for el in grid[0]:\\n            top.append(top[-1] + el)\\n        for el in grid[1]:\\n            bottom.append(bottom[-1] + el)\\n        opponent = float(\\'inf\\')\\n        mindex = None\\n        for i in range(n):\\n            curropp = max(top[-1] - top[i + 1], bottom[i])\\n            if curropp <= opponent:\\n                opponent = curropp\\n                mindex = i\\n        return max(top[-1] - top[mindex + 1], bottom[mindex])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        top = [0]\\n        bottom = [0]\\n        for el in grid[0]:\\n            top.append(top[-1] + el)\\n        for el in grid[1]:\\n            bottom.append(bottom[-1] + el)\\n        opponent = float(\\'inf\\')\\n        mindex = None\\n        for i in range(n):\\n            curropp = max(top[-1] - top[i + 1], bottom[i])\\n            if curropp <= opponent:\\n                opponent = curropp\\n                mindex = i\\n        return max(top[-1] - top[mindex + 1], bottom[mindex])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1688455,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1670942,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1915452,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1567668,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1724586,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1809414,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2030005,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2019797,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2036812,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2035459,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1688455,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1670942,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1915452,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1567668,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1724586,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 1809414,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2030005,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2019797,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2036812,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            },
            {
                "id": 2035459,
                "content": [
                    {
                        "username": "wleitne",
                        "content": "Feeling pretty dumb here. My solution passed the sample test cases, failed the full suite. I'm looking at one of the failures, and I don't understand how expected solution is possible. \n\nStarting Grid:\n`20  03 20 17  02 12 15 17  04 15 `\n`20 10 13 14 15  05  02  03 14  03 `\n\nMy red robot took the following path with a score of 128:\n` 00  00  00  00  00  00  00  00  00  00 `\n`20 10 13 14 15  05  02  03 14  00 `\n\nMy blue robot took the entire bottom row, and got a score of 96. However, the expected outcome was 63. ***Can someone show me the expected path for the red robot?*** My robots' paths look correct to me given the rules, so I don't understand how that 63 is possible.\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@Ashish2828](/Ashish2828) Can u please explain more  ?\\n"
                    },
                    {
                        "username": "Ashish2828",
                        "content": "Man here in this q it is asked to find the route that first robot should travel so that the sum of the second robot is minimised . I did try the dp one and it failed.That is because dp maxi the profit for current robot but don\\'t look in the direction to minimize the sum for the second robot.\\nyou need to think to minimize the total sum for the second robot and you will get to the correct solution."
                    },
                    {
                        "username": "despondency",
                        "content": "I fell into the same trap and even wrote a DP solution. Thank you [@Arthur Chan](/Real1236)"
                    },
                    {
                        "username": "wleitne",
                        "content": "[@Real1236](/Real1236) Duh. lol.  It seems so obvious now. Thank you so much!"
                    },
                    {
                        "username": "Real1236",
                        "content": "What if the red robot descended a row on index 4?\n\n00 00 00 00 00 12 15 17 04 15\n20 10 13 14 00 00 00 00 00 00\n\nThen the blue robot can only take the top row, summing to 63.\n\nThe solution is not found by taking the path of the red robot that would get the highest score for the red robot. \nIt's found by the red robot taking a path that would leave blue with the minimum score possible."
                    },
                    {
                        "username": "ConvexChull",
                        "content": "greedy aint gonna work dont try that route"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Just a tip: Maximizing path for robot 1 doesn\\'t ensure the solution. Hence dp won\\'t work here. See the hint and try to think again"
                    },
                    {
                        "username": "zwb920922",
                        "content": "I couldn\\'t figure it out myself so hope to get an answer here."
                    },
                    {
                        "username": "despondency",
                        "content": "For those wondering here is a hint:\\n\\nIf you calculate the prefix sums for both rows, you can do the following:\\n\\n1. If you iterate over the first row\\'s prefix sums, you can calculate by using the prefix sums what would be the blue robot\\'s score if it were to take everything other than what the red would take from the current position. At each step you can calculate two of the blue robot sums which are:\\n\\na) Take everything that is left on the first row. (prefix1[grid[0].length - 1] - prefix[i]\\nb) Take everything that is left up to the current idx on the second row.  i - 1 >= 0 ? (prefix2[i-1] : 0\\n\\nIf you have those two sums, you can calculate what is the max of them.  If max > 0, then you will do ans = Math.min(ans, maxi) where maxi is the max of the two different blue robot scores.\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Should probably put \\'Game Theory\\' under related topics."
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "this question is simply on prefix sum"
                    },
                    {
                        "username": "mask01",
                        "content": "Should not be this question in the \"HARD\" category? Not be able to come up even with brute force.\\nOr I am dumb !!"
                    },
                    {
                        "username": "layyy",
                        "content": "Understand the difference between maximizing the points of Robot 1 and minimizing the points of Robot 2"
                    },
                    {
                        "username": "krishna1908",
                        "content": "[ [3,3,21] , [18,15,2] ]   \nfor this particular test case as far as I understood the question, the answer is 24 (3+21) because first player goes from 3,18,15,2 .  but the given answer is 21. Can someone please clarify this !!"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "The first player will go 3 -> 3 -> 15 -> 2 , because it is the optimal according to first player, and then answer for second player will be 21"
                    }
                ]
            }
        ]
    }
]