[
    {
        "title": "Construct String With Repeat Limit",
        "question_content": "You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.\nReturn the lexicographically largest repeatLimitedString possible.\nA string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.\n&nbsp;\nExample 1:\n\nInput: s = \"cczazcc\", repeatLimit = 3\nOutput: \"zzcccac\"\nExplanation: We use all of the characters from s to construct the repeatLimitedString \"zzcccac\".\nThe letter 'a' appears at most 1 time in a row.\nThe letter 'c' appears at most 3 times in a row.\nThe letter 'z' appears at most 2 times in a row.\nHence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\nThe string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\".\nNote that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString.\n\nExample 2:\n\nInput: s = \"aababab\", repeatLimit = 2\nOutput: \"bbabaa\"\nExplanation: We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". \nThe letter 'a' appears at most 2 times in a row.\nThe letter 'b' appears at most 2 times in a row.\nHence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\nThe string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\".\nNote that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString.\n\n&nbsp;\nConstraints:\n\n\t1 <= repeatLimit <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1784775,
                "title": "easy-understanding-c-code-with-comments",
                "content": "We want to form a lexicographically largest string using the characters in a given string.\\nBut we have to make sure that a letter is not repeated more than the given limit in a row (i.e consecutively).\\n\\nSo we use a ***priority_queue*** to pop the element which has the highest priority. *If it\\'s count is less than the repeatLimit,* we directly add to the ans.\\n\\n*But if it\\'s count is greater than the repeatLimit*, we just add the repeatLimit amount of the present character and we pop out the next priority character and add a single letter to the ans.\\nThis makes that a letter is not repeated more than limit in a row and lexicographically largest is maintained. After adding to the ans, if we have extra characters left out, we just push back into priority_queue for the next use.\\n\\nHere *if we are not able to pop*, the next priority character, we just return the ans so as we cannot add more than repeatedLimit charecters in a row.\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) { // k is the repeatLimit\\n        int n = s.length();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<n;i++) m[s[i]]++;\\n        priority_queue<pair<char,int>> pq;\\n        for(auto i: m){\\n            pq.push({i.first,i.second}); // pushing the characters with their frequencies.\\n        }\\n        \\n        string ans = \"\";\\n        while(!pq.empty()){\\n            char c1 = pq.top().first;\\n            int n1 = pq.top().second;\\n            pq.pop();\\n                \\n            int len = min(k,n1); // Adding characters upto minimum of repeatLimit and present character count.\\n            for(int i=0;i<len;i++){ // adding the highest priority element to the ans.\\n                ans += c1;\\n            }\\n            \\n            char c2;\\n            int n2=0;\\n            if(n1-len>0){ // If the cnt of present character is more than the limit.\\n                if(!pq.empty()){ //Getting the next priority character.\\n                    c2 = pq.top().first;\\n                    n2 = pq.top().second;\\n                    pq.pop();\\n                }\\n                else{\\n                    return ans; // if there is no another letter to add, we just return ans.\\n                }\\n                ans += c2; // Adding next priority character to ans.\\n                \\n                // If the elements are left out, pushing them back into priority queue for next use.\\n                pq.push({c1,n1-len});\\n                if(n2-1>0) pq.push({c2,n2-1}); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Upvote if it helps!**",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) { // k is the repeatLimit\\n        int n = s.length();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<n;i++) m[s[i]]++;\\n        priority_queue<pair<char,int>> pq;\\n        for(auto i: m){\\n            pq.push({i.first,i.second}); // pushing the characters with their frequencies.\\n        }\\n        \\n        string ans = \"\";\\n        while(!pq.empty()){\\n            char c1 = pq.top().first;\\n            int n1 = pq.top().second;\\n            pq.pop();\\n                \\n            int len = min(k,n1); // Adding characters upto minimum of repeatLimit and present character count.\\n            for(int i=0;i<len;i++){ // adding the highest priority element to the ans.\\n                ans += c1;\\n            }\\n            \\n            char c2;\\n            int n2=0;\\n            if(n1-len>0){ // If the cnt of present character is more than the limit.\\n                if(!pq.empty()){ //Getting the next priority character.\\n                    c2 = pq.top().first;\\n                    n2 = pq.top().second;\\n                    pq.pop();\\n                }\\n                else{\\n                    return ans; // if there is no another letter to add, we just return ans.\\n                }\\n                ans += c2; // Adding next priority character to ans.\\n                \\n                // If the elements are left out, pushing them back into priority queue for next use.\\n                pq.push({c1,n1-len});\\n                if(n2-1>0) pq.push({c2,n2-1}); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784797,
                "title": "java-priority-queue-and-stack-larger-string-with-repeat-limit",
                "content": "At first on looking into this problem it looked little complex,\\n\\nBut after thinking for some time, I am able to unwire it little easily..\\n\\nHere is the approach I took.\\n\\nIn-order to get a lexicographically larger number we know that it should have all larger alphabets in the starting of string like zzzzzzyyyyyyxxxxx.\\n\\nBut here they have given repeat count limit, so first things first we can sort the given string of characters using PriorityQueue.\\n\\n`1. Sort the given string in lexicographically large order using Max heap\\n\\nThen to maintain the repeat count and the lesser lexicographically small character once and then come back to larger charecter, I took the help of stack.\\n\\n 2. If the count of repeated character is more than the given repeat limit then add to stack\\n 3. Then add the small character once and check whether the stack is empty\\n 4. If its empty then you can continue in the same pattern\\n 5. If stack is not empty then add the characters to its repeat count and again go for lesser character and repeat this process till the Priority Queue is empty.\\n\\nNow its time to look into the code :)\\n\\n\\n```\\n   public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<Character> pq = new PriorityQueue<Character>((a,b)->b-a);\\n        for(char ch:s.toCharArray()){\\n        \\tpq.add(ch);\\n        }\\n        StringBuffer res = new StringBuffer();\\n        ArrayList<Character> list = new ArrayList<Character>();\\n        Stack<Character> stk = new Stack<Character>();\\n        int count = 0;\\n        char previouschar = pq.peek();\\n        while(!pq.isEmpty()){\\n        \\tchar curr = pq.poll();\\n        \\tif(curr==previouschar){\\n        \\t\\tif(count<repeatLimit){\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tstk.add(curr);\\n        \\t\\t}\\n        \\t\\tcount++;\\n        \\t}\\n        \\telse{\\n        \\t\\tif(stk.isEmpty()){\\n        \\t\\t\\tcount=0;\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t\\tpreviouschar = curr;\\n        \\t\\t\\tcount++;\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t\\tcount=0;\\n        \\t\\t\\twhile(!stk.isEmpty() && count<repeatLimit){\\n        \\t\\t\\t\\tres.append(stk.pop());\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return res.toString();\\n    }\\n\\n\\nHappy learning.. upvote if its helpful\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "At first on looking into this problem it looked little complex,\\n\\nBut after thinking for some time, I am able to unwire it little easily..\\n\\nHere is the approach I took.\\n\\nIn-order to get a lexicographically larger number we know that it should have all larger alphabets in the starting of string like zzzzzzyyyyyyxxxxx.\\n\\nBut here they have given repeat count limit, so first things first we can sort the given string of characters using PriorityQueue.\\n\\n`1. Sort the given string in lexicographically large order using Max heap\\n\\nThen to maintain the repeat count and the lesser lexicographically small character once and then come back to larger charecter, I took the help of stack.\\n\\n 2. If the count of repeated character is more than the given repeat limit then add to stack\\n 3. Then add the small character once and check whether the stack is empty\\n 4. If its empty then you can continue in the same pattern\\n 5. If stack is not empty then add the characters to its repeat count and again go for lesser character and repeat this process till the Priority Queue is empty.\\n\\nNow its time to look into the code :)\\n\\n\\n```\\n   public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<Character> pq = new PriorityQueue<Character>((a,b)->b-a);\\n        for(char ch:s.toCharArray()){\\n        \\tpq.add(ch);\\n        }\\n        StringBuffer res = new StringBuffer();\\n        ArrayList<Character> list = new ArrayList<Character>();\\n        Stack<Character> stk = new Stack<Character>();\\n        int count = 0;\\n        char previouschar = pq.peek();\\n        while(!pq.isEmpty()){\\n        \\tchar curr = pq.poll();\\n        \\tif(curr==previouschar){\\n        \\t\\tif(count<repeatLimit){\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tstk.add(curr);\\n        \\t\\t}\\n        \\t\\tcount++;\\n        \\t}\\n        \\telse{\\n        \\t\\tif(stk.isEmpty()){\\n        \\t\\t\\tcount=0;\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t\\tpreviouschar = curr;\\n        \\t\\t\\tcount++;\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tres.append(curr);\\n        \\t\\t\\tcount=0;\\n        \\t\\t\\twhile(!stk.isEmpty() && count<repeatLimit){\\n        \\t\\t\\t\\tres.append(stk.pop());\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return res.toString();\\n    }\\n\\n\\nHappy learning.. upvote if its helpful\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1784718,
                "title": "c-greedy-counting-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Greedy + Counting\\n\\nStore frequency of characters in `int cnt[26]`.\\n\\nWe pick characters in batches. In each batch, we pick the first character from `z` to `a` whose `cnt` is positive with the following caveats:\\n1. If the current character is the same as the one used in the previous batch, we need to skip it.\\n2. On top of case 1, if the `cnt` of the character used in the previous batch is positive, then we can only fill a single character in this batch.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/construct-string-with-repeat-limit/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int cnt[26] = {};\\n        string ans;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        while (true) {\\n            int i = 25;\\n            bool onlyOne = false;\\n            for (; i >= 0; --i) {\\n                if (ans.size() && i == ans.back() - \\'a\\' && cnt[i]) { // the character of our last batch still has some count left, so we only insert a single character in this batch\\n                    onlyOne = true;\\n                    continue;\\n                }\\n                if (cnt[i]) break; // found a character with positive count, fill with this character\\n            }\\n            if (i == -1) break; // no more characters to fill, break;\\n            int fill = onlyOne ? 1 : min(cnt[i], limit);\\n            cnt[i] -= fill;\\n            while (fill--) ans += \\'a\\' + i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/construct-string-with-repeat-limit/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int cnt[26] = {};\\n        string ans;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        while (true) {\\n            int i = 25;\\n            bool onlyOne = false;\\n            for (; i >= 0; --i) {\\n                if (ans.size() && i == ans.back() - \\'a\\' && cnt[i]) { // the character of our last batch still has some count left, so we only insert a single character in this batch\\n                    onlyOne = true;\\n                    continue;\\n                }\\n                if (cnt[i]) break; // found a character with positive count, fill with this character\\n            }\\n            if (i == -1) break; // no more characters to fill, break;\\n            int fill = onlyOne ? 1 : min(cnt[i], limit);\\n            cnt[i] -= fill;\\n            while (fill--) ans += \\'a\\' + i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784789,
                "title": "python3-priority-queue",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/793daa0aab0733bfadd4041fdaa6f8bdd38fe229) for solutions of weekly 281. \\n\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        pq = [(-ord(k), v) for k, v in Counter(s).items()] \\n        heapify(pq)\\n        ans = []\\n        while pq: \\n            k, v = heappop(pq)\\n            if ans and ans[-1] == k: \\n                if not pq: break \\n                kk, vv = heappop(pq)\\n                ans.append(kk)\\n                if vv-1: heappush(pq, (kk, vv-1))\\n                heappush(pq, (k, v))\\n            else: \\n                m = min(v, repeatLimit)\\n                ans.extend([k]*m)\\n                if v-m: heappush(pq, (k, v-m))\\n        return \"\".join(chr(-x) for x in ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        pq = [(-ord(k), v) for k, v in Counter(s).items()] \\n        heapify(pq)\\n        ans = []\\n        while pq: \\n            k, v = heappop(pq)\\n            if ans and ans[-1] == k: \\n                if not pq: break \\n                kk, vv = heappop(pq)\\n                ans.append(kk)\\n                if vv-1: heappush(pq, (kk, vv-1))\\n                heappush(pq, (k, v))\\n            else: \\n                m = min(v, repeatLimit)\\n                ans.extend([k]*m)\\n                if v-m: heappush(pq, (k, v-m))\\n        return \"\".join(chr(-x) for x in ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784754,
                "title": "greedy",
                "content": "1. Count all characters in 26 buckets (\\'a\\' to \\'z\\'). \\n2. While we have characters left:\\n\\t- Find the largest bucket `i` that still has characters.\\n\\t- Take up to limit characters from bucket `i`.\\n\\t- Find the second largest bucket `j` that has characters.\\n\\t- Pick 1 character from bucket `j`.\\n\\nCaveats:\\n- The largest bucket `i` could be the same as the second largest one `j` from the previous iteration.\\n\\t- So we should pick one less character from there.\\n- Make sure `i` and `j` only go one direction (down) for the performance.\\n\\n**C++**\\n```cpp\\nstring repeatLimitedString(string s, int lim) {\\n    string res;\\n    int cnt[26] = {};\\n    for (auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (int i = 25, j = 26; j >= 0; ) {\\n        while (i >= 0 && cnt[i] == 0)\\n            --i;\\n        if (i >= 0) {\\n            res += string(min(lim - (i == j), cnt[i]), \\'a\\' + i);\\n            cnt[i] -= min(lim - (i == j), cnt[i]);\\n        }\\n        j = min(i - 1, j);\\n        while (j >= 0 && cnt[j] == 0)\\n            --j;        \\n        if (j >=0) {\\n            res += string(1, \\'a\\' + j);\\n            --cnt[j];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring repeatLimitedString(string s, int lim) {\\n    string res;\\n    int cnt[26] = {};\\n    for (auto ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (int i = 25, j = 26; j >= 0; ) {\\n        while (i >= 0 && cnt[i] == 0)\\n            --i;\\n        if (i >= 0) {\\n            res += string(min(lim - (i == j), cnt[i]), \\'a\\' + i);\\n            cnt[i] -= min(lim - (i == j), cnt[i]);\\n        }\\n        j = min(i - 1, j);\\n        while (j >= 0 && cnt[j] == 0)\\n            --j;        \\n        if (j >=0) {\\n            res += string(1, \\'a\\' + j);\\n            --cnt[j];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784950,
                "title": "python-straightforward-solution-counting",
                "content": "We store the frequency of each character of the string in an array(A[26]). Now we start from the last index of the array which will store z as we need to generate output in lexiographically increasing order.\\n\\n```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        arr = [0] * 26\\n        a = ord(\\'a\\')\\n        \\n        for char in s:\\n            arr[ord(char)-a] += 1\\n\\t\\t\\t\\n        # Using an array to store the answer as appending to a string is a costly operation\\n        ans = []\\n        curr = 25\\n        prev = 24 \\n\\t\\t\\n        # We are starting with curr = 25 as we need to add the largest character first\\n        while curr >= 0:\\n            if arr[curr] == 0:\\n                curr -= 1\\n                continue\\n            \\n\\t\\t\\t# If the character is present in the string then we add it to our answer \\n            for i in range(min(repeatLimit, arr[curr])):\\n                ans.append(chr(curr + a))\\n                arr[curr] -= 1\\n                \\n\\t\\t\\t# If the above for loop was able to add all the characters then we can move on to the next one\\n            if arr[curr] == 0:\\n                curr -= 1\\n                continue\\n            \\n\\t\\t\\t# If the above for loop was not able to add all the characters then we need to add a second largest character before we can continue  adding the largest character to our answer again\\n            g = False\\n            for j in range(min(prev, curr-1), -1, -1):\\n                if arr[j]:\\n                    g = True\\n                    arr[j] -= 1\\n                    prev = j\\n                    ans.append(chr(j+a))\\n                    break\\n\\t\\t\\t# If g is false then we know that there were no other characters present other  than the largest character\\n            if not g: break\\n            \\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        arr = [0] * 26\\n        a = ord(\\'a\\')\\n        \\n        for char in s:\\n            arr[ord(char)-a] += 1\\n\\t\\t\\t\\n        # Using an array to store the answer as appending to a string is a costly operation\\n        ans = []\\n        curr = 25\\n        prev = 24 \\n\\t\\t\\n        # We are starting with curr = 25 as we need to add the largest character first\\n        while curr >= 0:\\n            if arr[curr] == 0:\\n                curr -= 1\\n                continue\\n            \\n\\t\\t\\t# If the character is present in the string then we add it to our answer \\n            for i in range(min(repeatLimit, arr[curr])):\\n                ans.append(chr(curr + a))\\n                arr[curr] -= 1\\n                \\n\\t\\t\\t# If the above for loop was able to add all the characters then we can move on to the next one\\n            if arr[curr] == 0:\\n                curr -= 1\\n                continue\\n            \\n\\t\\t\\t# If the above for loop was not able to add all the characters then we need to add a second largest character before we can continue  adding the largest character to our answer again\\n            g = False\\n            for j in range(min(prev, curr-1), -1, -1):\\n                if arr[j]:\\n                    g = True\\n                    arr[j] -= 1\\n                    prev = j\\n                    ans.append(chr(j+a))\\n                    break\\n\\t\\t\\t# If g is false then we know that there were no other characters present other  than the largest character\\n            if not g: break\\n            \\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784996,
                "title": "logic-explained-with-comments-priority-queue",
                "content": "As we **need lexicographically largest string** so start **adding largest character available**.\\nOne thing we need to **take care of** is we **cannot repeat a character more than repeatLimit times** so **when this happens** **add 1 next greatest charcter.**\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        int n(size(s));\\n        vector <int> m(26, 0);\\n        for (auto ch : s)   m[ch-\\'a\\']++;\\n        \\n        priority_queue <pair<char, int>> pq;\\n        for (int i=0; i<26; i++)\\n            if (m[i])   \\n                pq.push({i+\\'a\\', m[i]});\\n        \\n        string res;\\n        \\n        while (!pq.empty()) {\\n\\t\\t\\n            auto top = pq.top(); pq.pop();  // top contains lexicographically greatest character\\n            here :\\n            int lim = min(top.second, repeatLimit); // lim is number of times top can be added\\n            top.second -= lim;\\n\\t\\t\\t\\n            while (lim--)   res.push_back(top.first);\\n            if (top.second > 0) {\\n                if (pq.empty()) return res; // if we dont get next greatest character then we cannot use remaining characters so return res\\n                auto next = pq.top(); pq.pop(); // next contains lexicographically greatest character smaller than top\\n                res.push_back(next.first);\\n                next.second -= 1;\\n                if (next.second)    pq.push(next);\\n                goto here;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Upvote if it helps :)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        int n(size(s));\\n        vector <int> m(26, 0);\\n        for (auto ch : s)   m[ch-\\'a\\']++;\\n        \\n        priority_queue <pair<char, int>> pq;\\n        for (int i=0; i<26; i++)\\n            if (m[i])   \\n                pq.push({i+\\'a\\', m[i]});\\n        \\n        string res;\\n        \\n        while (!pq.empty()) {\\n\\t\\t\\n            auto top = pq.top(); pq.pop();  // top contains lexicographically greatest character\\n            here :\\n            int lim = min(top.second, repeatLimit); // lim is number of times top can be added\\n            top.second -= lim;\\n\\t\\t\\t\\n            while (lim--)   res.push_back(top.first);\\n            if (top.second > 0) {\\n                if (pq.empty()) return res; // if we dont get next greatest character then we cannot use remaining characters so return res\\n                auto next = pq.top(); pq.pop(); // next contains lexicographically greatest character smaller than top\\n                res.push_back(next.first);\\n                next.second -= 1;\\n                if (next.second)    pq.push(next);\\n                goto here;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784749,
                "title": "python-short-solution-using-heap",
                "content": "\\n      \\n        \\n        The idea is simple, keep a max heap of all the characters and their available counts.\\n        If the max character element at the top of the heap is already exceeding the limit interms of count,\\n        then pop the next one and add to heap. Also add back the unused max character element to the heap.\\n        \\n  \\n```\\ndef repeatLimitedString(self, s: str, limit: int) -> str:\\n\\theap = [ (-ord(ch), ch, count) for ch, count in Counter(s).items() ]\\n\\theapify(heap)\\n\\tres, count = [], 0\\n\\n\\twhile heap:\\n\\t\\tmax_heap_key, ch, rem = heappop(heap)\\n\\t\\tif res and res[-1] == ch and (count+1) > limit:\\n\\t\\t\\tif not heap: break\\n\\t\\t\\tmax_heap_key2, ch2, rem2 = heappop(heap)\\n\\t\\t\\theappush(heap, (max_heap_key, ch, rem))\\n\\t\\t\\tmax_heap_key, ch, rem = max_heap_key2, ch2, rem2\\n\\n\\t\\tif res and res[-1] != ch:\\n\\t\\t\\tcount = 0\\n\\n\\t\\tres.append(ch)\\n\\t\\trem -= 1\\n\\t\\tif rem:\\n\\t\\t\\theappush(heap, (max_heap_key, ch, rem))\\n\\t\\tcount += 1\\n\\treturn \\'\\'.join(res)           \\n```\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef repeatLimitedString(self, s: str, limit: int) -> str:\\n\\theap = [ (-ord(ch), ch, count) for ch, count in Counter(s).items() ]\\n\\theapify(heap)\\n\\tres, count = [], 0\\n\\n\\twhile heap:\\n\\t\\tmax_heap_key, ch, rem = heappop(heap)\\n\\t\\tif res and res[-1] == ch and (count+1) > limit:\\n\\t\\t\\tif not heap: break\\n\\t\\t\\tmax_heap_key2, ch2, rem2 = heappop(heap)\\n\\t\\t\\theappush(heap, (max_heap_key, ch, rem))\\n\\t\\t\\tmax_heap_key, ch, rem = max_heap_key2, ch2, rem2\\n\\n\\t\\tif res and res[-1] != ch:\\n\\t\\t\\tcount = 0\\n\\n\\t\\tres.append(ch)\\n\\t\\trem -= 1\\n\\t\\tif rem:\\n\\t\\t\\theappush(heap, (max_heap_key, ch, rem))\\n\\t\\tcount += 1\\n\\treturn \\'\\'.join(res)           \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784906,
                "title": "java-using-char-counting-array-with-o-1-space",
                "content": "My easy-understanding solution, O(n) time complexity and O(26) -> O(1) space.\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] counter = new int[26];\\n        int max = 0;\\n        for (char ch : s.toCharArray()) {\\n            int curr = ch - \\'a\\';\\n            max = Math.max(max, curr);\\n            counter[curr]++;\\n        }\\n        int repeated = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (max >= 0) {\\n            builder.append((char)(\\'a\\' + max));\\n            counter[max]--;\\n            repeated++;\\n            if (counter[max] == 0) {\\n                max = findNextMax(counter, max - 1);\\n                repeated = 0;\\n\\t\\t\\t\\tcontinue;\\n            } \\n            if (repeated == repeatLimit) {\\n\\t\\t\\t\\t// Greedy, use the next possible char once and get back to curr.\\n\\t\\t\\t\\t// if no other char available, the curr word is the largest subsequence. \\n                int lower = findNextMax(counter, max - 1);\\n                if (lower < 0) {\\n                    return builder.toString();\\n                }\\n                builder.append((char)(\\'a\\' + lower));\\n                counter[lower]--;\\n                repeated = 0;\\n            }\\n        }\\n        return builder.toString();\\n    }\\n    \\n    private int findNextMax(int[] counter, int from) {\\n        int curr = from;\\n        while (curr >= 0) {\\n            if (counter[curr] > 0) {\\n                return curr;\\n            }\\n            curr--;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] counter = new int[26];\\n        int max = 0;\\n        for (char ch : s.toCharArray()) {\\n            int curr = ch - \\'a\\';\\n            max = Math.max(max, curr);\\n            counter[curr]++;\\n        }\\n        int repeated = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (max >= 0) {\\n            builder.append((char)(\\'a\\' + max));\\n            counter[max]--;\\n            repeated++;\\n            if (counter[max] == 0) {\\n                max = findNextMax(counter, max - 1);\\n                repeated = 0;\\n\\t\\t\\t\\tcontinue;\\n            } \\n            if (repeated == repeatLimit) {\\n\\t\\t\\t\\t// Greedy, use the next possible char once and get back to curr.\\n\\t\\t\\t\\t// if no other char available, the curr word is the largest subsequence. \\n                int lower = findNextMax(counter, max - 1);\\n                if (lower < 0) {\\n                    return builder.toString();\\n                }\\n                builder.append((char)(\\'a\\' + lower));\\n                counter[lower]--;\\n                repeated = 0;\\n            }\\n        }\\n        return builder.toString();\\n    }\\n    \\n    private int findNextMax(int[] counter, int from) {\\n        int curr = from;\\n        while (curr >= 0) {\\n            if (counter[curr] > 0) {\\n                return curr;\\n            }\\n            curr--;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600589,
                "title": "java-solution-classic-implementation-of-map-priorityqueue",
                "content": "# In the priority queue sorting part, Character.compare(b,a) can be replaced by return b-a; which reduces the runtime \\n\\n```\\nclass pair{\\n    Character ele;\\n    int freq;\\n    pair(Character ele, int freq){\\n        this.ele = ele;\\n        this.freq = freq;\\n    }\\n}\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            return Character.compare(b.ele, a.ele);\\n        });\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Character, Integer> entry : map.entrySet()){\\n            pair p = new pair(entry.getKey(), entry.getValue());\\n            pq.offer(p);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair LexicographicallyLargest = pq.poll();\\n            int frequency = LexicographicallyLargest.freq;\\n            for(int i = 0;i<repeatLimit;i++){\\n                sb.append(LexicographicallyLargest.ele);\\n                LexicographicallyLargest.freq--;\\n                if(LexicographicallyLargest.freq == 0){\\n                    break;\\n                }\\n            }\\n            if(LexicographicallyLargest.freq > 0){\\n                if(!pq.isEmpty()){\\n                    pair LexicographicallySecondLargest = pq.poll();\\n                    sb.append(LexicographicallySecondLargest.ele);\\n                    LexicographicallySecondLargest.freq--;\\n                    if(LexicographicallySecondLargest.freq != 0){\\n                        pq.offer(LexicographicallySecondLargest);\\n                    }\\n                    pq.offer(LexicographicallyLargest);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    Character ele;\\n    int freq;\\n    pair(Character ele, int freq){\\n        this.ele = ele;\\n        this.freq = freq;\\n    }\\n}\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            return Character.compare(b.ele, a.ele);\\n        });\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Character, Integer> entry : map.entrySet()){\\n            pair p = new pair(entry.getKey(), entry.getValue());\\n            pq.offer(p);\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair LexicographicallyLargest = pq.poll();\\n            int frequency = LexicographicallyLargest.freq;\\n            for(int i = 0;i<repeatLimit;i++){\\n                sb.append(LexicographicallyLargest.ele);\\n                LexicographicallyLargest.freq--;\\n                if(LexicographicallyLargest.freq == 0){\\n                    break;\\n                }\\n            }\\n            if(LexicographicallyLargest.freq > 0){\\n                if(!pq.isEmpty()){\\n                    pair LexicographicallySecondLargest = pq.poll();\\n                    sb.append(LexicographicallySecondLargest.ele);\\n                    LexicographicallySecondLargest.freq--;\\n                    if(LexicographicallySecondLargest.freq != 0){\\n                        pq.offer(LexicographicallySecondLargest);\\n                    }\\n                    pq.offer(LexicographicallyLargest);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359278,
                "title": "c-simple-c-code-no-priority-queue-87-time-85-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> alphabet(26,0);\\n        int f = 0, n = s.size();\\n        string ans = \"\";\\n        for(char &ch : s){\\n            alphabet[ch-\\'a\\']++;\\n            //sum++;\\n        }\\n        while(f < n)\\n        {\\n            int x;\\n            for(int i = 25; i >= 0; i--)\\n            {\\n                if(!alphabet[i]) continue;\\n                x = i;\\n                break;\\n            }\\n            int mx = min(repeatLimit, alphabet[x]);\\n            for(int j = 0; j < mx; j++){\\n                ans += (\\'a\\'+ x);\\n                alphabet[x]--;\\n                f++;\\n            }\\n            if(alphabet[x] == 0 || f == n) continue;\\n            int y = x;\\n            for(int i = x-1; i >= 0; i--)\\n            {\\n                if(!alphabet[i]) continue;\\n                x = i;\\n                break;\\n            }\\n            if(y == x) return ans;\\n            ans += (\\'a\\' + x);\\n            alphabet[x]--;\\n            f++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> alphabet(26,0);\\n        int f = 0, n = s.size();\\n        string ans = \"\";\\n        for(char &ch : s){\\n            alphabet[ch-\\'a\\']++;\\n            //sum++;\\n        }\\n        while(f < n)\\n        {\\n            int x;\\n            for(int i = 25; i >= 0; i--)\\n            {\\n                if(!alphabet[i]) continue;\\n                x = i;\\n                break;\\n            }\\n            int mx = min(repeatLimit, alphabet[x]);\\n            for(int j = 0; j < mx; j++){\\n                ans += (\\'a\\'+ x);\\n                alphabet[x]--;\\n                f++;\\n            }\\n            if(alphabet[x] == 0 || f == n) continue;\\n            int y = x;\\n            for(int i = x-1; i >= 0; i--)\\n            {\\n                if(!alphabet[i]) continue;\\n                x = i;\\n                break;\\n            }\\n            if(y == x) return ans;\\n            ans += (\\'a\\' + x);\\n            alphabet[x]--;\\n            f++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793235,
                "title": "simple-implementation-using-priority-queue-t-c-o-n-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int freq[26] = {0};\\n        string ans = \"\";\\n\\t\\t\\n        for(auto c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        priority_queue<pair<char,int>>pq;\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq[i] > 0){\\n                pq.emplace((i+\\'a\\'),freq[i]);\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            \\n            auto [key,val] = pq.top();\\n            pq.pop();\\n            int count = val;\\n            \\n            for(int i=0;i<repeatLimit && count > 0 ; i++){\\n                ans += key;\\n                count--;\\n            }\\n            \\n            if(count > 0 && pq.size() > 0){\\n                auto [secondKey , secondVal] = pq.top();\\n                pq.pop();\\n                \\n                ans += secondKey;\\n                if(secondVal > 1){\\n                    pq.emplace(secondKey,secondVal-1);\\n                }\\n                pq.emplace(key,count);\\n            }      \\n        }    \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int freq[26] = {0};\\n        string ans = \"\";\\n\\t\\t\\n        for(auto c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        \\n        priority_queue<pair<char,int>>pq;\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq[i] > 0){\\n                pq.emplace((i+\\'a\\'),freq[i]);\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            \\n            auto [key,val] = pq.top();\\n            pq.pop();\\n            int count = val;\\n            \\n            for(int i=0;i<repeatLimit && count > 0 ; i++){\\n                ans += key;\\n                count--;\\n            }\\n            \\n            if(count > 0 && pq.size() > 0){\\n                auto [secondKey , secondVal] = pq.top();\\n                pq.pop();\\n                \\n                ans += secondKey;\\n                if(secondVal > 1){\\n                    pq.emplace(secondKey,secondVal-1);\\n                }\\n                pq.emplace(key,count);\\n            }      \\n        }    \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786864,
                "title": "priorityqueue-longest-happy-string",
                "content": "Found it quite close to `Longest Happy String`: https://leetcode.com/problems/longest-happy-string/\\n\\nFor solution and explanation for it, please see this (Thanks to @lechen999): https://leetcode.com/problems/longest-happy-string/discuss/564248/Python-HEAP-solution-with-explanation\\n\\nWe first count each char\\'s appearing times\\nThen use max heap to implement `Longest Happy String`.\\nHowever, please pay attention to \"the actual appearing time in stack\", which we\\'ll also need a map to record. Whenever found the prior char `x` exceeds the `repeatLimit` (I simplified it as `k`), we heappop a less appearing char `y` and append it to stack, and `times[y]` should be 1, and clear the `times[x]` because we have a new \"stack top\". The same for `x` not appearing exceeds `k`. \\n\\nHope it helps:\\n```\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def repeatLimitedString(self, string: str, k: int) -> str:\\n        \"\"\"\\n        look close to the problem:\\n            it\\'s  lexicographically largest \\n            not \"longest\"\\n        \"\"\"\\n        appear, times = defaultdict(), defaultdict()\\n        pq, stack = [], []\\n        for s in string:\\n            appear[s] = appear.get(s, 0) + 1\\n        \\n        for s in appear:\\n            pq.append((-ord(s), appear[s]))\\n        \\n        heapify(pq)\\n        appear.clear()\\n        \\n        while pq:\\n            char, num = heappop(pq)\\n            s = chr(-char)\\n            if s in times and times[s] == k: # if reach the repeatedLimit\\n                if not pq:\\n                    return \\'\\'.join(stack)\\n                char2, num2 = heappop(pq)\\n                token = chr(-char2)\\n                stack.append(token)\\n                if num2 - 1 > 0:\\n                    heappush(pq, (char2, num2 - 1))\\n                heappush(pq, (char, num))\\n                del times[s]\\n                times[token] = 1\\n                continue\\n            if stack and stack[-1] != s:\\n                # reset times\\n                del times[stack[-1]]\\n            stack.append(s)\\n            times[s] = times.get(s, 0) + 1\\n            \\n            if num - 1 > 0:\\n                heappush(pq, (char, num - 1))\\n        return \\'\\'.join(stack) \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def repeatLimitedString(self, string: str, k: int) -> str:\\n        \"\"\"\\n        look close to the problem:\\n            it\\'s  lexicographically largest \\n            not \"longest\"\\n        \"\"\"\\n        appear, times = defaultdict(), defaultdict()\\n        pq, stack = [], []\\n        for s in string:\\n            appear[s] = appear.get(s, 0) + 1\\n        \\n        for s in appear:\\n            pq.append((-ord(s), appear[s]))\\n        \\n        heapify(pq)\\n        appear.clear()\\n        \\n        while pq:\\n            char, num = heappop(pq)\\n            s = chr(-char)\\n            if s in times and times[s] == k: # if reach the repeatedLimit\\n                if not pq:\\n                    return \\'\\'.join(stack)\\n                char2, num2 = heappop(pq)\\n                token = chr(-char2)\\n                stack.append(token)\\n                if num2 - 1 > 0:\\n                    heappush(pq, (char2, num2 - 1))\\n                heappush(pq, (char, num))\\n                del times[s]\\n                times[token] = 1\\n                continue\\n            if stack and stack[-1] != s:\\n                # reset times\\n                del times[stack[-1]]\\n            stack.append(s)\\n            times[s] = times.get(s, 0) + 1\\n            \\n            if num - 1 > 0:\\n                heappush(pq, (char, num - 1))\\n        return \\'\\'.join(stack) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784794,
                "title": "greedy-python-solution-100-runtime",
                "content": "Upvote if you find this article helpful\\u2B06\\uFE0F.\\n### STEPS:\\n1. Basically we make a sorted table with freq of each character.\\n2. Then we take the most lexicographically superior character (Call it A).\\n3. If its freq is in limits, directly add it.\\n4. If its freq is more than the limit. Add repeatLimit number of A\\'s and then search for the next lexicographically superior character(Call it TEMP) and add it just once, as we will again add the remaining A\\'s.\\n5. Repeat this process until either all A\\'s are consumed or we run out of TEMP characters.\\n6. Repeat all these steps for all other remaining characters in lexicographic order.\\n\\n**NOTE: Here we make the Greedy choice of choosing a lexicographically superior character at each step, while selecting A and also while selecting TEMP.**\\n**NOTE: I have not removed characters if a characters freq becomes 0. This is because random pop() operations in the middle of a list takes O(n) time. For pop() operations in default index(End of list) is O(1). Refer to this article \\u27A1\\uFE0F [Time Complexity of Python Library Functinons](https://wiki.python.org/moin/TimeComplexity)** \\n\\n### STATUS:\\n![image](https://assets.leetcode.com/users/images/e113bb3f-5f5a-40a4-92ff-a0049a454b4b_1645331843.2130945.png)\\n\\n### CODE:\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        table = Counter(s)\\n        char_set = [\\'0\\', \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\',\\n                    \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n        sorted_table = []\\n        for i in range(26,-1,-1):\\n            if char_set[i] in table:\\n                sorted_table.append((char_set[i],table[char_set[i]]))\\n\\n        result = \"\"\\n        n = len(sorted_table)\\n        for i in range(n):\\n            char, curr_freq = sorted_table[i] # The lexicographically larger character and its frequency\\n            index_to_take_from = i + 1 # We take from this index the next lexicographically larger character(TEMP) if the repeatLimit for A is exceeded\\n            while curr_freq > repeatLimit: # Limit exceeded\\n                result += char*repeatLimit # Add repeatLimit number of character A\\'s\\n                curr_freq -= repeatLimit # Decrease frequency of character A\\n                # Now we search for the next lexicographically superior character that can be used once\\n                while index_to_take_from < n: # Till we run out of characters\\n                    ch_avail, freq_avail = sorted_table[index_to_take_from]\\n                    if freq_avail == 0: # If its freq is 0 that means that it was previously used. This is done as we are not removing the character from table if its freq becomes 0. \\n                        index_to_take_from += 1 # Check for next lexicographically superior character\\n                    else:\\n                        result += ch_avail # If found then add that character \\n                        sorted_table[index_to_take_from] = (ch_avail,freq_avail-1) # Update the new characters frequency\\n                        break\\n                else:\\n                    break # We cannot find any lexicographically superior character\\n            else:\\n                result += char*curr_freq # If the freq is in limits then just add them\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        table = Counter(s)\\n        char_set = [\\'0\\', \\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\', \\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\', \\'p\\', \\'q\\', \\'r\\', \\'s\\',\\n                    \\'t\\', \\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\', \\'z\\']\\n        sorted_table = []\\n        for i in range(26,-1,-1):\\n            if char_set[i] in table:\\n                sorted_table.append((char_set[i],table[char_set[i]]))\\n\\n        result = \"\"\\n        n = len(sorted_table)\\n        for i in range(n):\\n            char, curr_freq = sorted_table[i] # The lexicographically larger character and its frequency\\n            index_to_take_from = i + 1 # We take from this index the next lexicographically larger character(TEMP) if the repeatLimit for A is exceeded\\n            while curr_freq > repeatLimit: # Limit exceeded\\n                result += char*repeatLimit # Add repeatLimit number of character A\\'s\\n                curr_freq -= repeatLimit # Decrease frequency of character A\\n                # Now we search for the next lexicographically superior character that can be used once\\n                while index_to_take_from < n: # Till we run out of characters\\n                    ch_avail, freq_avail = sorted_table[index_to_take_from]\\n                    if freq_avail == 0: # If its freq is 0 that means that it was previously used. This is done as we are not removing the character from table if its freq becomes 0. \\n                        index_to_take_from += 1 # Check for next lexicographically superior character\\n                    else:\\n                        result += ch_avail # If found then add that character \\n                        sorted_table[index_to_take_from] = (ch_avail,freq_avail-1) # Update the new characters frequency\\n                        break\\n                else:\\n                    break # We cannot find any lexicographically superior character\\n            else:\\n                result += char*curr_freq # If the freq is in limits then just add them\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784793,
                "title": "greedy-priority-queue-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) \\n    {\\n        int n=s.size(),i;\\n        priority_queue <pair<char,int>> q;\\n        vector <int> a(26);\\n        for(auto x : s)\\n        {\\n            a[x-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)\\n        {\\n            if(a[i]>0)\\n            {\\n                q.push({i+\\'a\\',a[i]});\\n            }\\n        }\\n        string ans=\"\";\\n        while(!q.empty())\\n        {\\n            auto f=q.top();\\n            q.pop();\\n            if(f.second>k)\\n            {\\n                for(i=0;i<k;i++)\\n                {\\n                    ans.push_back(f.first);\\n                }\\n                f.second-=k;\\n                if(!q.empty())\\n                {\\n                    auto sec=q.top();\\n                    q.pop();\\n                    sec.second--;\\n                    ans.push_back(sec.first);\\n                    if(sec.second>0)\\n                    {\\n                        q.push({sec.first,sec.second});\\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                q.push({f.first,f.second});\\n            }\\n            else\\n            {\\n                for(i=0;i<f.second;i++)\\n                {\\n                    ans.push_back(f.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) \\n    {\\n        int n=s.size(),i;\\n        priority_queue <pair<char,int>> q;\\n        vector <int> a(26);\\n        for(auto x : s)\\n        {\\n            a[x-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)\\n        {\\n            if(a[i]>0)\\n            {\\n                q.push({i+\\'a\\',a[i]});\\n            }\\n        }\\n        string ans=\"\";\\n        while(!q.empty())\\n        {\\n            auto f=q.top();\\n            q.pop();\\n            if(f.second>k)\\n            {\\n                for(i=0;i<k;i++)\\n                {\\n                    ans.push_back(f.first);\\n                }\\n                f.second-=k;\\n                if(!q.empty())\\n                {\\n                    auto sec=q.top();\\n                    q.pop();\\n                    sec.second--;\\n                    ans.push_back(sec.first);\\n                    if(sec.second>0)\\n                    {\\n                        q.push({sec.first,sec.second});\\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                q.push({f.first,f.second});\\n            }\\n            else\\n            {\\n                for(i=0;i<f.second;i++)\\n                {\\n                    ans.push_back(f.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942213,
                "title": "java-priority-queue-hash-map-implementation",
                "content": "```\\nclass Element {\\n    char letter;\\n    int frequency;\\n    Element(char letter, int frequency) {\\n        this.letter = letter;\\n        this.frequency = frequency;\\n    }\\n}\\n\\nclass ElementComparator implements Comparator<Element> {\\n    @Override\\n    public int compare(Element e1, Element e2) {\\n        return Character.compare(e2.letter, e1.letter);\\n    }\\n}\\n\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<Element> maxHeap = new PriorityQueue<>(new ElementComparator());\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(char letter: s.toCharArray()) {\\n           freqMap.put(letter, freqMap.getOrDefault(letter, 0) + 1); \\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap.entrySet()) {\\n            maxHeap.offer(new Element(entry.getKey(), entry.getValue()));\\n        }\\n        StringBuilder answer = new StringBuilder();\\n        while(!maxHeap.isEmpty()) {\\n            Element element = maxHeap.poll();\\n            for(int i=0;i<repeatLimit;i++) {\\n                answer.append(element.letter);\\n                element.frequency--;\\n                if(element.frequency == 0) {\\n                    break;\\n                }\\n            }\\n            if(element.frequency != 0) {\\n                if(!maxHeap.isEmpty()) {\\n                    Element next = maxHeap.poll();\\n                    answer.append(next.letter);\\n                    next.frequency--;\\n                    if(next.frequency != 0) {\\n                        maxHeap.offer(next);\\n                    }\\n                    maxHeap.offer(element);\\n                }\\n            }\\n        }\\n        return answer.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Element {\\n    char letter;\\n    int frequency;\\n    Element(char letter, int frequency) {\\n        this.letter = letter;\\n        this.frequency = frequency;\\n    }\\n}\\n\\nclass ElementComparator implements Comparator<Element> {\\n    @Override\\n    public int compare(Element e1, Element e2) {\\n        return Character.compare(e2.letter, e1.letter);\\n    }\\n}\\n\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<Element> maxHeap = new PriorityQueue<>(new ElementComparator());\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(char letter: s.toCharArray()) {\\n           freqMap.put(letter, freqMap.getOrDefault(letter, 0) + 1); \\n        }\\n        for(Map.Entry<Character, Integer> entry: freqMap.entrySet()) {\\n            maxHeap.offer(new Element(entry.getKey(), entry.getValue()));\\n        }\\n        StringBuilder answer = new StringBuilder();\\n        while(!maxHeap.isEmpty()) {\\n            Element element = maxHeap.poll();\\n            for(int i=0;i<repeatLimit;i++) {\\n                answer.append(element.letter);\\n                element.frequency--;\\n                if(element.frequency == 0) {\\n                    break;\\n                }\\n            }\\n            if(element.frequency != 0) {\\n                if(!maxHeap.isEmpty()) {\\n                    Element next = maxHeap.poll();\\n                    answer.append(next.letter);\\n                    next.frequency--;\\n                    if(next.frequency != 0) {\\n                        maxHeap.offer(next);\\n                    }\\n                    maxHeap.offer(element);\\n                }\\n            }\\n        }\\n        return answer.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889344,
                "title": "simple-java-solution-with-o-n-time-complexity",
                "content": "Bullets boints to make this question super easily\\n\\n* Construct a string which contains all the alphabet from a to z and also a integer array of length 26.\\n* count repeatation of each character and stored in integer arrat.\\n* Now loop over integer array in reverse order and apply following codition.\\n* if repeated char is less then equal to repeatLimit then directly add it in to answer string,\\n* else first add character to answer at most repeatLimit and then loop over them till that character value becomes zero.\\n```class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        int []arr = new int[26];\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]<=repeatLimit){\\n                String a = Character.toString(alphabet.charAt(i));\\n                str.append(a.repeat(arr[i]));\\n            }else{\\n                String a = Character.toString(alphabet.charAt(i));\\n                str.append(a.repeat(repeatLimit));\\n                arr[i]-=repeatLimit;\\n                int j = i-1;\\n                while(arr[i]>0&&j>=0){\\n                    if(arr[j]>0){\\n                        str.append(alphabet.charAt(j));\\n                        arr[j]--;\\n                        str.append(a.repeat(Math.min(repeatLimit, arr[i])));\\n                        arr[i]-=Math.min(repeatLimit, arr[i]);\\n                    }\\n                    if(arr[j]==0)\\n                        j--;\\n                }\\n                i=j+1;\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n        int []arr = new int[26];\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]<=repeatLimit){\\n                String a = Character.toString(alphabet.charAt(i));\\n                str.append(a.repeat(arr[i]));\\n            }else{\\n                String a = Character.toString(alphabet.charAt(i));\\n                str.append(a.repeat(repeatLimit));\\n                arr[i]-=repeatLimit;\\n                int j = i-1;\\n                while(arr[i]>0&&j>=0){\\n                    if(arr[j]>0){\\n                        str.append(alphabet.charAt(j));\\n                        arr[j]--;\\n                        str.append(a.repeat(Math.min(repeatLimit, arr[i])));\\n                        arr[i]-=Math.min(repeatLimit, arr[i]);\\n                    }\\n                    if(arr[j]==0)\\n                        j--;\\n                }\\n                i=j+1;\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797372,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int cnt[26] = {0};\\n        \\n        for (auto c : s) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        \\n        string ans;\\n        int prevsize = -1;\\n        \\n        int k = 0;\\n        while (ans.size() < s.size()) {            \\n            for (int i = 25; i >= 0; --i) {\\n                \\n                if (cnt[i] == 0) {\\n                    continue;\\n                }\\n                \\n                if ((i + \\'a\\') == ans.back() && k == repeatLimit) {\\n                    continue;\\n                }\\n                \\n                k = (i + \\'a\\') == ans.back() ? k + 1 : 1;\\n                \\n                ans.push_back((i + \\'a\\'));\\n                --cnt[i];\\n                break;\\n            }\\n            \\n            if (prevsize == ans.size()) {\\n                break;\\n            }\\n            \\n            prevsize = ans.size();\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int cnt[26] = {0};\\n        \\n        for (auto c : s) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        \\n        string ans;\\n        int prevsize = -1;\\n        \\n        int k = 0;\\n        while (ans.size() < s.size()) {            \\n            for (int i = 25; i >= 0; --i) {\\n                \\n                if (cnt[i] == 0) {\\n                    continue;\\n                }\\n                \\n                if ((i + \\'a\\') == ans.back() && k == repeatLimit) {\\n                    continue;\\n                }\\n                \\n                k = (i + \\'a\\') == ans.back() ? k + 1 : 1;\\n                \\n                ans.push_back((i + \\'a\\'));\\n                --cnt[i];\\n                break;\\n            }\\n            \\n            if (prevsize == ans.size()) {\\n                break;\\n            }\\n            \\n            prevsize = ans.size();\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786238,
                "title": "java-easy-to-understand-priorityqueue-solution",
                "content": "1. Add all the characters to a PriorityQueue which sorts in reverse order.\\n2. Remove all the elements in the queue and add them to a String if they are occuring less then the limit\\n3. Else push them to another PriorityQueue  and add them if there is a new character to go before this.\\n\\nUpvote if you like the solution.\\n\\n```\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        PriorityQueue<Character> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        PriorityQueue<Character> extra = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(char c : s.toCharArray()){\\n            q.add(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\n        char prev = q.poll();\\n        sb.append(prev);\\n        int count = 1;\\n\\n        while(!q.isEmpty()){\\n            char c =  q.poll();\\n            if(prev == c && count < repeatLimit) {\\n                sb.append(c);\\n                count++;\\n            } else if (prev == c ) {\\n                extra.add(c);\\n            } else {\\n                if (!extra.isEmpty() && extra.peek() > c){\\n                    sb.append(c);\\n                    int popCount =0;\\n                    while (!extra.isEmpty() && extra.peek() > c && popCount < repeatLimit) {\\n                        q.add(extra.poll());\\n                        popCount++;\\n                    }\\n                } else {\\n                    sb.append(c);\\n                }\\n                prev = c;\\n                count=1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        PriorityQueue<Character> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        PriorityQueue<Character> extra = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(char c : s.toCharArray()){\\n            q.add(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\n        char prev = q.poll();\\n        sb.append(prev);\\n        int count = 1;\\n\\n        while(!q.isEmpty()){\\n            char c =  q.poll();\\n            if(prev == c && count < repeatLimit) {\\n                sb.append(c);\\n                count++;\\n            } else if (prev == c ) {\\n                extra.add(c);\\n            } else {\\n                if (!extra.isEmpty() && extra.peek() > c){\\n                    sb.append(c);\\n                    int popCount =0;\\n                    while (!extra.isEmpty() && extra.peek() > c && popCount < repeatLimit) {\\n                        q.add(extra.poll());\\n                        popCount++;\\n                    }\\n                } else {\\n                    sb.append(c);\\n                }\\n                prev = c;\\n                count=1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785175,
                "title": "c-easy-solution",
                "content": "```\\n#define deb(x) cout << #x << \" = \" << x << endl\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rL) {\\n        map<char,int> m ;\\n        for (int i =0;i<26;i++)m[i+\\'a\\']=0;\\n        for (int i = 0 ;i <s.length();i++)\\n            m[s[i]]++;\\n        string res = \"\";\\n        priority_queue <pair<int,int>>pq ;\\n        for(int i =0 ;i<26;i++) if(m[i+\\'a\\'])pq.push({i+\\'a\\',m[i+\\'a\\']});\\n        while(!pq.empty()){\\n            char c = pq.top().first;\\n            int x = pq.top().second;\\n            pq.pop();\\n            int leftOvers = x-rL;\\n            // deb(c);\\n            // deb(x);\\n            if(leftOvers<=0){\\n                if(res.length()){\\n                    if(res[res.length()-1]==c) continue;\\n                }\\n                while(x){\\n                    res+=c;\\n                    x--;\\n                }\\n            }else{\\n                while(x!=leftOvers){\\n                    res+=c;\\n                    x--;\\n                }\\n                if(pq.empty()) return res;\\n                char ctemp = pq.top().first;\\n                int xtemp = pq.top().second;\\n                pq.pop();\\n                res+=ctemp;\\n                xtemp--;\\n                pq.push({c,leftOvers});\\n                if(xtemp) pq.push({ctemp,xtemp});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define deb(x) cout << #x << \" = \" << x << endl\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rL) {\\n        map<char,int> m ;\\n        for (int i =0;i<26;i++)m[i+\\'a\\']=0;\\n        for (int i = 0 ;i <s.length();i++)\\n            m[s[i]]++;\\n        string res = \"\";\\n        priority_queue <pair<int,int>>pq ;\\n        for(int i =0 ;i<26;i++) if(m[i+\\'a\\'])pq.push({i+\\'a\\',m[i+\\'a\\']});\\n        while(!pq.empty()){\\n            char c = pq.top().first;\\n            int x = pq.top().second;\\n            pq.pop();\\n            int leftOvers = x-rL;\\n            // deb(c);\\n            // deb(x);\\n            if(leftOvers<=0){\\n                if(res.length()){\\n                    if(res[res.length()-1]==c) continue;\\n                }\\n                while(x){\\n                    res+=c;\\n                    x--;\\n                }\\n            }else{\\n                while(x!=leftOvers){\\n                    res+=c;\\n                    x--;\\n                }\\n                if(pq.empty()) return res;\\n                char ctemp = pq.top().first;\\n                int xtemp = pq.top().second;\\n                pq.pop();\\n                res+=ctemp;\\n                xtemp--;\\n                pq.push({c,leftOvers});\\n                if(xtemp) pq.push({ctemp,xtemp});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1785095,
                "title": "c-easy-thinking-and-approach",
                "content": "\\n* Count all characters in 26 buckets (\\'a\\' to \\'z\\').\\n* While we have characters left:\\n\\t* \\tFind the largest bucket i with characters.\\n\\t* \\tPick up to limit characters from that bucket.\\n\\t* \\tFind the second largest bucket j with characters.\\n\\t* \\tPick 1 character from the next largest bucket.\\n\\n\\n```\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    #define debug2(x,y) cout<<#x<<\":\"<<x<<\"|\"<<#y<<\":\"<<y<<endl;\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int arr[26] = {0};\\n        for(auto& val:s){\\n            arr[val-\\'a\\']++;\\n        }\\n        \\n        // cout<<\"[\"<<\" \";\\n        // for(int i = 0;i<=25;i++){\\n        //     debug((char)(i+\\'a\\'),arr[i]);\\n        // }\\n        // cout<<\"]\"<<endl;\\n        \\n        string str = \"\";\\n        int idx = 25;\\n        \\n        while(idx >= 0){\\n            //debug(idx);\\n            int rp = repeatLimit;\\n            while(arr[idx] != 0 && rp){\\n                str += (idx + \\'a\\');\\n                //debug2(idx,str);\\n                arr[idx]--;\\n                //debug2(idx,arr[idx]);\\n                rp--;\\n            }\\n            if(arr[idx] == 0){\\n                idx--;\\n                continue;\\n            }\\n            if(arr[idx] != 0){\\n                if(idx != 0){\\n                    int j = idx-1;\\n                    //debug2(j,arr[j]);\\n                    while(j >= 0 && arr[j] == 0) j--;\\n                    //debug2(j,arr[j]);\\n                    if(j < 0) break;\\n                    str += (j+\\'a\\');\\n                    arr[j]--;\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    #define debug2(x,y) cout<<#x<<\":\"<<x<<\"|\"<<#y<<\":\"<<y<<endl;\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int arr[26] = {0};\\n        for(auto& val:s){\\n            arr[val-\\'a\\']++;\\n        }\\n        \\n        // cout<<\"[\"<<\" \";\\n        // for(int i = 0;i<=25;i++){\\n        //     debug((char)(i+\\'a\\'),arr[i]);\\n        // }\\n        // cout<<\"]\"<<endl;\\n        \\n        string str = \"\";\\n        int idx = 25;\\n        \\n        while(idx >= 0){\\n            //debug(idx);\\n            int rp = repeatLimit;\\n            while(arr[idx] != 0 && rp){\\n                str += (idx + \\'a\\');\\n                //debug2(idx,str);\\n                arr[idx]--;\\n                //debug2(idx,arr[idx]);\\n                rp--;\\n            }\\n            if(arr[idx] == 0){\\n                idx--;\\n                continue;\\n            }\\n            if(arr[idx] != 0){\\n                if(idx != 0){\\n                    int j = idx-1;\\n                    //debug2(j,arr[j]);\\n                    while(j >= 0 && arr[j] == 0) j--;\\n                    //debug2(j,arr[j]);\\n                    if(j < 0) break;\\n                    str += (j+\\'a\\');\\n                    arr[j]--;\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1784756,
                "title": "c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n        int limit = rl;\\n        int n= s.size();\\n        sort(s.begin(), s.end());\\n        reverse(s.begin(), s.end());\\n        //construction of p\\n        string p; \\n        p.push_back(s[0]);\\n        int size = 1;\\n        unordered_map<char, int> map;\\n        for(int i = 0; i<n; i++){\\n            map[s[i]]++;\\n            if(s[i]!= p[size-1]){\\n                size++;\\n                p.push_back(s[i]);\\n            }\\n        }\\n        //for(int i = 0; i<size; i++) cout<<p[i]<<\" - \"<<map[p[i]]<<endl;\\n        \\n        string res;\\n        if(size == 1){\\n            for(int i = 0; i< min(limit, map[p[0]]); i++) res.push_back(p[0]);\\n            return res;\\n        }\\n        int curr = 0;\\n        int next = 1;\\n        while(next < size){\\n            if(!map[p[curr]]) {\\n                curr = next;\\n                next++;\\n                continue;\\n            }\\n            //limit >= fre\\n            if(limit >= map[p[curr]] and map[p[curr]]){\\n                //push those\\n                for(int i=0; i<map[p[curr]]; i++) res.push_back(p[curr]);\\n                map[p[curr]] = 0;\\n                curr = next;\\n                next++;\\n                //limit = rl; //reseting it to rl\\n                continue;\\n            }\\n            //limit < fre\\n            for(int i = 0; i<limit; i++){\\n                //push limit times\\n                res.push_back(p[curr]);\\n            }\\n            map[p[curr]]-= limit;\\n            if(map[p[next]]){\\n                res.push_back(p[next]);\\n                map[p[next]]--;\\n            }\\n            else {\\n                next++;\\n                if(next == size) break;\\n                res.push_back(p[next]);\\n                map[p[next]]--;\\n            }\\n        }\\n        if(curr<size and map[p[curr]] and p[curr] != res[res.size()-1]){\\n            for(int i = 0; i< min(limit, map[p[curr]]); i++) res.push_back(p[curr]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n        int limit = rl;\\n        int n= s.size();\\n        sort(s.begin(), s.end());\\n        reverse(s.begin(), s.end());\\n        //construction of p\\n        string p; \\n        p.push_back(s[0]);\\n        int size = 1;\\n        unordered_map<char, int> map;\\n        for(int i = 0; i<n; i++){\\n            map[s[i]]++;\\n            if(s[i]!= p[size-1]){\\n                size++;\\n                p.push_back(s[i]);\\n            }\\n        }\\n        //for(int i = 0; i<size; i++) cout<<p[i]<<\" - \"<<map[p[i]]<<endl;\\n        \\n        string res;\\n        if(size == 1){\\n            for(int i = 0; i< min(limit, map[p[0]]); i++) res.push_back(p[0]);\\n            return res;\\n        }\\n        int curr = 0;\\n        int next = 1;\\n        while(next < size){\\n            if(!map[p[curr]]) {\\n                curr = next;\\n                next++;\\n                continue;\\n            }\\n            //limit >= fre\\n            if(limit >= map[p[curr]] and map[p[curr]]){\\n                //push those\\n                for(int i=0; i<map[p[curr]]; i++) res.push_back(p[curr]);\\n                map[p[curr]] = 0;\\n                curr = next;\\n                next++;\\n                //limit = rl; //reseting it to rl\\n                continue;\\n            }\\n            //limit < fre\\n            for(int i = 0; i<limit; i++){\\n                //push limit times\\n                res.push_back(p[curr]);\\n            }\\n            map[p[curr]]-= limit;\\n            if(map[p[next]]){\\n                res.push_back(p[next]);\\n                map[p[next]]--;\\n            }\\n            else {\\n                next++;\\n                if(next == size) break;\\n                res.push_back(p[next]);\\n                map[p[next]]--;\\n            }\\n        }\\n        if(curr<size and map[p[curr]] and p[curr] != res[res.size()-1]){\\n            for(int i = 0; i< min(limit, map[p[curr]]); i++) res.push_back(p[curr]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3279670,
                "title": "max-heap-easy-to-understand-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//actual code begins here\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) \\n    {\\n         //final constructed string to be returned from this function\\n         string ans = \"\";\\n\\n         //first of all we will take the mapping of the char from string\\n         unordered_map<char,int>mp;\\n\\n         //taking the mapping of the every char to keep that in heap\\n         for(int i=0;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             mp[ch]++;\\n         }\\n\\n         //priority queue for keeping the large char on the top\\n         priority_queue<pair<char,int>>pq;\\n\\n         for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n         {\\n              char ch = it->first;\\n              int freq = it->second;     \\n              pq.push(make_pair(ch,freq));\\n         }\\n         //building the string according to the given constraint\\n         while(!pq.empty())\\n         {\\n             pair<char,int>p1 = pq.top();\\n             pq.pop();\\n             char ele1 = p1.first;\\n             int freq1 = p1.second;\\n\\n             if(freq1 < k)\\n             {\\n                 //appending ch1 freq1 times to the current answer\\n                 while(freq1 > 0)\\n                 {\\n                     ans.push_back(ele1);\\n                     freq1--;\\n                 }\\n             }\\n             else if(freq1 == k)\\n             {\\n                 //appending ch1 freq1 times to the current answer\\n                 while(freq1 > 0)\\n                 {\\n                     ans.push_back(ele1);\\n                     freq1--;\\n                 }\\n             }\\n             else if(freq1 > k)\\n             {\\n                  //appending ch1 freq1 times to the current answer\\n                  int temp = k;\\n                  while(temp > 0)\\n                  {\\n                     ans.push_back(ele1);\\n                     temp--;\\n                  }\\n                  freq1 = freq1 - k;\\n                  \\n                  //breaking the streak of the k characters\\n                  \\n                  //if we do not have any one to break the freq of the curr char then break\\n                  if(pq.size() == 0)\\n                  break;\\n\\n                  //else we have someone that can break the freq of the curr char\\n                  pair<char,int>p2 = pq.top();\\n                  pq.pop();\\n                  char ele2 = p2.first;\\n                  int freq2 = p2.second;\\n                  \\n                  if(freq2 > 0)\\n                  {\\n                      ans.push_back(ele2);\\n                      freq2--;\\n                      \\n                      if(freq2 > 0)\\n                      pq.push(make_pair(ele2,freq2));\\n                  }\\n                  if(freq1 > 0)\\n                  pq.push(make_pair(ele1,freq1));\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//actual code begins here\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) \\n    {\\n         //final constructed string to be returned from this function\\n         string ans = \"\";\\n\\n         //first of all we will take the mapping of the char from string\\n         unordered_map<char,int>mp;\\n\\n         //taking the mapping of the every char to keep that in heap\\n         for(int i=0;i<s.length();i++)\\n         {\\n             char ch = s[i];\\n             mp[ch]++;\\n         }\\n\\n         //priority queue for keeping the large char on the top\\n         priority_queue<pair<char,int>>pq;\\n\\n         for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n         {\\n              char ch = it->first;\\n              int freq = it->second;     \\n              pq.push(make_pair(ch,freq));\\n         }\\n         //building the string according to the given constraint\\n         while(!pq.empty())\\n         {\\n             pair<char,int>p1 = pq.top();\\n             pq.pop();\\n             char ele1 = p1.first;\\n             int freq1 = p1.second;\\n\\n             if(freq1 < k)\\n             {\\n                 //appending ch1 freq1 times to the current answer\\n                 while(freq1 > 0)\\n                 {\\n                     ans.push_back(ele1);\\n                     freq1--;\\n                 }\\n             }\\n             else if(freq1 == k)\\n             {\\n                 //appending ch1 freq1 times to the current answer\\n                 while(freq1 > 0)\\n                 {\\n                     ans.push_back(ele1);\\n                     freq1--;\\n                 }\\n             }\\n             else if(freq1 > k)\\n             {\\n                  //appending ch1 freq1 times to the current answer\\n                  int temp = k;\\n                  while(temp > 0)\\n                  {\\n                     ans.push_back(ele1);\\n                     temp--;\\n                  }\\n                  freq1 = freq1 - k;\\n                  \\n                  //breaking the streak of the k characters\\n                  \\n                  //if we do not have any one to break the freq of the curr char then break\\n                  if(pq.size() == 0)\\n                  break;\\n\\n                  //else we have someone that can break the freq of the curr char\\n                  pair<char,int>p2 = pq.top();\\n                  pq.pop();\\n                  char ele2 = p2.first;\\n                  int freq2 = p2.second;\\n                  \\n                  if(freq2 > 0)\\n                  {\\n                      ans.push_back(ele2);\\n                      freq2--;\\n                      \\n                      if(freq2 > 0)\\n                      pq.push(make_pair(ele2,freq2));\\n                  }\\n                  if(freq1 > 0)\\n                  pq.push(make_pair(ele1,freq1));\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3223476,
                "title": "using-priority-queue-faster-100",
                "content": "# Approach\\nWe count every character and use\\npriority queue to achieve lexicographical order\\n```\\nE.g zzzzccca, repeatLimit=3\\n0) we build a queue: [z:4, c:3, a:1]\\n1) Start iterating a queue, on every iteration we\\n  2) dequeue {z:4} \\n  3) generate \"zzz\" (now we left with {z:1})\\n  4) pick next element in a queue {c:3}, generate ONE \"c\", now we left with {c:2}\\n  5) push {z:1} back to the queue, repeat from 2\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar repeatLimitedString = function (s, repeatLimit) {\\n  const freq = {}, \\n  //https://github.com/datastructures-js/priority-queue\\n  queue = new MaxPriorityQueue(), result=[];\\n  for(let c of s) freq[c]=freq[c]?freq[c]+1:1;\\n  for(let [k,v] of Object.entries(freq))\\n    queue.enqueue({l:k, c:v}, k.charCodeAt(0)-97);\\n  \\n  while(!queue.isEmpty()){\\n    const {element:top, priority:prior} = queue.dequeue();\\n    for(let i=0; i<repeatLimit && top.c>0;i++, top.c--)\\n      result.push(top.l);\\n\\n    if(top.c>0){\\n      if(!queue.isEmpty()){\\n        const f = queue.front().element;\\n        result.push(f.l);\\n        f.c--;\\n        if(f.c===0) queue.dequeue();\\n        queue.enqueue(top, prior);\\n      }\\n    }\\n  }\\n  return result.join(\"\");\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nE.g zzzzccca, repeatLimit=3\\n0) we build a queue: [z:4, c:3, a:1]\\n1) Start iterating a queue, on every iteration we\\n  2) dequeue {z:4} \\n  3) generate \"zzz\" (now we left with {z:1})\\n  4) pick next element in a queue {c:3}, generate ONE \"c\", now we left with {c:2}\\n  5) push {z:1} back to the queue, repeat from 2\\n```\n```\\nvar repeatLimitedString = function (s, repeatLimit) {\\n  const freq = {}, \\n  //https://github.com/datastructures-js/priority-queue\\n  queue = new MaxPriorityQueue(), result=[];\\n  for(let c of s) freq[c]=freq[c]?freq[c]+1:1;\\n  for(let [k,v] of Object.entries(freq))\\n    queue.enqueue({l:k, c:v}, k.charCodeAt(0)-97);\\n  \\n  while(!queue.isEmpty()){\\n    const {element:top, priority:prior} = queue.dequeue();\\n    for(let i=0; i<repeatLimit && top.c>0;i++, top.c--)\\n      result.push(top.l);\\n\\n    if(top.c>0){\\n      if(!queue.isEmpty()){\\n        const f = queue.front().element;\\n        result.push(f.l);\\n        f.c--;\\n        if(f.c===0) queue.dequeue();\\n        queue.enqueue(top, prior);\\n      }\\n    }\\n  }\\n  return result.join(\"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207310,
                "title": "c-faster-and-less-memory-than-90-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        1. construct a map\\n        2. then build a string using largest char first, with in repeatlimit.\\n        3. if reach limit, insert a second largest char and continue try using largest char\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        // construct a map\\n        vector<int> map(26,0);\\n        for (char c : s)\\n            map[c-\\'a\\']++;\\n\\n        // then build a string using largest char first, with in repeatlimit.\\n        // if reach limit, insert a second largest char and continue try using largest char\\n        string res;        \\n        for(int i = 25; i>=0; i--)\\n        {\\n            while (map[i] > 0)\\n            {\\n                for (int k = 0; k < min(map[i], repeatLimit); k++)\\n                    res+= \\'a\\'+i; \\n                \\n                bool con = false;\\n                map[i]-=min(map[i], repeatLimit);\\n                if (map[i] > 0)\\n                {\\n                    for (int j = i-1; j>=0; j--)\\n                    {\\n                        if(map[j] > 0)\\n                        {\\n                            res += \\'a\\'+j;\\n                            map[j] --;\\n                            con = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (!con)\\n                    break;\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        // construct a map\\n        vector<int> map(26,0);\\n        for (char c : s)\\n            map[c-\\'a\\']++;\\n\\n        // then build a string using largest char first, with in repeatlimit.\\n        // if reach limit, insert a second largest char and continue try using largest char\\n        string res;        \\n        for(int i = 25; i>=0; i--)\\n        {\\n            while (map[i] > 0)\\n            {\\n                for (int k = 0; k < min(map[i], repeatLimit); k++)\\n                    res+= \\'a\\'+i; \\n                \\n                bool con = false;\\n                map[i]-=min(map[i], repeatLimit);\\n                if (map[i] > 0)\\n                {\\n                    for (int j = i-1; j>=0; j--)\\n                    {\\n                        if(map[j] > 0)\\n                        {\\n                            res += \\'a\\'+j;\\n                            map[j] --;\\n                            con = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (!con)\\n                    break;\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042781,
                "title": "java-o-n-no-map-or-queue-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a frequency count array for all letters in the input string. Iterate over the frequency count array from the count of `z` to `a`. Skip the letters for which the count is `0`. Append one letter at a time to the output string till the frequency count of the letter becomes `0` or the repeat limit is reached. If the repeat limit is reached, remember the letter\\'s index, move on to the next lexicographically largest letter and append a single instance of that, then move back to the remembered letter and continue the procees as normal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build a frequency count array for all letters in the input string `s`.\\n2. Iterate through the frequency count array from the index of `z` to `a`.\\n3. Skip any letter for which the frequency is `0`.\\n4. Append one instance of the letter at a time to the output string till the frequency of the letter becomes `0` or the repeat limit is reached.\\n5. If the repeat limit is reached and the frequency of the letter is > 0, remember the letter\\'s index and move on to the next iteration.\\n6. In each iteration, check if there\\'s a remembered letter. If yes, append a single instance of the current letter to the output string and skip back to the remembered letter\\'s index. Then continue the process as normal.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String repeatLimitedString(String s, int repeatLimit) {\\n    int[] freq = new int[26];\\n\\n    for (char c : s.toCharArray())\\n      freq[c - \\'a\\']++;\\n\\n    int pendingLetterIndex = -1;\\n    StringBuilder sb = new StringBuilder();\\n\\n    for (int i=25; i >= 0; i--) {\\n      if (freq[i] == 0)\\n        continue;\\n\\n      if (pendingLetterIndex > 0) {\\n        // A lexicographically larger letter is still avaialble.\\n        // Append a single instance of the current letter and move\\n        // back to the remembered letter.\\n\\n        sb.append((char)(\\'a\\' + i));\\n        freq[i]--;\\n        i = pendingLetterIndex;\\n        pendingLetterIndex = -1;\\n      } else {\\n        for (int j=0; j < repeatLimit && freq[i] > 0; j++, freq[i]--)\\n          sb.append((char)(\\'a\\' + i));\\n\\n        // Repeat limit reached, remember to get back to this letter.\\n        if (freq[i] > 0)\\n          pendingLetterIndex = i+1;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public String repeatLimitedString(String s, int repeatLimit) {\\n    int[] freq = new int[26];\\n\\n    for (char c : s.toCharArray())\\n      freq[c - \\'a\\']++;\\n\\n    int pendingLetterIndex = -1;\\n    StringBuilder sb = new StringBuilder();\\n\\n    for (int i=25; i >= 0; i--) {\\n      if (freq[i] == 0)\\n        continue;\\n\\n      if (pendingLetterIndex > 0) {\\n        // A lexicographically larger letter is still avaialble.\\n        // Append a single instance of the current letter and move\\n        // back to the remembered letter.\\n\\n        sb.append((char)(\\'a\\' + i));\\n        freq[i]--;\\n        i = pendingLetterIndex;\\n        pendingLetterIndex = -1;\\n      } else {\\n        for (int j=0; j < repeatLimit && freq[i] > 0; j++, freq[i]--)\\n          sb.append((char)(\\'a\\' + i));\\n\\n        // Repeat limit reached, remember to get back to this letter.\\n        if (freq[i] > 0)\\n          pendingLetterIndex = i+1;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802906,
                "title": "c-construct-string-with-repeat-limit-o-n-approach-using-priority-queue",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    string repeatString(char ch,int num) {\\n        string res=\"\";\\n        while(num--)\\n            res+=ch;\\n        return res;\\n    }\\n    \\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        priority_queue<pair<char,int>> pq;\\n        vector<int> freq(26);\\n        \\n        for(int i=0;i<s.length();i++)\\n            freq[s[i]-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++) {\\n            if(freq[i]) {\\n                char keyElement = (\\'a\\'+i);\\n                pq.push({keyElement,freq[i]});\\n            }\\n        }\\n        \\n        string resultString = \"\";\\n        \\n        while(pq.size()>1) {\\n            \\n            char firstChar = pq.top().first;\\n            int firstCharCount = pq.top().second;\\n            pq.pop();\\n            \\n            if(firstCharCount<=repeatLimit) {\\n                \\n                resultString+=repeatString(firstChar,firstCharCount);\\n            }\\n            else {\\n                firstCharCount-=repeatLimit; // 1\\n                \\n                // pulling out second char. \\n                char secondChar = pq.top().first; // a \\n                int secondCharCount = pq.top().second; // 4\\n                pq.pop(); \\n                \\n                resultString+= (repeatString(firstChar,repeatLimit)+secondChar); //bba\\n                \\n                if(--secondCharCount)\\n                    pq.push({secondChar,secondCharCount}); //{a:3}\\n                if(firstCharCount)\\n                    pq.push({firstChar,firstCharCount}); //{b:1}\\n                \\n            }\\n        }\\n        \\n        if(pq.empty()==false) // contains one element \\n                resultString+=repeatString(pq.top().first,min(repeatLimit,pq.top().second));\\n        \\n        \\n        return resultString;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    string repeatString(char ch,int num) {\\n        string res=\"\";\\n        while(num--)\\n            res+=ch;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1796612,
                "title": "java-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(1)\\n   */\\n  public String repeatLimitedString(String s, int repeatLimit) {\\n    String dic = \"abcdefghijklmnopqrstuvwxyz\";\\n    // Space O(26)\\n    int[] bucket = new int[26];\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      bucket[s.charAt(i) - \\'a\\']++;\\n    }\\n    \\n    // Space O(26)\\n    List<Integer> trace = new ArrayList<>();\\n    for (int i = 25; i >= 0; i--) {\\n      if (bucket[i] > 0) {\\n        trace.add(i);\\n      }\\n    }\\n\\n    StringBuilder str = new StringBuilder();\\n    int cur = 0;\\n    int next = 1;\\n    int limit = repeatLimit;\\n    // Time O(n)\\n    while (cur < trace.size() && limit > 0) {\\n      str.append(dic.charAt(trace.get(cur)));\\n      bucket[trace.get(cur)]--;\\n      limit--;\\n      if (bucket[trace.get(cur)] == 0) {\\n        if (next > trace.size() - 1) {\\n          break;\\n        }\\n        cur = next;\\n        next++;\\n        limit = repeatLimit;\\n      }\\n      if (limit == 0) {\\n        if (next > trace.size() - 1) {\\n          break;\\n        }\\n        str.append(dic.charAt(trace.get(next)));\\n        bucket[trace.get(next)]--;\\n        limit = repeatLimit;\\n      }\\n      if (next < trace.size() && bucket[trace.get(next)] == 0) {\\n        next++;\\n      }\\n    }\\n    // Time O(n)\\n    return str.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(1)\\n   */\\n  public String repeatLimitedString(String s, int repeatLimit) {\\n    String dic = \"abcdefghijklmnopqrstuvwxyz\";\\n    // Space O(26)\\n    int[] bucket = new int[26];\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      bucket[s.charAt(i) - \\'a\\']++;\\n    }\\n    \\n    // Space O(26)\\n    List<Integer> trace = new ArrayList<>();\\n    for (int i = 25; i >= 0; i--) {\\n      if (bucket[i] > 0) {\\n        trace.add(i);\\n      }\\n    }\\n\\n    StringBuilder str = new StringBuilder();\\n    int cur = 0;\\n    int next = 1;\\n    int limit = repeatLimit;\\n    // Time O(n)\\n    while (cur < trace.size() && limit > 0) {\\n      str.append(dic.charAt(trace.get(cur)));\\n      bucket[trace.get(cur)]--;\\n      limit--;\\n      if (bucket[trace.get(cur)] == 0) {\\n        if (next > trace.size() - 1) {\\n          break;\\n        }\\n        cur = next;\\n        next++;\\n        limit = repeatLimit;\\n      }\\n      if (limit == 0) {\\n        if (next > trace.size() - 1) {\\n          break;\\n        }\\n        str.append(dic.charAt(trace.get(next)));\\n        bucket[trace.get(next)]--;\\n        limit = repeatLimit;\\n      }\\n      if (next < trace.size() && bucket[trace.get(next)] == 0) {\\n        next++;\\n      }\\n    }\\n    // Time O(n)\\n    return str.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788655,
                "title": "python-simple-solution-faster-than-100-using-2-pointers-sorting",
                "content": "Hi ,\\n\\nHere is a simple solution.   Please **Upvote** if you like!\\n\\nNote: \\n\\t\\tletters = sorted(list(c.keys())+[\\'\\']) is to take care of the edgecase when `second` is None\\n\\n```\\n\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\t\\n        c = collections.Counter(s)\\n        res = []\\n        letters = sorted(list(c.keys())+[\\'\\'])\\n\\n        first,second = letters.pop(),letters.pop()\\n\\n        while first and second:\\n            if c[first] > repeatLimit:\\n                c[first] -= repeatLimit\\n                res += first * repeatLimit\\n                res += second\\n                c[second] -= 1\\n                if c[second]==0:\\n                    second = letters.pop()\\n\\n            else:\\n                res += first * c[first]\\n                c[first] = 0\\n                first = second\\n                second = letters.pop()\\n        if first:      \\n            res += first * min(c[first], repeatLimit)\\n        return \\'\\'.join(res)\\n         \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Hi ,\\n\\nHere is a simple solution.   Please **Upvote** if you like!\\n\\nNote: \\n\\t\\tletters = sorted(list(c.keys())+[\\'\\']) is to take care of the edgecase when `second` is None\\n\\n```\\n\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\t\\n        c = collections.Counter(s)\\n        res = []\\n        letters = sorted(list(c.keys())+[\\'\\'])\\n\\n        first,second = letters.pop(),letters.pop()\\n\\n        while first and second:\\n            if c[first] > repeatLimit:\\n                c[first] -= repeatLimit\\n                res += first * repeatLimit\\n                res += second\\n                c[second] -= 1\\n                if c[second]==0:\\n                    second = letters.pop()\\n\\n            else:\\n                res += first * c[first]\\n                c[first] = 0\\n                first = second\\n                second = letters.pop()\\n        if first:      \\n            res += first * min(c[first], repeatLimit)\\n        return \\'\\'.join(res)\\n         \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1786768,
                "title": "confusion-help-needed",
                "content": "Can someone explain why the answer returned for testcase #2 ```aababab``` is ```bbabaa``` and not ```bbaabaa``` even when the latter is lexicographically larger?",
                "solutionTags": [],
                "code": "```aababab```\n```bbabaa```\n```bbaabaa```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786176,
                "title": "c-worst-to-best-bruteforce-n-2-priorityqueue-o-nlogn-counting-greedy-o-n",
                "content": "# Bruteforce Solution\\n**#1 Bruteforce Approach O(N^2) not accepted (failed at 144th testcase were the limit is \\'1\\')**\\n1. first sort the string.\\n2. now traverse through the string and find the index were the *limit* is reached as soon as the limit reached find the next element which is not equal to the current element \\n3. then swap the both element \\n4. after doing that it can be observe that the resultant string is left with the extra character at the end of the string \\n\\tEg:\\n\\tstring s = **\"aaaaaaabbbccccd\"**\\n\\tlimit = **3**\\n\\t* resultant string looks like \\n\\t\\t\\t **\"dcccbcbbaaaaaaa\"**\\n\\t* now we need to pop some of the last element from the string and we have done\\n\\t* to do so, we need to count the occurence of the last character (***in example it is \\'a\\' = 7*** )\\n\\t* Number of character to be deleted will be = **count - limit** *i.e* **7-3 = 4**\\n 5. now just delete the required character from the string and done!.\\n\\t  \\n\\t  resultant string  =  **\"dcccbcbbaaaaaaa\"**\\n\\t  count = 7, limit = 3;\\n\\t  noOfdelete = 7 - 3 = 4\\n\\t  After deletion string = **\"\"dcccbcbbaaa   |   aaaa\"\"**\\n\\t  \\n\\t  C++ Code : \\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        sort(s.rbegin(), s.rend());\\n        int count = 0;int j = 0;\\n        for(int i=0; i<s.size()-1; i++)\\n        {\\n            j = i;\\n            if(count >= repeatLimit)\\n            { \\n                for( ; j<s.size(); j++)\\n                {\\n                    if(s[i] != s[j])\\n                    {\\n                        swap(s[i], s[j]);   \\n                        break;\\n                    }\\n                }\\n                count = 0;\\n            }\\n            if(s[i] != s[i+1])count=0;\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        int c = 1;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i] != s[i+1] && i-1 >= 0)\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        if(c <= repeatLimit)return s;\\n        int t = c - repeatLimit;\\n        while(t-- && !s.empty())s.pop_back();\\n         \\n        return s;\\n    }\\n};\\n\\t  \\n```\\n# Priority Queue Solution (Better)\\n**priority queue O(NLogN), accepted**\\n\\n1. count all occurence of each and every character (*using map or a vector*)\\n2. make a priority queue of pair and push all the element and frequency in it.\\n3. Push the very first character in the answer minimum of limit and the frequency of the first character in the priority queue *i.e.* **push character X min(limit, characterFreq)**\\n4. reduce the characterFreq as **characterFreq -= limit**\\n5. if characterFreq is -ve we will continue\\n6. else if the priority queue is empty then simply return the anwer \\n7. else push one occurence of the top most character in priority queue \\n8. also reduce the newFrew by 1 *i.e.* newFreq -= 1\\n\\nNOTE : You will understood the approach more clear by dry runnig the code \\n\\nCODE C++:\\n```\\n\\nclass Solution{\\n    public:\\n    string repeatLimitedString(string s, int limit)\\n    {\\n        map<char,int> mpp;\\n        for(auto i:s)\\n        {\\n            mpp[i]++;\\n        }\\n        \\n        priority_queue<pair<char,int>> pq;\\n        for(auto i:mpp)\\n        {\\n            pq.push({i.first, i.second});\\n        }\\n        \\n        string ans;\\n        while(!pq.empty())\\n        {\\n            pair<char,int> temp = pq.top(); pq.pop();\\n            \\n            point : // ( * )\\n            \\n            int fill = min(limit, temp.second);\\n            temp.second -= fill;\\n            \\n            while(fill--)ans.push_back(temp.first);\\n            if(temp.second > 0)\\n            {\\n                if(pq.empty())return ans;\\n                \\n                pair<char, int> now = pq.top(); pq.pop();\\n                ans.push_back(now.first);\\n                now.second -= 1;\\n                if(now.second) pq.push(now);\\n                goto point; ( * )\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**I personally came up with only these two approach, the best Approach actually idea of @lzl124631x Thanks @lzl124631x for giving such optimised solution**\\n\\nlink to his blog : https://leetcode.com/problems/construct-string-with-repeat-limit/discuss/1784718/C%2B%2B-Greedy-%2B-Counting-O(N)-Time-O(1)-space\\n\\n\\nNOTE : This is my very first blog please forgive any mistake done in the blog.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        sort(s.rbegin(), s.rend());\\n        int count = 0;int j = 0;\\n        for(int i=0; i<s.size()-1; i++)\\n        {\\n            j = i;\\n            if(count >= repeatLimit)\\n            { \\n                for( ; j<s.size(); j++)\\n                {\\n                    if(s[i] != s[j])\\n                    {\\n                        swap(s[i], s[j]);   \\n                        break;\\n                    }\\n                }\\n                count = 0;\\n            }\\n            if(s[i] != s[i+1])count=0;\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        int c = 1;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i] != s[i+1] && i-1 >= 0)\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        if(c <= repeatLimit)return s;\\n        int t = c - repeatLimit;\\n        while(t-- && !s.empty())s.pop_back();\\n         \\n        return s;\\n    }\\n};\\n\\t  \\n```\n```\\n\\nclass Solution{\\n    public:\\n    string repeatLimitedString(string s, int limit)\\n    {\\n        map<char,int> mpp;\\n        for(auto i:s)\\n        {\\n            mpp[i]++;\\n        }\\n        \\n        priority_queue<pair<char,int>> pq;\\n        for(auto i:mpp)\\n        {\\n            pq.push({i.first, i.second});\\n        }\\n        \\n        string ans;\\n        while(!pq.empty())\\n        {\\n            pair<char,int> temp = pq.top(); pq.pop();\\n            \\n            point : // ( * )\\n            \\n            int fill = min(limit, temp.second);\\n            temp.second -= fill;\\n            \\n            while(fill--)ans.push_back(temp.first);\\n            if(temp.second > 0)\\n            {\\n                if(pq.empty())return ans;\\n                \\n                pair<char, int> now = pq.top(); pq.pop();\\n                ans.push_back(now.first);\\n                now.second -= 1;\\n                if(now.second) pq.push(now);\\n                goto point; ( * )\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786126,
                "title": "priority-queue-c-solution-accepted",
                "content": "class Solution {\\npublic:\\n\\n    string repeatLimitedString(string s, int k) {\\n        string ans = \"\";\\n        \\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        priority_queue<pair<char , int>>pq;\\n        \\n        for(auto value : mp){\\n            pq.push({value.first ,  value.second});\\n        }\\n        \\n        while(!pq.empty()){\\n            char first = pq.top().first;\\n            int second = pq.top().second;\\n            pq.pop();\\n            \\n            int size = min(second , k);\\n            \\n            for(int i = 0 ; i < size ; i++){\\n                ans += first;\\n            }\\n            \\n            if(second - k > 0){\\n                if(!pq.empty()){\\n                    char first2 = pq.top().first;\\n                    int second2 = pq.top().second;\\n                    pq.pop();\\n                    ans += first2;\\n                    if(second2 - 1 > 0){\\n                        pq.push({first2 , second2 - 1});\\n                    }\\n                }else{\\n                    return ans;\\n                }\\n                pq.push({first , second - k});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string repeatLimitedString(string s, int k) {\\n        string ans = \"\";\\n        \\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785919,
                "title": "c-frequency-vector-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit){\\n        vector<int> hash(26);\\n        for(int i=0;i<s.length();i++) hash[s[i]-\\'a\\']++;\\n        priority_queue<pair<char,int>> pq; \\n        for(int i=0;i<26;i++) if(hash[i]) pq.push({\\'a\\'+i,hash[i]});\\n        string res=\"\";\\n        while(!pq.empty()){\\n            char c=pq.top().first; int freq=pq.top().second; pq.pop();\\n            int temp=min(limit,freq);\\n            while(temp--) res.push_back(c);\\n            if(pq.empty()) return res;\\n            freq=freq-min(limit,freq);\\n            if(freq){\\n                char smol=pq.top().first; int smolfreq=pq.top().second; pq.pop();\\n            res.push_back(smol); smolfreq--;\\n            if(smolfreq) pq.push({smol,smolfreq});\\n                pq.push({c,freq});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit){\\n        vector<int> hash(26);\\n        for(int i=0;i<s.length();i++) hash[s[i]-\\'a\\']++;\\n        priority_queue<pair<char,int>> pq; \\n        for(int i=0;i<26;i++) if(hash[i]) pq.push({\\'a\\'+i,hash[i]});\\n        string res=\"\";\\n        while(!pq.empty()){\\n            char c=pq.top().first; int freq=pq.top().second; pq.pop();\\n            int temp=min(limit,freq);\\n            while(temp--) res.push_back(c);\\n            if(pq.empty()) return res;\\n            freq=freq-min(limit,freq);\\n            if(freq){\\n                char smol=pq.top().first; int smolfreq=pq.top().second; pq.pop();\\n            res.push_back(smol); smolfreq--;\\n            if(smolfreq) pq.push({smol,smolfreq});\\n                pq.push({c,freq});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785807,
                "title": "simple-javascript-solution-159-ms",
                "content": "```\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    const aCode = \"a\".charCodeAt();\\n    const counts = new Array(26).fill(0);\\n    let result = \"\";\\n    let cnt, takeOne, len, lastLetter;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        ++counts[s.charCodeAt(i) - aCode];\\n    }\\n    \\n    while (result.length < s.length) {\\n        takeOne = false;\\n        len = result.length;\\n\\n        for (let i = 26; i >= 0; --i) {\\n            if (counts[i] > 0) {\\n                \\n                if (lastLetter === i) {\\n                    takeOne = true;\\n                    continue;\\n                }\\n                \\n                lastLetter = i;\\n                cnt = takeOne ? 1 : Math.min(counts[i], repeatLimit);\\n                result += String.fromCharCode(i + aCode).repeat(cnt);\\n                counts[i] -= cnt;\\n                break;\\n            }\\n        }\\n        \\n        if (result.length === len) break;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    const aCode = \"a\".charCodeAt();\\n    const counts = new Array(26).fill(0);\\n    let result = \"\";\\n    let cnt, takeOne, len, lastLetter;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        ++counts[s.charCodeAt(i) - aCode];\\n    }\\n    \\n    while (result.length < s.length) {\\n        takeOne = false;\\n        len = result.length;\\n\\n        for (let i = 26; i >= 0; --i) {\\n            if (counts[i] > 0) {\\n                \\n                if (lastLetter === i) {\\n                    takeOne = true;\\n                    continue;\\n                }\\n                \\n                lastLetter = i;\\n                cnt = takeOne ? 1 : Math.min(counts[i], repeatLimit);\\n                result += String.fromCharCode(i + aCode).repeat(cnt);\\n                counts[i] -= cnt;\\n                break;\\n            }\\n        }\\n        \\n        if (result.length === len) break;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785744,
                "title": "easy-to-understand-c",
                "content": "```\\n// Using priority queue\\n    string repeatLimitedString(string s, int k) {\\n        string res = \"\";\\n        \\n        map<char,int> mp;\\n        \\n        for(auto x:s)\\n        {\\n           mp[x]++;\\n        }\\n        \\n        priority_queue<pair<char,int>> pq;\\n        \\n        for(auto x:mp)\\n        {\\n            pq.push({x.first,x.second});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            char c1 = pq.top().first;\\n            int f1 = pq.top().second;\\n            pq.pop();\\n            \\n            int len = min(k,f1);\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                res += c1;\\n            }\\n            \\n            if(!pq.empty() and f1 - len > 0)\\n            {\\n                char c2 = pq.top().first;\\n                int f2 = pq.top().second;\\n                \\n                pq.pop();\\n                \\n                res += c2;\\n                if(f1 - len > 0)\\n                {\\n                    pq.push({c1,f1-len});\\n                }\\n                if(f2 - 1 > 0)\\n                {\\n                    pq.push({c2,f2-1});\\n                } \\n            }   \\n            \\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Using priority queue\\n    string repeatLimitedString(string s, int k) {\\n        string res = \"\";\\n        \\n        map<char,int> mp;\\n        \\n        for(auto x:s)\\n        {\\n           mp[x]++;\\n        }\\n        \\n        priority_queue<pair<char,int>> pq;\\n        \\n        for(auto x:mp)\\n        {\\n            pq.push({x.first,x.second});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            char c1 = pq.top().first;\\n            int f1 = pq.top().second;\\n            pq.pop();\\n            \\n            int len = min(k,f1);\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                res += c1;\\n            }\\n            \\n            if(!pq.empty() and f1 - len > 0)\\n            {\\n                char c2 = pq.top().first;\\n                int f2 = pq.top().second;\\n                \\n                pq.pop();\\n                \\n                res += c2;\\n                if(f1 - len > 0)\\n                {\\n                    pq.push({c1,f1-len});\\n                }\\n                if(f2 - 1 > 0)\\n                {\\n                    pq.push({c2,f2-1});\\n                } \\n            }   \\n            \\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785408,
                "title": "priority-queue-max-heap-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int r) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        // Keep the characters and it\\'s count in max heap, Charater as first element\\n        priority_queue<pair<char,int>>pq;\\n        for(auto p:mp)\\n        {\\n            pq.push(p);\\n        }\\n        string ans;\\n        // For each top element, if it has occurance greater or equal to repeatLimit than take this character repeatLimit times \\n        while(!pq.empty())\\n        {\\n            auto [c,f]=pq.top();\\n            pq.pop();\\n            for(int i=0;i<r and f>0;i++)\\n            {\\n                ans+=c;\\n                f--;\\n            }\\n            // if frecuency of current charater>repeatLimit\\n            if(f)\\n            {\\n                // than check if there is any element in heap so that we can take that \\n                if(!pq.empty())\\n                {\\n                    auto p=pq.top();\\n                    pq.pop();\\n                    ans+=p.first;\\n                   if(p.second-- >1)\\n                   {\\n                       pq.push(p);\\n                   }\\n                pq.push({c,f}); \\n                }\\n\\t\\t\\t\\t// otherwise if this was the last element that return from here\\n                else\\n                {\\n                    return ans;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int r) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        // Keep the characters and it\\'s count in max heap, Charater as first element\\n        priority_queue<pair<char,int>>pq;\\n        for(auto p:mp)\\n        {\\n            pq.push(p);\\n        }\\n        string ans;\\n        // For each top element, if it has occurance greater or equal to repeatLimit than take this character repeatLimit times \\n        while(!pq.empty())\\n        {\\n            auto [c,f]=pq.top();\\n            pq.pop();\\n            for(int i=0;i<r and f>0;i++)\\n            {\\n                ans+=c;\\n                f--;\\n            }\\n            // if frecuency of current charater>repeatLimit\\n            if(f)\\n            {\\n                // than check if there is any element in heap so that we can take that \\n                if(!pq.empty())\\n                {\\n                    auto p=pq.top();\\n                    pq.pop();\\n                    ans+=p.first;\\n                   if(p.second-- >1)\\n                   {\\n                       pq.push(p);\\n                   }\\n                pq.push({c,f}); \\n                }\\n\\t\\t\\t\\t// otherwise if this was the last element that return from here\\n                else\\n                {\\n                    return ans;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785069,
                "title": "my-java-solution-with-comments",
                "content": "The approach is to add as many copies of the \"higher\" characters as possible, up to repeatLimit. Then, add only 1 copy of the next highest character as a separator, and \"go back\" to the previous character.\\n\\nFor example, with ```s = \"zzzzyy\"``` and ```repeatLimit = 2```, we:\\n1) Add 2 copies of \\'z\\'. Since we still have 2 copies remaining that we want to use later, we set ```goBack = 25```.\\n2) Since ```goBack != 0```, add only 1 copy of \\'y\\'. Set ```i = 26``` so that on next loop iteration ```i = 25``` again, and we can add more \\'z\\'.\\n3) Add 2 more copies of \\'z\\'.\\n4) Add final \\'y\\', which produces \\'zzyzzy\\'.\\n\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\t    // count number of each character\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            counts[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\t// if we hit repeatLimit for a character, we can \"go back\"\\n\\t\\t// to it later after adding some lower character\\n        int goBack = 0;\\n\\t\\t\\n        for (int i = 25; i >= 0; i--) { // z -> a\\n            if (counts[i] > 0) {\\n                char c = (char)(\\'a\\' + i);\\n\\t\\t\\t\\t\\n                if (goBack == 0) {\\n\\t\\t\\t\\t\\t// append as many copies as we have, up to repeatLimit\\n                    for (int j = 0; j < repeatLimit && counts[i] > 0; j++) {\\n                        sb.append(c);\\n                        counts[i]--;\\n                    }\\n\\t\\t\\t\\t\\t// if we still have more available then we hit repeatLimit, and we\\'ll need\\n\\t\\t\\t\\t\\t// to add some lower character before we can add more of this one\\n                    if (counts[i] > 0) {\\n                        goBack = i;\\n                    }\\n                } else {\\n\\t\\t\\t\\t\\t// when goBack is not 0, we want to append only 1 copy of the next lower\\n\\t\\t\\t\\t\\t// character, then go back to the higher character by re-setting i to goBack+1\\n                    sb.append(c);\\n                    counts[i]--;\\n                    i = goBack + 1;\\n                    goBack = 0;\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```s = \"zzzzyy\"```\n```repeatLimit = 2```\n```goBack = 25```\n```goBack != 0```\n```i = 26```\n```i = 25```\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\t    // count number of each character\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            counts[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\t// if we hit repeatLimit for a character, we can \"go back\"\\n\\t\\t// to it later after adding some lower character\\n        int goBack = 0;\\n\\t\\t\\n        for (int i = 25; i >= 0; i--) { // z -> a\\n            if (counts[i] > 0) {\\n                char c = (char)(\\'a\\' + i);\\n\\t\\t\\t\\t\\n                if (goBack == 0) {\\n\\t\\t\\t\\t\\t// append as many copies as we have, up to repeatLimit\\n                    for (int j = 0; j < repeatLimit && counts[i] > 0; j++) {\\n                        sb.append(c);\\n                        counts[i]--;\\n                    }\\n\\t\\t\\t\\t\\t// if we still have more available then we hit repeatLimit, and we\\'ll need\\n\\t\\t\\t\\t\\t// to add some lower character before we can add more of this one\\n                    if (counts[i] > 0) {\\n                        goBack = i;\\n                    }\\n                } else {\\n\\t\\t\\t\\t\\t// when goBack is not 0, we want to append only 1 copy of the next lower\\n\\t\\t\\t\\t\\t// character, then go back to the higher character by re-setting i to goBack+1\\n                    sb.append(c);\\n                    counts[i]--;\\n                    i = goBack + 1;\\n                    goBack = 0;\\n                }\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784981,
                "title": "java-simple-map-greedy",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int limit) {\\n        int[] map = new int[26];\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            map[s.charAt(i) - \\'a\\']++;\\n        }\\n        return construct(map, limit);\\n    }\\n    \\n    public String construct(int[] map, int k) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 25; i >= 0; i--) {\\n            while (map[i] != 0) {\\n                int same = 0;\\n                while (same < k && map[i] > 0) {\\n                    ans.append((char)(i + \\'a\\'));\\n                    same++;\\n                    map[i]--;\\n                }\\n                if (map[i] > 0) {\\n                    //  brings the next smaller character available\\n                    int nse = next(map, i);\\n                    if (nse == -1) {\\n                        break;\\n                    } else {\\n                        ans.append((char)(nse + \\'a\\'));\\n                        map[nse]--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n    \\n    \\n    public int next(int[] map, int p) {\\n        for (int i = p - 1; i >= 0; i--) {\\n            if (map[i] != 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int limit) {\\n        int[] map = new int[26];\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            map[s.charAt(i) - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1784918,
                "title": "javascript-greedy-192ms",
                "content": "Main idea: greedy.\\nto make lexical greatest, so each time use out current largest char (search from end 25 -> 0)\\n  (1) freq <= limit, append (freq char) directly, f[i] = 0\\n  (2) freq > limit, append (limit char), find a bridge (second largest char, to make lexical greatest), append it, f[i] -= limit,\\n       until freq <= limit, redo (1)\\n\\t   if cannot find a bridge char, stop now is the answer\\n```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst repeatLimitedString = (s, limit) => {\\n    let f = Array(26).fill(0), res = \\'\\';\\n    for (const c of s) f[ord(c) - 97]++;\\n    for (let i = 25; ~i; i--) { // each time use out current largest char\\n        if (f[i] == 0) continue;\\n        let c = String.fromCharCode(97 + i);\\n        while (f[i] > limit) { // condition 2\\n            res += c.repeat(limit);\\n            f[i] -= limit;\\n            let findBridge = false, bridge, j;\\n            for (j = 25; ~j; j--) { // find second larger char\\n                if (j == i) continue; // should be different from current char\\n                if (f[j] > 0) {\\n                    findBridge = true;\\n                    bridge = String.fromCharCode(97 + j);\\n                    break;\\n                }\\n            }\\n            if (!findBridge) return res;\\n            res += bridge;\\n            f[j]--;\\n        }\\n        res += c.repeat(f[i]); // condition 1\\n        f[i] = 0;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst repeatLimitedString = (s, limit) => {\\n    let f = Array(26).fill(0), res = \\'\\';\\n    for (const c of s) f[ord(c) - 97]++;\\n    for (let i = 25; ~i; i--) { // each time use out current largest char\\n        if (f[i] == 0) continue;\\n        let c = String.fromCharCode(97 + i);\\n        while (f[i] > limit) { // condition 2\\n            res += c.repeat(limit);\\n            f[i] -= limit;\\n            let findBridge = false, bridge, j;\\n            for (j = 25; ~j; j--) { // find second larger char\\n                if (j == i) continue; // should be different from current char\\n                if (f[j] > 0) {\\n                    findBridge = true;\\n                    bridge = String.fromCharCode(97 + j);\\n                    break;\\n                }\\n            }\\n            if (!findBridge) return res;\\n            res += bridge;\\n            f[j]--;\\n        }\\n        res += c.repeat(f[i]); // condition 1\\n        f[i] = 0;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784764,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int i = 25, dp[] = new int[26];\\n        for (char c: s.toCharArray()) dp[c - \\'a\\']++;\\n        StringBuilder sb = new StringBuilder();\\n        while(i > -1) {\\n            while (dp[i] > 0) {\\n                int number = Math.min(dp[i], repeatLimit);\\n                for (int j = 0; j < number; j++) sb.append((char)(i + \\'a\\'));\\n                dp[i] -= number;\\n                if (dp[i] > 0) {\\n                    char c = getPrevChar(dp , i-1);\\n                    if (c == \\'$\\') break;\\n                    else if (c != \\'$\\') sb.append(c);\\n                }\\n            }\\n            i--;\\n        }\\n        return sb.toString();\\n    }\\n\\n    private char getPrevChar(int[] dp,int i) {\\n        if (i < 0) return \\'$\\';\\n        if (dp[i] == 0) return getPrevChar(dp, i - 1);\\n        else {\\n            dp[i]--;\\n            return (char)(\\'a\\' + i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int i = 25, dp[] = new int[26];\\n        for (char c: s.toCharArray()) dp[c - \\'a\\']++;\\n        StringBuilder sb = new StringBuilder();\\n        while(i > -1) {\\n            while (dp[i] > 0) {\\n                int number = Math.min(dp[i], repeatLimit);\\n                for (int j = 0; j < number; j++) sb.append((char)(i + \\'a\\'));\\n                dp[i] -= number;\\n                if (dp[i] > 0) {\\n                    char c = getPrevChar(dp , i-1);\\n                    if (c == \\'$\\') break;\\n                    else if (c != \\'$\\') sb.append(c);\\n                }\\n            }\\n            i--;\\n        }\\n        return sb.toString();\\n    }\\n\\n    private char getPrevChar(int[] dp,int i) {\\n        if (i < 0) return \\'$\\';\\n        if (dp[i] == 0) return getPrevChar(dp, i - 1);\\n        else {\\n            dp[i]--;\\n            return (char)(\\'a\\' + i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784716,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        TreeMap<Character, Integer> tm = new TreeMap<>(Collections.reverseOrder());\\n        StringBuffer sb = new StringBuffer();\\n        boolean shouldGetLargest = true;\\n        for(char c: s.toCharArray())\\n        {\\n            tm.put(c, tm.getOrDefault(c,0)+1);      \\n        }\\n        while(tm.size()>0){\\n            char c = tm.firstKey();// get the largest character\\n            if(sb.length()!=0 && sb.charAt(sb.length()-1) == c){ // if last char of sb is same as largest character\\n               shouldGetLargest = false;     \\n            }\\n            int charCount =0, count = 0;\\n\\n            if(shouldGetLargest){\\n                charCount = tm.get(c);\\n                count = Math.min(charCount,repeatLimit);\\n            }else{\\n                //get second largest\\n                if(tm.size()>1){\\n                char largest = c;\\n                c = tm.subMap(largest, false, \\'a\\', true).firstKey(); // exclude largest\\n                charCount = tm.get(c);\\n                count = 1;// use second largest char only once to build lexicographically largest\\n                }\\n                // if should get next largest and only one key exists we should drop them - happens automatically because count == charCount\\n            }\\n                if(count==charCount)\\n                    tm.remove(c);\\n                else\\n                tm.put(c, charCount-count);\\n\\n                while(count>0){ //insert till repeat limit or available character count\\n                    sb.append(c);\\n                    count--;\\n                }\\n            \\n            if(!shouldGetLargest)// if we used second largest this time, use largest next time\\n                shouldGetLargest = !shouldGetLargest;\\n        }\\n        return sb.toString();\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        TreeMap<Character, Integer> tm = new TreeMap<>(Collections.reverseOrder());\\n        StringBuffer sb = new StringBuffer();\\n        boolean shouldGetLargest = true;\\n        for(char c: s.toCharArray())\\n        {\\n            tm.put(c, tm.getOrDefault(c,0)+1);      \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3751664,
                "title": "python3-priority-queue-greedy-couting-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = collections.Counter(s)\\n        chars = [(-ord(k), k, v) for k, v in cnt.items()]\\n\\n        heapq.heapify(chars)\\n        res = []\\n        while chars:\\n            o, ch, ct = heapq.heappop(chars)\\n            add = 0\\n            if len(res) >= repeatLimit and res[-1] == ch:\\n                if not chars: break\\n                no, nch, nct = heapq.heappop(chars)\\n                res.append(nch)\\n                if nct - 1 != 0: heapq.heappush(chars, (no, nch, nct - 1))\\n            else:\\n                add = min(repeatLimit, ct)\\n                res.extend([ch for _ in range(add)])\\n            if ct - add != 0: heapq.heappush(chars, (o, ch, ct - add))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = collections.Counter(s)\\n        chars = [(-ord(k), k, v) for k, v in cnt.items()]\\n\\n        heapq.heapify(chars)\\n        res = []\\n        while chars:\\n            o, ch, ct = heapq.heappop(chars)\\n            add = 0\\n            if len(res) >= repeatLimit and res[-1] == ch:\\n                if not chars: break\\n                no, nch, nct = heapq.heappop(chars)\\n                res.append(nch)\\n                if nct - 1 != 0: heapq.heappush(chars, (no, nch, nct - 1))\\n            else:\\n                add = min(repeatLimit, ct)\\n                res.extend([ch for _ in range(add)])\\n            if ct - add != 0: heapq.heappush(chars, (o, ch, ct - add))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729504,
                "title": "java-pq-single-pass",
                "content": "# Intuition\\nTypical problems:\\nhttps://leetcode.com/problems/task-scheduler/description/\\nhttps://leetcode.com/problems/rearrange-string-k-distance-apart/description/\\nhttps://leetcode.com/problems/reorganize-string/\\nhttps://leetcode.com/problems/construct-string-with-repeat-limit/\\n\\nso i decided to take the same approach.\\n\\n# Approach\\nChallenge here is to repeat as much as possible but keeping the lexo large. This requires paying attention to cornor cases. Simple idea is to construct output one by one if is allowed as per the requirement. I used pivot to suggest the starting of repeats, repeat until allowed or available. if not, add new char to the output and repeat the process. I hate this coding style but it worked for me. I checked all other solutions, and couldnt find any other cleaner way.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c :  s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n        Queue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\\n            (a, b) -> Character.compare(b.getKey(), a.getKey())\\n        );\\n\\n        pq.addAll(map.entrySet());\\n\\n        StringBuilder ret = new StringBuilder();\\n        int pivot = -1;\\n        while(!pq.isEmpty()) {\\n            Map.Entry<Character, Integer> node = pq.poll();\\n            if(pivot == -1 || ret.charAt(pivot) != node.getKey() || ret.length() - pivot < repeatLimit) {\\n                ret.append(node.getKey());\\n                node.setValue(node.getValue()-1);\\n                if(node.getValue()!=0)\\n                    pq.add(node);\\n                if(pivot == -1 || ret.charAt(pivot) != node.getKey())\\n                    pivot = ret.length()-1;\\n                continue;\\n            }\\n            if(pq.isEmpty()) return ret.toString();\\n            Map.Entry<Character, Integer> node1 = pq.poll();\\n            ret.append(node1.getKey());\\n            node1.setValue(node1.getValue()-1);\\n            if(node1.getValue()!=0)\\n                pq.add(node1); \\n            pq.add(node);\\n            pivot = ret.length()-1;\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c :  s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\n        Queue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\\n            (a, b) -> Character.compare(b.getKey(), a.getKey())\\n        );\\n\\n        pq.addAll(map.entrySet());\\n\\n        StringBuilder ret = new StringBuilder();\\n        int pivot = -1;\\n        while(!pq.isEmpty()) {\\n            Map.Entry<Character, Integer> node = pq.poll();\\n            if(pivot == -1 || ret.charAt(pivot) != node.getKey() || ret.length() - pivot < repeatLimit) {\\n                ret.append(node.getKey());\\n                node.setValue(node.getValue()-1);\\n                if(node.getValue()!=0)\\n                    pq.add(node);\\n                if(pivot == -1 || ret.charAt(pivot) != node.getKey())\\n                    pivot = ret.length()-1;\\n                continue;\\n            }\\n            if(pq.isEmpty()) return ret.toString();\\n            Map.Entry<Character, Integer> node1 = pq.poll();\\n            ret.append(node1.getKey());\\n            node1.setValue(node1.getValue()-1);\\n            if(node1.getValue()!=0)\\n                pq.add(node1); \\n            pq.add(node);\\n            pivot = ret.length()-1;\\n        }\\n\\n        return ret.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094682,
                "title": "8ms-fastest-java-solution-try-to-beat-this",
                "content": "# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int k) {\\n\\n        byte[] res;\\n        int resP = 0;\\n        int[] freqs = new int[26];\\n        for (byte aChar : (res = s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))) ++freqs[aChar - 97];\\n        \\n        for (int i = 25, j; i >= 0; i = j) {\\n            j = i - 1;\\n            while (freqs[i] > k) {\\n                for (int _j = 0; _j < k; ++_j) res[resP++] = (byte) (97 + i);\\n                freqs[i] -= k;\\n\\n                for (; j >= 0 && freqs[j] == 0; --j) ;\\n                if (j < 0) return new String(res, 0, resP);\\n        \\n                res[resP++] = (byte) (97 + j);\\n                --freqs[j];\\n            }\\n            for (int _j = freqs[i]; _j > 0; --_j) res[resP++] = (byte) (97 + i);\\n        }\\n        \\n        return new String(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int k) {\\n\\n        byte[] res;\\n        int resP = 0;\\n        int[] freqs = new int[26];\\n        for (byte aChar : (res = s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))) ++freqs[aChar - 97];\\n        \\n        for (int i = 25, j; i >= 0; i = j) {\\n            j = i - 1;\\n            while (freqs[i] > k) {\\n                for (int _j = 0; _j < k; ++_j) res[resP++] = (byte) (97 + i);\\n                freqs[i] -= k;\\n\\n                for (; j >= 0 && freqs[j] == 0; --j) ;\\n                if (j < 0) return new String(res, 0, resP);\\n        \\n                res[resP++] = (byte) (97 + j);\\n                --freqs[j];\\n            }\\n            for (int _j = freqs[i]; _j > 0; --_j) res[resP++] = (byte) (97 + i);\\n        }\\n        \\n        return new String(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888521,
                "title": "priority-queue-map-easy-to-understand",
                "content": "\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\tstring repeatLimitedString(string s, int repeatLimit)\\n        {\\n\\n            map<char, int> mpp;\\n            for (auto x: s)\\n            {\\n                mpp[x]++;\\n            }\\n\\n            priority_queue<pair<char, int>> pq;\\n\\n            for (auto x: mpp)\\n            {\\n                pq.push({ x.first,\\n                    x.second });\\n            }\\n\\n            string ans = \"\";\\n\\n            while (!pq.empty())\\n            {\\n                //take out the first priority element\\n                auto x = pq.top();\\n                int k = repeatLimit;\\n                int freq1 = x.second;\\n                char ch1 = x.first;\\n                pq.pop();\\n\\n                /*take minimum of the repaetlimit and frequency of the element\\n                and append it to the ans.*/\\n                int mi = min(k, freq1);\\n                freq1 -= mi;\\n                ans += string(mi, ch1);\\n                \\n                /*if the frequency of the taken element has been zero then no \\n\\t\\t\\t\\tneed to append the 2nd most priority element and skip the  \\n\\t\\t\\t\\titeration.*/\\n                if (pq.empty() || freq1 == 0)\\n                {\\n                    continue;\\n                }\\n                \\n                /*take the 2nd most priority element and append its one char*/\\n                auto y = pq.top();\\n                int freq2 = y.second;\\n                char ch2 = y.first;\\n                pq.pop();\\n\\n                ans += ch2;\\n                freq2--;\\n                \\n                /*again push the elements back in priority queue if their\\n                frequency > 0,that means they will be used again*/\\n                if (freq1 > 0)\\n                {\\n                    pq.push({ ch1,\\n                        freq1 });\\n                }\\n                if (freq2 > 0)\\n                {\\n                    pq.push({ ch2,\\n                        freq2 });\\n                }\\n            }\\n\\n            return ans;\\n        }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\tstring repeatLimitedString(string s, int repeatLimit)\\n        {\\n\\n            map<char, int> mpp;\\n            for (auto x: s)\\n            {\\n                mpp[x]++;\\n            }\\n\\n            priority_queue<pair<char, int>> pq;\\n\\n            for (auto x: mpp)\\n            {\\n                pq.push({ x.first,\\n                    x.second });\\n            }\\n\\n            string ans = \"\";\\n\\n            while (!pq.empty())\\n            {\\n                //take out the first priority element\\n                auto x = pq.top();\\n                int k = repeatLimit;\\n                int freq1 = x.second;\\n                char ch1 = x.first;\\n                pq.pop();\\n\\n                /*take minimum of the repaetlimit and frequency of the element\\n                and append it to the ans.*/\\n                int mi = min(k, freq1);\\n                freq1 -= mi;\\n                ans += string(mi, ch1);\\n                \\n                /*if the frequency of the taken element has been zero then no \\n\\t\\t\\t\\tneed to append the 2nd most priority element and skip the  \\n\\t\\t\\t\\titeration.*/\\n                if (pq.empty() || freq1 == 0)\\n                {\\n                    continue;\\n                }\\n                \\n                /*take the 2nd most priority element and append its one char*/\\n                auto y = pq.top();\\n                int freq2 = y.second;\\n                char ch2 = y.first;\\n                pq.pop();\\n\\n                ans += ch2;\\n                freq2--;\\n                \\n                /*again push the elements back in priority queue if their\\n                frequency > 0,that means they will be used again*/\\n                if (freq1 > 0)\\n                {\\n                    pq.push({ ch1,\\n                        freq1 });\\n                }\\n                if (freq2 > 0)\\n                {\\n                    pq.push({ ch2,\\n                        freq2 });\\n                }\\n            }\\n\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2245359,
                "title": "easy-understanding-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        \\n\\t\\t//sorting the given string though not required.\\n        sort(s.begin(),s.end());\\n\\t\\t//creating a map to store the character and its corresponding count value;\\n        map<char,int>mapp;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mapp[s[i]]++;\\n        }\\n\\t\\t/*creating a max priority queue that will be used to give\\n\\t\\tlexicographical most significant character*/\\n        priority_queue<pair<char,int>>pq;\\n        for(auto it = mapp.begin();it!=mapp.end();it++)\\n        {\\n            pq.push({it->first,it->second});\\n        }\\n        while(!pq.empty())\\n        {\\n            char c = pq.top().first;\\n            int cnt = pq.top().second;\\n            int temp = cnt;\\n            pq.pop();\\n\\t\\t\\t// appending the most significant character till min(limit,count);\\n            for(int i = 0;i<min(limit,temp);i++)\\n            {\\n                ans+=c;\\n                cnt-=1;\\n            }\\n\\t\\t\\t/* if count != 0 then it simply means we have reached the limit so we check \\n\\t\\t\\tfor next significant character if available and append it.*/\\n            if(cnt > 0 && !pq.empty())\\n            {\\n                char tc = pq.top().first;\\n                int tcnt = pq.top().second;\\n                pq.pop();\\n                ans+=tc;\\n                tcnt-=1;\\n                if(tcnt >0)\\n                    pq.push({tc,tcnt});\\n                pq.push({c,cnt});\\n            }\\n            else if(cnt > 0 && pq.empty())\\n                break;\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        \\n\\t\\t//sorting the given string though not required.\\n        sort(s.begin(),s.end());\\n\\t\\t//creating a map to store the character and its corresponding count value;\\n        map<char,int>mapp;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mapp[s[i]]++;\\n        }\\n\\t\\t/*creating a max priority queue that will be used to give\\n\\t\\tlexicographical most significant character*/\\n        priority_queue<pair<char,int>>pq;\\n        for(auto it = mapp.begin();it!=mapp.end();it++)\\n        {\\n            pq.push({it->first,it->second});\\n        }\\n        while(!pq.empty())\\n        {\\n            char c = pq.top().first;\\n            int cnt = pq.top().second;\\n            int temp = cnt;\\n            pq.pop();\\n\\t\\t\\t// appending the most significant character till min(limit,count);\\n            for(int i = 0;i<min(limit,temp);i++)\\n            {\\n                ans+=c;\\n                cnt-=1;\\n            }\\n\\t\\t\\t/* if count != 0 then it simply means we have reached the limit so we check \\n\\t\\t\\tfor next significant character if available and append it.*/\\n            if(cnt > 0 && !pq.empty())\\n            {\\n                char tc = pq.top().first;\\n                int tcnt = pq.top().second;\\n                pq.pop();\\n                ans+=tc;\\n                tcnt-=1;\\n                if(tcnt >0)\\n                    pq.push({tc,tcnt});\\n                pq.push({c,cnt});\\n            }\\n            else if(cnt > 0 && pq.empty())\\n                break;\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973741,
                "title": "python-3-o-n-o-1-without-priority-queue",
                "content": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        count = collections.Counter(s)\\n        chrs = list(map(list, sorted(count.items(), reverse=True)))\\n        res = []\\n        first, second = 0, 1\\n        n = len(chrs)\\n        \\n        while second < n:\\n            if chrs[first][1] <= repeatLimit:\\n                res.append(chrs[first][0] * chrs[first][1])\\n                first += 1\\n                while chrs[first][1] == 0:\\n                    first += 1\\n                if first >= second:\\n                    second = first + 1\\n            else:\\n                res.append(chrs[first][0] * repeatLimit + chrs[second][0])\\n                chrs[first][1] -= repeatLimit\\n                chrs[second][1] -= 1\\n                if chrs[second][1] == 0:\\n                    second += 1\\n        \\n        res.append(chrs[first][0] * min(repeatLimit, chrs[first][1]))\\n        return \\'\\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        count = collections.Counter(s)\\n        chrs = list(map(list, sorted(count.items(), reverse=True)))\\n        res = []\\n        first, second = 0, 1\\n        n = len(chrs)\\n        \\n        while second < n:\\n            if chrs[first][1] <= repeatLimit:\\n                res.append(chrs[first][0] * chrs[first][1])\\n                first += 1\\n                while chrs[first][1] == 0:\\n                    first += 1\\n                if first >= second:\\n                    second = first + 1\\n            else:\\n                res.append(chrs[first][0] * repeatLimit + chrs[second][0])\\n                chrs[first][1] -= repeatLimit\\n                chrs[second][1] -= 1\\n                if chrs[second][1] == 0:\\n                    second += 1\\n        \\n        res.append(chrs[first][0] * min(repeatLimit, chrs[first][1]))\\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 1929014,
                "title": "python3-o-n-stack",
                "content": "dct size is at most 26 letters, so sorting is O(26log26)=O(1)\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        dct=collections.Counter(s)\\n        stack=sorted([(el,freq) for el,freq in dct.items()])\\n        res=[]\\n        while stack:\\n            el,freq=stack.pop()\\n            res.extend([el*min(freq,repeatLimit)])\\n            if freq>repeatLimit:\\n                if not stack: break\\n                el2,freq2=stack.pop()\\n                res.append(el2)\\n                if freq2-1>0: stack.append((el2,freq2-1))\\n                if freq-repeatLimit>0: stack.append((el,freq-repeatLimit))\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        dct=collections.Counter(s)\\n        stack=sorted([(el,freq) for el,freq in dct.items()])\\n        res=[]\\n        while stack:\\n            el,freq=stack.pop()\\n            res.extend([el*min(freq,repeatLimit)])\\n            if freq>repeatLimit:\\n                if not stack: break\\n                el2,freq2=stack.pop()\\n                res.append(el2)\\n                if freq2-1>0: stack.append((el2,freq2-1))\\n                if freq-repeatLimit>0: stack.append((el,freq-repeatLimit))\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898178,
                "title": "c-code-with-constant-space-and-o-n-time",
                "content": "\\nfill the vector v with frequencies of all characters and traverse through the vector from end.\\nincrease count (c = 0) every time a char is added to result string res and every time check if c is less than limit\\nif so then add the char to res else check if that char has more freq than limit . if yes then store the index i in backInd variable as we need to comeback to that index after inserting a single char in res.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int n = s.length();\\n        bool rem = false;\\n        int backInd = 0;\\n        vector<int>v(26,0);\\n        for(auto ele : s)\\n        {\\n            v[ele - \\'a\\']++;\\n        }\\n        string res = \"\";\\n        int c = 0;\\n        for(int i = 25; i >= 0; i--)\\n        {\\n            while(v[i] > 0)\\n            {\\n                if(c < limit)\\n                {\\n                    res += i + \\'a\\';\\n                    c++;\\n                    v[i]--;\\n                }\\n                else \\n                {\\n                    if(v[i] > 0)\\n                    {\\n                        backInd = i;\\n                        rem = true;\\n                        break;\\n                    }\\n                }\\n                if(rem)\\n                {\\n                    c = 0;\\n                    i = backInd;\\n                    rem = false;\\n                    \\n                }\\n                \\n                    \\n            }\\n            c = 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int n = s.length();\\n        bool rem = false;\\n        int backInd = 0;\\n        vector<int>v(26,0);\\n        for(auto ele : s)\\n        {\\n            v[ele - \\'a\\']++;\\n        }\\n        string res = \"\";\\n        int c = 0;\\n        for(int i = 25; i >= 0; i--)\\n        {\\n            while(v[i] > 0)\\n            {\\n                if(c < limit)\\n                {\\n                    res += i + \\'a\\';\\n                    c++;\\n                    v[i]--;\\n                }\\n                else \\n                {\\n                    if(v[i] > 0)\\n                    {\\n                        backInd = i;\\n                        rem = true;\\n                        break;\\n                    }\\n                }\\n                if(rem)\\n                {\\n                    c = 0;\\n                    i = backInd;\\n                    rem = false;\\n                    \\n                }\\n                \\n                    \\n            }\\n            c = 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826912,
                "title": "2182-python-priority-queue-heap-technique-explanation",
                "content": "Here are some questions that I used the same technique:\\n\\n- https://leetcode.com/problems/reorganize-string/discuss/1826921/767.-Priority-Queue-Heap-Technique-Explanation\\n- https://leetcode.com/problems/longest-happy-string/discuss/1826917/1405.-Priority-Queue-Heap-Technique-Explanation\\n\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n       \\n        \\n        seen = collections.Counter(s) #Put in dictionary \\n        \\n        \\n        heap = []\\n        heapq.heapify(heap)\\n        \\n        #heap push\\n        for key, value in seen.items():\\n            \\n            heapq.heappush(heap, (-ord(key), value)) #Max heap push {-99:2}\\n            \\n        output = \"\"\\n        \\n        \\n        while len(heap) > 0:\\n            \\n            char, count = heapq.heappop(heap) #Heap pop max\\n            \\n            if len(output) > 0 and output[-1] == chr(-char): #if the new char is same as prev in output\\n                if len(heap) > 0:\\n                    nextChar, nextCount = heapq.heappop(heap) #Heap pop next most char\\n                   \\n                    output = output + chr(-nextChar)  #Only use it once\\n                    new_second_count = nextCount - 1\\n                   \\n                    if new_second_count > 0: #Heap push second max back to heap\\n                        heapq.heappush(heap, (nextChar, new_second_count))\\n               \\n                else:\\n                    break\\n            \\n            fill = min(count, repeatLimit) \\n            output = output + (chr(-char) * fill) #Still add the max char to output\\n            new_count = count - fill\\n            \\n            if new_count > 0:\\n                heapq.heappush(heap, (char, new_count)) #Heap push max back to heap\\n                \\n        return output\\n    \\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n       \\n        \\n        seen = collections.Counter(s) #Put in dictionary \\n        \\n        \\n        heap = []\\n        heapq.heapify(heap)\\n        \\n        #heap push\\n        for key, value in seen.items():\\n            \\n            heapq.heappush(heap, (-ord(key), value)) #Max heap push {-99:2}",
                "codeTag": "Java"
            },
            {
                "id": 1818350,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int m=repeatLimit;\\n        sort(s.rbegin(),s.rend());\\n        int n=s.size();\\n        int a[26]={0};\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        string ss=\"\";\\n        for (int i = 25; i >-1; i--)\\n    {\\n        int p= a[i];\\n        while (p > 0)\\n        {\\n            for (int j = 0; j < min(a[i], m); j++)\\n            {\\n                ss+=\\'a\\'+i;\\n                p--;\\n            }\\n            if (p> 0)\\n            {\\n                bool flag = true;\\n                for (int j = i - 1; j >= 0; j--)\\n                {\\n                    if (a[j] != 0)\\n                    {\\n                        flag = false;\\n                        ss+=\\'a\\'+j;\\n                        a[j]--;\\n                        break;\\n                    }\\n                }\\n\\n                if (flag==true){\\n                    a[i]=p;\\n                    break;\\n                }\\n            }\\n            a[i] = p;\\n        }\\n    }\\n        return ss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int m=repeatLimit;\\n        sort(s.rbegin(),s.rend());\\n        int n=s.size();\\n        int a[26]={0};\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        string ss=\"\";\\n        for (int i = 25; i >-1; i--)\\n    {\\n        int p= a[i];\\n        while (p > 0)\\n        {\\n            for (int j = 0; j < min(a[i], m); j++)\\n            {\\n                ss+=\\'a\\'+i;\\n                p--;\\n            }\\n            if (p> 0)\\n            {\\n                bool flag = true;\\n                for (int j = i - 1; j >= 0; j--)\\n                {\\n                    if (a[j] != 0)\\n                    {\\n                        flag = false;\\n                        ss+=\\'a\\'+j;\\n                        a[j]--;\\n                        break;\\n                    }\\n                }\\n\\n                if (flag==true){\\n                    a[i]=p;\\n                    break;\\n                }\\n            }\\n            a[i] = p;\\n        }\\n    }\\n        return ss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813743,
                "title": "c-elegant-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) {\\n        priority_queue<pair<char, int>> pq; //max heap priotiy queue\\n        int freq[26] = {0};\\n        for(auto& x: s) //to store all the elements in the priority queue, we need frequencies.\\n            freq[x-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++)\\n            if(freq[i] > 0)\\n                pq.push({i+\\'a\\', freq[i]});\\n        //now max heap contains the string elements with their frequencies.\\n        string ans=\"\";\\n        while(!pq.empty())\\n        {\\n            auto[ch, ct] = pq.top();  //pop out the largest lexicographical element.  \\n            pq.pop();\\n            string temp(min(ct, k), ch); //min(ct, k) because of the repeat limit.\\n            if(ct > k && !pq.empty())\\n            {\\n                auto[x, y] = pq.top();  //if ct > k, we need the second largest element to appear \\n                pq.pop();\\n                temp += x;\\n                y--;\\n                if(y>0)  //if second largest element has only one occurance, we don\\'t repush it.\\n                    pq.push({x, y});\\n                \\n                pq.push({ch, ct-k}); //we push the largest element wiht the remaining freq.\\n            }\\n            ans += temp;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int k) {\\n        priority_queue<pair<char, int>> pq; //max heap priotiy queue\\n        int freq[26] = {0};\\n        for(auto& x: s) //to store all the elements in the priority queue, we need frequencies.\\n            freq[x-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++)\\n            if(freq[i] > 0)\\n                pq.push({i+\\'a\\', freq[i]});\\n        //now max heap contains the string elements with their frequencies.\\n        string ans=\"\";\\n        while(!pq.empty())\\n        {\\n            auto[ch, ct] = pq.top();  //pop out the largest lexicographical element.  \\n            pq.pop();\\n            string temp(min(ct, k), ch); //min(ct, k) because of the repeat limit.\\n            if(ct > k && !pq.empty())\\n            {\\n                auto[x, y] = pq.top();  //if ct > k, we need the second largest element to appear \\n                pq.pop();\\n                temp += x;\\n                y--;\\n                if(y>0)  //if second largest element has only one occurance, we don\\'t repush it.\\n                    pq.push({x, y});\\n                \\n                pq.push({ch, ct-k}); //we push the largest element wiht the remaining freq.\\n            }\\n            ans += temp;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794194,
                "title": "a-few-solutions",
                "content": "Construct the output string `t` from processing the input string `s`.  Use a map `m` to count each character `c` in `s`, then cherry-pick each lexicographically largest candidate until the valid candidates are exhausted.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun repeatLimitedString(s: String, K: Int): String {\\n        var t = mutableListOf<Char>()\\n        var m = s.toCharArray().toList().groupingBy{ it.toInt() }.eachCount().toMutableMap()\\n        var (last, run) = Pair(0, 0)\\n        var ok = true\\n        while (ok) {\\n            ok = false\\n            for (x in 122 downTo 97) {\\n                if (!m.contains(x) || (last == x && run == K))\\n                    continue\\n                ok = true\\n                t.add(x.toChar())\\n                run = if (last == x) 1 + run else 1; last = x\\n                m[x] = m[x]!! - 1\\n                if (m[x] == 0)\\n                    m.remove(x)\\n                break\\n            }\\n        }\\n        return t.joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet repeatLimitedString = (s, K, m = new Map(), t = [], last = \\'0\\', run = 0) => {\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    let ok = false;\\n    do {\\n        ok = false;\\n        for (let x = 122; 97 <= x && !ok; --x) {\\n            let c = String.fromCharCode(x);\\n            if (!m.has(c) || (last == c && run == K))\\n                continue;\\n            ok = true;\\n            run = last == c ? 1 + run : 1, t.push(c), last = c\\n            m.set(c, -1 + m.get(c));\\n            if (!m.get(c))\\n                m.delete(c);\\n        }\\n    } while (ok);\\n    return t.join(\\'\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, K: int, last = \\'\\\\0\\', run = 0) -> str:\\n        t = []\\n        m = Counter(s)\\n        while True:\\n            ok = False\\n            for x in range(122, 97 - 1, -1):\\n                c = chr(x)\\n                if c not in m or (last == c and run == K):\\n                    continue\\n                ok = True\\n                t.append(c); run = 1 + run if last == c else 1; last = c\\n                m[c] -= 1\\n                if not m[c]:\\n                    del m[c]\\n                break\\n            if not ok:\\n                break\\n        return \\'\\'.join(t)\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn repeat_limited_string(s: String, K: i32) -> String {\\n        let mut t: Vec<char> = vec![];\\n        let mut m = HashMap::<u32, usize>::new();\\n        for c in s.chars().into_iter() {\\n            let x = c as u32;\\n            let entry = m.entry(x).or_insert(0); *entry += 1;\\n        }\\n        let (mut last, mut run) = (0 as u32, 0);\\n        let mut ok = true;\\n        while ok {\\n            ok = false;\\n            for c in (b\\'a\\'..=b\\'z\\').rev() {\\n                let x = c as u32;\\n                if !m.contains_key(&x) || (last == x && run == K) {\\n                    continue;\\n                }\\n                ok = true;\\n                run = 1 + if last == x { run } else { 0 };\\n                last = x;\\n                if let Some(ch) = char::from_u32(x) {\\n                    t.push(ch);\\n                }\\n                let entry = m.entry(x).or_insert(1); *entry -= 1;\\n                if (*entry == 0) {\\n                    m.remove(&x);\\n                }\\n                break;\\n            }\\n        }\\n        return t.iter().collect::<String>();\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    string repeatLimitedString(string s, int K, Map m = {}, char last = \\'\\\\0\\', int run = 0, string t = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        auto ok = false;\\n        do {\\n            ok = false;\\n            for (auto c{ \\'z\\' }; \\'a\\' <= c && !ok; --c) {\\n                if (!m[c] || (last == c && run == K))\\n                    continue;\\n                ok = true;\\n                t.push_back(c), run = last == c ? 1 + run : 1, last = c;\\n                if (!--m[c])\\n                    m.erase(c);\\n            }\\n        } while (ok);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun repeatLimitedString(s: String, K: Int): String {\\n        var t = mutableListOf<Char>()\\n        var m = s.toCharArray().toList().groupingBy{ it.toInt() }.eachCount().toMutableMap()\\n        var (last, run) = Pair(0, 0)\\n        var ok = true\\n        while (ok) {\\n            ok = false\\n            for (x in 122 downTo 97) {\\n                if (!m.contains(x) || (last == x && run == K))\\n                    continue\\n                ok = true\\n                t.add(x.toChar())\\n                run = if (last == x) 1 + run else 1; last = x\\n                m[x] = m[x]!! - 1\\n                if (m[x] == 0)\\n                    m.remove(x)\\n                break\\n            }\\n        }\\n        return t.joinToString(\"\")\\n    }\\n}\\n```\n```\\nlet repeatLimitedString = (s, K, m = new Map(), t = [], last = \\'0\\', run = 0) => {\\n    for (let c of s)\\n        m.set(c, 1 + (m.get(c) || 0));\\n    let ok = false;\\n    do {\\n        ok = false;\\n        for (let x = 122; 97 <= x && !ok; --x) {\\n            let c = String.fromCharCode(x);\\n            if (!m.has(c) || (last == c && run == K))\\n                continue;\\n            ok = true;\\n            run = last == c ? 1 + run : 1, t.push(c), last = c\\n            m.set(c, -1 + m.get(c));\\n            if (!m.get(c))\\n                m.delete(c);\\n        }\\n    } while (ok);\\n    return t.join(\\'\\');\\n};\\n```\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, K: int, last = \\'\\\\0\\', run = 0) -> str:\\n        t = []\\n        m = Counter(s)\\n        while True:\\n            ok = False\\n            for x in range(122, 97 - 1, -1):\\n                c = chr(x)\\n                if c not in m or (last == c and run == K):\\n                    continue\\n                ok = True\\n                t.append(c); run = 1 + run if last == c else 1; last = c\\n                m[c] -= 1\\n                if not m[c]:\\n                    del m[c]\\n                break\\n            if not ok:\\n                break\\n        return \\'\\'.join(t)\\n```\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn repeat_limited_string(s: String, K: i32) -> String {\\n        let mut t: Vec<char> = vec![];\\n        let mut m = HashMap::<u32, usize>::new();\\n        for c in s.chars().into_iter() {\\n            let x = c as u32;\\n            let entry = m.entry(x).or_insert(0); *entry += 1;\\n        }\\n        let (mut last, mut run) = (0 as u32, 0);\\n        let mut ok = true;\\n        while ok {\\n            ok = false;\\n            for c in (b\\'a\\'..=b\\'z\\').rev() {\\n                let x = c as u32;\\n                if !m.contains_key(&x) || (last == x && run == K) {\\n                    continue;\\n                }\\n                ok = true;\\n                run = 1 + if last == x { run } else { 0 };\\n                last = x;\\n                if let Some(ch) = char::from_u32(x) {\\n                    t.push(ch);\\n                }\\n                let entry = m.entry(x).or_insert(1); *entry -= 1;\\n                if (*entry == 0) {\\n                    m.remove(&x);\\n                }\\n                break;\\n            }\\n        }\\n        return t.iter().collect::<String>();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    string repeatLimitedString(string s, int K, Map m = {}, char last = \\'\\\\0\\', int run = 0, string t = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        auto ok = false;\\n        do {\\n            ok = false;\\n            for (auto c{ \\'z\\' }; \\'a\\' <= c && !ok; --c) {\\n                if (!m[c] || (last == c && run == K))\\n                    continue;\\n                ok = true;\\n                t.push_back(c), run = last == c ? 1 + run : 1, last = c;\\n                if (!--m[c])\\n                    m.erase(c);\\n            }\\n        } while (ok);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790684,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        \\n        \\n        Queue<Character> qe=  new PriorityQueue<>((a,b)->b-a);\\n        int ch[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int tmp=s.charAt(i)-\\'a\\';\\n            ch[tmp]++;\\n            if(ch[tmp]==1)\\n                qe.add(s.charAt(i));\\n                \\n        }\\n        StringBuilder ans=new StringBuilder();\\n        while(qe.size()>0)\\n        {\\n            char c=qe.poll();\\n            int count=0;\\n            while(ch[c-\\'a\\']>0 && count<repeatLimit)\\n            {\\n                ans.append(c);\\n                count++;\\n                ch[c-\\'a\\']--;\\n            }\\n            if(ch[c-\\'a\\']>0 && qe.size()>0)\\n            {\\n                char p=qe.peek();\\n                ans.append(p);\\n                ch[p-\\'a\\']--;\\n                if(ch[p-\\'a\\']==0)\\n                    qe.poll();\\n                qe.add(c);\\n            }\\n        }\\n        return ans.toString();\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        \\n        \\n        Queue<Character> qe=  new PriorityQueue<>((a,b)->b-a);\\n        int ch[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int tmp=s.charAt(i)-\\'a\\';\\n            ch[tmp]++;\\n            if(ch[tmp]==1)\\n                qe.add(s.charAt(i));\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1790514,
                "title": "c-100-solution-concise-greedy-solution-with-description",
                "content": "```\\nTime: O(N)\\nSpace O(1)  or O(26)\\n```\\n\\n```\\nRuntime:  40 ms, faster than 99.96% of C++ online submissions\\nMemory Usage: 22.1 MB, less than 95.74% of C++ online submissions \\n```\\n\\nThere are 2 parts, (A) Count the number of each character (B) Construct the output string (Greedy)\\n\\nNow, let us focus on the second part. We call it greedy because at each step we try to use as many characters as possible. We explain the main idea with an example \"aaaaaabbbbcccc\" and limit=2.\\n\\nFirst, we deal with \"c\", there are 4 of  \"c\" and limit is 2. The TRICKY part is to construct the target with \"holes\" as denoted with \"~\" in the following:\\n`\"cc~cc\"`\\n\\nSecond, we deal with \"b\", there are 4 of \"b\"\\nPhase 1: fill holes\\n`\"ccbcc\"`\\nPhase 2: increase following the same greedy idea\\n`\"ccbccbb~b\"`\\n\\nLast, we deal with \"a\", there are 5 of \"a\"\\nPhase 1: fill holes\\n`\"ccbccbbab\"`\\nPhase 2: increase following the same greedy idea\\n`\"ccbccbbabaa~aa~a\"`\\n\\nFinally, we use all characters. It means that no more holes can be filled. As a result, we just cut at the **first** hole and return what is left.\\n\\nOf course, it needs skill to keep tracking of holes in the target string. I have prepared an example c++ code in the following, which is quite efficient according to the result.\\n\\nHave fun!\\n\\n```\\n//*NOTE*\\n//You can recover lines of outputing codes to check how it works. \\n\\nchar buf[200001];\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int a=0, b=0, n=s.size(), cnt[26]={0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0};\\n        const char * c=s.c_str();\\n        for(int i=0; i<n; ++cnt[c[i++]-\\'a\\']) {}\\n        for(int k=25, m; k>=0; --k) {\\n            //phase 1: fill previous holes\\n            for(; cnt[k] && a<b; --cnt[k], a+=repeatLimit+1) {\\n                buf[a]=\\'a\\'+k;\\n            }\\n            if(cnt[k]) {\\n                //phase 2: increase with limit\\n                for(a=b+repeatLimit, m=0; cnt[k]; --cnt[k]) {\\n                    if(m++==repeatLimit) {\\n                        m=1;\\n                        ++b;\\n                        // buf[b]=\\' \\';\\n                    }\\n                    buf[b++]=\\'a\\'+k;\\n                }\\n                // buf[b]=\\'\\\\0\\';\\n            }\\n            a=min(a, b);\\n            // cout<<k<<\":\"<<buf<<\" | a=\"<<a<<\",b=\"<<b<<\"\\\\n\";\\n        }\\n        buf[a]=\\'\\\\0\\';\\n        return buf;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nTime: O(N)\\nSpace O(1)  or O(26)\\n```\n```\\nRuntime:  40 ms, faster than 99.96% of C++ online submissions\\nMemory Usage: 22.1 MB, less than 95.74% of C++ online submissions \\n```\n```\\n//*NOTE*\\n//You can recover lines of outputing codes to check how it works. \\n\\nchar buf[200001];\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int a=0, b=0, n=s.size(), cnt[26]={0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0};\\n        const char * c=s.c_str();\\n        for(int i=0; i<n; ++cnt[c[i++]-\\'a\\']) {}\\n        for(int k=25, m; k>=0; --k) {\\n            //phase 1: fill previous holes\\n            for(; cnt[k] && a<b; --cnt[k], a+=repeatLimit+1) {\\n                buf[a]=\\'a\\'+k;\\n            }\\n            if(cnt[k]) {\\n                //phase 2: increase with limit\\n                for(a=b+repeatLimit, m=0; cnt[k]; --cnt[k]) {\\n                    if(m++==repeatLimit) {\\n                        m=1;\\n                        ++b;\\n                        // buf[b]=\\' \\';\\n                    }\\n                    buf[b++]=\\'a\\'+k;\\n                }\\n                // buf[b]=\\'\\\\0\\';\\n            }\\n            a=min(a, b);\\n            // cout<<k<<\":\"<<buf<<\" | a=\"<<a<<\",b=\"<<b<<\"\\\\n\";\\n        }\\n        buf[a]=\\'\\\\0\\';\\n        return buf;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1788703,
                "title": "c-easy-to-understand-accepted",
                "content": "Steps to solve the problem.\\n\\n1) Get all the alhpabets that are in the input string and see how many time do they repeat, create a dictionary/hash map.\\n2) Sort the above dictionary or create a sorted list (Z,Y,X.....) which can be used to insert the items in new string. For lexicographically larger string we need to insert the last alphabets first eg. **ZZZYYKKM...**  This list will be used to iterate throught the above created dictionary and then insert in the new string.\\n3) Insert the first element in the new string and decrease the no of alphabets left. Keep on doing this for a particular alphabet untill all the instances of that alphabet are used or until the repeated limit is reached.\\n4) If all the repetaed instances are use then just delete that entry from the dictionary (as we have used all the instances).\\n5) If there still some isntances left but we reach the repeated limit then we take the next element in the sorted list eg. if the repeated limit is 2 we start with **ZZ** then we take next element **X** and then we again go back to Z as for lexigraphically long the last alphabet has more priority.\\n6) We keep on repeating the above steps till all the alphabets are used.\\n\\n```\\nstring RepeatLimitedString(string s, int repeatLimit)\\n        {\\n            List<char> newString = new List<char>();\\n            Dictionary<char, int> noOfAlphabets = new Dictionary<char, int>();\\n            foreach (var c in s)\\n            {\\n                if (noOfAlphabets.ContainsKey(c))\\n                {\\n                    noOfAlphabets[c]++;\\n                }\\n                else\\n                {\\n                    noOfAlphabets[c] = 1;\\n                }\\n            }\\n\\n            var sortedChars = noOfAlphabets.Keys.ToList();\\n            sortedChars.Sort();//A....Z\\n            sortedChars.Reverse(); //Z....A\\n\\n            int i = 0;\\n            int currentCharRepeatedLimit = 0;\\n\\n            while (sortedChars.Count != 0)\\n            {\\n                if (noOfAlphabets.ContainsKey(sortedChars[i]) && noOfAlphabets[sortedChars[i]] > 0 && currentCharRepeatedLimit < repeatLimit)\\n                {\\n                    newString.Add(sortedChars[i]);\\n                    noOfAlphabets[sortedChars[i]]--;\\n                    currentCharRepeatedLimit++;\\n\\n                    if (noOfAlphabets[sortedChars[i]] == 0)//All instances of alphabet are used \\n                    {\\n                        noOfAlphabets.Remove(sortedChars[i]);\\n                        sortedChars.Remove(sortedChars[i]);\\n                        currentCharRepeatedLimit = 0;\\n                    }\\n\\n                    if (i > 0 && noOfAlphabets.ContainsKey(sortedChars[i - 1]) && noOfAlphabets[sortedChars[i - 1]] != 0)//If there is alphabet still at the previous index i.e 0 , then use it to get the lexicographically larger string\\n                    {\\n                        i--;\\n                        currentCharRepeatedLimit = 0;\\n                    }\\n                }\\n                else // Some instances are still left for the char[i] but the repeated limit is reached then go to next alphabet\\n                {\\n                    i++;\\n                    currentCharRepeatedLimit = 0;\\n                }\\n            }\\n\\n            return string.Join(\"\", newString);\\n        }\\n\\t\\t```\\n\\t\\t\\nPlease provide any improvement or any issue you find with this code.\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nstring RepeatLimitedString(string s, int repeatLimit)\\n        {\\n            List<char> newString = new List<char>();\\n            Dictionary<char, int> noOfAlphabets = new Dictionary<char, int>();\\n            foreach (var c in s)\\n            {\\n                if (noOfAlphabets.ContainsKey(c))\\n                {\\n                    noOfAlphabets[c]++;\\n                }\\n                else\\n                {\\n                    noOfAlphabets[c] = 1;\\n                }\\n            }\\n\\n            var sortedChars = noOfAlphabets.Keys.ToList();\\n            sortedChars.Sort();//A....Z\\n            sortedChars.Reverse(); //Z....A\\n\\n            int i = 0;\\n            int currentCharRepeatedLimit = 0;\\n\\n            while (sortedChars.Count != 0)\\n            {\\n                if (noOfAlphabets.ContainsKey(sortedChars[i]) && noOfAlphabets[sortedChars[i]] > 0 && currentCharRepeatedLimit < repeatLimit)\\n                {\\n                    newString.Add(sortedChars[i]);\\n                    noOfAlphabets[sortedChars[i]]--;\\n                    currentCharRepeatedLimit++;\\n\\n                    if (noOfAlphabets[sortedChars[i]] == 0)//All instances of alphabet are used \\n                    {\\n                        noOfAlphabets.Remove(sortedChars[i]);\\n                        sortedChars.Remove(sortedChars[i]);\\n                        currentCharRepeatedLimit = 0;\\n                    }\\n\\n                    if (i > 0 && noOfAlphabets.ContainsKey(sortedChars[i - 1]) && noOfAlphabets[sortedChars[i - 1]] != 0)//If there is alphabet still at the previous index i.e 0 , then use it to get the lexicographically larger string\\n                    {\\n                        i--;\\n                        currentCharRepeatedLimit = 0;\\n                    }\\n                }\\n                else // Some instances are still left for the char[i] but the repeated limit is reached then go to next alphabet\\n                {\\n                    i++;\\n                    currentCharRepeatedLimit = 0;\\n                }\\n            }\\n\\n            return string.Join(\"\", newString);\\n        }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788556,
                "title": "python-beats-100-of-python3-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/68e0acfe-0b0d-46b1-b8bd-f5f52de36bba_1645434845.4794686.png)\\n\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        lst = sorted(list(s), reverse=True)\\n        cnt = 1\\n        j=0\\n        for i in range(1, len(lst)):\\n            if lst[i-1] == lst[i]:\\n                cnt+=1\\n                if cnt > repeatLimit:\\n                    j=max(j, i+1)\\n                    while j<len(lst):\\n                        if lst[j] != lst[i]:\\n                            lst[j], lst[i] = lst[i], lst[j]\\n                            cnt=1\\n                            break\\n                        j+=1\\n                    if j>=len(lst):\\n                        return \\'\\'.join(lst[:i])\\n            else:\\n              cnt = 1\\n        return \\'\\'.join(lst)\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/68e0acfe-0b0d-46b1-b8bd-f5f52de36bba_1645434845.4794686.png)\\n\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        lst = sorted(list(s), reverse=True)\\n        cnt = 1\\n        j=0\\n        for i in range(1, len(lst)):\\n            if lst[i-1] == lst[i]:\\n                cnt+=1\\n                if cnt > repeatLimit:\\n                    j=max(j, i+1)\\n                    while j<len(lst):\\n                        if lst[j] != lst[i]:\\n                            lst[j], lst[i] = lst[i], lst[j]\\n                            cnt=1\\n                            break\\n                        j+=1\\n                    if j>=len(lst):\\n                        return \\'\\'.join(lst[:i])\\n            else:\\n              cnt = 1\\n        return \\'\\'.join(lst)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1786741,
                "title": "c-fully-commented-with-o-n-time-complexity-and-o-1-space",
                "content": "class Solution {\\npublic:\\n    \\n    string repeatLimitedString(string s, int l) {\\n\\t\\tint m[26]; // variable for storing 26 characters\\n\\t\\n        for(char c:s)m[c-\\'a\\']++; // frequncy count;\\n        \\n        int i=25,j; //i-> last character ie., \\'z\\' \\n        \\n        string res=\"\"; //for storing ans \\n        \\n        while(i>=0){ // iterating to z-a characters \\n            int x=l;  // temparary variable for storing limit;\\n            \\n            while(m[i] && x){ //if character remain in our map && x has value more than 0\\n                res+=(\\'a\\'+i); //appending the current character\\n                m[i]--; //reducing the frequency count\\n                x--; //reducing the limit as well\\n            }\\n            \\n            if(m[i]){ // current character still has more frequency to come again\\n                int j=i-1; //hence pointing the next character which is less than the current character;\\n                \\n                while(j>=0 && m[j]==0) // after this loop j will be a valid chacter which has frequency;\\n                    j--;\\n                \\n                if(j>=0){ //if valid character exist then \\n                    res+=(\\'a\\'+j); // add that valid character\\n                    m[j]--; //and reduce its frequency\\n                }\\n                else //if j has value less than 0 implies no valid character exist as character can be in range [0, 25]\\n                    break;\\n            }\\n            if(!m[i]) //if that current character has no value then decrement it\\n                i--;\\n        }\\n        return res;\\n        \\n        // time complexity -> O( 26*N ) == O(N) , where N is the size of string;\\n        // space complexity -> O(1) \\n    }\\n};\\n\\n**if you find it helpful please upvote**\\n**Time complexity -> O( 26*N ) == O(N) , where N is the size of string;\\n space complexity -> O(1)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string repeatLimitedString(string s, int l) {\\n\\t\\tint m[26]; // variable for storing 26 characters\\n\\t\\n        for(char c:s)m[c-\\'a\\']++; // frequncy count;\\n        \\n        int i=25,j; //i-> last character ie., \\'z\\' \\n        \\n        string res=\"\"; //for storing ans \\n        \\n        while(i>=0){ // iterating to z-a characters \\n            int x=l;  // temparary variable for storing limit;\\n            \\n            while(m[i] && x){ //if character remain in our map && x has value more than 0\\n                res+=(\\'a\\'+i); //appending the current character\\n                m[i]--; //reducing the frequency count\\n                x--; //reducing the limit as well\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786552,
                "title": "c-solution-using-hashmap-and-greedy-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int l) {\\n        map<char,int>mp;\\n        for(auto i:s)\\n            mp[i]++;\\n        s=\"\";\\n        int flag=0;\\n        auto itr=mp.rbegin();\\n        \\n        while(itr!=mp.rend())\\n        {\\n            if(flag==1)\\n                break;\\n            \\n            while(flag==0&&itr->second>l)\\n                {\\n                    int lt=l;\\n                    while(lt--)\\n                        s+=itr->first;\\n                    itr->second-=l;\\n                    auto it=itr;\\n                    it++;\\n                    while(it!=mp.rend()&&it->second==0)\\n                        it++;\\n                    if(it==mp.rend())\\n                    {\\n                        flag=1;\\n                        break;\\n                    }    \\n                    s+=it->first;\\n                    it->second--;\\n                }\\n            if(flag==0&&itr->second<=l)\\n            {\\n                while(itr->second--)\\n                    s+=itr->first;\\n                itr++;\\n            }\\n        }\\n       return s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int l) {\\n        map<char,int>mp;\\n        for(auto i:s)\\n            mp[i]++;\\n        s=\"\";\\n        int flag=0;\\n        auto itr=mp.rbegin();\\n        \\n        while(itr!=mp.rend())\\n        {\\n            if(flag==1)\\n                break;\\n            \\n            while(flag==0&&itr->second>l)\\n                {\\n                    int lt=l;\\n                    while(lt--)\\n                        s+=itr->first;\\n                    itr->second-=l;\\n                    auto it=itr;\\n                    it++;\\n                    while(it!=mp.rend()&&it->second==0)\\n                        it++;\\n                    if(it==mp.rend())\\n                    {\\n                        flag=1;\\n                        break;\\n                    }    \\n                    s+=it->first;\\n                    it->second--;\\n                }\\n            if(flag==0&&itr->second<=l)\\n            {\\n                while(itr->second--)\\n                    s+=itr->first;\\n                itr++;\\n            }\\n        }\\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786236,
                "title": "c-java-python-greedy-o-n-complexity-o-1-space",
                "content": "C++\\n```\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> freq(26, 0);\\n        for( auto &c : s) ++freq[c -\\'a\\'];\\n            \\n        string ret;\\n        int count = 0, last = -1;\\n        bool found = true;\\n        while( found ) {\\n            found = false;\\n            for( int i=25; i>=0 && !found; --i ) {\\n                if( freq[i]>0 && (count<repeatLimit || last!=i) ) {\\n                    ret += \\'a\\' + i;\\n                    ++count; --freq[i];\\n                    if( last!=i ) count = 1;\\n                    last = i;\\n                    found = true;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n```\\nJava:\\n```\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int freq[] = new int[26];\\n        for (char c : s.toCharArray())\\n            freq[c - \\'a\\']++;\\n        StringBuilder ret = new StringBuilder();\\n        int count = 0, last = -1;\\n        boolean found = true;\\n        while( found ) {\\n            found = false;\\n            for( int i=25; i>=0 && !found; --i ) {\\n                if( freq[i]>0 && (count<repeatLimit || last!=i) ) {\\n                    ret.append((char)(\\'a\\' + i));\\n                    ++count; --freq[i];\\n                    if( last!=i ) count = 1;\\n                    last = i;\\n                    found = true;\\n                }\\n            }\\n        }\\n        return ret.toString();\\n    }\\n```\\n\\nPython:\\n```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        freq = [0] * 26\\n        a = ord(\\'a\\')\\n        \\n        for c in s:\\n            freq[ord(c)-a] += 1\\n        \\n        ret = []\\n        last = -1\\n        count = 0\\n        found = True\\n\\n        while found==True:\\n            found = False\\n            for i in range(25, -1, -1):\\n                if found==True:\\n                    break;\\n                found = False\\n                if freq[i]>0 and (count<repeatLimit or last!=i):\\n                    ret.append(chr(i+a))\\n                    count = count+1\\n                    freq[i] = freq[i]-1\\n                    if last!=i:\\n                        count=1\\n                    last = i\\n                    found = True\\n        return \\'\\'.join(ret)\\n\\t```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> freq(26, 0);\\n        for( auto &c : s) ++freq[c -\\'a\\'];\\n            \\n        string ret;\\n        int count = 0, last = -1;\\n        bool found = true;\\n        while( found ) {\\n            found = false;\\n            for( int i=25; i>=0 && !found; --i ) {\\n                if( freq[i]>0 && (count<repeatLimit || last!=i) ) {\\n                    ret += \\'a\\' + i;\\n                    ++count; --freq[i];\\n                    if( last!=i ) count = 1;\\n                    last = i;\\n                    found = true;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n```\n```\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int freq[] = new int[26];\\n        for (char c : s.toCharArray())\\n            freq[c - \\'a\\']++;\\n        StringBuilder ret = new StringBuilder();\\n        int count = 0, last = -1;\\n        boolean found = true;\\n        while( found ) {\\n            found = false;\\n            for( int i=25; i>=0 && !found; --i ) {\\n                if( freq[i]>0 && (count<repeatLimit || last!=i) ) {\\n                    ret.append((char)(\\'a\\' + i));\\n                    ++count; --freq[i];\\n                    if( last!=i ) count = 1;\\n                    last = i;\\n                    found = true;\\n                }\\n            }\\n        }\\n        return ret.toString();\\n    }\\n```\n```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        freq = [0] * 26\\n        a = ord(\\'a\\')\\n        \\n        for c in s:\\n            freq[ord(c)-a] += 1\\n        \\n        ret = []\\n        last = -1\\n        count = 0\\n        found = True\\n\\n        while found==True:\\n            found = False\\n            for i in range(25, -1, -1):\\n                if found==True:\\n                    break;\\n                found = False\\n                if freq[i]>0 and (count<repeatLimit or last!=i):\\n                    ret.append(chr(i+a))\\n                    count = count+1\\n                    freq[i] = freq[i]-1\\n                    if last!=i:\\n                        count=1\\n                    last = i\\n                    found = True\\n        return \\'\\'.join(ret)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1786235,
                "title": "c-o-n-time-and-space-using-normal-queue-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int n = s.size();\\n        string ans = string(n, \\'_\\');\\n        vector<int>count(26,0);\\n        for(char &i : s) count[i-\\'a\\']++;\\n        queue<int>q;\\n        int ind = 0;\\n        for(int i = 25; i >= 0; i--){\\n            int cur = 0;\\n            while(!q.empty() && count[i]){\\n                ans[q.front()] = i+\\'a\\';\\n                q.pop();\\n                count[i]--;\\n            }\\n            while(count[i]){\\n                if(ind >= n) break;\\n                if(cur == repeatLimit){\\n                    q.push(ind++);\\n                    cur = 0;\\n                }else{\\n                    ans[ind] = i+\\'a\\';\\n                    cur++;ind++;\\n                    count[i]--;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i ++){\\n            if(ans[i]==\\'_\\'){\\n                ans.erase(i+ans.begin(), ans.end());\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int n = s.size();\\n        string ans = string(n, \\'_\\');\\n        vector<int>count(26,0);\\n        for(char &i : s) count[i-\\'a\\']++;\\n        queue<int>q;\\n        int ind = 0;\\n        for(int i = 25; i >= 0; i--){\\n            int cur = 0;\\n            while(!q.empty() && count[i]){\\n                ans[q.front()] = i+\\'a\\';\\n                q.pop();\\n                count[i]--;\\n            }\\n            while(count[i]){\\n                if(ind >= n) break;\\n                if(cur == repeatLimit){\\n                    q.push(ind++);\\n                    cur = 0;\\n                }else{\\n                    ans[ind] = i+\\'a\\';\\n                    cur++;ind++;\\n                    count[i]--;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i ++){\\n            if(ans[i]==\\'_\\'){\\n                ans.erase(i+ans.begin(), ans.end());\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786105,
                "title": "java-forever-priority-queue-max-heap-of-characters-with-frequency",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c: s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c: map.keySet()) {\\n            pq.add(new int[]{c - \\'a\\', map.get(c)});\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!pq.isEmpty()) {\\n            int[] tmp = pq.poll();\\n            char c = (char)(tmp[0] + (int)\\'a\\');\\n            int cnt = Math.min(repeatLimit, tmp[1]);\\n            while (cnt-- > 0) {\\n                sb.append(c);\\n            }\\n            if (tmp[1] > repeatLimit) {\\n                if (pq.isEmpty()) {\\n                    break;\\n                }\\n                int[] tmp2 = pq.poll();\\n                char c2 = (char)(tmp2[0] + (int)\\'a\\');\\n                sb.append(c2);\\n                tmp[1] -= repeatLimit;\\n                tmp2[1] -= 1;\\n                if (tmp[1] != 0) {\\n                    pq.add(tmp);\\n                } \\n                if (tmp2[1] != 0) {\\n                    pq.add(tmp2);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c: s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1786061,
                "title": "where-i-went-wrong-somebody-help",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int vis[26]={0};\\n        int n=s.length();\\n        string res=\"\";\\n        for(int i=0;i<n;i++){\\n            vis[s[i]-\\'a\\']++;\\n        }\\n        unordered_map<int,char> mp;\\n        for(int i=0;i<26;i++){\\n            mp[i]=i+\\'a\\';\\n        }\\n        stack< pair<int,int> > st;\\n        for(int i=0;i<26;i++){\\n            if(vis[i]>0){\\n                st.push({i,vis[i]});\\n            }\\n        }\\n        string re=\"\";\\n        while(!st.empty()){\\n            if(st.top().second<=repeatLimit){\\n                int p=st.top().second;\\n                while(p--){\\n                    res+=(mp[st.top().first]);\\n                }\\n                st.pop();\\n            }\\n            else{\\n                int p=st.top().second;\\n                int q=st.top().first;\\n                st.pop();\\n                int r=repeatLimit;\\n                while(r--){\\n                    res+=mp[q];\\n                }\\n                p=p-repeatLimit;\\n                if(st.empty()){\\n                    break;\\n                }\\n                else{\\n                    while(0==st.top().second && !st.empty()){\\n                        st.pop();\\n                    }\\n                    if(st.empty()){\\n                        break;\\n                    }\\n                    int a=st.top().first;\\n                    int b=st.top().second;\\n                    res=res+mp[a];\\n                    st.pop();\\n                    st.push({a,b-1});\\n                    \\n                }\\n                st.push({q,p});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int vis[26]={0};\\n        int n=s.length();\\n        string res=\"\";\\n        for(int i=0;i<n;i++){\\n            vis[s[i]-\\'a\\']++;\\n        }\\n        unordered_map<int,char> mp;\\n        for(int i=0;i<26;i++){\\n            mp[i]=i+\\'a\\';\\n        }\\n        stack< pair<int,int> > st;\\n        for(int i=0;i<26;i++){\\n            if(vis[i]>0){\\n                st.push({i,vis[i]});\\n            }\\n        }\\n        string re=\"\";\\n        while(!st.empty()){\\n            if(st.top().second<=repeatLimit){\\n                int p=st.top().second;\\n                while(p--){\\n                    res+=(mp[st.top().first]);\\n                }\\n                st.pop();\\n            }\\n            else{\\n                int p=st.top().second;\\n                int q=st.top().first;\\n                st.pop();\\n                int r=repeatLimit;\\n                while(r--){\\n                    res+=mp[q];\\n                }\\n                p=p-repeatLimit;\\n                if(st.empty()){\\n                    break;\\n                }\\n                else{\\n                    while(0==st.top().second && !st.empty()){\\n                        st.pop();\\n                    }\\n                    if(st.empty()){\\n                        break;\\n                    }\\n                    int a=st.top().first;\\n                    int b=st.top().second;\\n                    res=res+mp[a];\\n                    st.pop();\\n                    st.push({a,b-1});\\n                    \\n                }\\n                st.push({q,p});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786060,
                "title": "straightforward-c-implementation-greedy-o-n-time-with-o-1-space",
                "content": "We need to form a lexicographically largest string using the characters in the given string. However, we cannot use any char more than *repeatLimit* times continuously. \\n\\n**Intuition**:  Going with greedy approach, we go from *z* to *a*  and try to form the answer string. In case we have a character with a frequency higher than *repeatLimit* times, once we use *repeatLimit* times, we can use a character lexicographically smaller than the current character once, and then we can use the current character again for *repeatLimit* times.\\n\\nRefer comments for implementations details\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // get the previous  last char having remaining freq>0\\n    int getlast(int curr,vector<int> &v){\\n        \\n        for(int i=curr-1;i>=0;i--){\\n            if(v[i]) return i;\\n        }\\n        return -1;\\n    }\\n    string repeatLimitedString(string s, int limit) {\\n        \\n        vector<int> v(26,0);\\n        for(int i=0;i<s.size();i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        string ans=\"\";\\n\\n        for(int j=25;j>=0;j--){\\n            \\n                if(v[j]){\\n\\t\\t\\t\\t// using the current character min(freq(character,repeatlimit)) times\\n                    for(int i=0;i<limit && v[j];i++){\\n                        ans+=char(j+\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// decreasing the frequency of current character by one\\n                        v[j]--;\\n                    }\\n                    // if the frequency of the current character is still greater than 0\\n                    if(v[j]){\\n                        int last=getlast(j,v);\\n\\t\\t\\t\\t\\t\\t//  if we do not have any available character smaller than the current character, return \\n                        if(last==-1) return ans;\\n                        ans+=char(last+\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// decreasing the frequency of  the used character\\n                        v[last]--;\\n                        j++; \\n                    }\\n                }\\n            }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // get the previous  last char having remaining freq>0\\n    int getlast(int curr,vector<int> &v){\\n        \\n        for(int i=curr-1;i>=0;i--){\\n            if(v[i]) return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785866,
                "title": "construct-string-with-repeat-limit",
                "content": "class Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n           vector<int>freq(26,0);\\n            int n=s.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                    freq[s[i]-\\'a\\']++;\\n            }\\n            string ans=\"\";\\n            int curr=0;\\n            int index=-1;\\n            for(int i=25;i>=0;i--)\\n            {\\n               \\n                   if(freq[i]>0&&curr==0)\\n                   {\\n                           curr=freq[i];\\n                           if(curr<=repeatLimit)\\n                           {\\n                                   while(curr-->0)\\n                                           ans.push_back(i+\\'a\\');\\n                                   curr=0;\\n                                   \\n                           }\\n                           else if(curr>repeatLimit)\\n                           {\\n                                   for(int j=1;j<=repeatLimit;j++)\\n                                           ans.push_back(i+\\'a\\');\\n                                   curr-=repeatLimit;\\n                                   index=i;\\n                                   \\n                           }\\n                   }\\n                    else\\n                    {\\n                            if(freq[i]>0&&curr!=0)\\n                            {\\n                                  \\n                               \\n                                    int yet=freq[i];\\n                                    while(yet&&curr)\\n                                    {\\n                                            yet--;\\n                                            ans.push_back(i+\\'a\\');\\n                                            if(curr<=repeatLimit)\\n                                            {\\n                                                    for(int j=1;j<=curr;j++)\\n                                                            ans.push_back(index+\\'a\\');\\n                                                    curr=0;\\n                                            }\\n                                            else\\n                                            {\\n                                                     for(int j=1;j<=repeatLimit;j++)\\n                                                            ans.push_back(index+\\'a\\');\\n                                                    curr-=repeatLimit;\\n                                                    \\n                                            }\\n                                    }\\n                                  \\n                                    if(yet>0)\\n                                    {\\n                                            if(yet<=repeatLimit)\\n                                            {\\n                                                 for(int j=1;j<=yet;j++)\\n                                                            ans.push_back(i+\\'a\\');\\n                                                    curr=0;\\n                                                    index=i;\\n                                                    yet=0;\\n                                            }\\n                                    else\\n                                    {\\n                                              for(int j=1;j<=repeatLimit;j++)\\n                                                            ans.push_back(i+\\'a\\');\\n                                                  yet-=repeatLimit;\\n                                           \\n                                    }\\n                                    }\\n                                    if(yet!=0)\\n                                    {\\n                                            curr=yet;\\n                                            index=i;\\n                                    }\\n                                    \\n                                   \\n                            }\\n                    }\\n                  \\n                    \\n            }\\n            char ch=ans.back();\\n            int count=0;\\n           cout<<index<<endl;\\n            cout<<curr<<endl;\\n        \\n\\n            if(curr>=0)\\n            {\\n             \\n                   if(curr<=repeatLimit)\\n                   {\\n                           if(ans.back()!=index+\\'a\\')\\n                           \\n                           for(int i=1;i<=curr;i++)\\n                                   ans.push_back(index+\\'a\\');\\n                   }\\n                    else if(curr>repeatLimit)\\n                    {\\n                           if(ans.back()!=index+\\'a\\')\\n                            for(int k=1;k<=repeatLimit;k++)ans.push_back(index+\\'a\\');\\n                    }\\n                    else\\n                    {\\n                      count++;      \\n                    }\\n                    \\n           }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n           vector<int>freq(26,0);\\n            int n=s.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                    freq[s[i]-\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785755,
                "title": "c-code-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int mem[26];\\n        memset(mem, 0, sizeof(mem));\\n        for (auto c : s) {\\n            mem[c - \\'a\\']++;\\n        }\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < 26 ; i++) {\\n            if (!mem[i]) continue;\\n            pq.push(make_pair(i, mem[i]));\\n        }\\n        \\n        string res =\"\";\\n        while (!pq.empty()) {\\n            auto p = pq.top(); pq.pop();\\n            auto tmp = p;\\n            bool flag = false;\\n            if (res.size() && p.first + \\'a\\' == res.back()) {\\n                if (pq.empty()) break;\\n                tmp = pq.top(); pq.pop();\\n                swap(tmp, p);\\n                flag = true;\\n            }\\n            int nb = 0;\\n            nb = flag ? 1 : min(p.second,repeatLimit); \\n\\n            for (int i = 0; i < nb; i++) {\\n                res += (p.first + \\'a\\');\\n            }\\n            p.second -= nb;\\n            if (p.second > 0) pq.push(p);\\n            \\n            if (p.first != tmp.first) {\\n                pq.push(tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int mem[26];\\n        memset(mem, 0, sizeof(mem));\\n        for (auto c : s) {\\n            mem[c - \\'a\\']++;\\n        }\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < 26 ; i++) {\\n            if (!mem[i]) continue;\\n            pq.push(make_pair(i, mem[i]));\\n        }\\n        \\n        string res =\"\";\\n        while (!pq.empty()) {\\n            auto p = pq.top(); pq.pop();\\n            auto tmp = p;\\n            bool flag = false;\\n            if (res.size() && p.first + \\'a\\' == res.back()) {\\n                if (pq.empty()) break;\\n                tmp = pq.top(); pq.pop();\\n                swap(tmp, p);\\n                flag = true;\\n            }\\n            int nb = 0;\\n            nb = flag ? 1 : min(p.second,repeatLimit); \\n\\n            for (int i = 0; i < nb; i++) {\\n                res += (p.first + \\'a\\');\\n            }\\n            p.second -= nb;\\n            if (p.second > 0) pq.push(p);\\n            \\n            if (p.first != tmp.first) {\\n                pq.push(tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785532,
                "title": "java-priority-queue-o-n-log-n",
                "content": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n       Map<Character,Integer> map = new HashMap<>();\\n       for(char c : s.toCharArray()){\\n           map.put(c,map.getOrDefault(c,0)+1);\\n       } \\n                \\n       PriorityQueue<Pair> maxHeap = new PriorityQueue<>((Pair a,Pair b)->b.key-a.key);\\n       for(Map.Entry<Character,Integer> entry : map.entrySet()){\\n           Character key = entry.getKey();\\n           Integer value = entry.getValue();\\n           maxHeap.add(new Pair(key,value));\\n       } \\n        \\n       StringBuilder res = new StringBuilder(); \\n       while(maxHeap.size()>0){\\n          Pair pair = maxHeap.poll();         \\n \\n          int count = pair.val; \\n           \\n          for(int i=0;i<repeatLimit && count>0;i++){\\n              res.append(pair.key);\\n              count--;\\n          }\\n           \\n          if(count>0 && maxHeap.size()>0){\\n                Pair nextPair = maxHeap.poll();\\n                res.append(nextPair.key);\\n                if(nextPair.val>1){\\n                   maxHeap.add(new Pair(nextPair.key,nextPair.val-1)); \\n                } \\n                maxHeap.add(new Pair(pair.key,count)); \\n              \\n          }\\n       }\\n        \\n       return res.toString(); \\n    }\\n    \\n    class Pair{\\n      char key;\\n      int val;\\n        \\n      Pair(char key,int val){\\n         this.key = key;\\n         this.val = val; \\n      }  \\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n       Map<Character,Integer> map = new HashMap<>();\\n       for(char c : s.toCharArray()){\\n           map.put(c,map.getOrDefault(c,0)+1);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1785455,
                "title": "c-easy-code-with-priority-queue-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        priority_queue<pair<char,int>>pq;\\n        \\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        /\\n        for(auto x:mp){\\n            pq.push({x.first,x.second});\\n        }\\n        char ch=\\'-\\';\\n        int cnt=0;\\n        string ans=\"\";\\n        while(!pq.empty()){\\n         pair<char,int>t=pq.top();\\n            pq.pop();\\n            int l;\\n            if(ch!=\\'-\\'&&t.first<ch){\\n                l=1;\\n            }\\n            else{\\n            l=min(repeatLimit,t.second);\\n            }\\n            int temp=l;\\n            while(temp--){\\n                ans+=t.first;\\n            }\\n\\n            if(ch!=\\'-\\'){\\n              \\n                pq.push({ch,cnt});\\n            }\\n        if(t.second-l>0){\\n               ch=t.first;\\n               cnt=t.second-l;\\n           }\\n            else{\\n                ch=\\'-\\';\\n                cnt=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        priority_queue<pair<char,int>>pq;\\n        \\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        /\\n        for(auto x:mp){\\n            pq.push({x.first,x.second});\\n        }\\n        char ch=\\'-\\';\\n        int cnt=0;\\n        string ans=\"\";\\n        while(!pq.empty()){\\n         pair<char,int>t=pq.top();\\n            pq.pop();\\n            int l;\\n            if(ch!=\\'-\\'&&t.first<ch){\\n                l=1;\\n            }\\n            else{\\n            l=min(repeatLimit,t.second);\\n            }\\n            int temp=l;\\n            while(temp--){\\n                ans+=t.first;\\n            }\\n\\n            if(ch!=\\'-\\'){\\n              \\n                pq.push({ch,cnt});\\n            }\\n        if(t.second-l>0){\\n               ch=t.first;\\n               cnt=t.second-l;\\n           }\\n            else{\\n                ch=\\'-\\';\\n                cnt=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785415,
                "title": "sliding-window-binary-search-c",
                "content": "**Algorithm**:\\n1. First sort the string in descending order.\\n2. Perform sliding window by keeping the window size=limit\\n3. If within the window a character not  equal to the character at the begining of the window is found, then start the window from that character.\\n4. Else if we come out of the window, check if that character is equal to the character in previous window, then swap it with another character from the string which is not equal to that chracter, if not found then the string computed till now is the answer.\\n5. We store the computed string yet in another string to avoid creating a substring while returning the answer.\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        if(s.length()==1)\\n            return s;\\n        sort(s.begin(),s.end(),greater<char>());\\n        string ans;\\n        for(int i=0;i<s.length();)\\n        {\\n            int j;\\n            for(j=i;j<i+limit&&j<s.length();j++)\\n            {\\n                if(s[j]!=s[i])  //beginnig of a new window\\n                 {\\n                    i=j;\\n                 }\\n                ans+=s[j];     //computed string till now.\\n               \\n                \\n            }\\n            if(j==s.length())\\n                return ans;\\n            if(s[j]==s[i])  \\n            {\\n                \\n            auto it=upper_bound(s.begin()+j,s.end(),s[j],greater<int>()); //binary search for the next character\\n                \\n                    if(it!=s.end())\\n                    {\\n                        swap(s[distance(s.begin(),it)],s[j]);\\n                        i=j;\\n                        \\n                    }\\n                \\n                if(i!=j)\\n                   return ans;\\n                    \\n                \\n            }\\n            else\\n              i=j;\\n            \\n           }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        if(s.length()==1)\\n            return s;\\n        sort(s.begin(),s.end(),greater<char>());\\n        string ans;\\n        for(int i=0;i<s.length();)\\n        {\\n            int j;\\n            for(j=i;j<i+limit&&j<s.length();j++)\\n            {\\n                if(s[j]!=s[i])  //beginnig of a new window\\n                 {\\n                    i=j;\\n                 }\\n                ans+=s[j];     //computed string till now.\\n               \\n                \\n            }\\n            if(j==s.length())\\n                return ans;\\n            if(s[j]==s[i])  \\n            {\\n                \\n            auto it=upper_bound(s.begin()+j,s.end(),s[j],greater<int>()); //binary search for the next character\\n                \\n                    if(it!=s.end())\\n                    {\\n                        swap(s[distance(s.begin(),it)],s[j]);\\n                        i=j;\\n                        \\n                    }\\n                \\n                if(i!=j)\\n                   return ans;\\n                    \\n                \\n            }\\n            else\\n              i=j;\\n            \\n           }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785276,
                "title": "c-priority-queue-character-frequency",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        priority_queue<pair<int, int>> pq;\\n        int cnt[26] = {0};\\n        int n = s.length();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int idx = s[i] - \\'a\\';\\n            cnt[idx]++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(cnt[i] > 0) {\\n                pq.push({i, cnt[i]});\\n            }\\n        }\\n        \\n        pair<int, int> prev = {-1, 0};\\n        string res = \"\";\\n        \\n        while(!pq.empty()) {\\n            pair<int, int> p = pq.top();\\n            pq.pop();\\n            \\n            if(prev.second > 0) pq.push(prev);\\n            \\n            int idx = p.first;\\n            int freq = p.second;\\n            \\n            if(prev.second > 0 && prev.first > idx) {\\n                res += (\\'a\\' + idx);\\n                --freq;\\n            }\\n            else {\\n                for(int i = 0; i < repeatLimit; i++) {\\n                    res += (\\'a\\' + idx);\\n                    --freq;\\n                    if(freq == 0) break;\\n                }\\n            }\\n            \\n            prev = {idx, freq};\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        priority_queue<pair<int, int>> pq;\\n        int cnt[26] = {0};\\n        int n = s.length();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int idx = s[i] - \\'a\\';\\n            cnt[idx]++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(cnt[i] > 0) {\\n                pq.push({i, cnt[i]});\\n            }\\n        }\\n        \\n        pair<int, int> prev = {-1, 0};\\n        string res = \"\";\\n        \\n        while(!pq.empty()) {\\n            pair<int, int> p = pq.top();\\n            pq.pop();\\n            \\n            if(prev.second > 0) pq.push(prev);\\n            \\n            int idx = p.first;\\n            int freq = p.second;\\n            \\n            if(prev.second > 0 && prev.first > idx) {\\n                res += (\\'a\\' + idx);\\n                --freq;\\n            }\\n            else {\\n                for(int i = 0; i < repeatLimit; i++) {\\n                    res += (\\'a\\' + idx);\\n                    --freq;\\n                    if(freq == 0) break;\\n                }\\n            }\\n            \\n            prev = {idx, freq};\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785215,
                "title": "100-fast-python",
                "content": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = Counter(s)\\n        n, hp = 0, []\\n        for c in sorted(cnt, reverse=True):\\n            heappush(hp, (n, c))\\n            n += 1\\n        ans = \"\"\\n        while hp:\\n            if cnt[hp[0][1]] <= repeatLimit:    # use all\\n                n1, c1 = heappop(hp)\\n                ans += c1 * cnt[c1]\\n            else:                               # use the limited number\\n                n1, c1 = heappop(hp)\\n                ans += c1 * repeatLimit\\n                cnt[c1] -= repeatLimit\\n                if hp:                          # use 1 of the next character\\n                    n2, c2 = heappop(hp)\\n                    ans += c2\\n                    cnt[c2] -= 1\\n                    if cnt[c2]:\\n                        heappush(hp, (n2, c2))  # push the next character back\\n                    heappush(hp, (n1, c1))      # push the current character back\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = Counter(s)\\n        n, hp = 0, []\\n        for c in sorted(cnt, reverse=True):\\n            heappush(hp, (n, c))\\n            n += 1\\n        ans = \"\"\\n        while hp:\\n            if cnt[hp[0][1]] <= repeatLimit:    # use all\\n                n1, c1 = heappop(hp)\\n                ans += c1 * cnt[c1]\\n            else:                               # use the limited number\\n                n1, c1 = heappop(hp)\\n                ans += c1 * repeatLimit\\n                cnt[c1] -= repeatLimit\\n                if hp:                          # use 1 of the next character\\n                    n2, c2 = heappop(hp)\\n                    ans += c2\\n                    cnt[c2] -= 1\\n                    if cnt[c2]:\\n                        heappush(hp, (n2, c2))  # push the next character back\\n                    heappush(hp, (n1, c1))      # push the current character back\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785193,
                "title": "priority-queue-and-queue-c",
                "content": "class Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        \\n        priority_queue<char>pq;\\n        for(int i=0;i<s.length();i++){\\n                    pq.push(s[i]);\\n        }\\n        int k=repeatLimit;\\n        int cnt=1;\\n        string ans=\"\";\\n        ans+=pq.top();\\n        pq.pop();\\n        queue<char>extra;\\n        while(!pq.empty()){\\n              \\n                if(cnt!=repeatLimit and ans.back()==pq.top() and extra.empty()){\\n                            ans+=pq.top();\\n                            pq.pop();\\n                            cnt++;\\n                }\\n                else  if(cnt==repeatLimit and ans.back()==pq.top() and extra.empty()){\\n                            extra.push(pq.top());\\n                            pq.pop();\\n                    \\n                }\\n            \\n                else if(extra.front()!=ans.back() and !extra.empty()){\\n                            ans+=extra.front();\\n                            extra.pop();\\n                            cnt=1;\\n                       \\n                }\\n            \\n                else if(cnt!=repeatLimit and ans.back()==extra.front() and !extra.empty()){\\n                            ans+=extra.front();\\n                            extra.pop();\\n                            cnt++;\\n                }\\n                \\n                else  if(cnt==repeatLimit and ans.back()==pq.top() and !extra.empty() and ans.back()==pq.top()){\\n                            extra.push(pq.top());\\n                            pq.pop();\\n                    \\n                }\\n            \\n            \\n                else{\\n                        if(!extra.empty()){\\n                                 if(ans.back()!=pq.top() and extra.front()!=ans.back()){\\n                                                ans+=extra.front();\\n                                                extra.pop();\\n                                                cnt=1;   \\n                                 }\\n                                else{\\n                                    \\n                                                ans+=pq.top();\\n                                                pq.pop();\\n                                                cnt=1;\\n                                        \\n                                }\\n  \\n                        }\\n                        else{\\n\\n                                                ans+=pq.top();\\n                                                pq.pop();\\n                                                cnt=1;\\n                                        \\n                        }\\n                    \\n                    \\n                    \\n                    \\n                }\\n              \\n            }\\n            cout<<\"here come stack\";\\n          \\n            while(!extra.empty()){\\n                \\n                if(ans.back()!=extra.front()){\\n                    \\n                            ans+=extra.front();\\n                            extra.pop();\\n                            cnt=1;\\n                }\\n                \\n                else if(ans.back()==extra.front() and cnt!=repeatLimit){\\n                    \\n                    \\n                             ans+=extra.front();\\n                             extra.pop();\\n                             cnt++;\\n                    \\n                    \\n                }\\n                else{\\n                    \\n                            extra.pop();\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        \\n        \\n        priority_queue<char>pq;\\n        for(int i=0;i<s.length();i++){\\n                    pq.push(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785181,
                "title": "c-o-n-priority-queue-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int r) {\\n        int n = s.length();\\n        vector<int> freq(26);\\n        for(char i:s){\\n            freq[i-\\'a\\']++;\\n        }\\n        priority_queue<pair<char, int>> maxh;\\n        for(int i = 0; i < 26; i++){\\n            if(freq[i]) \\n                maxh.push({i+\\'a\\',freq[i]}); // pushing the characters with their frequencies.\\n        }\\n        string ans;\\n        while(!maxh.empty()) {\\n            pair<char, int>p1, p2;\\n            p1 = maxh.top();\\n            maxh.pop();\\n            int fill = min(p1.second, r), temp = fill;\\n            while(temp--) {\\n                ans += p1.first;\\n            }\\n            if(p1.second-fill > 0) {\\n                if(!maxh.empty()) {\\n                    p2 = maxh.top();\\n                    maxh.pop();\\n                    ans += p2.first;\\n                }\\n                else {\\n                    return ans;\\n                }\\n                if(p2.second-1) {\\n                        maxh.push({p2.first, p2.second-1});\\n                }\\n                maxh.push({p1.first, p1.second-fill});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int r) {\\n        int n = s.length();\\n        vector<int> freq(26);\\n        for(char i:s){\\n            freq[i-\\'a\\']++;\\n        }\\n        priority_queue<pair<char, int>> maxh;\\n        for(int i = 0; i < 26; i++){\\n            if(freq[i]) \\n                maxh.push({i+\\'a\\',freq[i]}); // pushing the characters with their frequencies.\\n        }\\n        string ans;\\n        while(!maxh.empty()) {\\n            pair<char, int>p1, p2;\\n            p1 = maxh.top();\\n            maxh.pop();\\n            int fill = min(p1.second, r), temp = fill;\\n            while(temp--) {\\n                ans += p1.first;\\n            }\\n            if(p1.second-fill > 0) {\\n                if(!maxh.empty()) {\\n                    p2 = maxh.top();\\n                    maxh.pop();\\n                    ans += p2.first;\\n                }\\n                else {\\n                    return ans;\\n                }\\n                if(p2.second-1) {\\n                        maxh.push({p2.first, p2.second-1});\\n                }\\n                maxh.push({p1.first, p1.second-fill});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785163,
                "title": "simple-c-code-using-stack",
                "content": "# Intuition \\n1. Sort the string in descending order(this maintains the lexographically largest property). \\n2. Now, we just have to rearrange the characters in groups of maximum **repeatLimit** characters each.\\n3. If number of characters is greater than **repeatLimit**, then use only **repeatLimit** count of current character and then add 1 instance of next lexographically larger character.\\n4. If number of characters is smaller or equal to **repeatLimit**, then use all the instances of current character.\\n\\n# Implementation\\nI am using stack to do the 3rd and 4th step. Each element of stack is storing the {currentCharacter, countOfCurrentCharacter}\\n\\n```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n        sort(begin(s), end(s), greater<char>());\\n        \\n        stack<pair<char,int>> st;\\n        for(int i=s.size()-1 ; i>=0 ; --i) {\\n            if(st.empty() or st.top().first!=s[i])\\n                st.push({s[i], 1});\\n            else\\n                st.top().second++;\\n        }\\n        \\n        string ans;\\n        while(!st.empty()) {\\n            auto t = st.top();\\n            st.pop();\\n\\n            if(t.ss <= rl)\\n                ans += string(t.ss, t.ff);\\n            else {\\n                ans += string(rl, t.ff);\\n                t.ss -= rl;\\n                \\n                if(st.empty())\\n                    return ans;\\n                \\n                auto temp = st.top();\\n                st.pop();\\n                ans += temp.ff;\\n                temp.ss--;\\n                if(temp.ss > 0)\\n                    st.push(temp);\\n                st.push(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n        sort(begin(s), end(s), greater<char>());\\n        \\n        stack<pair<char,int>> st;\\n        for(int i=s.size()-1 ; i>=0 ; --i) {\\n            if(st.empty() or st.top().first!=s[i])\\n                st.push({s[i], 1});\\n            else\\n                st.top().second++;\\n        }\\n        \\n        string ans;\\n        while(!st.empty()) {\\n            auto t = st.top();\\n            st.pop();\\n\\n            if(t.ss <= rl)\\n                ans += string(t.ss, t.ff);\\n            else {\\n                ans += string(rl, t.ff);\\n                t.ss -= rl;\\n                \\n                if(st.empty())\\n                    return ans;\\n                \\n                auto temp = st.top();\\n                st.pop();\\n                ans += temp.ff;\\n                temp.ss--;\\n                if(temp.ss > 0)\\n                    st.push(temp);\\n                st.push(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785103,
                "title": "python-counting-o-n-time-o-1-space",
                "content": "1. Track frequency of each character from the input string using an array or a dictionary\\n2. Track all distinct characters in the array in ascending lexicographical order (a, b, c, ...., x, y, z) using a stack.\\n3. Go over all these characters. We exit if frequency of all characters listed in the stack is exhausted, or we reach the repeatLimit with the last element.\\n\\n```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\'\\'\\'\\n        Time: O(N)\\n        Space: O(1)\\n        \\'\\'\\'\\n        # Maintain frequency of all elements of s\\n        charMap = Counter(s)\\n        \\n        # Create a sorted stack to keep track of order of characters\\n\\t\\t# Note: Size of stack can only be at most 26 (in worst case).\\n        stack = list(charMap.keys())\\n        stack.sort()\\n        \\n        currCount = 0\\n        result = []\\n        \\n        while stack:\\n            \\n            char = stack[-1]\\n            \\n            # Exhaust all values from index until repeatLimit is hit\\n            while currCount < repeatLimit and charMap[char] > 0:\\n                result.append(char)\\n                charMap[char] -= 1\\n                currCount += 1\\n                \\n            # If this is the last element and all elements are exhauseted or we have reached the repeat limit\\n            if len(stack) == 1 and (charMap[char] == 0 or currCount >= repeatLimit):\\n                stack.pop()\\n                break\\n            \\n            # All elements exhausted at this index but more elements are there in arr\\n            if charMap[char] == 0:\\n                stack.pop()                             \\n            \\n            # Still more elements at this index but repeatLimit is reached\\n            elif currCount >= repeatLimit:\\n                # Grab 1 the element that is lexicographically smaller\\n                topElem = stack.pop()\\n                elem = stack[-1]\\n                result.append(elem)\\n                charMap[elem] -= 1\\n                \\n                # If there was only 1 element in elem, remove it from stack\\n                if charMap[elem] == 0:\\n                    stack.pop()\\n                stack.append(topElem)\\n            \\n            # Reset the currCount since we will grab repeatLimit elements again\\n            currCount = 0\\n        \\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\'\\'\\'\\n        Time: O(N)\\n        Space: O(1)\\n        \\'\\'\\'\\n        # Maintain frequency of all elements of s\\n        charMap = Counter(s)\\n        \\n        # Create a sorted stack to keep track of order of characters\\n\\t\\t# Note: Size of stack can only be at most 26 (in worst case).\\n        stack = list(charMap.keys())\\n        stack.sort()\\n        \\n        currCount = 0\\n        result = []\\n        \\n        while stack:\\n            \\n            char = stack[-1]\\n            \\n            # Exhaust all values from index until repeatLimit is hit\\n            while currCount < repeatLimit and charMap[char] > 0:\\n                result.append(char)\\n                charMap[char] -= 1\\n                currCount += 1\\n                \\n            # If this is the last element and all elements are exhauseted or we have reached the repeat limit\\n            if len(stack) == 1 and (charMap[char] == 0 or currCount >= repeatLimit):\\n                stack.pop()\\n                break\\n            \\n            # All elements exhausted at this index but more elements are there in arr\\n            if charMap[char] == 0:\\n                stack.pop()                             \\n            \\n            # Still more elements at this index but repeatLimit is reached\\n            elif currCount >= repeatLimit:\\n                # Grab 1 the element that is lexicographically smaller\\n                topElem = stack.pop()\\n                elem = stack[-1]\\n                result.append(elem)\\n                charMap[elem] -= 1\\n                \\n                # If there was only 1 element in elem, remove it from stack\\n                if charMap[elem] == 0:\\n                    stack.pop()\\n                stack.append(topElem)\\n            \\n            # Reset the currCount since we will grab repeatLimit elements again\\n            currCount = 0\\n        \\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1785030,
                "title": "priority-queue-hashmap-brute-force-rutime-128ms-most-intuitive-solution-possible-ever",
                "content": "![image](https://assets.leetcode.com/users/images/7c2fd628-520f-4f3f-9ac3-1b064c224700_1645331180.561206.png)\\n```\\nclass Solution {\\npublic:\\n    \\n    struct comp{\\n        \\n        bool operator()(const pair<char,int>&a, const pair<char,int>&b)\\n        {\\n            return a.first < b.first; // max heap\\n        }\\n    };\\n    string repeatLimitedString(string s, int rL) {\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>, comp>pq; // space - O(26)\\n        unordered_map<char,int>mp;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(auto x : mp){\\n            pq.push({x.first, x.second});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto p1 = pq.top();\\n            char ch1 = p1.first;\\n            int f1 = p1.second;\\n            pq.pop();\\n            \\n            char ch2;\\n            int f2=0;\\n            if(!ans.empty() and ans[ans.size()-1] == ch1){ // check from previous chracter\\n                auto p2 = pq.top();\\n                ch2 = p2.first;\\n                f2 = p2.second;\\n                pq.pop();    \\n            }\\n            \\n            \\n            if(f2!=0){\\n                ans.push_back(ch2);\\n                f2--;\\n            }\\n            int c=0;\\n            while(f1)\\n            {\\n                ans.push_back(ch1);\\n                c++;\\n                f1--;\\n                if(c == rL){\\n                    break;\\n                }\\n            }\\n            \\n            \\n            if(f1!=0)\\n                pq.push({ch1, f1});\\n            if(f2!=0)\\n                pq.push({ch2, f2});\\n            if(pq.size()==1 and pq.top().first == ans[ans.size()-1]) return ans;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct comp{\\n        \\n        bool operator()(const pair<char,int>&a, const pair<char,int>&b)\\n        {\\n            return a.first < b.first; // max heap\\n        }\\n    };\\n    string repeatLimitedString(string s, int rL) {\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>, comp>pq; // space - O(26)\\n        unordered_map<char,int>mp;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(auto x : mp){\\n            pq.push({x.first, x.second});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto p1 = pq.top();\\n            char ch1 = p1.first;\\n            int f1 = p1.second;\\n            pq.pop();\\n            \\n            char ch2;\\n            int f2=0;\\n            if(!ans.empty() and ans[ans.size()-1] == ch1){ // check from previous chracter\\n                auto p2 = pq.top();\\n                ch2 = p2.first;\\n                f2 = p2.second;\\n                pq.pop();    \\n            }\\n            \\n            \\n            if(f2!=0){\\n                ans.push_back(ch2);\\n                f2--;\\n            }\\n            int c=0;\\n            while(f1)\\n            {\\n                ans.push_back(ch1);\\n                c++;\\n                f1--;\\n                if(c == rL){\\n                    break;\\n                }\\n            }\\n            \\n            \\n            if(f1!=0)\\n                pq.push({ch1, f1});\\n            if(f2!=0)\\n                pq.push({ch2, f2});\\n            if(pq.size()==1 and pq.top().first == ans[ans.size()-1]) return ans;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785008,
                "title": "3-liner-python-solution",
                "content": "```\\n    def repeatLimitedString(self, s: str, k: int) -> str:\\n        leters , sol, stack, rep, prev , ll = (x for x in sorted(s, reverse=True)) , [], [], 0, None ,len(s)\\n        while ele:=stack.pop() if rep <= k and stack else next(leters, 0):_,prev = sol.append(ele) if (rep:=1 if ele != prev else rep+1) <= k else stack.append(ele) , ele\\n        return \"\".join(sol)\\n```\\n\\t\\n If you have any questions, feel free to ask.\\n \\n Happy Coding !!",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n    def repeatLimitedString(self, s: str, k: int) -> str:\\n        leters , sol, stack, rep, prev , ll = (x for x in sorted(s, reverse=True)) , [], [], 0, None ,len(s)\\n        while ele:=stack.pop() if rep <= k and stack else next(leters, 0):_,prev = sol.append(ele) if (rep:=1 if ele != prev else rep+1) <= k else stack.append(ele) , ele\\n        return \"\".join(sol)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784992,
                "title": "priority-queue-c-o-n-time-o-1-space",
                "content": "As Heap can not grow beyond 26 alphabets, \\nHence complexity can be coined as **O(N)** time and **O(1)** space. \\n\\nSimilar problem : [1405. Longest Happy String]( https://leetcode.com/problems/longest-happy-string/ )\\n\\nPlease comment if you differ me. :) \\n```\\npublic class Solution {\\n    public string RepeatLimitedString(string s, int repeatLimit) {\\n        SortedSet<(char c, int cnt)> heap = new SortedSet<(char c, int cnt)>();\\n        \\n        int[] counter = new int[26];\\n        foreach(var c in s)\\n            counter[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26; i++){\\n            if(counter[i] > 0)\\n                heap.Add(((char) (i+\\'a\\'), counter[i]));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char prev =  \\'*\\';\\n        int count = 0;\\n        \\n        while(heap.Count > 0) {\\n            var max = heap.Max;\\n            heap.Remove(max);\\n            int cnt = 0;\\n            if(max.c != prev){\\n                cnt = Math.Min(repeatLimit, max.cnt);\\n            }else if(heap.Count > 0 ){\\n                var curMax = max;\\n                max = heap.Max;\\n                heap.Remove(max);\\n                heap.Add(curMax);\\n                cnt = 1;\\n            }else break;\\n\\n            for(int i=0; i<cnt; i++)\\n                sb.Append(max.c);\\n            \\n            max.cnt -= cnt;\\n            prev = max.c;\\n            if(max.cnt > 0)\\n                heap.Add(max);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public string RepeatLimitedString(string s, int repeatLimit) {\\n        SortedSet<(char c, int cnt)> heap = new SortedSet<(char c, int cnt)>();\\n        \\n        int[] counter = new int[26];\\n        foreach(var c in s)\\n            counter[c-\\'a\\']++;\\n        \\n        for(int i=0;i<26; i++){\\n            if(counter[i] > 0)\\n                heap.Add(((char) (i+\\'a\\'), counter[i]));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char prev =  \\'*\\';\\n        int count = 0;\\n        \\n        while(heap.Count > 0) {\\n            var max = heap.Max;\\n            heap.Remove(max);\\n            int cnt = 0;\\n            if(max.c != prev){\\n                cnt = Math.Min(repeatLimit, max.cnt);\\n            }else if(heap.Count > 0 ){\\n                var curMax = max;\\n                max = heap.Max;\\n                heap.Remove(max);\\n                heap.Add(curMax);\\n                cnt = 1;\\n            }else break;\\n\\n            for(int i=0; i<cnt; i++)\\n                sb.Append(max.c);\\n            \\n            max.cnt -= cnt;\\n            prev = max.c;\\n            if(max.cnt > 0)\\n                heap.Add(max);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784984,
                "title": "passed-149-150-test-cases-in-java",
                "content": "Dont try this solution,it\\'s not tidy but do read my approach! It might help you!\\uD83D\\uDE4F\\uD83C\\uDFFB\\nAnyone who who knows how to pass the last test case or what I am missing, please comment so that I can learn from you.\\n```\\nFAILED TEST CASE :: \\n\"bplpcfifosybmjxphbxdltxtfrjspgixoxzbpwrtkopepjxfooazjyosengdlvyfchqhqxznnhuuxhtbrojyhxwlsrklsryvmufoibgfyxgjw\"\\n1\\n```\\n```\\nclass Pair {\\n    char c;\\n    int freq;\\n\\n    Pair(char c, int freq) {\\n        this.c = c;\\n        this.freq = freq;\\n    }\\n}\\n\\nclass Solution {\\n     public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        char[] string = s.toCharArray();\\n//        Arrays.sort(string);\\n        int[] ch = new int[26];\\n\\n        for (char cc : string)\\n            ch[cc - \\'a\\']++;\\n\\n        Deque<Pair> q = new ArrayDeque<>();\\n\\n        for (int i = 25; i >= 0; i--) {\\n            if (ch[i] != 0) {\\n                q.add(new Pair((char) (i + \\'a\\'), ch[i]));\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        while (q.size() > 1) {\\n            Pair temp = q.poll();\\n            if (!sb.isEmpty() && temp.c == sb.charAt(sb.length() - 1)) {\\n                Pair temp2 = q.poll();\\n                sb.append(temp2.c);\\n                if (temp2.freq - 1 != 0)\\n                    q.addFirst(new Pair(temp2.c, temp2.freq - 1));\\n\\n            }\\n            int ff = Math.min(temp.freq, repeatLimit);\\n            while (ff-- > 0) sb.append(temp.c);\\n\\n            if (temp.freq - repeatLimit > 0)\\n                q.addFirst(new Pair(temp.c, temp.freq - repeatLimit));\\n\\n        }\\n\\n         if (q.size() == 1) {\\n            Pair tt = q.poll();\\n            int gg = Math.min(tt.freq, repeatLimit);\\n            sb.append(String.valueOf(tt.c).repeat(Math.max(0, gg)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFAILED TEST CASE :: \\n\"bplpcfifosybmjxphbxdltxtfrjspgixoxzbpwrtkopepjxfooazjyosengdlvyfchqhqxznnhuuxhtbrojyhxwlsrklsryvmufoibgfyxgjw\"\\n1\\n```\n```\\nclass Pair {\\n    char c;\\n    int freq;\\n\\n    Pair(char c, int freq) {\\n        this.c = c;\\n        this.freq = freq;\\n    }\\n}\\n\\nclass Solution {\\n     public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        char[] string = s.toCharArray();\\n//        Arrays.sort(string);\\n        int[] ch = new int[26];\\n\\n        for (char cc : string)\\n            ch[cc - \\'a\\']++;\\n\\n        Deque<Pair> q = new ArrayDeque<>();\\n\\n        for (int i = 25; i >= 0; i--) {\\n            if (ch[i] != 0) {\\n                q.add(new Pair((char) (i + \\'a\\'), ch[i]));\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        while (q.size() > 1) {\\n            Pair temp = q.poll();\\n            if (!sb.isEmpty() && temp.c == sb.charAt(sb.length() - 1)) {\\n                Pair temp2 = q.poll();\\n                sb.append(temp2.c);\\n                if (temp2.freq - 1 != 0)\\n                    q.addFirst(new Pair(temp2.c, temp2.freq - 1));\\n\\n            }\\n            int ff = Math.min(temp.freq, repeatLimit);\\n            while (ff-- > 0) sb.append(temp.c);\\n\\n            if (temp.freq - repeatLimit > 0)\\n                q.addFirst(new Pair(temp.c, temp.freq - repeatLimit));\\n\\n        }\\n\\n         if (q.size() == 1) {\\n            Pair tt = q.poll();\\n            int gg = Math.min(tt.freq, repeatLimit);\\n            sb.append(String.valueOf(tt.c).repeat(Math.max(0, gg)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784975,
                "title": "c-simplest-solution-using-two-pointer-without-extra-space",
                "content": "```\\nstring repeatLimitedString(string s, int repeatLimit) {\\n        int p1 = 0, p2 = 0;\\n        int cnt = 1;\\n        sort(s.begin(), s.end(), greater<>());\\n        while(p2 < s.size()) {\\n            if(s[p1] != s[p2]) {\\n                p1++;\\n                cnt++;\\n            }\\n            if(s[p1] == s[p2]) {\\n                p2++;\\n                cnt = 1;\\n            }\\n            if(cnt > repeatLimit) {\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                cnt = 1;\\n            }\\n            \\n        }\\n        while(p2 - p1 >repeatLimit) {\\n            s.pop_back();\\n            repeatLimit++;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring repeatLimitedString(string s, int repeatLimit) {\\n        int p1 = 0, p2 = 0;\\n        int cnt = 1;\\n        sort(s.begin(), s.end(), greater<>());\\n        while(p2 < s.size()) {\\n            if(s[p1] != s[p2]) {\\n                p1++;\\n                cnt++;\\n            }\\n            if(s[p1] == s[p2]) {\\n                p2++;\\n                cnt = 1;\\n            }\\n            if(cnt > repeatLimit) {\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                cnt = 1;\\n            }\\n            \\n        }\\n        while(p2 - p1 >repeatLimit) {\\n            s.pop_back();\\n            repeatLimit++;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784948,
                "title": "c-textbook-priority-queue-clean-concise-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        \\n        \\n        \\n        vector<int> cnt(26, 0);\\n        for(auto c : s) cnt[c-\\'a\\']++;\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>> maxHeap;\\n        for(int i=0;i<26;i++)\\n            if(cnt[i]) maxHeap.push({i, cnt[i]});\\n    \\n        vector<char> ans;\\n\\n        while(maxHeap.size()){\\n            \\n            auto [c1, frq1] = maxHeap.top();\\n            maxHeap.pop();\\n            \\n\\n            if( ans.size() == 0 || (ans.back() - \\'a\\' != c1) ){\\n                // can place the character c1 + \\'a\\' in a row \\n\\t\\t\\t\\t\\n                int taken = min(limit, frq1);\\n                \\n                for(int i=0;i<taken;i++)\\n                    ans.push_back(c1+\\'a\\');\\n                \\n                frq1 -= taken;\\n                if(frq1)\\n                    maxHeap.push({c1, frq1});\\n            }\\n            else{\\n                // need to place 1 small character\\n                if(maxHeap.size() == 0) break;\\n\\n                auto [c2, frq2] = maxHeap.top();\\n                maxHeap.pop();\\n\\n                ans.push_back(c2 + \\'a\\');\\n\\n                frq2-=1;\\n                if(frq2)\\n                    maxHeap.push({c2, frq2});\\n\\n                maxHeap.push({c1, frq1});\\n            }\\n        }\\n\\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        \\n        \\n        \\n        vector<int> cnt(26, 0);\\n        for(auto c : s) cnt[c-\\'a\\']++;\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>> maxHeap;\\n        for(int i=0;i<26;i++)\\n            if(cnt[i]) maxHeap.push({i, cnt[i]});\\n    \\n        vector<char> ans;\\n\\n        while(maxHeap.size()){\\n            \\n            auto [c1, frq1] = maxHeap.top();\\n            maxHeap.pop();\\n            \\n\\n            if( ans.size() == 0 || (ans.back() - \\'a\\' != c1) ){\\n                // can place the character c1 + \\'a\\' in a row \\n\\t\\t\\t\\t\\n                int taken = min(limit, frq1);\\n                \\n                for(int i=0;i<taken;i++)\\n                    ans.push_back(c1+\\'a\\');\\n                \\n                frq1 -= taken;\\n                if(frq1)\\n                    maxHeap.push({c1, frq1});\\n            }\\n            else{\\n                // need to place 1 small character\\n                if(maxHeap.size() == 0) break;\\n\\n                auto [c2, frq2] = maxHeap.top();\\n                maxHeap.pop();\\n\\n                ans.push_back(c2 + \\'a\\');\\n\\n                frq2-=1;\\n                if(frq2)\\n                    maxHeap.push({c2, frq2});\\n\\n                maxHeap.push({c1, frq1});\\n            }\\n        }\\n\\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784927,
                "title": "c-o-n-time-and-o-n-space",
                "content": "We went from \\'z\\' to \\'a\\'.\\nWe looped over current largest alphabet till it was exhausted or we were unable to use it due to no remaining alphabet smaller than the current alphabet.\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string ans = \"\";\\n        \\n        unordered_map<char , int>mp;\\n        for(auto &ele : s) //inserting the elements in map\\n            mp[ele]++;\\n        \\n        for(char ch = \\'z\\' ; ch >= \\'a\\' ; ch--) //checking for every character //O(1) because it has constant no of loops , i.e, 26\\n        {\\n            char curr = ch;\\n            int cnt = 0;\\n            while(mp[ch] > 0) //checking for current character //O(n) \\n            {\\n                ans += ch;\\n                mp[ch]--;\\n                cnt++;\\n                if(cnt == repeatLimit and mp[ch] > 0)\\n                {\\n                    curr = ch - 1;\\n                    while(mp[curr] == 0 and curr >= \\'a\\') //O(1)(loop <= 26)\\n                        curr--;\\n                    \\n                    if(curr >= \\'a\\')\\n                    {\\n                        ans += curr;\\n                        mp[curr]--;\\n                    }\\n                    cnt = 0; //char inserted if possible\\n                }\\n                if(curr < \\'a\\') //no prev element to add\\n                    break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string ans = \"\";\\n        \\n        unordered_map<char , int>mp;\\n        for(auto &ele : s) //inserting the elements in map\\n            mp[ele]++;\\n        \\n        for(char ch = \\'z\\' ; ch >= \\'a\\' ; ch--) //checking for every character //O(1) because it has constant no of loops , i.e, 26\\n        {\\n            char curr = ch;\\n            int cnt = 0;\\n            while(mp[ch] > 0) //checking for current character //O(n) \\n            {\\n                ans += ch;\\n                mp[ch]--;\\n                cnt++;\\n                if(cnt == repeatLimit and mp[ch] > 0)\\n                {\\n                    curr = ch - 1;\\n                    while(mp[curr] == 0 and curr >= \\'a\\') //O(1)(loop <= 26)\\n                        curr--;\\n                    \\n                    if(curr >= \\'a\\')\\n                    {\\n                        ans += curr;\\n                        mp[curr]--;\\n                    }\\n                    cnt = 0; //char inserted if possible\\n                }\\n                if(curr < \\'a\\') //no prev element to add\\n                    break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784886,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    void sadd(string& s, char ch, vector<int>& cnt, int rl){\\n        int c = min(cnt[ch - \\'a\\'], rl);\\n        \\n        for(int i=1;i<=c;i++)\\n            s += ch;\\n        \\n        cnt[ch - \\'a\\'] -= c;\\n    }\\n    \\n    char findLar(vector<int>& cnt, int ignore){\\n        for(int i=25;i>=0;i--){\\n            if(i == ignore)\\n                continue;\\n            \\n            if(cnt[i] > 0)\\n                return i + \\'a\\';\\n        }\\n        \\n        return \\'.\\';\\n    }\\n    \\n    string repeatLimitedString(string s, int rl) {\\n        vector<int> cnt(26, 0);\\n        for(char c: s)\\n            cnt[c - \\'a\\']++;\\n        \\n        string ans = \"\";\\n        \\n        while(true){\\n            char fch = findLar(cnt, ans.back() - \\'a\\');\\n            if(fch == \\'.\\')\\n                return ans;\\n            \\n            int tmp = rl;\\n            for(int k=fch-\\'a\\'+1;k<26;k++){\\n                if(cnt[k] > 0){\\n                    tmp = 1;\\n                    break;\\n                }\\n            }\\n            \\n            sadd(ans, fch, cnt, tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void sadd(string& s, char ch, vector<int>& cnt, int rl){\\n        int c = min(cnt[ch - \\'a\\'], rl);\\n        \\n        for(int i=1;i<=c;i++)\\n            s += ch;\\n        \\n        cnt[ch - \\'a\\'] -= c;\\n    }\\n    \\n    char findLar(vector<int>& cnt, int ignore){\\n        for(int i=25;i>=0;i--){\\n            if(i == ignore)\\n                continue;\\n            \\n            if(cnt[i] > 0)\\n                return i + \\'a\\';\\n        }\\n        \\n        return \\'.\\';\\n    }\\n    \\n    string repeatLimitedString(string s, int rl) {\\n        vector<int> cnt(26, 0);\\n        for(char c: s)\\n            cnt[c - \\'a\\']++;\\n        \\n        string ans = \"\";\\n        \\n        while(true){\\n            char fch = findLar(cnt, ans.back() - \\'a\\');\\n            if(fch == \\'.\\')\\n                return ans;\\n            \\n            int tmp = rl;\\n            for(int k=fch-\\'a\\'+1;k<26;k++){\\n                if(cnt[k] > 0){\\n                    tmp = 1;\\n                    break;\\n                }\\n            }\\n            \\n            sadd(ans, fch, cnt, tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784875,
                "title": "easy-o-n-one-pass-solution",
                "content": "All you have to do in this question is to store the count of each character occurring in s. \\nSince we have to generate lexicographically largest string hence we will start from \\'z\\' onwards and will try to take its maximum occurrences and update the frequency array. whenenver the count of consecutive similar characters will become equal to limit we will move to preceding character with count>0 and place one of its occurence.\\n\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n      int n=s.length();\\n      vector<int>fre(26,0);\\n      for(auto x: s)\\n      {\\n          fre[x-\\'a\\']++;\\n      }\\n        string ans;\\n      for(int i=25;i>=0;i--)\\n      {\\n          int c=0,j=i-1;\\n          while(fre[i]!=0)\\n          {\\n              ans.push_back(i+\\'a\\');\\n              fre[i]--;\\n              c++;\\n              if(c==rl && fre[i])\\n              {\\n                  while(j>=0 && fre[j]==0)\\n                      j--;\\n                  if(j>=0)\\n                  {\\n                      ans.push_back(j+\\'a\\');\\n                      fre[j]--;\\n                  }\\n                  else\\n                  {\\n                      fre[i]=0;\\n                  }\\n                  c=0;\\n              }\\n          }\\n      }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string repeatLimitedString(string s, int rl) {\\n      int n=s.length();\\n      vector<int>fre(26,0);\\n      for(auto x: s)\\n      {\\n          fre[x-\\'a\\']++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1784858,
                "title": "python-counter-simple-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        c = Counter(s)\\n        c = sorted(c.items(),key = lambda i: i[0])\\n        ans = \"\"\\n        stack = [c.pop()]\\n        while stack:\\n            ch, num = stack.pop()\\n            if num <= repeatLimit:\\n                ans += ch * num\\n                if c:\\n                    stack.append(c.pop())\\n            else:\\n                ans += ch * repeatLimit\\n                num = num - repeatLimit\\n                stack.append((ch,num))\\n                if c:\\n                    ans += c[-1][0]\\n                    nums = c[-1][1] - 1\\n                    char = c[-1][0]\\n                    c[-1] = (char, nums)\\n                    if c[-1][1] == 0:\\n                        c.pop()\\n                else:\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        c = Counter(s)\\n        c = sorted(c.items(),key = lambda i: i[0])\\n        ans = \"\"\\n        stack = [c.pop()]\\n        while stack:\\n            ch, num = stack.pop()\\n            if num <= repeatLimit:\\n                ans += ch * num\\n                if c:\\n                    stack.append(c.pop())\\n            else:\\n                ans += ch * repeatLimit\\n                num = num - repeatLimit\\n                stack.append((ch,num))\\n                if c:\\n                    ans += c[-1][0]\\n                    nums = c[-1][1] - 1\\n                    char = c[-1][0]\\n                    c[-1] = (char, nums)\\n                    if c[-1][1] == 0:\\n                        c.pop()\\n                else:\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784809,
                "title": "java-heap-simple",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int [] f = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            f[s.charAt(i)-\\'a\\']++; // frequency map with char count\\n        }\\n        PriorityQueue<int []> queue = new PriorityQueue<>((a, b) -> b[0] - a[0]); // queue ordered decending by char\\n        for(int i=0;i<26;i++){\\n            if(f[i] > 0){\\n                queue.add(new int[]{i, f[i]});\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder(); \\n        while(!queue.isEmpty()){\\n            int [] c = queue.poll();\\n            int x = 0;\\n            char ch = (char) (c[0]+\\'a\\');\\n            while(x++ < r && c[1]-- > 0){\\n                sb.append(ch);\\n            }\\n            if(queue.isEmpty()){\\n                break;\\n            }else if(c[1] > 0){\\n                int [] cn = queue.poll();\\n                queue.add(c);\\n                sb.append((char)(cn[0] +\\'a\\'));\\n                if(--cn[1] > 0){\\n                    queue.add(cn);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int [] f = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            f[s.charAt(i)-\\'a\\']++; // frequency map with char count\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1784755,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string res=\"\";\\n        int a[26]={0};\\n        int n=s.size();\\n        priority_queue<pair<char,int>> pq;\\n        unordered_set<char> st;\\n        for(int i=0;i<n;i++){\\n            a[s[i]-\\'a\\']++;\\n            st.insert(s[i]);\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(a[i]!=0){\\n                pq.push({\\'a\\'+i,a[i]});\\n            }\\n        }\\n        \\n        int cnt=st.size();\\n        while(!pq.empty()){\\n            char ch=pq.top().first;\\n            int num=min(pq.top().second,repeatLimit);\\n            for(int i=1;i<=num;i++){\\n                res+=ch;\\n            }\\n            \\n            pair<char,int> p1=pq.top();\\n            p1.second=p1.second-num;\\n            pq.pop();\\n                        \\n            if(p1.second!=0){\\n                pq.push(p1);\\n            }else{\\n                continue;\\n            }\\n            \\n            if(pq.size()==1){\\n                break;\\n            }\\n            \\n            if(pq.size()>=2){\\n                p1=pq.top();\\n                pq.pop();\\n                pair<char,int> p2=pq.top();\\n                res+=p2.first;\\n                p2.second=p2.second-1;\\n                pq.pop();\\n                if(p2.second!=0){\\n                    pq.push(p2);\\n                }\\n                pq.push(p1);\\n            }\\n            \\n\\n            \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string res=\"\";\\n        int a[26]={0};\\n        int n=s.size();\\n        priority_queue<pair<char,int>> pq;\\n        unordered_set<char> st;\\n        for(int i=0;i<n;i++){\\n            a[s[i]-\\'a\\']++;\\n            st.insert(s[i]);\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(a[i]!=0){\\n                pq.push({\\'a\\'+i,a[i]});\\n            }\\n        }\\n        \\n        int cnt=st.size();\\n        while(!pq.empty()){\\n            char ch=pq.top().first;\\n            int num=min(pq.top().second,repeatLimit);\\n            for(int i=1;i<=num;i++){\\n                res+=ch;\\n            }\\n            \\n            pair<char,int> p1=pq.top();\\n            p1.second=p1.second-num;\\n            pq.pop();\\n                        \\n            if(p1.second!=0){\\n                pq.push(p1);\\n            }else{\\n                continue;\\n            }\\n            \\n            if(pq.size()==1){\\n                break;\\n            }\\n            \\n            if(pq.size()>=2){\\n                p1=pq.top();\\n                pq.pop();\\n                pair<char,int> p2=pq.top();\\n                res+=p2.first;\\n                p2.second=p2.second-1;\\n                pq.pop();\\n                if(p2.second!=0){\\n                    pq.push(p2);\\n                }\\n                pq.push(p1);\\n            }\\n            \\n\\n            \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784751,
                "title": "python-heap",
                "content": "\\tclass Solution:\\n\\t\\tdef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\t\\t\\tmaxHeap = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor k, v in collections.Counter(s).items():\\n\\t\\t\\t\\theappush(maxHeap, (-ord(k), v))\\n\\t\\t\\twhile maxHeap:            \\n\\t\\t\\t\\tchar1, freq1 = heappop(maxHeap)\\n\\t\\t\\t\\tif not res or chr(-char1) != res[-1]:\\n\\t\\t\\t\\t\\tif freq1 > repeatLimit:\\n\\t\\t\\t\\t\\t\\tres += chr(-char1) * repeatLimit\\n\\t\\t\\t\\t\\t\\tfreq1 -= repeatLimit\\n\\t\\t\\t\\t\\t\\theappush(maxHeap, (char1, freq1))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += chr(-char1) * (freq1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif len(maxHeap) == 0:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tchar2, freq2 = heappop(maxHeap)\\n\\t\\t\\t\\t\\t\\tres += chr(-char2)\\n\\t\\t\\t\\t\\t\\tfreq2 -= 1\\n\\t\\t\\t\\t\\t\\tif freq2 > 0:\\n\\t\\t\\t\\t\\t\\t\\theappush(maxHeap, (char2, freq2))\\n\\t\\t\\t\\t\\t\\theappush(maxHeap, (char1, freq1))\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\t\\t\\tmaxHeap = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor k, v in collections.Counter(s).items():\\n\\t\\t\\t\\theappush(maxHeap, (-ord(k), v))\\n\\t\\t\\twhile maxHeap:            \\n\\t\\t\\t\\tchar1, freq1 = heappop(maxHeap)\\n\\t\\t\\t\\tif not res or chr(-char1) != res[-1]:\\n\\t\\t\\t\\t\\tif freq1 > repeatLimit:\\n\\t\\t\\t\\t\\t\\tres += chr(-char1) * repeatLimit\\n\\t\\t\\t\\t\\t\\tfreq1 -= repeatLimit\\n\\t\\t\\t\\t\\t\\theappush(maxHeap, (char1, freq1))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += chr(-char1) * (freq1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif len(maxHeap) == 0:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tchar2, freq2 = heappop(maxHeap)\\n\\t\\t\\t\\t\\t\\tres += chr(-char2)\\n\\t\\t\\t\\t\\t\\tfreq2 -= 1\\n\\t\\t\\t\\t\\t\\tif freq2 > 0:\\n\\t\\t\\t\\t\\t\\t\\theappush(maxHeap, (char2, freq2))\\n\\t\\t\\t\\t\\t\\theappush(maxHeap, (char1, freq1))\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 4085949,
                "title": "typescript-4-solutions-with-comments-time-o-n",
                "content": "# Code 1 - Fill in the Gaps\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize output\\n    const buf: string[] = new Array(N).fill(\" \");\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        // Check the output for gaps\\n        for (let j = 0; j < N && counts[i] > 0; ++j) {\\n            // Fill sequential gaps up to max repeatLimit\\n            const M = Math.min(repeatLimit, counts[i]);\\n            for (let k = 0; k < M && buf[j] === \" \"; ++k) {\\n                buf[j++] = char;\\n                --counts[i];\\n            }\\n        }\\n    }\\n\\n    // Truncate the output to the first gap\\n    let len = buf.indexOf(\" \");\\n    buf.length = (len >= 0) ? len : N;\\n    \\n    return buf.join(\"\");\\n};\\n```\\n\\n# Code 2 - Queue\\n- Time complexity: O(N)\\n- Space complexity: O(M), where M is max letter frequency\\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize the output\\n    const buf: string[] = [];\\n\\n    // Initialize the queue.\\n    // It will contain only one\\n    // repeating letter at a time\\n    // Ex: [\"zzz\", \"zzz\", \"zz\"]\\n    const q: string[] = [\"\"];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use the letter as a separator\\n        // to move queue entries to output\\n        const M = Math.min(counts[i], q.length - 1);\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        for (let j = 0; j < M; buf.push(q[j++], char)) {}\\n        counts[i] -= M;\\n        q.splice(0, M);\\n\\n        // If letter was fully used\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Last entry does not need a separator\\n        // as it\\'ll be neighbored by this letter.\\n        // Add it directly to the output.\\n        buf.push(q.pop());\\n\\n        // Populate the queue with groups of this letter\\n        for (let len = 0; counts[i] > 0; counts[i] -= len) {\\n            len = Math.min(counts[i], repeatLimit);\\n            q.push(char.repeat(len));\\n        }\\n    }\\n    \\n    buf.push(q[0]);\\n    return buf.join(\"\");\\n};\\n```\\n\\n# Code 3 - Stack\\n- Time complexity: O(N)\\n- Space complexity: O(M), where M is max letter frequency\\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize the output\\n    const buf: string[] = [];\\n\\n    // Initialize the stack.\\n    // It will contain only one\\n    // repeating letter at a time\\n    // Ex: [\"zz\", \"zzz\", \"zzz\"]\\n    const stack: string[] = [\"\"];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use the letter as a separator\\n        // to move stack entries to output\\n        let M = Math.min(counts[i], stack.length - 1);\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        for (counts[i] -= M; --M >= 0; buf.push(stack.pop(), char)) {}\\n\\n        // If letter was fully used\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Last entry does not need a separator\\n        // as it\\'ll be neighbored by this letter.\\n        // Add it directly to the output.\\n        buf.push(stack.pop());\\n\\n        // Populate the queue with groups of this letter\\n        let str = char.repeat(counts[i] % repeatLimit);\\n        (str.length > 0) && stack.push(str);\\n        counts[i] -= str.length;\\n        str = char.repeat(repeatLimit);\\n        while (counts[i] > 0) {\\n            stack.push(str);\\n            counts[i] -= repeatLimit;\\n        }\\n    }\\n\\n    buf.push(stack.pop());\\n    return buf.join(\"\");\\n};\\n```\\n\\n# Code 4 - Greedy\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from input\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n    \\n    // Initialize vars\\n    let prev = \"\";\\n    let quot = 0;\\n    let rmdr = 0;\\n    const buf: string[] = [];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use current letter as separator for previous letter\\n        const M = Math.min(counts[i], quot);\\n        const curr = String.fromCharCode(25 - i + LOWER_A);\\n        for (let j = 0; ++j <= M; buf.push(prev.repeat(repeatLimit), curr)) {}\\n\\n        // If current letter was fully used\\n        if (counts[i] <= M) {\\n            quot -= M;\\n            continue;\\n        }\\n\\n        // If previous letter was fully used, add\\n        // remainder and update vars to current letter\\n        buf.push(prev.repeat(rmdr));\\n        prev = curr;\\n        counts[i] -= M;\\n        rmdr = counts[i] % repeatLimit;\\n        rmdr = (rmdr > 0) ? rmdr : repeatLimit;\\n        quot = (counts[i] - rmdr) / repeatLimit;\\n    }\\n    \\n    // Add final group to output\\n    buf.push(prev.repeat((quot > 0) ? repeatLimit : rmdr));\\n\\n    // Return output\\n    return buf.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack",
                    "Greedy",
                    "Queue"
                ],
                "code": "```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize output\\n    const buf: string[] = new Array(N).fill(\" \");\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        // Check the output for gaps\\n        for (let j = 0; j < N && counts[i] > 0; ++j) {\\n            // Fill sequential gaps up to max repeatLimit\\n            const M = Math.min(repeatLimit, counts[i]);\\n            for (let k = 0; k < M && buf[j] === \" \"; ++k) {\\n                buf[j++] = char;\\n                --counts[i];\\n            }\\n        }\\n    }\\n\\n    // Truncate the output to the first gap\\n    let len = buf.indexOf(\" \");\\n    buf.length = (len >= 0) ? len : N;\\n    \\n    return buf.join(\"\");\\n};\\n```\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize the output\\n    const buf: string[] = [];\\n\\n    // Initialize the queue.\\n    // It will contain only one\\n    // repeating letter at a time\\n    // Ex: [\"zzz\", \"zzz\", \"zz\"]\\n    const q: string[] = [\"\"];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use the letter as a separator\\n        // to move queue entries to output\\n        const M = Math.min(counts[i], q.length - 1);\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        for (let j = 0; j < M; buf.push(q[j++], char)) {}\\n        counts[i] -= M;\\n        q.splice(0, M);\\n\\n        // If letter was fully used\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Last entry does not need a separator\\n        // as it\\'ll be neighbored by this letter.\\n        // Add it directly to the output.\\n        buf.push(q.pop());\\n\\n        // Populate the queue with groups of this letter\\n        for (let len = 0; counts[i] > 0; counts[i] -= len) {\\n            len = Math.min(counts[i], repeatLimit);\\n            q.push(char.repeat(len));\\n        }\\n    }\\n    \\n    buf.push(q[0]);\\n    return buf.join(\"\");\\n};\\n```\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from s\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n\\n    // Initialize the output\\n    const buf: string[] = [];\\n\\n    // Initialize the stack.\\n    // It will contain only one\\n    // repeating letter at a time\\n    // Ex: [\"zz\", \"zzz\", \"zzz\"]\\n    const stack: string[] = [\"\"];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use the letter as a separator\\n        // to move stack entries to output\\n        let M = Math.min(counts[i], stack.length - 1);\\n        const char = String.fromCharCode(25 - i + LOWER_A);\\n        for (counts[i] -= M; --M >= 0; buf.push(stack.pop(), char)) {}\\n\\n        // If letter was fully used\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Last entry does not need a separator\\n        // as it\\'ll be neighbored by this letter.\\n        // Add it directly to the output.\\n        buf.push(stack.pop());\\n\\n        // Populate the queue with groups of this letter\\n        let str = char.repeat(counts[i] % repeatLimit);\\n        (str.length > 0) && stack.push(str);\\n        counts[i] -= str.length;\\n        str = char.repeat(repeatLimit);\\n        while (counts[i] > 0) {\\n            stack.push(str);\\n            counts[i] -= repeatLimit;\\n        }\\n    }\\n\\n    buf.push(stack.pop());\\n    return buf.join(\"\");\\n};\\n```\n```Typescript\\nconst LOWER_A = \"a\".charCodeAt(0);\\nfunction repeatLimitedString(s: string, repeatLimit: number): string {\\n    const N = s.length;\\n\\n    // Base case\\n    if (N <= repeatLimit) {\\n        return s;\\n    }\\n\\n    // Get letter frequencies from input\\n    const counts = new Array(26).fill(0);\\n    for (let i = 0; i < N; ++counts[25 - s.charCodeAt(i++) + LOWER_A]){}\\n    \\n    // Initialize vars\\n    let prev = \"\";\\n    let quot = 0;\\n    let rmdr = 0;\\n    const buf: string[] = [];\\n\\n    // For each letter in DESC order\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] <= 0) {\\n            continue;\\n        }\\n\\n        // Use current letter as separator for previous letter\\n        const M = Math.min(counts[i], quot);\\n        const curr = String.fromCharCode(25 - i + LOWER_A);\\n        for (let j = 0; ++j <= M; buf.push(prev.repeat(repeatLimit), curr)) {}\\n\\n        // If current letter was fully used\\n        if (counts[i] <= M) {\\n            quot -= M;\\n            continue;\\n        }\\n\\n        // If previous letter was fully used, add\\n        // remainder and update vars to current letter\\n        buf.push(prev.repeat(rmdr));\\n        prev = curr;\\n        counts[i] -= M;\\n        rmdr = counts[i] % repeatLimit;\\n        rmdr = (rmdr > 0) ? rmdr : repeatLimit;\\n        quot = (counts[i] - rmdr) / repeatLimit;\\n    }\\n    \\n    // Add final group to output\\n    buf.push(prev.repeat((quot > 0) ? repeatLimit : rmdr));\\n\\n    // Return output\\n    return buf.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082305,
                "title": "java-solution-using-arraylist-and-pair-class-beats-90-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Max(O(nlog(n)), O(n*repeatLimit))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    char ch;\\n    int val;\\n\\n    Pair(char ch, int val){\\n        this.ch = ch;\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        ArrayList<Pair> list = createList(s);\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        boolean fl = true;\\n\\n        while(!list.isEmpty()){\\n            if(fl == false && list.size()==1){\\n                break;\\n            }\\n            else if(fl == false){\\n                Pair p = list.get(list.size()-2);\\n                sb.append(p.ch);\\n                p.val--;\\n                if(p.val <= 0){\\n                    list.remove(list.size()-2);\\n                }\\n                fl = true;\\n            }\\n            else if(fl == true){\\n                Pair p = list.get(list.size()-1);\\n                int val = p.val;\\n                char ch = p.ch;\\n                for(int i=0; i<repeatLimit && i<val; i++){\\n                    sb.append(ch);\\n                }\\n                int k = val-repeatLimit;\\n                if(k <= 0){\\n                    list.remove(list.size()-1);\\n                }\\n                else{\\n                    p.val = k;\\n                    fl = false;\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static ArrayList<Pair> createList(String s){\\n        ArrayList<Pair> list = new ArrayList<Pair>();\\n\\n        char[] str = s.toCharArray();\\n        Arrays.sort(str);\\n        s = String.valueOf(str);\\n\\n        int c = 1;\\n\\n        for(int i=0; i<s.length()-1; i++){\\n            if(s.charAt(i) == s.charAt(i+1))\\n                c++ ;\\n            else{\\n                list.add(new Pair(s.charAt(i), c));\\n                c = 1;\\n            }\\n        }\\n\\n        char ch = s.charAt(s.length()-1);\\n        list.add(new Pair(ch,c));\\n\\n        return list;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    char ch;\\n    int val;\\n\\n    Pair(char ch, int val){\\n        this.ch = ch;\\n        this.val = val;\\n    }\\n}\\n\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        ArrayList<Pair> list = createList(s);\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        boolean fl = true;\\n\\n        while(!list.isEmpty()){\\n            if(fl == false && list.size()==1){\\n                break;\\n            }\\n            else if(fl == false){\\n                Pair p = list.get(list.size()-2);\\n                sb.append(p.ch);\\n                p.val--;\\n                if(p.val <= 0){\\n                    list.remove(list.size()-2);\\n                }\\n                fl = true;\\n            }\\n            else if(fl == true){\\n                Pair p = list.get(list.size()-1);\\n                int val = p.val;\\n                char ch = p.ch;\\n                for(int i=0; i<repeatLimit && i<val; i++){\\n                    sb.append(ch);\\n                }\\n                int k = val-repeatLimit;\\n                if(k <= 0){\\n                    list.remove(list.size()-1);\\n                }\\n                else{\\n                    p.val = k;\\n                    fl = false;\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static ArrayList<Pair> createList(String s){\\n        ArrayList<Pair> list = new ArrayList<Pair>();\\n\\n        char[] str = s.toCharArray();\\n        Arrays.sort(str);\\n        s = String.valueOf(str);\\n\\n        int c = 1;\\n\\n        for(int i=0; i<s.length()-1; i++){\\n            if(s.charAt(i) == s.charAt(i+1))\\n                c++ ;\\n            else{\\n                list.add(new Pair(s.charAt(i), c));\\n                c = 1;\\n            }\\n        }\\n\\n        char ch = s.charAt(s.length()-1);\\n        list.add(new Pair(ch,c));\\n\\n        return list;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056797,
                "title": "c-time-better-than-90-clean-explained-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n        vector<int> hash(26, 0);\\n        string res = \"\";\\n        int ch, temp = repeatLimit, size = 0;\\n        for(auto x: s)  ++hash[x-\\'a\\'];\\n        priority_queue<int> pq;\\n\\n        for(int i=25; i>=0; i--) if(hash[i] > 0) pq.push(i), ++size;\\n\\n        ch = pq.top();\\n        pq.pop();\\n        while(size>0)\\n        {\\n            // Keep appending the largest character to res, until elapse of the count of character or repeatLimit\\n            while(hash[ch] > 0 and temp > 0)\\n            {\\n                res += \\'a\\'+ch;\\n                --hash[ch];\\n                --temp;\\n            }\\n\\n            // If we have more of largest character in the original string but repeatLimit is elapsed. Then we just add the next largest character to the res and renew the repeatLimit count of largest character.\\n            if(hash[ch] > 0 and temp == 0)\\n            {\\n                if(pq.empty()) break;\\n                res += (\\'a\\'+pq.top());\\n                if(--hash[pq.top()] == 0) pq.pop();\\n                temp = repeatLimit;\\n            }\\n\\n            // If either the count of largest character elapsed or repeatLimit is elapsed. We take the next largest character and continue until we parse all the character in input string.\\n            else if(hash[ch] == 0 or temp == 0)\\n            {\\n                ch = pq.top();\\n                pq.pop();\\n                --size;\\n                temp = repeatLimit;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n        vector<int> hash(26, 0);\\n        string res = \"\";\\n        int ch, temp = repeatLimit, size = 0;\\n        for(auto x: s)  ++hash[x-\\'a\\'];\\n        priority_queue<int> pq;\\n\\n        for(int i=25; i>=0; i--) if(hash[i] > 0) pq.push(i), ++size;\\n\\n        ch = pq.top();\\n        pq.pop();\\n        while(size>0)\\n        {\\n            // Keep appending the largest character to res, until elapse of the count of character or repeatLimit\\n            while(hash[ch] > 0 and temp > 0)\\n            {\\n                res += \\'a\\'+ch;\\n                --hash[ch];\\n                --temp;\\n            }\\n\\n            // If we have more of largest character in the original string but repeatLimit is elapsed. Then we just add the next largest character to the res and renew the repeatLimit count of largest character.\\n            if(hash[ch] > 0 and temp == 0)\\n            {\\n                if(pq.empty()) break;\\n                res += (\\'a\\'+pq.top());\\n                if(--hash[pq.top()] == 0) pq.pop();\\n                temp = repeatLimit;\\n            }\\n\\n            // If either the count of largest character elapsed or repeatLimit is elapsed. We take the next largest character and continue until we parse all the character in input string.\\n            else if(hash[ch] == 0 or temp == 0)\\n            {\\n                ch = pq.top();\\n                pq.pop();\\n                --size;\\n                temp = repeatLimit;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050599,
                "title": "python-o-nlogn-o-n",
                "content": "We want the \"Lexicographically largest repeatLimitedString possible\".\\n\\nWhat does that mean?\\n\\nIt means, we want the put the greatest characters in the string in the beginning, followed by the smaller ones. But, we are also given the limit which indicates how many characters we can put in a row.\\n\\n\\tSo, if we have as string as \"abcdzzzzzz\" and limit = 3\\n\\t\\n\\tIt means we cannot have an output string that starts with \"zzzzzz\" or \"zzzzz\" or \"zzzz\"\\n\\tbecause we can repeat \"z\" only \"3\" times in a row.\\n\\t\\n\\tSince we can only repeat it \"3\" times in a row, the best way would be - \\n\\t\\n\\tFirst use at most \"3\" z characters -> output = \"zzz\"\\n\\t\\n\\tSince we cannot use \"z\" again, use one second greatest character\\n\\tHere, second greatest is \"d\" so we put it in output\\n\\t\\n\\toutput = \"zzzd\"\\n\\t\\n\\tAnd now, as you can see, we can again use multiple \"z\" together.\\n\\t\\n\\toutput  =\"zzzdzzz\"\\n\\t\\n\\tAnd that\\'s the whole idea.\\n\\t\\nSince we want the greatest characters to be in the beginning, if we reach the limit and we still have a particular character to use that is the greatest at that time, we will put one second greatest character in between so that we can again use the greatest character at most \"limit\" number of times.\\n\\nAnd to keep track of the greatest characters, we have three different options. We can either sort the characters that the string has, or we can use a maxHeap which will give us the greatest and second greatest character at any time, or we can use a simple list of length \"26\" to keep track of the characters and their frequencies.\\n# **1. SORTING APPROACH - O(NLogN)**\\n\\n```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n\\t# First, we want to know how many times each character appears in the string \"s\"\\n\\tfreq = Counter(s)\\n\\n\\t# A list of all the characters in the string\\n\\tcharList = [key for key in freq]\\n\\n\\t# Sort the charList\\n\\tcharList.sort()\\n\\n\\t# Output string to return\\n\\toutput = []\\n\\n\\t# To keep track of the largest character at any time\\n\\ti = len(charList) - 1\\n\\n\\t# What was the previous character\\n\\tprevCharacter = \\'\\'\\n\\n\\twhile len(output) != len(s):\\n\\n\\t\\t# If previous character is not the same as character at \"i\" index in charList\\n\\t\\tif prevCharacter != charList[i]:\\n\\n\\t\\t\\t# How many times we can use this character in a row\\n\\t\\t\\trepeatedCount = 0\\n\\n\\t\\t\\t# Now, we can put at most \"repeatLimit\" characters in output\\n\\t\\t\\twhile repeatedCount < repeatLimit and freq[charList[i]] > 0:\\n\\t\\t\\t\\toutput.append(charList[i])\\n\\t\\t\\t\\tfreq[charList[i]] -= 1\\n\\t\\t\\t\\trepeatedCount += 1\\n\\n\\t\\t\\t# Update the previous character\\n\\t\\t\\tprevCharacter = charList[i]\\n\\n\\t\\t\\t# If the frequency of character at \"i\" is already 0, we can decrement \"i\"\\n\\t\\t\\tif freq[charList[i]] == 0: \\n\\n\\t\\t\\t\\t# Decrement i\\n\\t\\t\\t\\ti -= 1\\n\\n\\t\\t# If previous character is the same as character at \"i\" index in charList\\n\\t\\telse:\\n\\t\\t\\t# We cannot use it again at this point\\n\\t\\t\\t# So, we have to use the second greatest character at this time, if it exists\\n\\t\\t\\t# If the second greater does not exist, break as there is no longer string possible\\n\\n\\t\\t\\t# secondGreatest\\n\\t\\t\\tj = i - 1\\n\\n\\t\\t\\t# We can only use a character if its frequency is not already 0\\n\\t\\t\\twhile j >= 0 and freq[charList[j]] == 0: j -= 1\\n\\n\\t\\t\\t# If j goes out of bounds, then there is no longer string possible at this point\\n\\t\\t\\tif j < 0: break\\n\\n\\t\\t\\t# Otherwise, we can use the character at index \"j\" in charList\\n\\t\\t\\t# We will only put one instance of this second character in the output\\n\\t\\t\\t# Because we want as many greater characters as possible in the beginning of the output string\\n\\t\\t\\toutput.append(charList[j])\\n\\n\\t\\t\\t# Update the previous character\\n\\t\\t\\tprevCharacter = charList[j]\\n\\n\\t\\t\\t# Reduce the frequency in the dictionary\\n\\t\\t\\tfreq[charList[j]] -= 1\\n\\n\\t# Return the output string\\n\\treturn \"\".join(output)\\n```\\n\\n\\n# **2. MAX HEAP APPROACH - O(NLogN)**\\n```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        # First, we want to know how many times each character appears in the string \"s\"\\n        freq = Counter(s)\\n        \\n        # We can create a maxHeap that will give us the greatest character at any time\\n        maxHeap = []\\n        \\n        for key in freq: heappush(maxHeap, [-ord(key), key])\\n        \\n        # Output string to return\\n        output = []\\n        \\n        # What was the previous character\\n        prevCharacter = \\'\\'\\n        \\n        while len(output) != len(s):\\n            \\n            # Top of heap\\n            greatestCharacter = heappop(maxHeap)[1]\\n            \\n            # If previous character is not the same as the greatest character at this point\\n            if prevCharacter != greatestCharacter:\\n                \\n                # How many times we can use this character in a row\\n                repeatedCount = 0\\n                \\n                # Now, we can put at most \"repeatLimit\" characters in output\\n                while repeatedCount < repeatLimit and freq[greatestCharacter] > 0:\\n                    output.append(greatestCharacter)\\n                    freq[greatestCharacter] -= 1\\n                    repeatedCount += 1\\n                    \\n                # Update the previous character\\n                prevCharacter = greatestCharacter\\n                \\n                # If the frequency of greatestCharacter is already 0\\n                # No need to push it back to the heap\\n                # Otherwise, push it back\\n                if freq[greatestCharacter] > 0: heappush(maxHeap, [-ord(greatestCharacter), greatestCharacter])\\n            \\n            # If previous character is the same as character at \"i\" index in charList\\n            else:\\n                # We cannot use it again at this point\\n                # So, we have to use the second greatest character at this time, if it exists\\n                \\n                # We can only use a character if its frequency is not already 0\\n                while maxHeap and freq[maxHeap[0][1]] == 0: heappop(maxHeap)\\n\\n                # If second greatest does not exist, break\\n                if not maxHeap: break\\n                    \\n                # Get the second greatest character\\n                secondGreatest = heappop(maxHeap)[1]\\n                \\n                # We will only put one instance of this second greatest character in the output\\n                # Because we want as many greater characters as possible in the beginning of the output string\\n                output.append(secondGreatest)\\n                \\n                # Update the previous character\\n                prevCharacter = secondGreatest\\n                \\n                # Reduce the frequency in the dictionary\\n                freq[secondGreatest] -= 1\\n                \\n                # If the frequency of secondGreatest is already 0\\n                # No need to push it back to the heap\\n                # Otherwise, push it back\\n                if freq[secondGreatest] > 0: heappush(maxHeap, [-ord(secondGreatest), secondGreatest])\\n                \\n                # And don\\'t forget to put the first greatest character back into the heap\\n                heappush(maxHeap, [-ord(greatestCharacter), greatestCharacter])\\n        \\n        # Return the output string\\n        return \"\".join(output)\\n```\\n\\n# **3. COUNTING APPROACH - O(N)**\\n\\n```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        # Output string to return\\n        output = []\\n        \\n        # It is given that the input string will have lowercase alphabets only\\n        # So basically, the maximum number of unique characters a string can have is 26\\n        # So, instead of having a frequency map and then creating a list or heap out of it,\\n        # We can create a list of length 26 where each index represents the character and value represents the frequency\\n        # And since the indices are already in sorted order, there is no need to explicitly sort the list\\n        freq = [0] * 26\\n        for c in s: freq[ord(c) - ord(\\'a\\')] += 1\\n        \\n        #  Now, we can begin with our main logic\\n        \\n        # Previous character\\n        previousCharacter = \\'\\'\\n        \\n        # Index of the greatest character at any time\\n        # Initialize it as the last index in the \"freq\" list\\n        i = 25\\n            \\n        while len(output) != len(s):\\n            \\n            # Make sure \"i\" points to a character that has a non-zero frequency\\n            while i >= 0 and freq[i] == 0: i -= 1\\n            \\n            # Greatest character at this time\\n            greatestCharacter = chr(i + ord(\\'a\\'))\\n            \\n            # If the previous character was not the same as current character\\n            if previousCharacter != greatestCharacter:\\n                \\n                # How many times we can use this character in a row\\n                repeatedCount = 0\\n                \\n                # Now, we can put at most \"repeatLimit\" characters in output\\n                while repeatedCount < repeatLimit and freq[i] > 0:\\n                    output.append(greatestCharacter)\\n                    freq[i] -= 1\\n                    repeatedCount += 1\\n                    \\n                # Update the previous character\\n                previousCharacter = greatestCharacter\\n            \\n            # If the previous character was the same as current character\\n            else:\\n                \\n                # We cannot use the current character in output at this point\\n                # So, we have to put the second greatest character in the output\\n                j = i - 1\\n                \\n                # Make sure secondGreatest character has a non-zero frequency\\n                while j >= 0 and freq[j] == 0: j -= 1\\n                    \\n                # If there is no secondGreatest character available, break\\n                if j < 0: break\\n                    \\n                # Otherwise, use the character at index \"j\" in \"freq\" once\\n                secondGreatest = chr(j + ord(\\'a\\'))\\n                \\n                output.append(secondGreatest)\\n                \\n                # Update the frequency\\n                freq[j] -= 1\\n                \\n                # Update the previous character\\n                previousCharacter = secondGreatest\\n                \\n        # Return the output string\\n        return \"\".join(output)   \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n\\t# First, we want to know how many times each character appears in the string \"s\"\\n\\tfreq = Counter(s)\\n\\n\\t# A list of all the characters in the string\\n\\tcharList = [key for key in freq]\\n\\n\\t# Sort the charList\\n\\tcharList.sort()\\n\\n\\t# Output string to return\\n\\toutput = []\\n\\n\\t# To keep track of the largest character at any time\\n\\ti = len(charList) - 1\\n\\n\\t# What was the previous character\\n\\tprevCharacter = \\'\\'\\n\\n\\twhile len(output) != len(s):\\n\\n\\t\\t# If previous character is not the same as character at \"i\" index in charList\\n\\t\\tif prevCharacter != charList[i]:\\n\\n\\t\\t\\t# How many times we can use this character in a row\\n\\t\\t\\trepeatedCount = 0\\n\\n\\t\\t\\t# Now, we can put at most \"repeatLimit\" characters in output\\n\\t\\t\\twhile repeatedCount < repeatLimit and freq[charList[i]] > 0:\\n\\t\\t\\t\\toutput.append(charList[i])\\n\\t\\t\\t\\tfreq[charList[i]] -= 1\\n\\t\\t\\t\\trepeatedCount += 1\\n\\n\\t\\t\\t# Update the previous character\\n\\t\\t\\tprevCharacter = charList[i]\\n\\n\\t\\t\\t# If the frequency of character at \"i\" is already 0, we can decrement \"i\"\\n\\t\\t\\tif freq[charList[i]] == 0: \\n\\n\\t\\t\\t\\t# Decrement i\\n\\t\\t\\t\\ti -= 1\\n\\n\\t\\t# If previous character is the same as character at \"i\" index in charList\\n\\t\\telse:\\n\\t\\t\\t# We cannot use it again at this point\\n\\t\\t\\t# So, we have to use the second greatest character at this time, if it exists\\n\\t\\t\\t# If the second greater does not exist, break as there is no longer string possible\\n\\n\\t\\t\\t# secondGreatest\\n\\t\\t\\tj = i - 1\\n\\n\\t\\t\\t# We can only use a character if its frequency is not already 0\\n\\t\\t\\twhile j >= 0 and freq[charList[j]] == 0: j -= 1\\n\\n\\t\\t\\t# If j goes out of bounds, then there is no longer string possible at this point\\n\\t\\t\\tif j < 0: break\\n\\n\\t\\t\\t# Otherwise, we can use the character at index \"j\" in charList\\n\\t\\t\\t# We will only put one instance of this second character in the output\\n\\t\\t\\t# Because we want as many greater characters as possible in the beginning of the output string\\n\\t\\t\\toutput.append(charList[j])\\n\\n\\t\\t\\t# Update the previous character\\n\\t\\t\\tprevCharacter = charList[j]\\n\\n\\t\\t\\t# Reduce the frequency in the dictionary\\n\\t\\t\\tfreq[charList[j]] -= 1\\n\\n\\t# Return the output string\\n\\treturn \"\".join(output)\\n```\n```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        # First, we want to know how many times each character appears in the string \"s\"\\n        freq = Counter(s)\\n        \\n        # We can create a maxHeap that will give us the greatest character at any time\\n        maxHeap = []\\n        \\n        for key in freq: heappush(maxHeap, [-ord(key), key])\\n        \\n        # Output string to return\\n        output = []\\n        \\n        # What was the previous character\\n        prevCharacter = \\'\\'\\n        \\n        while len(output) != len(s):\\n            \\n            # Top of heap\\n            greatestCharacter = heappop(maxHeap)[1]\\n            \\n            # If previous character is not the same as the greatest character at this point\\n            if prevCharacter != greatestCharacter:\\n                \\n                # How many times we can use this character in a row\\n                repeatedCount = 0\\n                \\n                # Now, we can put at most \"repeatLimit\" characters in output\\n                while repeatedCount < repeatLimit and freq[greatestCharacter] > 0:\\n                    output.append(greatestCharacter)\\n                    freq[greatestCharacter] -= 1\\n                    repeatedCount += 1\\n                    \\n                # Update the previous character\\n                prevCharacter = greatestCharacter\\n                \\n                # If the frequency of greatestCharacter is already 0\\n                # No need to push it back to the heap\\n                # Otherwise, push it back\\n                if freq[greatestCharacter] > 0: heappush(maxHeap, [-ord(greatestCharacter), greatestCharacter])\\n            \\n            # If previous character is the same as character at \"i\" index in charList\\n            else:\\n                # We cannot use it again at this point\\n                # So, we have to use the second greatest character at this time, if it exists\\n                \\n                # We can only use a character if its frequency is not already 0\\n                while maxHeap and freq[maxHeap[0][1]] == 0: heappop(maxHeap)\\n\\n                # If second greatest does not exist, break\\n                if not maxHeap: break\\n                    \\n                # Get the second greatest character\\n                secondGreatest = heappop(maxHeap)[1]\\n                \\n                # We will only put one instance of this second greatest character in the output\\n                # Because we want as many greater characters as possible in the beginning of the output string\\n                output.append(secondGreatest)\\n                \\n                # Update the previous character\\n                prevCharacter = secondGreatest\\n                \\n                # Reduce the frequency in the dictionary\\n                freq[secondGreatest] -= 1\\n                \\n                # If the frequency of secondGreatest is already 0\\n                # No need to push it back to the heap\\n                # Otherwise, push it back\\n                if freq[secondGreatest] > 0: heappush(maxHeap, [-ord(secondGreatest), secondGreatest])\\n                \\n                # And don\\'t forget to put the first greatest character back into the heap\\n                heappush(maxHeap, [-ord(greatestCharacter), greatestCharacter])\\n        \\n        # Return the output string\\n        return \"\".join(output)\\n```\n```\\ndef repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        # Output string to return\\n        output = []\\n        \\n        # It is given that the input string will have lowercase alphabets only\\n        # So basically, the maximum number of unique characters a string can have is 26\\n        # So, instead of having a frequency map and then creating a list or heap out of it,\\n        # We can create a list of length 26 where each index represents the character and value represents the frequency\\n        # And since the indices are already in sorted order, there is no need to explicitly sort the list\\n        freq = [0] * 26\\n        for c in s: freq[ord(c) - ord(\\'a\\')] += 1\\n        \\n        #  Now, we can begin with our main logic\\n        \\n        # Previous character\\n        previousCharacter = \\'\\'\\n        \\n        # Index of the greatest character at any time\\n        # Initialize it as the last index in the \"freq\" list\\n        i = 25\\n            \\n        while len(output) != len(s):\\n            \\n            # Make sure \"i\" points to a character that has a non-zero frequency\\n            while i >= 0 and freq[i] == 0: i -= 1\\n            \\n            # Greatest character at this time\\n            greatestCharacter = chr(i + ord(\\'a\\'))\\n            \\n            # If the previous character was not the same as current character\\n            if previousCharacter != greatestCharacter:\\n                \\n                # How many times we can use this character in a row\\n                repeatedCount = 0\\n                \\n                # Now, we can put at most \"repeatLimit\" characters in output\\n                while repeatedCount < repeatLimit and freq[i] > 0:\\n                    output.append(greatestCharacter)\\n                    freq[i] -= 1\\n                    repeatedCount += 1\\n                    \\n                # Update the previous character\\n                previousCharacter = greatestCharacter\\n            \\n            # If the previous character was the same as current character\\n            else:\\n                \\n                # We cannot use the current character in output at this point\\n                # So, we have to put the second greatest character in the output\\n                j = i - 1\\n                \\n                # Make sure secondGreatest character has a non-zero frequency\\n                while j >= 0 and freq[j] == 0: j -= 1\\n                    \\n                # If there is no secondGreatest character available, break\\n                if j < 0: break\\n                    \\n                # Otherwise, use the character at index \"j\" in \"freq\" once\\n                secondGreatest = chr(j + ord(\\'a\\'))\\n                \\n                output.append(secondGreatest)\\n                \\n                # Update the frequency\\n                freq[j] -= 1\\n                \\n                # Update the previous character\\n                previousCharacter = secondGreatest\\n                \\n        # Return the output string\\n        return \"\".join(output)   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4042962,
                "title": "python3-maxheap",
                "content": "Intuition:\\n* Keep using the largest lexograhpical character that is available from string ```s``` up to the ```repeatLimit```\\n* Once that largest lexographicla character has been used, proceed to next largest lexographical character\\n\\nCaveats\\n* We can\\'t simply just discard the current largest lexogrphical character if we hit the ```repeatLimit```\\n* If we hit the ```repeatLimit``` before consiming the current largest lexographical character, then we try to break the current streak with the next largest lexographical character we can retrieve from the heap using only 1 occruence of the next\\n* If we can\\'t retrieve anything, then we are done trying to build the string\\n* If there is still occruencs of both the ```first_largest``` and ```second_largest``` push them back to the heap\\n\\nNote:\\n* For the counts array, i offset the indcies by 1 and negate in order to use max heap, otherwise 0 would come before -25, which is what we dont want\\n\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        counts = [0]*26\\n        for ch in s:\\n            counts[ord(ch) - ord(\\'a\\')] += 1\\n        \\n        largest_chars = [-(i+1) for i in range(26) if counts[i] != 0] #one based indexing to allow for ordering\\n        heapq.heapify(largest_chars)\\n        \\n        ans = \"\"\\n        waiting = -1\\n        \\n        while largest_chars:\\n            first_largest = -heapq.heappop(largest_chars) - 1\\n            \\n            #use up first largest as much as we can\\n            repeat = 0\\n            while repeat < repeatLimit and counts[first_largest] > 0:\\n                ans += chr(ord(\\'a\\') + first_largest)\\n                repeat += 1\\n                counts[first_largest] -= 1\\n            \\n            #no more of firt largest\\n            if counts[first_largest] == 0:\\n                continue\\n            #otherwise we can break this wit the second largest\\n            else:\\n                if not largest_chars:\\n                    return ans\\n                second_largest = -heapq.heappop(largest_chars) - 1\\n                ans += chr(ord(\\'a\\') + second_largest)\\n                counts[second_largest] -= 1\\n                \\n                #add back in\\n                if counts[second_largest] > 0:\\n                    heapq.heappush(largest_chars, -(second_largest + 1))\\n                    \\n                #dont forget first largest\\n                heapq.heappush(largest_chars, -(first_largest +1))\\n        \\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```s```\n```repeatLimit```\n```repeatLimit```\n```repeatLimit```\n```first_largest```\n```second_largest```\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        counts = [0]*26\\n        for ch in s:\\n            counts[ord(ch) - ord(\\'a\\')] += 1\\n        \\n        largest_chars = [-(i+1) for i in range(26) if counts[i] != 0] #one based indexing to allow for ordering\\n        heapq.heapify(largest_chars)\\n        \\n        ans = \"\"\\n        waiting = -1\\n        \\n        while largest_chars:\\n            first_largest = -heapq.heappop(largest_chars) - 1\\n            \\n            #use up first largest as much as we can\\n            repeat = 0\\n            while repeat < repeatLimit and counts[first_largest] > 0:\\n                ans += chr(ord(\\'a\\') + first_largest)\\n                repeat += 1\\n                counts[first_largest] -= 1\\n            \\n            #no more of firt largest\\n            if counts[first_largest] == 0:\\n                continue\\n            #otherwise we can break this wit the second largest\\n            else:\\n                if not largest_chars:\\n                    return ans\\n                second_largest = -heapq.heappop(largest_chars) - 1\\n                ans += chr(ord(\\'a\\') + second_largest)\\n                counts[second_largest] -= 1\\n                \\n                #add back in\\n                if counts[second_largest] > 0:\\n                    heapq.heappush(largest_chars, -(second_largest + 1))\\n                    \\n                #dont forget first largest\\n                heapq.heappush(largest_chars, -(first_largest +1))\\n        \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008985,
                "title": "c-easy-to-understand-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        map<char, int> m; \\n        for(auto i: s){\\n            m[i]++; \\n        }\\n        priority_queue<pair<char, int>> p; \\n        for(auto i: m)p.push(i); \\n        pair<char, int> temp = {\\'A\\', -1}; \\n        string ans; \\n        while(!p.empty()){\\n            auto x = p.top(); \\n            p.pop(); \\n            int count = 0; \\n            while(count< repeatLimit && x.second> 0){\\n                ans.push_back(x.first); \\n                x.second -=1; \\n                count ++ ; \\n            }\\n            if(!p.empty()&& x.second > 0){\\n                temp = x; \\n                x = p.top(); \\n                p.pop(); \\n                ans.push_back(x.first); \\n                x.second -=1; \\n                p.push(temp); \\n                if(x.second>0)p.push(x); \\n            }\\n\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        map<char, int> m; \\n        for(auto i: s){\\n            m[i]++; \\n        }\\n        priority_queue<pair<char, int>> p; \\n        for(auto i: m)p.push(i); \\n        pair<char, int> temp = {\\'A\\', -1}; \\n        string ans; \\n        while(!p.empty()){\\n            auto x = p.top(); \\n            p.pop(); \\n            int count = 0; \\n            while(count< repeatLimit && x.second> 0){\\n                ans.push_back(x.first); \\n                x.second -=1; \\n                count ++ ; \\n            }\\n            if(!p.empty()&& x.second > 0){\\n                temp = x; \\n                x = p.top(); \\n                p.pop(); \\n                ans.push_back(x.first); \\n                x.second -=1; \\n                p.push(temp); \\n                if(x.second>0)p.push(x); \\n            }\\n\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997225,
                "title": "no-built-in-priority-queue-priority-queue-implementation-max-heap-c",
                "content": "# Approach\\n\\nLet\\'s try to implement Max Heap directly, with no usage of built-in Priority Queue\\n\\nMax Heap stores maximum element in the root, in spite of usually used Min Heap\\n\\nIn our MaxHeap we will store pair (char : it\\'s frequency) as values and make a comparison on the first element of the pair **(lexicographically)**\\n\\n## What are the operations?\\n\\n1) **SiftUp** - checks if we can move a node up to make your Heap a correct Max Heap (e.g. you got a child and it\\'s value is bigger than the parents value, so we need to swap them). We need to check while we can go upwards **(while v != 0)** and do a swap if we need to. \\n2) **SiftDown** - does the same as SiftUp, but in the opposite direction. It\\'s a bit more difficult than SiftUp, because here we need to do the following:\\n\\n    2.1 Check if left child exists by looking at **2 * v + 1** index\\n    2.2 Check if right child exists by looking at **2 * v + 2** index \\n    2.3 Find the maximum child from left and right and swap this maximum child with the parent\\n\\n3) **Heapify** - builds a correct Max Heap on given array. Time complexity is O(N) using SiftDown (with SiftUp it won\\'t be working for the same O(N) time).\\n4) **GetMax & ExtractMax** - GetMax **returns** max element, meanwhile **ExtractMax** deletes it. (Optionally, you can create a function that does both at the same time)\\n5) **Insert** - inserts pair in the end of MaxHeap.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // \\u0432 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0435 \\u043C\\u0430\\u043A\\u0441 \\u043A\\u0443\\u0447\\u0438 \\u0445\\u0440\\u0430\\u043D\\u0438\\u043C \\u043F\\u0430\\u0440\\u0443 (\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B char : \\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u0432\\u0441\\u0442\\u0440\\u0435\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F)\\n\\n    void SiftUp(std::vector<std::pair<char, int>>& MaxHeap, int v) {\\n        while (v != 0) {\\n            if (MaxHeap[v].first > MaxHeap[(v - 1) / 2].first) {\\n                std::swap(MaxHeap[v], MaxHeap[(v - 1) / 2]);\\n                v = (v - 1) / 2;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    void SiftDown(std::vector<std::pair<char, int>>& MaxHeap, int v) {\\n        int n = MaxHeap.size();\\n        while (2 * v + 1 < n) {\\n            int u = 2 * v + 1;\\n            if (2 * v + 2 < n && MaxHeap[2 * v + 2].first > MaxHeap[2 * v + 1].first) {\\n                u = 2 * v + 2;\\n            }\\n            if (MaxHeap[u].first > MaxHeap[v].first) {\\n                std::swap(MaxHeap[u], MaxHeap[v]);\\n                v = u;\\n            } else {\\n                break;\\n            }\\n        } \\n    }\\n\\n    void Heapify(std::vector<std::pair<char, int>>& array) {\\n        for (int i = array.size() - 1; i >= 0; --i) {\\n            SiftDown(array, i);\\n        }\\n    }\\n\\n    std::pair<char, int> GetMax(std::vector<std::pair<char, int>>& MaxHeap) {\\n        return MaxHeap[0];\\n    }\\n\\n    void ExtractMax(std::vector<std::pair<char, int>>& MaxHeap) {;\\n        MaxHeap[0] = MaxHeap[MaxHeap.size() - 1];\\n        MaxHeap.pop_back();\\n        SiftDown(MaxHeap, 0);\\n    }\\n\\n    void Insert(std::vector<std::pair<char, int>>& MaxHeap, std::pair<char, int> value) {\\n\\t\\t\\t\\tMaxHeap.push_back(value);\\n        SiftUp(MaxHeap, MaxHeap.size() - 1);\\n    }\\n\\n    void ToVector(std::vector<std::pair<char, int>>& array, std::string s) {\\n\\t\\t\\tstd::vector<int> freq(26, 0);\\n\\t\\t\\tfor (const auto& item : s) {\\n\\t\\t\\t\\tfreq[item - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j = 0; j < freq.size(); ++j) {\\n\\t\\t\\t\\tif (freq[j] > 0) {\\n\\t\\t\\t\\t\\tchar letter = char(int(\\'a\\') + j);\\n\\t\\t\\t\\t\\tarray.push_back(std::make_pair(letter, freq[j]));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n    }\\n\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        std::string answer;\\n        std::vector<std::pair<char, int>> MaxHeap;\\n        ToVector(MaxHeap, s);\\n        Heapify(MaxHeap);\\n\\n        while (MaxHeap.size() > 0) {\\n            std::pair<char, int> first_max_pair = GetMax(MaxHeap);\\n\\t\\t\\t\\t\\t\\tExtractMax(MaxHeap);\\n\\n            int max_frequency = first_max_pair.second;\\n\\n            // \\u0434\\u043E\\u0441\\u0442\\u0430\\u0451\\u043C max \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u043F\\u043E\\u043A\\u0430 \\u043C\\u043E\\u0436\\u0435\\u043C\\n\\n            for (int i = 0; i < repeatLimit && max_frequency > 0; ++i) {\\n                char letter = first_max_pair.first;\\n                answer.push_back(letter);\\n                --max_frequency;\\n            }\\n\\n            // \\u0435\\u0441\\u043B\\u0438 \\u043C\\u0430\\u043A\\u0441 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0435\\u0449\\u0451 \\u043E\\u0441\\u0442\\u0430\\u043B\\u0441\\u044F, \\u043D\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0432\\u0437\\u044F\\u0442\\u044C \\u043D\\u0435 \\u043C\\u043E\\u0436\\u0435\\u043C \\u0438\\u0437-\\u0437\\u0430 repeatLimit\\n\\n            if (max_frequency > 0 && MaxHeap.size() > 0) {\\n\\t\\t\\t\\t\\t\\t\\tstd::pair<char, int> second_max_pair = GetMax(MaxHeap);\\n\\t\\t\\t\\t\\t\\t\\tExtractMax(MaxHeap);\\n\\n\\t\\t\\t\\t\\t\\t\\tanswer.push_back(second_max_pair.first);\\n\\n\\t\\t\\t\\t\\t\\t\\tif (second_max_pair.second > 1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tInsert(MaxHeap, std::make_pair(second_max_pair.first, second_max_pair.second - 1));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// \\u0432\\u0437\\u044F\\u043B\\u0438 2 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C, \\u0442\\u0435\\u043F\\u0435\\u0440\\u044C \\u0432\\u0435\\u0440\\u043D\\u0451\\u043C \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E 1-\\u044B\\u0439 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C\\n\\t\\t\\t\\t\\t\\t\\tInsert(MaxHeap, std::make_pair(first_max_pair.first, max_frequency));\\n            }\\n        }\\n      return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // \\u0432 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0435 \\u043C\\u0430\\u043A\\u0441 \\u043A\\u0443\\u0447\\u0438 \\u0445\\u0440\\u0430\\u043D\\u0438\\u043C \\u043F\\u0430\\u0440\\u0443 (\\u0441\\u0438\\u043C\\u0432\\u043E\\u043B char : \\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u0432\\u0441\\u0442\\u0440\\u0435\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F)\\n\\n    void SiftUp(std::vector<std::pair<char, int>>& MaxHeap, int v) {\\n        while (v != 0) {\\n            if (MaxHeap[v].first > MaxHeap[(v - 1) / 2].first) {\\n                std::swap(MaxHeap[v], MaxHeap[(v - 1) / 2]);\\n                v = (v - 1) / 2;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    void SiftDown(std::vector<std::pair<char, int>>& MaxHeap, int v) {\\n        int n = MaxHeap.size();\\n        while (2 * v + 1 < n) {\\n            int u = 2 * v + 1;\\n            if (2 * v + 2 < n && MaxHeap[2 * v + 2].first > MaxHeap[2 * v + 1].first) {\\n                u = 2 * v + 2;\\n            }\\n            if (MaxHeap[u].first > MaxHeap[v].first) {\\n                std::swap(MaxHeap[u], MaxHeap[v]);\\n                v = u;\\n            } else {\\n                break;\\n            }\\n        } \\n    }\\n\\n    void Heapify(std::vector<std::pair<char, int>>& array) {\\n        for (int i = array.size() - 1; i >= 0; --i) {\\n            SiftDown(array, i);\\n        }\\n    }\\n\\n    std::pair<char, int> GetMax(std::vector<std::pair<char, int>>& MaxHeap) {\\n        return MaxHeap[0];\\n    }\\n\\n    void ExtractMax(std::vector<std::pair<char, int>>& MaxHeap) {;\\n        MaxHeap[0] = MaxHeap[MaxHeap.size() - 1];\\n        MaxHeap.pop_back();\\n        SiftDown(MaxHeap, 0);\\n    }\\n\\n    void Insert(std::vector<std::pair<char, int>>& MaxHeap, std::pair<char, int> value) {\\n\\t\\t\\t\\tMaxHeap.push_back(value);\\n        SiftUp(MaxHeap, MaxHeap.size() - 1);\\n    }\\n\\n    void ToVector(std::vector<std::pair<char, int>>& array, std::string s) {\\n\\t\\t\\tstd::vector<int> freq(26, 0);\\n\\t\\t\\tfor (const auto& item : s) {\\n\\t\\t\\t\\tfreq[item - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j = 0; j < freq.size(); ++j) {\\n\\t\\t\\t\\tif (freq[j] > 0) {\\n\\t\\t\\t\\t\\tchar letter = char(int(\\'a\\') + j);\\n\\t\\t\\t\\t\\tarray.push_back(std::make_pair(letter, freq[j]));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n    }\\n\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        std::string answer;\\n        std::vector<std::pair<char, int>> MaxHeap;\\n        ToVector(MaxHeap, s);\\n        Heapify(MaxHeap);\\n\\n        while (MaxHeap.size() > 0) {\\n            std::pair<char, int> first_max_pair = GetMax(MaxHeap);\\n\\t\\t\\t\\t\\t\\tExtractMax(MaxHeap);\\n\\n            int max_frequency = first_max_pair.second;\\n\\n            // \\u0434\\u043E\\u0441\\u0442\\u0430\\u0451\\u043C max \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u043F\\u043E\\u043A\\u0430 \\u043C\\u043E\\u0436\\u0435\\u043C\\n\\n            for (int i = 0; i < repeatLimit && max_frequency > 0; ++i) {\\n                char letter = first_max_pair.first;\\n                answer.push_back(letter);\\n                --max_frequency;\\n            }\\n\\n            // \\u0435\\u0441\\u043B\\u0438 \\u043C\\u0430\\u043A\\u0441 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0435\\u0449\\u0451 \\u043E\\u0441\\u0442\\u0430\\u043B\\u0441\\u044F, \\u043D\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0432\\u0437\\u044F\\u0442\\u044C \\u043D\\u0435 \\u043C\\u043E\\u0436\\u0435\\u043C \\u0438\\u0437-\\u0437\\u0430 repeatLimit\\n\\n            if (max_frequency > 0 && MaxHeap.size() > 0) {\\n\\t\\t\\t\\t\\t\\t\\tstd::pair<char, int> second_max_pair = GetMax(MaxHeap);\\n\\t\\t\\t\\t\\t\\t\\tExtractMax(MaxHeap);\\n\\n\\t\\t\\t\\t\\t\\t\\tanswer.push_back(second_max_pair.first);\\n\\n\\t\\t\\t\\t\\t\\t\\tif (second_max_pair.second > 1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tInsert(MaxHeap, std::make_pair(second_max_pair.first, second_max_pair.second - 1));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// \\u0432\\u0437\\u044F\\u043B\\u0438 2 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C, \\u0442\\u0435\\u043F\\u0435\\u0440\\u044C \\u0432\\u0435\\u0440\\u043D\\u0451\\u043C \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E 1-\\u044B\\u0439 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0443\\u043C\\n\\t\\t\\t\\t\\t\\t\\tInsert(MaxHeap, std::make_pair(first_max_pair.first, max_frequency));\\n            }\\n        }\\n      return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980542,
                "title": "very-easy-using-greedy-approach-t-c-o-nlogn",
                "content": "# Approach\\n1. lexicographically largest bnane ke liye sort krke jbtk  freq.      repeatlimit ke km hai add krte rhna hai.\\n2. hm k time hi add kr skte hai ish liye secondLargest ko ek baar add krenge aur phir se largest ko add krenge agr exist lrta hai to.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        /*\\n        HINT:- lexicographically largest bnane ke liye sort krke jbtk freq. repeatlimit ke km hai\\n               add krte rhna hai.\\n               hm k time hi add kr skte hai ish liye secondLargest ko ek baar add krenge aur phir se \\n               largest ko add krenge agr exist lrta hai to.\\n        */\\n        map<char,int>mp;\\n        for(int i=0;i<s.size();i++){  // frequncy of each character\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<char,int> >pq;\\n        for(auto it:mp){\\n            pq.push(it);\\n        }\\n        string result = \"\";\\n\\n        while(!pq.empty()){\\n            auto largest = pq.top();\\n            pq.pop();\\n            int len = min(repeatLimit, largest.second);  // we will take minimum of repeatLimit and freq.\\n            for(int i=0;i<len;i++){\\n                result += largest.first;\\n            }\\n\\n            pair<char,int> secondLargest;\\n            if(largest.second - len > 0){  // repeatLimit se jda freq. hai agr largest ki \\n                if(!pq.empty()){\\n                    secondLargest = pq.top();\\n                    pq.pop();\\n                    result += secondLargest.first;\\n                }\\n                else{\\n                    return result;\\n                }\\n\\n                if(secondLargest.second - 1>0) pq.push({secondLargest.first, secondLargest.second-1});\\n                pq.push({largest.first, largest.second-len});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        /*\\n        HINT:- lexicographically largest bnane ke liye sort krke jbtk freq. repeatlimit ke km hai\\n               add krte rhna hai.\\n               hm k time hi add kr skte hai ish liye secondLargest ko ek baar add krenge aur phir se \\n               largest ko add krenge agr exist lrta hai to.\\n        */\\n        map<char,int>mp;\\n        for(int i=0;i<s.size();i++){  // frequncy of each character\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<char,int> >pq;\\n        for(auto it:mp){\\n            pq.push(it);\\n        }\\n        string result = \"\";\\n\\n        while(!pq.empty()){\\n            auto largest = pq.top();\\n            pq.pop();\\n            int len = min(repeatLimit, largest.second);  // we will take minimum of repeatLimit and freq.\\n            for(int i=0;i<len;i++){\\n                result += largest.first;\\n            }\\n\\n            pair<char,int> secondLargest;\\n            if(largest.second - len > 0){  // repeatLimit se jda freq. hai agr largest ki \\n                if(!pq.empty()){\\n                    secondLargest = pq.top();\\n                    pq.pop();\\n                    result += secondLargest.first;\\n                }\\n                else{\\n                    return result;\\n                }\\n\\n                if(secondLargest.second - 1>0) pq.push({secondLargest.first, secondLargest.second-1});\\n                pq.push({largest.first, largest.second-len});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962587,
                "title": "freq-array-greedy-way-of-picking-chars",
                "content": "# Intuition\\nStart allocating from z to a, if you reach the limit of current character, pick the one character from remaining set & repeat the same. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ // $$N$$ is the length of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] freq = new int[26];\\n        for(char c : s.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n\\n        StringBuilder result = new StringBuilder(); \\n        for(int i=25; i>=0; i--){\\n            int nextAvailableCharIndex = getNextAvailableIndex(freq, i-1);\\n\\n            while(freq[i] > 0){\\n\\n                int len = Math.min(repeatLimit, freq[i]);\\n                freq[i] -= len; \\n                while(len-- > 0){\\n                    result.append((char)(i+\\'a\\'));\\n                }\\n                if(freq[i]==0)\\n                    continue; \\n\\n                if(nextAvailableCharIndex >= 0 && freq[nextAvailableCharIndex] == 0){\\n                    nextAvailableCharIndex = getNextAvailableIndex(freq, nextAvailableCharIndex-1);\\n                }\\n\\n                if(nextAvailableCharIndex == -1)\\n                    return result.toString();\\n\\n                result.append((char)(nextAvailableCharIndex+\\'a\\'));\\n                freq[nextAvailableCharIndex]--;\\n            }\\n        }\\n        return result.toString(); \\n    }\\n\\n    int getNextAvailableIndex(int[] freq, int lastIndex){\\n        while(lastIndex >= 0 && freq[lastIndex]==0)\\n            lastIndex--;\\n        return lastIndex; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] freq = new int[26];\\n        for(char c : s.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n\\n        StringBuilder result = new StringBuilder(); \\n        for(int i=25; i>=0; i--){\\n            int nextAvailableCharIndex = getNextAvailableIndex(freq, i-1);\\n\\n            while(freq[i] > 0){\\n\\n                int len = Math.min(repeatLimit, freq[i]);\\n                freq[i] -= len; \\n                while(len-- > 0){\\n                    result.append((char)(i+\\'a\\'));\\n                }\\n                if(freq[i]==0)\\n                    continue; \\n\\n                if(nextAvailableCharIndex >= 0 && freq[nextAvailableCharIndex] == 0){\\n                    nextAvailableCharIndex = getNextAvailableIndex(freq, nextAvailableCharIndex-1);\\n                }\\n\\n                if(nextAvailableCharIndex == -1)\\n                    return result.toString();\\n\\n                result.append((char)(nextAvailableCharIndex+\\'a\\'));\\n                freq[nextAvailableCharIndex]--;\\n            }\\n        }\\n        return result.toString(); \\n    }\\n\\n    int getNextAvailableIndex(int[] freq, int lastIndex){\\n        while(lastIndex >= 0 && freq[lastIndex]==0)\\n            lastIndex--;\\n        return lastIndex; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948197,
                "title": "simple-javascript-solution-using-greedy-approach-and-heap",
                "content": "We are solving this question using 3 condition. As it is already mentioned there is character limits in the string. \\n\\nSo the first condition is for when character frequency is in the repeatLimit\\n\\nsecond condition is for when character frequency is out of repeatLimit. In this case we append characters upto repeatLimit.\\n\\nthird condition is for when previous character is same as current character. In this case we append 1 character of current.\\n\\nSo using heap this question can be solved easily.\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\n\\nvar Heap = function() {\\n    this.heap = [];\\n}\\n\\nfunction findMinIndex(a) {\\n    if(a.length) {\\n    let minIndex = 0, min = a[0][2];\\n    for(let i = 1; i < a.length; i++) {\\n        if(a[i][2] > min) {\\n            minIndex = i;\\n            min = a[i][2];\\n        }\\n    }\\n\\n    return minIndex;}\\n}\\n\\nHeap.prototype.swap = function(a, b) {\\n    if(this.heap.length) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n}\\n\\nHeap.prototype.insert = function(value) {\\n    this.heap.push(value);\\n    const minIndex = findMinIndex(this.heap);\\n    this.swap(0, minIndex);\\n}\\n\\nHeap.prototype.extract = function() {\\n    const value = this.heap.shift();\\n    const minIndex = findMinIndex(this.heap);\\n    this.swap(0, minIndex);\\n    return value;\\n}\\n\\nHeap.prototype.length = function() {\\n    return this.heap.length;\\n}\\n\\nvar repeat = function(c, l) {\\n    let s = \"\";\\n    for(let i = 0; i < l; i++) {\\n        s += c;\\n    }\\n\\n    return s;\\n}\\n\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    let heap = new Heap(), map = {};\\n\\n    for(let c of s) {\\n        map[c] = (map[c] || 0) + 1;\\n    }\\n\\n\\n    for(let [x, y] of Object.entries(map)) {\\n        heap.insert([x, y, x.charCodeAt() - 97]);\\n    }\\n    let s1 = \"\", prev = \"\";\\n    while(heap.length()) {\\n        const element = heap.extract();\\n\\n        if(repeatLimit >= element[1] && prev !== element[0]) {\\n            s1 += repeat(element[0], element[1]);\\n            prev = element[0];   \\n        } else if(prev != element[0] && repeatLimit < element[1]) {\\n            const remain = element[1] - repeatLimit;\\n            s1 += repeat(element[0], repeatLimit);\\n            heap.insert([element[0], remain, element[0].charCodeAt() - 97]);\\n            prev = element[0];   \\n        } else if(prev === element[0]) {\\n            const element1 = heap.extract();\\n            if(element1) {\\n                s1 += element1[0];\\n                if(element1[1] - 1 > 0) {\\n                heap.insert([element1[0], element1[1] - 1, element1[0].charCodeAt() - 97]);}\\n                heap.insert(element);\\n                prev = element1[0];\\n            }   \\n        }\\n\\n    }\\n\\n    return s1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\n\\nvar Heap = function() {\\n    this.heap = [];\\n}\\n\\nfunction findMinIndex(a) {\\n    if(a.length) {\\n    let minIndex = 0, min = a[0][2];\\n    for(let i = 1; i < a.length; i++) {\\n        if(a[i][2] > min) {\\n            minIndex = i;\\n            min = a[i][2];\\n        }\\n    }\\n\\n    return minIndex;}\\n}\\n\\nHeap.prototype.swap = function(a, b) {\\n    if(this.heap.length) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n}\\n\\nHeap.prototype.insert = function(value) {\\n    this.heap.push(value);\\n    const minIndex = findMinIndex(this.heap);\\n    this.swap(0, minIndex);\\n}\\n\\nHeap.prototype.extract = function() {\\n    const value = this.heap.shift();\\n    const minIndex = findMinIndex(this.heap);\\n    this.swap(0, minIndex);\\n    return value;\\n}\\n\\nHeap.prototype.length = function() {\\n    return this.heap.length;\\n}\\n\\nvar repeat = function(c, l) {\\n    let s = \"\";\\n    for(let i = 0; i < l; i++) {\\n        s += c;\\n    }\\n\\n    return s;\\n}\\n\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    let heap = new Heap(), map = {};\\n\\n    for(let c of s) {\\n        map[c] = (map[c] || 0) + 1;\\n    }\\n\\n\\n    for(let [x, y] of Object.entries(map)) {\\n        heap.insert([x, y, x.charCodeAt() - 97]);\\n    }\\n    let s1 = \"\", prev = \"\";\\n    while(heap.length()) {\\n        const element = heap.extract();\\n\\n        if(repeatLimit >= element[1] && prev !== element[0]) {\\n            s1 += repeat(element[0], element[1]);\\n            prev = element[0];   \\n        } else if(prev != element[0] && repeatLimit < element[1]) {\\n            const remain = element[1] - repeatLimit;\\n            s1 += repeat(element[0], repeatLimit);\\n            heap.insert([element[0], remain, element[0].charCodeAt() - 97]);\\n            prev = element[0];   \\n        } else if(prev === element[0]) {\\n            const element1 = heap.extract();\\n            if(element1) {\\n                s1 += element1[0];\\n                if(element1[1] - 1 > 0) {\\n                heap.insert([element1[0], element1[1] - 1, element1[0].charCodeAt() - 97]);}\\n                heap.insert(element);\\n                prev = element1[0];\\n            }   \\n        }\\n\\n    }\\n\\n    return s1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937106,
                "title": "easiest-solution-using-priority-queues-hashmaps-and-greedy-algorithm-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        unordered_map<char, int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        priority_queue<pair<char, int>>pq;\\n        for(auto p:m){\\n            pq.push(p);\\n        }\\n        string result = \"\";\\n        while(!pq.empty()){\\n            pair<char, int> largest = pq.top();\\n            pq.pop();\\n            int len = min(repeatLimit, largest.second);\\n            for(int i=0;i<len;i++){\\n                result+=largest.first;\\n            }\\n            pair<char, int>secondLargest;\\n            if(largest.second-len>0){\\n                if(!pq.empty()){\\n                secondLargest = pq.top();\\n                pq.pop();\\n                result+=secondLargest.first;\\n        }\\n            else{\\n                return result;\\n            }\\n            if(secondLargest.second-1>0)\\n            pq.push({secondLargest.first, secondLargest.second-1});\\n            pq.push({largest.first, largest.second-len});\\n        }\\n    }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        unordered_map<char, int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        priority_queue<pair<char, int>>pq;\\n        for(auto p:m){\\n            pq.push(p);\\n        }\\n        string result = \"\";\\n        while(!pq.empty()){\\n            pair<char, int> largest = pq.top();\\n            pq.pop();\\n            int len = min(repeatLimit, largest.second);\\n            for(int i=0;i<len;i++){\\n                result+=largest.first;\\n            }\\n            pair<char, int>secondLargest;\\n            if(largest.second-len>0){\\n                if(!pq.empty()){\\n                secondLargest = pq.top();\\n                pq.pop();\\n                result+=secondLargest.first;\\n        }\\n            else{\\n                return result;\\n            }\\n            if(secondLargest.second-1>0)\\n            pq.push({secondLargest.first, secondLargest.second-1});\\n            pq.push({largest.first, largest.second-len});\\n        }\\n    }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906973,
                "title": "simple-approach",
                "content": "# Intuition\\nDescending order in alphabetical order\\n\\n# Approach\\nusing a vector for each char in the string \\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int>temp(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n        }\\n        string res=\"\";\\n        int prev=-1;\\n        for(int i=25;i>=0;i--)\\n        {\\n            if(temp[i]!=0)\\n            {\\n                int count=0;\\n                while(temp[i]>0 && count!=repeatLimit)\\n                {\\n                    res+=(\\'a\\'+i);\\n                    temp[i]--;\\n                    count++;\\n                    if(count==repeatLimit && temp[i]>0)\\n                    {\\n                        int flag=0;\\n                        int k=i-1;\\n                        while(k>=0)\\n                        {\\n                            if(temp[k]>0)\\n                            {\\n                                res+=(\\'a\\'+k);\\n                                temp[k]--;\\n                                flag=1;\\n                                break;\\n                            }\\n                            k--;\\n                        }\\n                        if(flag==1)\\n                        {\\n                            count=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int>temp(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n        }\\n        string res=\"\";\\n        int prev=-1;\\n        for(int i=25;i>=0;i--)\\n        {\\n            if(temp[i]!=0)\\n            {\\n                int count=0;\\n                while(temp[i]>0 && count!=repeatLimit)\\n                {\\n                    res+=(\\'a\\'+i);\\n                    temp[i]--;\\n                    count++;\\n                    if(count==repeatLimit && temp[i]>0)\\n                    {\\n                        int flag=0;\\n                        int k=i-1;\\n                        while(k>=0)\\n                        {\\n                            if(temp[k]>0)\\n                            {\\n                                res+=(\\'a\\'+k);\\n                                temp[k]--;\\n                                flag=1;\\n                                break;\\n                            }\\n                            k--;\\n                        }\\n                        if(flag==1)\\n                        {\\n                            count=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878267,
                "title": "greedy",
                "content": "**time: `NlogN`; space: `O(1)`**\\n```\\nstring repeatLimitedString(string s, int r)\\n{\\n\\tsort(begin(s), end(s), greater{});\\n\\tint i{1};\\n\\tfor(int c{1}, j{1}; i<size(s) ; ++i)\\n\\t{\\n\\t\\tc = s[i]==s[i-1] ? c+1 : 1;\\n\\t\\tif(c>r)\\n\\t\\t{\\n\\t\\t\\tj=max(j,i);\\n\\t\\t\\tfor( ; j<size(s) and s[j]==s[i]; ++j);\\n\\t\\t\\tif(j==size(s)) break;\\n\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t}\\n\\t}\\n\\treturn {begin(s), begin(s)+i};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring repeatLimitedString(string s, int r)\\n{\\n\\tsort(begin(s), end(s), greater{});\\n\\tint i{1};\\n\\tfor(int c{1}, j{1}; i<size(s) ; ++i)\\n\\t{\\n\\t\\tc = s[i]==s[i-1] ? c+1 : 1;\\n\\t\\tif(c>r)\\n\\t\\t{\\n\\t\\t\\tj=max(j,i);\\n\\t\\t\\tfor( ; j<size(s) and s[j]==s[i]; ++j);\\n\\t\\t\\tif(j==size(s)) break;\\n\\t\\t\\tswap(s[i], s[j]);\\n\\t\\t}\\n\\t}\\n\\treturn {begin(s), begin(s)+i};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841812,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     private Dictionary<char, int> _counter = new Dictionary<char, int>();\\n    private PriorityQueue<char, Repet> _queue = new PriorityQueue<char, Repet>();\\n\\n    class Repet : IComparable<Repet>\\n    {\\n        public char Letter { get; set; }\\n\\n        public int Count { get; set; }\\n\\n        public Repet(char letter, int count)\\n        {\\n            Letter = letter;\\n            Count = count;\\n        }\\n\\n        public int CompareTo(Repet? other)\\n        {\\n            if (other.Letter == Letter)\\n            {\\n                return other.Letter.CompareTo(Letter);\\n            }\\n\\n            return other.Letter.CompareTo(Letter);\\n        }\\n    }\\n    \\n    public string RepeatLimitedString(string s, int repeatLimit) {\\n        FillLetterCount(s);\\n        FillQueue();\\n        \\n        var result = new StringBuilder();\\n        char? lastAppendedValue = null;\\n        \\n        while (_queue.Count != 0)\\n        {\\n            _queue.TryDequeue(out char l, out Repet r);\\n            \\n            if (lastAppendedValue != l)\\n            {\\n                lastAppendedValue = BuildNextPart(l, r, repeatLimit, result);\\n            }\\n            else\\n            {\\n                var buffer = new Queue<Repet>();\\n                _queue.Enqueue(l, r);\\n                \\n                while (_queue.Count != 0)\\n                {\\n                    _queue.TryDequeue(out l, out r);\\n\\n                    if (l != lastAppendedValue)\\n                    {\\n                        var limit = buffer.Count > 0 ? 1 : repeatLimit;\\n                        lastAppendedValue = BuildNextPart(l, r, limit, result);\\n                        break;\\n                    }\\n\\n                    buffer.Enqueue(r);\\n                }\\n\\n                if (buffer.Peek().Letter == lastAppendedValue)\\n                {\\n                    return result.ToString();\\n                }\\n\\n                while (buffer.Count != 0)\\n                {\\n                    var c = buffer.Dequeue();\\n                    _queue.Enqueue(c.Letter, c);\\n                }\\n            }\\n        }\\n\\n        return result.ToString();\\n    }\\n\\n    void FillLetterCount(string value)\\n    {\\n        foreach (var l in value)\\n        {\\n            _counter.TryGetValue(l, out int v);\\n            _counter[l] = v + 1;\\n        }\\n    }\\n\\n    void FillQueue()\\n    {\\n        foreach (var pair in _counter)\\n        {\\n            _queue.Enqueue(pair.Key, new Repet(pair.Key, pair.Value));\\n        }\\n    }\\n\\n    char BuildNextPart(char l, Repet r, int repeatLimit, StringBuilder result)\\n    {\\n        var countToAppend = r.Count <= repeatLimit ? r.Count : repeatLimit;\\n        result.Append(new string(r.Letter, countToAppend));\\n\\n        if (r.Count > repeatLimit)\\n        {\\n            _queue.Enqueue(l, new Repet(l, r.Count - repeatLimit));\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     private Dictionary<char, int> _counter = new Dictionary<char, int>();\\n    private PriorityQueue<char, Repet> _queue = new PriorityQueue<char, Repet>();\\n\\n    class Repet : IComparable<Repet>\\n    {\\n        public char Letter { get; set; }\\n\\n        public int Count { get; set; }\\n\\n        public Repet(char letter, int count)\\n        {\\n            Letter = letter;\\n            Count = count;\\n        }\\n\\n        public int CompareTo(Repet? other)\\n        {\\n            if (other.Letter == Letter)\\n            {\\n                return other.Letter.CompareTo(Letter);\\n            }\\n\\n            return other.Letter.CompareTo(Letter);\\n        }\\n    }\\n    \\n    public string RepeatLimitedString(string s, int repeatLimit) {\\n        FillLetterCount(s);\\n        FillQueue();\\n        \\n        var result = new StringBuilder();\\n        char? lastAppendedValue = null;\\n        \\n        while (_queue.Count != 0)\\n        {\\n            _queue.TryDequeue(out char l, out Repet r);\\n            \\n            if (lastAppendedValue != l)\\n            {\\n                lastAppendedValue = BuildNextPart(l, r, repeatLimit, result);\\n            }\\n            else\\n            {\\n                var buffer = new Queue<Repet>();\\n                _queue.Enqueue(l, r);\\n                \\n                while (_queue.Count != 0)\\n                {\\n                    _queue.TryDequeue(out l, out r);\\n\\n                    if (l != lastAppendedValue)\\n                    {\\n                        var limit = buffer.Count > 0 ? 1 : repeatLimit;\\n                        lastAppendedValue = BuildNextPart(l, r, limit, result);\\n                        break;\\n                    }\\n\\n                    buffer.Enqueue(r);\\n                }\\n\\n                if (buffer.Peek().Letter == lastAppendedValue)\\n                {\\n                    return result.ToString();\\n                }\\n\\n                while (buffer.Count != 0)\\n                {\\n                    var c = buffer.Dequeue();\\n                    _queue.Enqueue(c.Letter, c);\\n                }\\n            }\\n        }\\n\\n        return result.ToString();\\n    }\\n\\n    void FillLetterCount(string value)\\n    {\\n        foreach (var l in value)\\n        {\\n            _counter.TryGetValue(l, out int v);\\n            _counter[l] = v + 1;\\n        }\\n    }\\n\\n    void FillQueue()\\n    {\\n        foreach (var pair in _counter)\\n        {\\n            _queue.Enqueue(pair.Key, new Repet(pair.Key, pair.Value));\\n        }\\n    }\\n\\n    char BuildNextPart(char l, Repet r, int repeatLimit, StringBuilder result)\\n    {\\n        var countToAppend = r.Count <= repeatLimit ? r.Count : repeatLimit;\\n        result.Append(new string(r.Letter, countToAppend));\\n\\n        if (r.Count > repeatLimit)\\n        {\\n            _queue.Enqueue(l, new Repet(l, r.Count - repeatLimit));\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829400,
                "title": "c-counter-and-priority-queue-easy-to-read-and-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int cnt[26] = {};\\n\\n        for (char c : s) {\\n            cnt[c - \\'a\\']++;\\n        }\\n\\n        priority_queue<pair<char, int>> q;\\n        for (int i = 25; i >= 0; i--) {\\n            if(cnt[i] != 0) {\\n                q.push({i + \\'a\\', cnt[i]});\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(q.size()) {\\n            auto curr = q.top(); q.pop();\\n            char c = curr.first; int count = curr.second;\\n            \\n            int len = min(limit, count);\\n            for (int rep = 0; rep < len; rep++) {\\n                ans += c;\\n            }\\n            count -= len;\\n            if (count > 0) {\\n                if (q.size()) {\\n                    auto nextSmall = q.top(); q.pop();\\n                    char ch = nextSmall.first; int nextSmallCount = nextSmall.second;\\n                    ans += ch; nextSmallCount--;\\n                    if (nextSmallCount > 0) {\\n                        q.push({ch, nextSmallCount});\\n                    }\\n                } else {\\n                    return ans;\\n                }\\n\\n            }\\n\\n            if (count > 0) {\\n                q.push({c, count});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int limit) {\\n        int cnt[26] = {};\\n\\n        for (char c : s) {\\n            cnt[c - \\'a\\']++;\\n        }\\n\\n        priority_queue<pair<char, int>> q;\\n        for (int i = 25; i >= 0; i--) {\\n            if(cnt[i] != 0) {\\n                q.push({i + \\'a\\', cnt[i]});\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(q.size()) {\\n            auto curr = q.top(); q.pop();\\n            char c = curr.first; int count = curr.second;\\n            \\n            int len = min(limit, count);\\n            for (int rep = 0; rep < len; rep++) {\\n                ans += c;\\n            }\\n            count -= len;\\n            if (count > 0) {\\n                if (q.size()) {\\n                    auto nextSmall = q.top(); q.pop();\\n                    char ch = nextSmall.first; int nextSmallCount = nextSmall.second;\\n                    ans += ch; nextSmallCount--;\\n                    if (nextSmallCount > 0) {\\n                        q.push({ch, nextSmallCount});\\n                    }\\n                } else {\\n                    return ans;\\n                }\\n\\n            }\\n\\n            if (count > 0) {\\n                q.push({c, count});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818507,
                "title": "o-n-solution-using-priorityqueue-and-a-frequency-array",
                "content": "# Intuition\\nCount the frequency of characters and use a TreeSet to keep them sorted. Iterate through the characters in descending order and repeat them up to the repeatLimit.\\n\\n# Approach\\n1. Count the frequency of each character using an array of size 26 (for lowercase alphabets).\\n2. Use a TreeSet to keep the characters sorted in descending order of their frequency.\\n3. Iterate through the characters in descending order and repeat each character up to the repeatLimit.\\n4. Handle special cases when the character\\'s frequency is already used up or if it needs to be replaced by another character.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input string s.\\n\\n- Space complexity:\\nO(1) for the frequency array and TreeSet.\\n\\n# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] freq = new int[26];\\n        TreeSet<Character> set = new TreeSet<>();\\n\\n        // Count the frequency of characters and populate the TreeSet with unique characters.\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n            set.add(ch);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n\\n        // Iterate through the characters in descending order and repeat each character up to the repeatLimit.\\n        while (!set.isEmpty()) {\\n            char top = set.pollLast();\\n            count = 1;\\n\\n            while (count <= repeatLimit && freq[top - \\'a\\'] > 0) {\\n                sb.append(top);\\n                count++;\\n                freq[top - \\'a\\']--;\\n            }\\n\\n            if (!set.isEmpty() && freq[top - \\'a\\'] > 0) {\\n                count = 0;\\n                char temp = set.pollLast();\\n                sb.append(temp);\\n                set.add(top);\\n                freq[temp - \\'a\\']--;\\n\\n                if (freq[temp - \\'a\\'] != 0)\\n                    set.add(temp);\\n            } else if (!set.isEmpty() && freq[top - \\'a\\'] == 0) {\\n                count = 0;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int[] freq = new int[26];\\n        TreeSet<Character> set = new TreeSet<>();\\n\\n        // Count the frequency of characters and populate the TreeSet with unique characters.\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n            set.add(ch);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n\\n        // Iterate through the characters in descending order and repeat each character up to the repeatLimit.\\n        while (!set.isEmpty()) {\\n            char top = set.pollLast();\\n            count = 1;\\n\\n            while (count <= repeatLimit && freq[top - \\'a\\'] > 0) {\\n                sb.append(top);\\n                count++;\\n                freq[top - \\'a\\']--;\\n            }\\n\\n            if (!set.isEmpty() && freq[top - \\'a\\'] > 0) {\\n                count = 0;\\n                char temp = set.pollLast();\\n                sb.append(temp);\\n                set.add(top);\\n                freq[temp - \\'a\\']--;\\n\\n                if (freq[temp - \\'a\\'] != 0)\\n                    set.add(temp);\\n            } else if (!set.isEmpty() && freq[top - \\'a\\'] == 0) {\\n                count = 0;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807272,
                "title": "c-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string RepeatLimitedString(string s, int repeatLimit)\\n    {\\n        var heap = new PriorityQueue<LetterWithCount, char>(new Comparer());\\n        heap.EnqueueRange(s.GroupBy(c => c).Select(g => (new LetterWithCount(g.Key, g.Count()), g.Key)));\\n\\n        var exceedLimits = new Queue<LetterWithCount>();\\n\\n        var limitedStringBuilder = new StringBuilder();\\n        var prev = new char();\\n        int limit = 0;\\n        LetterWithCount current;\\n\\n        while(heap.Count > 0 || exceedLimits.Any())\\n        {\\n            if(heap.Count == 0 && prev == exceedLimits.Peek().Letter)\\n            {\\n                break;\\n            }\\n            current = exceedLimits.Any() && exceedLimits.Peek().Letter != prev ? exceedLimits.Dequeue() : heap.Dequeue();\\n            limit = exceedLimits.Any() && exceedLimits.Peek().Letter > current.Letter ? 1 : repeatLimit;\\n            limitedStringBuilder.Append(GetLimitedLetters(current, limit, exceedLimits, ref prev));\\n        }\\n        \\n\\n        return limitedStringBuilder.ToString();\\n    }\\n\\n    private string GetLimitedLetters(LetterWithCount current, int repeatLimit, Queue<LetterWithCount> exceedLimits, ref char prev)\\n    {\\n        var count = Math.Min(repeatLimit, current.Count);\\n        prev = current.Letter;\\n\\n        if (current.Count - repeatLimit > 0)\\n        {\\n            exceedLimits.Enqueue(new LetterWithCount(current.Letter, current.Count - repeatLimit));\\n        }\\n\\n        return new string(current.Letter, count);\\n    }\\n\\n    private record LetterWithCount(char Letter, int Count);\\n\\n    private class Comparer : IComparer<char>\\n    {\\n        public int Compare(char x, char y)\\n        {\\n            return y.CompareTo(x);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string RepeatLimitedString(string s, int repeatLimit)\\n    {\\n        var heap = new PriorityQueue<LetterWithCount, char>(new Comparer());\\n        heap.EnqueueRange(s.GroupBy(c => c).Select(g => (new LetterWithCount(g.Key, g.Count()), g.Key)));\\n\\n        var exceedLimits = new Queue<LetterWithCount>();\\n\\n        var limitedStringBuilder = new StringBuilder();\\n        var prev = new char();\\n        int limit = 0;\\n        LetterWithCount current;\\n\\n        while(heap.Count > 0 || exceedLimits.Any())\\n        {\\n            if(heap.Count == 0 && prev == exceedLimits.Peek().Letter)\\n            {\\n                break;\\n            }\\n            current = exceedLimits.Any() && exceedLimits.Peek().Letter != prev ? exceedLimits.Dequeue() : heap.Dequeue();\\n            limit = exceedLimits.Any() && exceedLimits.Peek().Letter > current.Letter ? 1 : repeatLimit;\\n            limitedStringBuilder.Append(GetLimitedLetters(current, limit, exceedLimits, ref prev));\\n        }\\n        \\n\\n        return limitedStringBuilder.ToString();\\n    }\\n\\n    private string GetLimitedLetters(LetterWithCount current, int repeatLimit, Queue<LetterWithCount> exceedLimits, ref char prev)\\n    {\\n        var count = Math.Min(repeatLimit, current.Count);\\n        prev = current.Letter;\\n\\n        if (current.Count - repeatLimit > 0)\\n        {\\n            exceedLimits.Enqueue(new LetterWithCount(current.Letter, current.Count - repeatLimit));\\n        }\\n\\n        return new string(current.Letter, count);\\n    }\\n\\n    private record LetterWithCount(char Letter, int Count);\\n\\n    private class Comparer : IComparer<char>\\n    {\\n        public int Compare(char x, char y)\\n        {\\n            return y.CompareTo(x);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795468,
                "title": "map-heap-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n        priority_queue<pair<char, int>> pq; \\n\\n        unordered_map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            m[s[i]]++;\\n        }   \\n\\n        for(auto it : m)\\n        {\\n            pq.push({it.first, it.second});\\n        }\\n\\n        string ans = \"\";\\n\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n\\n            auto top2 = pq.top();\\n            pq.pop();\\n\\n            if(top1.second <= repeatLimit)\\n            {\\n                for(int i=0; i<top1.second; i++)\\n                {\\n                    ans += top1.first;\\n                }\\n\\n                pq.push(top2);\\n            }\\n            else\\n            {\\n                for(int i=0; i<repeatLimit; i++)\\n                {\\n                    ans += top1.first;\\n                    top1.second--;\\n                }\\n                pq.push(top1);\\n\\n                ans+= top2.first;\\n                top2.second--;\\n                if(top2.second > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n            }\\n        }\\n\\n        if(pq.size() > 0)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n\\n            if(top1.second > repeatLimit)\\n            {\\n                for(int i=0; i<repeatLimit; i++)\\n                {\\n                    ans += top1.first;\\n                    top1.second--;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0; i<top1.second; i++)\\n                {\\n                    ans += top1.first;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) \\n    {\\n        priority_queue<pair<char, int>> pq; \\n\\n        unordered_map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            m[s[i]]++;\\n        }   \\n\\n        for(auto it : m)\\n        {\\n            pq.push({it.first, it.second});\\n        }\\n\\n        string ans = \"\";\\n\\n        while(pq.size() > 1)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n\\n            auto top2 = pq.top();\\n            pq.pop();\\n\\n            if(top1.second <= repeatLimit)\\n            {\\n                for(int i=0; i<top1.second; i++)\\n                {\\n                    ans += top1.first;\\n                }\\n\\n                pq.push(top2);\\n            }\\n            else\\n            {\\n                for(int i=0; i<repeatLimit; i++)\\n                {\\n                    ans += top1.first;\\n                    top1.second--;\\n                }\\n                pq.push(top1);\\n\\n                ans+= top2.first;\\n                top2.second--;\\n                if(top2.second > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n            }\\n        }\\n\\n        if(pq.size() > 0)\\n        {\\n            auto top1 = pq.top();\\n            pq.pop();\\n\\n            if(top1.second > repeatLimit)\\n            {\\n                for(int i=0; i<repeatLimit; i++)\\n                {\\n                    ans += top1.first;\\n                    top1.second--;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0; i<top1.second; i++)\\n                {\\n                    ans += top1.first;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788619,
                "title": "easyy-heap-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeat) {\\n        // count\\n        int cnt[26] ={0};\\n        for(auto it: s){\\n            cnt[it -\\'a\\']++;\\n        }\\n        for(auto it: cnt){\\n            cout<<it<<\" \";\\n        }\\n        // pq taaki largest freq ka access rahe\\n        priority_queue<pair<int,int>>pq;\\n        for(int i =0;i<26;i++){\\n            if(cnt[i]>0) pq.push({i,cnt[i]});\\n        }\\n        string ans =\"\";\\n        \\n        while(!pq.empty()){\\n            int chr1 = pq.top().first;\\n            int freq1 = pq.top().second;\\n            pq.pop();\\n            if(ans.size()==0 || ans.back()!= (char)(chr1 + \\'a\\')){\\n                // utna hi print krunga jitna chahiye\\n                int times = min(repeat,freq1);\\n                for(int i =0;i<times;i++){\\n                    ans+= (char)(chr1 +\\'a\\');\\n                }\\n                freq1 -=times;\\n                // abhi bhi bacha hai toh daal rha pq me vapas\\n                if(freq1){\\n                    pq.push({chr1,freq1});\\n                }\\n            }\\n            else{\\n                cout<< \"workin\";\\n                if(pq.size()==0) break;\\n                int chr2 = pq.top().first;\\n                int freq2 = pq.top().second;\\n                pq.pop();\\n                ans += (char)(chr2 +\\'a\\');\\n                freq2--;\\n                \\n                if(freq2){\\n                    pq.push({chr2,freq2});\\n                }\\n                pq.push({chr1,freq1});\\n            }\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeat) {\\n        // count\\n        int cnt[26] ={0};\\n        for(auto it: s){\\n            cnt[it -\\'a\\']++;\\n        }\\n        for(auto it: cnt){\\n            cout<<it<<\" \";\\n        }\\n        // pq taaki largest freq ka access rahe\\n        priority_queue<pair<int,int>>pq;\\n        for(int i =0;i<26;i++){\\n            if(cnt[i]>0) pq.push({i,cnt[i]});\\n        }\\n        string ans =\"\";\\n        \\n        while(!pq.empty()){\\n            int chr1 = pq.top().first;\\n            int freq1 = pq.top().second;\\n            pq.pop();\\n            if(ans.size()==0 || ans.back()!= (char)(chr1 + \\'a\\')){\\n                // utna hi print krunga jitna chahiye\\n                int times = min(repeat,freq1);\\n                for(int i =0;i<times;i++){\\n                    ans+= (char)(chr1 +\\'a\\');\\n                }\\n                freq1 -=times;\\n                // abhi bhi bacha hai toh daal rha pq me vapas\\n                if(freq1){\\n                    pq.push({chr1,freq1});\\n                }\\n            }\\n            else{\\n                cout<< \"workin\";\\n                if(pq.size()==0) break;\\n                int chr2 = pq.top().first;\\n                int freq2 = pq.top().second;\\n                pq.pop();\\n                ans += (char)(chr2 +\\'a\\');\\n                freq2--;\\n                \\n                if(freq2){\\n                    pq.push({chr2,freq2});\\n                }\\n                pq.push({chr1,freq1});\\n            }\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3679557,
                "title": "easy-solution-brief-explanation-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main idea is to fill the greatest characters from the given array. But there is a edge case. You should fill the characters by interchanging greatest and second greatest characters using a two pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a array of size 26 with the counter of each character from the string.\\n2. assign \\'h\\' as the highest pointer and l as the second highest.\\n3. You should always place the pointers at non-zero element means\\n    arr[h]!=0 and arr[l]!=0.\\n4.Then use stringBuilder to build the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int[] arr = new int[26];\\n        for(Character c:s.toCharArray())arr[c-\\'a\\']++;\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int h=25;\\n        while(h>=0 && arr[h]==0)h--;// place h at non-zero element\\n        int l=h-1;\\n        while(l>=0 && arr[l]==0)l--;//place l one step behind h.\\n        int x=r;\\n        while(h>=0){ // loop runs until h>=0.\\n            x=r;\\n            while(x>0 && arr[h]>0){ // append possible chars at h.\\n                sb.append((char)(97+h));\\n                arr[h]--;\\n                x--;\\n            }\\n            if(arr[h]!=0){ //if arr[h]!=0 it means we need to include a char smaller than char at h\\n                while(l>=0 && arr[l]==0)l--;\\n                if(l>=0 && arr[l]!=0){ // if we have char smaller than arr[h] include one only.\\n                    sb.append((char)(97+l));\\n                    arr[l]--;\\n                }\\n                else break; // else we left with one type of char.it can violate the given condition. break loop.\\n            }\\n            else if(arr[h]==0){ // if you include all the chars at h.you need to make l as the h and move l to the left.\\n                h=l;\\n                l--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int[] arr = new int[26];\\n        for(Character c:s.toCharArray())arr[c-\\'a\\']++;\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int h=25;\\n        while(h>=0 && arr[h]==0)h--;// place h at non-zero element\\n        int l=h-1;\\n        while(l>=0 && arr[l]==0)l--;//place l one step behind h.\\n        int x=r;\\n        while(h>=0){ // loop runs until h>=0.\\n            x=r;\\n            while(x>0 && arr[h]>0){ // append possible chars at h.\\n                sb.append((char)(97+h));\\n                arr[h]--;\\n                x--;\\n            }\\n            if(arr[h]!=0){ //if arr[h]!=0 it means we need to include a char smaller than char at h\\n                while(l>=0 && arr[l]==0)l--;\\n                if(l>=0 && arr[l]!=0){ // if we have char smaller than arr[h] include one only.\\n                    sb.append((char)(97+l));\\n                    arr[l]--;\\n                }\\n                else break; // else we left with one type of char.it can violate the given condition. break loop.\\n            }\\n            else if(arr[h]==0){ // if you include all the chars at h.you need to make l as the h and move l to the left.\\n                h=l;\\n                l--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669698,
                "title": "heap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose a string is reversely sorted.\\n\\nThe largest lexigraphical string could be obtained by inserting second largest character into repeatLimit largest character in a row (if need be).\\n\\n(char, s.count(char)) could be store in a max-heap. If the first char still remains after concatenating to the result string by popping an element from the heap, we pop another element to be the second char.\\n\\nIf there are chars left, push back to heap and heapify.\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        L = list(Counter(s).items())\\n        heapq._heapify_max(L)\\n        ret = \\'\\'\\n        \\n        while len(L) > 1:\\n            char1, count1 = heapq._heappop_max(L)\\n            ret += char1 * min(repeatLimit, count1)\\n            count1 -= min(repeatLimit, count1)\\n\\n            if count1 > 0:\\n                char2, count2 = heapq._heappop_max(L)\\n                \\n                ret += char2\\n                count2 -= 1\\n                \\n                if count2 > 0:\\n                    heappush(L, (char2, count2))\\n            \\n            \\n                heappush(L, (char1, count1))\\n            heapq._heapify_max(L)\\n        \\n        if len(L) > 0:\\n            char, count = heappop(L)\\n            ret += char * min(repeatLimit, count)\\n\\n        return ret\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        L = list(Counter(s).items())\\n        heapq._heapify_max(L)\\n        ret = \\'\\'\\n        \\n        while len(L) > 1:\\n            char1, count1 = heapq._heappop_max(L)\\n            ret += char1 * min(repeatLimit, count1)\\n            count1 -= min(repeatLimit, count1)\\n\\n            if count1 > 0:\\n                char2, count2 = heapq._heappop_max(L)\\n                \\n                ret += char2\\n                count2 -= 1\\n                \\n                if count2 > 0:\\n                    heappush(L, (char2, count2))\\n            \\n            \\n                heappush(L, (char1, count1))\\n            heapq._heapify_max(L)\\n        \\n        if len(L) > 0:\\n            char, count = heappop(L)\\n            ret += char * min(repeatLimit, count)\\n\\n        return ret\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634345,
                "title": "help-me-with-this-tle-java-solution-but-got-tle",
                "content": "\\nCan anyone tell how can i make this code much faster.??\\nI have just created a stack and if a character is in the limit of repetation than im just going pop it and add to the result , if it reaches the repeatation limit than ill just search for a character starting from current top of stack that is not matching this character if ill get the character than im going to start the loop ; if i dont get any character then im just going to return it since im not able to avoid repeatation.\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int n=s.length();\\n        int[] count=new int[26];\\n        char[] stack=new char[n];\\n        int top=-1;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            count[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n      \\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<count[i];j++){\\n                stack[++top]=(char)(\\'a\\'+i);\\n            }\\n        }\\n     \\n        int curr_lexo=25;\\n        String ret=\"\";\\n        char curr=stack[top];\\n        int curr_rep=0;\\n\\t\\t\\n        while(top>=0)\\n        {\\n            \\n            if(stack[top]==\\'-\\')\\n            {\\n                top--;\\n                continue;\\n            }\\n            if(stack[top]!=curr)//new character\\n            {\\n                curr_rep=1;\\n                curr=stack[top];\\n                ret+=stack[top];\\n                top--;\\n            }               \\n            else //character is being repeated\\n            {\\n                 curr_rep++;\\n                 if(curr_rep<=repeatLimit)\\n                 ret+=stack[top];\\n                 else //curr_rep>limit\\n                 {\\n                     int j=top-1;\\n                     \\n                     while(j>=0 && (stack[j]==curr || stack[j]==\\'-\\'))\\n                     {\\n                         j--;\\n                     } \\n                     if(j<0)//there are no character left to reduce the repetation\\n                         return ret;\\n                     else\\n                     {\\n                         ret+=stack[j];\\n                         ret+=stack[top];\\n                         curr_rep=1;\\n                         stack[j]=\\'-\\';\\n                     }\\n                 }\\n                top--;\\n            }  \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        int n=s.length();\\n        int[] count=new int[26];\\n        char[] stack=new char[n];\\n        int top=-1;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            count[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n      \\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<count[i];j++){\\n                stack[++top]=(char)(\\'a\\'+i);\\n            }\\n        }\\n     \\n        int curr_lexo=25;\\n        String ret=\"\";\\n        char curr=stack[top];\\n        int curr_rep=0;\\n\\t\\t\\n        while(top>=0)\\n        {\\n            \\n            if(stack[top]==\\'-\\')\\n            {\\n                top--;\\n                continue;\\n            }\\n            if(stack[top]!=curr)//new character\\n            {\\n                curr_rep=1;\\n                curr=stack[top];\\n                ret+=stack[top];\\n                top--;\\n            }               \\n            else //character is being repeated\\n            {\\n                 curr_rep++;\\n                 if(curr_rep<=repeatLimit)\\n                 ret+=stack[top];\\n                 else //curr_rep>limit\\n                 {\\n                     int j=top-1;\\n                     \\n                     while(j>=0 && (stack[j]==curr || stack[j]==\\'-\\'))\\n                     {\\n                         j--;\\n                     } \\n                     if(j<0)//there are no character left to reduce the repetation\\n                         return ret;\\n                     else\\n                     {\\n                         ret+=stack[j];\\n                         ret+=stack[top];\\n                         curr_rep=1;\\n                         stack[j]=\\'-\\';\\n                     }\\n                 }\\n                top--;\\n            }  \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627959,
                "title": "java-without-pq-stack-only-array-of-size-26",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26) = O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int k) {\\n        int[] ch = new int[26];\\n        for(char c:s.toCharArray())\\n            ch[c-\\'a\\']++;\\n        \\n\\n        StringBuilder str = new StringBuilder();\\n        for(int i=25;i>=0;i--){\\n            if(ch[i]==0)\\n                continue;\\n            if(ch[i]<=k){\\n                for(int j=0;j<ch[i];j++)\\n                    str.append((char)(\\'a\\'+i));\\n                ch[i]=0;\\n            }else{\\n                while(ch[i]!=0){\\n                    int len = Math.min(ch[i],k);\\n                    for(int j=0;j<len;j++)\\n                        str.append((char)(\\'a\\'+i));\\n                    ch[i]-=len;\\n                    if(ch[i]==0)    break;\\n                    int l=i;\\n                    for(l=i-1;l>=0;l--)\\n                        if(ch[l]!=0)    break;\\n                    if(l==i || l<0)    break;\\n                    str.append((char)(\\'a\\'+l));\\n                    ch[l]--;\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int k) {\\n        int[] ch = new int[26];\\n        for(char c:s.toCharArray())\\n            ch[c-\\'a\\']++;\\n        \\n\\n        StringBuilder str = new StringBuilder();\\n        for(int i=25;i>=0;i--){\\n            if(ch[i]==0)\\n                continue;\\n            if(ch[i]<=k){\\n                for(int j=0;j<ch[i];j++)\\n                    str.append((char)(\\'a\\'+i));\\n                ch[i]=0;\\n            }else{\\n                while(ch[i]!=0){\\n                    int len = Math.min(ch[i],k);\\n                    for(int j=0;j<len;j++)\\n                        str.append((char)(\\'a\\'+i));\\n                    ch[i]-=len;\\n                    if(ch[i]==0)    break;\\n                    int l=i;\\n                    for(l=i-1;l>=0;l--)\\n                        if(ch[l]!=0)    break;\\n                    if(l==i || l<0)    break;\\n                    str.append((char)(\\'a\\'+l));\\n                    ch[l]--;\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581893,
                "title": "javascript-time-complexity-o-n-space-complexity-o-1-two-pointers",
                "content": "# Intuition\\n\\n# Approach\\nSorry for my bad english.\\nFirst I\\'ll store the character into an array, whose index represents for one character (26 elements), and the value of an element equals to how many times it appears in text\\n\\nAfter that I\\'ll use two pointers.\\nThe first pointer represents the largest character, the second pointer represents the second largest character.\\n\\nSo we will use the largest character to concat the string until it runs out or its repeat equals to the repeat limit.\\n\\nif it runs out, we use the next character and set the repeat to 0\\nif it reaches the limit, we get the second largest to concat to the string, set the repeat to 0\\n\\nPut them all into a loop, it\\'ll finish if both pointers are 0\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\nvar repeatLimitedString = function (s, repeatLimit) {\\n  let arr = Array.from(Array(26), () => 0);\\n\\n  for (let i = 0; i < s.length; i++) {\\n    arr[s.charCodeAt(i) - 97]++;\\n  }\\n\\n  let i = 25;\\n  let j = 24;\\n  let string = \"\";\\n  let repeat = 0;\\n  while (j >= 0 && i >= 0) {\\n    if (repeat == repeatLimit) {\\n      if (i != j && arr[j] != 0) {\\n        string += String.fromCharCode(j + 97);\\n        arr[j]--;\\n        repeat = 0;\\n      } else j--;\\n    }\\n    if (arr[i] > 0 && repeat < repeatLimit) {\\n      string += String.fromCharCode(i + 97);\\n      arr[i]--;\\n      repeat++;\\n    }\\n\\n    if (arr[i] == 0) {\\n      i--;\\n      repeat = 0;\\n    }\\n  }\\n\\n  return string;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\nvar repeatLimitedString = function (s, repeatLimit) {\\n  let arr = Array.from(Array(26), () => 0);\\n\\n  for (let i = 0; i < s.length; i++) {\\n    arr[s.charCodeAt(i) - 97]++;\\n  }\\n\\n  let i = 25;\\n  let j = 24;\\n  let string = \"\";\\n  let repeat = 0;\\n  while (j >= 0 && i >= 0) {\\n    if (repeat == repeatLimit) {\\n      if (i != j && arr[j] != 0) {\\n        string += String.fromCharCode(j + 97);\\n        arr[j]--;\\n        repeat = 0;\\n      } else j--;\\n    }\\n    if (arr[i] > 0 && repeat < repeatLimit) {\\n      string += String.fromCharCode(i + 97);\\n      arr[i]--;\\n      repeat++;\\n    }\\n\\n    if (arr[i] == 0) {\\n      i--;\\n      repeat = 0;\\n    }\\n  }\\n\\n  return string;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553869,
                "title": "python-max-heap",
                "content": "The idea is quite simple, but implementation is so ugly.\\n\\nThe same greedy idea as in:\\n* https://leetcode.com/problems/reorganize-string/discuss/3535813/Python%3A-Greedy\\n* https://leetcode.com/problems/string-without-aaa-or-bbb/discuss/3541085/python-greedy-logic-easy-or-not-here-we-go\\n* https://leetcode.com/problems/longest-happy-string/discuss/3543135/python-greedy-logic-easy-or-not-here-we-go-part-2\\n\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        max_heap = [[-(ord(c) - 97), c, count] for c, count in Counter(s).items()]\\n        heapify(max_heap)\\n        count = 0\\n        prev_top1 = None\\n        res = []\\n        while max_heap:\\n            if res and res[-1] == max_heap[0][1]:\\n                count += 1\\n            else:\\n                count = 0\\n            if count == repeatLimit:\\n                prev_top1 = heappop(max_heap)\\n            if max_heap:\\n                top1 = max_heap[0]\\n                top1[2] -= 1\\n                res.append(top1[1])\\n                if not top1[2]:\\n                    heappop(max_heap)\\n                if prev_top1:\\n                    heappush(max_heap, prev_top1)\\n                    prev_top1 = None\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        max_heap = [[-(ord(c) - 97), c, count] for c, count in Counter(s).items()]\\n        heapify(max_heap)\\n        count = 0\\n        prev_top1 = None\\n        res = []\\n        while max_heap:\\n            if res and res[-1] == max_heap[0][1]:\\n                count += 1\\n            else:\\n                count = 0\\n            if count == repeatLimit:\\n                prev_top1 = heappop(max_heap)\\n            if max_heap:\\n                top1 = max_heap[0]\\n                top1[2] -= 1\\n                res.append(top1[1])\\n                if not top1[2]:\\n                    heappop(max_heap)\\n                if prev_top1:\\n                    heappush(max_heap, prev_top1)\\n                    prev_top1 = None\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549837,
                "title": "c-priority-queue-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        map<char,int> mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        priority_queue<pair<char,int>> pq;\\n        for(auto x:mp){\\n            pq.push({x.first,x.second});\\n        }\\n        string ans = \"\";\\n        while(!pq.empty()){\\n           auto it = pq.top();\\n            pq.pop();\\n            char ch = it.first;\\n            int freq1 = it.second;\\n            \\n            int mini = min(repeatLimit,freq1);\\n            freq1 -= mini;\\n           // while(mini--) ans+=ch;\\n             ans += string(mini, ch);\\n            \\n            if(pq.empty()||freq1 ==0) continue;\\n            \\n            auto it2 = pq.top();\\n            char ch2 = it2.first;\\n            int freq2 = it2.second;\\n            pq.pop();\\n            freq2--;\\n            ans += ch2;\\n            \\n            if(freq1>0) pq.push({ch,freq1});\\n            if(freq2>0) pq.push({ch2,freq2});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        map<char,int> mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        priority_queue<pair<char,int>> pq;\\n        for(auto x:mp){\\n            pq.push({x.first,x.second});\\n        }\\n        string ans = \"\";\\n        while(!pq.empty()){\\n           auto it = pq.top();\\n            pq.pop();\\n            char ch = it.first;\\n            int freq1 = it.second;\\n            \\n            int mini = min(repeatLimit,freq1);\\n            freq1 -= mini;\\n           // while(mini--) ans+=ch;\\n             ans += string(mini, ch);\\n            \\n            if(pq.empty()||freq1 ==0) continue;\\n            \\n            auto it2 = pq.top();\\n            char ch2 = it2.first;\\n            int freq2 = it2.second;\\n            pq.pop();\\n            freq2--;\\n            ans += ch2;\\n            \\n            if(freq1>0) pq.push({ch,freq1});\\n            if(freq2>0) pq.push({ch2,freq2});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544686,
                "title": "greedy-swap-on-breaching-limit-no-priority-queue-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe output for a test case is a variation of lexicogrphically sorted string. Idea is to maintain a counter to track the current repeat count and swap with next higher character. If no character found, return the substring as we can not append any more characters.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe final solution is a variation of two pointer. Simply maintain i and j, where i will iterate over current character and j will keep a track of next higher character available.\\n\\n# Complexity\\n- Time complexity: O(n), where n is length of string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26) = O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int len = s.size();\\n        sort(s.begin(), s.end(), greater<char>());\\n\\n        vector<int> charCount(26, 0);\\n\\n        int i = 1, j=1, currentLimit = 0;\\n\\n        while(j<len) {\\n            j = max(i, j);\\n\\n            if(s[i] == s[i-1]) {\\n                currentLimit++;\\n            } else {\\n                currentLimit = 0;\\n            }\\n\\n            if(currentLimit == repeatLimit) {\\n                while(j<len and s[j] == s[i]) j++;\\n                if(j == len) return s.substr(0, i);\\n                swap(s[i], s[j]);\\n            }\\n            i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int len = s.size();\\n        sort(s.begin(), s.end(), greater<char>());\\n\\n        vector<int> charCount(26, 0);\\n\\n        int i = 1, j=1, currentLimit = 0;\\n\\n        while(j<len) {\\n            j = max(i, j);\\n\\n            if(s[i] == s[i-1]) {\\n                currentLimit++;\\n            } else {\\n                currentLimit = 0;\\n            }\\n\\n            if(currentLimit == repeatLimit) {\\n                while(j<len and s[j] == s[i]) j++;\\n                if(j == len) return s.substr(0, i);\\n                swap(s[i], s[j]);\\n            }\\n            i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542103,
                "title": "very-simple-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatlimit){\\n        unordered_map<char,int>m;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        priority_queue<pair<char,int>>pq;\\n        for(auto it:m){\\n            pq.push({it.first,it.second});\\n        }\\n        while(!pq.empty()){\\n            char t=pq.top().first;\\n            int p=pq.top().second;\\n            pq.pop();\\n            int len=min(p,repeatlimit);\\n            for(int i=0;i<len;i++){\\n                ans+=t;\\n            }\\n            char d;\\n            int  e;\\n\\n            if(p-len>0){\\n                \\n                if(!pq.empty()){\\n                    d=pq.top().first;\\n                    e=pq.top().second;\\n                    ans+=d;\\n                    pq.pop();\\n                }\\n                else{\\n                    return ans;\\n                }\\n                pq.push({t,p-len});\\n                if(e-1>0)pq.push({d,e-1});\\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatlimit){\\n        unordered_map<char,int>m;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        priority_queue<pair<char,int>>pq;\\n        for(auto it:m){\\n            pq.push({it.first,it.second});\\n        }\\n        while(!pq.empty()){\\n            char t=pq.top().first;\\n            int p=pq.top().second;\\n            pq.pop();\\n            int len=min(p,repeatlimit);\\n            for(int i=0;i<len;i++){\\n                ans+=t;\\n            }\\n            char d;\\n            int  e;\\n\\n            if(p-len>0){\\n                \\n                if(!pq.empty()){\\n                    d=pq.top().first;\\n                    e=pq.top().second;\\n                    ans+=d;\\n                    pq.pop();\\n                }\\n                else{\\n                    return ans;\\n                }\\n                pq.push({t,p-len});\\n                if(e-1>0)pq.push({d,e-1});\\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528575,
                "title": "greedy-c-solution-99-time-beats-97-space-beats",
                "content": "Intuition: count the occurrences of all the letters. Then try to insert the next letter according to the following rule: \\n1) if you need to take the maximum possible number of a given letter, then take the right number based on the number of letters and the limit. If there is a non-zero number of letters of the given type left after the last operation, then at the next step we need to put the next letter whose number is not equal to zero and continue putting the current letter, as this is the only way to achieve the maximum lexigraphic string.\\n2) if we do not need to take the maximum number of letters of a given type, we should just take 1 letter of that type and go to step 1 again starting with the maximum letter. \\nNote: letters can be inserted only if the number of letters of the given type is greater than zero\\nComplexity:\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(const string &s, int repeatLimit)\\n    {\\n        int dict[26] = {};\\n        bool has_lim = true;\\n        bool take_max = true;\\n        int previous = -1;\\n        int lim;\\n        string new_str = \"\";\\n\\n        for(const auto &chr : s)\\n        {\\n            ++dict[chr - \\'a\\'];\\n        }\\n\\n        while(has_lim)\\n        {\\n            has_lim = true;\\n            take_max = true;\\n            previous = -1;\\n\\n            for(int16_t i = 25; i >= 0; --i)\\n            {\\n                if(dict[i] == 0)\\n                {\\n                    continue;\\n                }\\n                has_lim = false;\\n                lim = repeatLimit;\\n\\n                // check last letter\\n                if(!new_str.empty() && i + \\'a\\' == new_str.back())\\n                {\\n                    has_lim = true;\\n                    break;\\n                }\\n\\n                if(take_max)\\n                {\\n                    while(dict[i] > 0 && lim > 0)\\n                    {\\n                        new_str += i + \\'a\\';\\n                        --dict[i];\\n                        --lim;\\n                    }\\n                    if(dict[i] > 0)\\n                    {\\n                        take_max = false;\\n                        previous = i + 1;\\n                    }\\n                    else\\n                    {\\n                        previous = 26;\\n                    }\\n                }\\n                else\\n                {\\n                    new_str += i + \\'a\\';\\n                    --dict[i];\\n                    take_max = true;\\n                    i = previous;\\n                    previous = 26;\\n                }\\n            }\\n        }\\n        return new_str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(const string &s, int repeatLimit)\\n    {\\n        int dict[26] = {};\\n        bool has_lim = true;\\n        bool take_max = true;\\n        int previous = -1;\\n        int lim;\\n        string new_str = \"\";\\n\\n        for(const auto &chr : s)\\n        {\\n            ++dict[chr - \\'a\\'];\\n        }\\n\\n        while(has_lim)\\n        {\\n            has_lim = true;\\n            take_max = true;\\n            previous = -1;\\n\\n            for(int16_t i = 25; i >= 0; --i)\\n            {\\n                if(dict[i] == 0)\\n                {\\n                    continue;\\n                }\\n                has_lim = false;\\n                lim = repeatLimit;\\n\\n                // check last letter\\n                if(!new_str.empty() && i + \\'a\\' == new_str.back())\\n                {\\n                    has_lim = true;\\n                    break;\\n                }\\n\\n                if(take_max)\\n                {\\n                    while(dict[i] > 0 && lim > 0)\\n                    {\\n                        new_str += i + \\'a\\';\\n                        --dict[i];\\n                        --lim;\\n                    }\\n                    if(dict[i] > 0)\\n                    {\\n                        take_max = false;\\n                        previous = i + 1;\\n                    }\\n                    else\\n                    {\\n                        previous = 26;\\n                    }\\n                }\\n                else\\n                {\\n                    new_str += i + \\'a\\';\\n                    --dict[i];\\n                    take_max = true;\\n                    i = previous;\\n                    previous = 26;\\n                }\\n            }\\n        }\\n        return new_str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513503,
                "title": "python3-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, rl: int) -> str:\\n        \\n        \\n        heap=[]\\n        \\n        freq=Counter(s)\\n        \\n        for k,v in freq.items():\\n            heappush(heap,(-ord(k),v))\\n        \\n        ans=\"\"\\n        \\n        while heap:\\n            \\n            k,v=heappop(heap)\\n            \\n            ch=chr(-k)\\n            \\n            if not ans or ans[-1]!=ch:\\n                ans+=min(rl,v)*ch\\n                if v>rl:\\n                    heappush(heap,(k,(v-rl)))\\n            else:\\n                if heap:\\n                    k1,v1=heappop(heap)\\n                    ch1=chr(-k1)\\n                    ans+=ch1\\n                    if v1-1>=1:\\n                        heappush(heap,(k1,(v1-1)))\\n                    \\n                    heappush(heap,(k,v))\\n                    \\n                \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, rl: int) -> str:\\n        \\n        \\n        heap=[]\\n        \\n        freq=Counter(s)\\n        \\n        for k,v in freq.items():\\n            heappush(heap,(-ord(k),v))\\n        \\n        ans=\"\"\\n        \\n        while heap:\\n            \\n            k,v=heappop(heap)\\n            \\n            ch=chr(-k)\\n            \\n            if not ans or ans[-1]!=ch:\\n                ans+=min(rl,v)*ch\\n                if v>rl:\\n                    heappush(heap,(k,(v-rl)))\\n            else:\\n                if heap:\\n                    k1,v1=heappop(heap)\\n                    ch1=chr(-k1)\\n                    ans+=ch1\\n                    if v1-1>=1:\\n                        heappush(heap,(k1,(v1-1)))\\n                    \\n                    heappush(heap,(k,v))\\n                    \\n                \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453845,
                "title": "c-max-heap-unordered-map-fast-solution",
                "content": "# Intuition\\n->Use unordered_map to store charcter with its count.\\n->create a max heap (Priority Queue) and store the pairs of char with its count.\\n-> Pop out top of the heap and check count of character,\\n|---> if ```cnt``` is less than or equal to ```repeatLimit``` simply add that character into ```ans``` string ```cnt``` times.\\n|---> if ```cnt``` is greater than ```repeatLimit``` then take one character from new top of heap and then append previous characters.\\n\\n=> check out code, definitely you will understand\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    string appendString(char ch, int cnt){\\n        string s = \"\";\\n        while(cnt--) s += ch;\\n        return s;\\n    }\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int n = s.length();\\n        if(n == 1) return s;\\n        string ans = \"\";\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<n; i++) mp[s[i]]++;\\n\\n        priority_queue<pair<char, int>> pq; //maxheap\\n        for(auto p : mp){\\n            pq.push({p.first, p.second});\\n        }\\n\\n        while(!pq.empty()){\\n            char ch = pq.top().first;\\n            int cnt = pq.top().second;\\n            pq.pop();\\n            if(cnt <= repeatLimit) ans += appendString(ch, cnt);\\n            else{\\n                ans += appendString(ch, repeatLimit);\\n                cnt -= repeatLimit;\\n                while(cnt > 0 && !pq.empty()){\\n                    //pop new top of heap          \\n                    char chex = pq.top().first;\\n                    int cntex = pq.top().second;\\n                    pq.pop();\\n                    ans += appendString(chex, 1); //add one character only\\n                    //again append ch \\n                    if(cnt <= repeatLimit){\\n                        ans += appendString(ch, cnt);\\n                        cnt = 0;\\n                    }\\n                    else{\\n                        ans += appendString(ch, repeatLimit);\\n                        cnt -= repeatLimit;\\n                    }\\n                    //push again after decreasing by 1\\n                    if(cntex > 1) pq.push({chex, cntex-1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cnt```\n```repeatLimit```\n```ans```\n```cnt```\n```cnt```\n```repeatLimit```\n```\\nclass Solution {\\nprivate:\\n    string appendString(char ch, int cnt){\\n        string s = \"\";\\n        while(cnt--) s += ch;\\n        return s;\\n    }\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int n = s.length();\\n        if(n == 1) return s;\\n        string ans = \"\";\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<n; i++) mp[s[i]]++;\\n\\n        priority_queue<pair<char, int>> pq; //maxheap\\n        for(auto p : mp){\\n            pq.push({p.first, p.second});\\n        }\\n\\n        while(!pq.empty()){\\n            char ch = pq.top().first;\\n            int cnt = pq.top().second;\\n            pq.pop();\\n            if(cnt <= repeatLimit) ans += appendString(ch, cnt);\\n            else{\\n                ans += appendString(ch, repeatLimit);\\n                cnt -= repeatLimit;\\n                while(cnt > 0 && !pq.empty()){\\n                    //pop new top of heap          \\n                    char chex = pq.top().first;\\n                    int cntex = pq.top().second;\\n                    pq.pop();\\n                    ans += appendString(chex, 1); //add one character only\\n                    //again append ch \\n                    if(cnt <= repeatLimit){\\n                        ans += appendString(ch, cnt);\\n                        cnt = 0;\\n                    }\\n                    else{\\n                        ans += appendString(ch, repeatLimit);\\n                        cnt -= repeatLimit;\\n                    }\\n                    //push again after decreasing by 1\\n                    if(cntex > 1) pq.push({chex, cntex-1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426866,
                "title": "rust-counting-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn repeat_limited_string(s: String, repeat_limit: i32) -> String {\\n        let mut freq = vec![0; 26];\\n        for ch in s.chars() {\\n            freq[ch as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut ans = String::new();\\n        loop {\\n            let mut insert_one = false;\\n            let mut i = 25i32;\\n            while i >= 0 {\\n                if ans.len() > 0\\n                    && ans.chars().last().unwrap() as i32 - \\'a\\' as i32 == i\\n                    && freq[i as usize] > 0\\n                {\\n                    insert_one = true;\\n                    i -= 1;\\n                    continue;\\n                }\\n                if freq[i as usize] > 0 {\\n                    break;\\n                }\\n                i -= 1;\\n            }\\n            if i == -1 {\\n                break;\\n            }\\n            let mut count = if insert_one {\\n                1\\n            } else {\\n                freq[i as usize].min(repeat_limit)\\n            };\\n            freq[i as usize] -= count;\\n            while count > 0 {\\n                ans.push((b\\'a\\' + (i as u8)) as char);\\n                count -= 1;\\n            }\\n        }\\n        ans      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn repeat_limited_string(s: String, repeat_limit: i32) -> String {\\n        let mut freq = vec![0; 26];\\n        for ch in s.chars() {\\n            freq[ch as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut ans = String::new();\\n        loop {\\n            let mut insert_one = false;\\n            let mut i = 25i32;\\n            while i >= 0 {\\n                if ans.len() > 0\\n                    && ans.chars().last().unwrap() as i32 - \\'a\\' as i32 == i\\n                    && freq[i as usize] > 0\\n                {\\n                    insert_one = true;\\n                    i -= 1;\\n                    continue;\\n                }\\n                if freq[i as usize] > 0 {\\n                    break;\\n                }\\n                i -= 1;\\n            }\\n            if i == -1 {\\n                break;\\n            }\\n            let mut count = if insert_one {\\n                1\\n            } else {\\n                freq[i as usize].min(repeat_limit)\\n            };\\n            freq[i as usize] -= count;\\n            while count > 0 {\\n                ans.push((b\\'a\\' + (i as u8)) as char);\\n                count -= 1;\\n            }\\n        }\\n        ans      \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3425130,
                "title": "python-heap-with-detailed-explanation-faster-than-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**A max heap**  heap.\\nA list of the result  res and then later join the list to build the string.\\n\\nBecause each time we append a character single or multiple times, we tend to choose the character with the largest ASCII value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep a max heap of the ASCII value of the character, the character itself, and the remaining/available count of the character. Tuple!!\\n2. While heap is not empty, pop the heap and get the three values: (max_heap_ascii, c, remain).\\n3. The main condition is that if res is empty or res[-1] == c, because if yes, we cannot append c at all: if the heap is empty, it means that there\\'re no other characters available and we must stop everything by break; if the heap is not empty, we must choose the new character that can be generated from a new heappop which is (max_heap_ascii2, c2, remain2). But please keep in mind that in this case you only need to append c2 one single time, and later you still need to append c single or multiple times. So you need to pay attention to remain2-1 and decide whether to heappush the (max_heap_ascii2, c2, remain2-1) for future growing of res, and be sure to (max_heap_ascii, c, remain) for future growing of res.\\n4. If res is empty or res[-1] != c, then the situation is fairly easy. Just decide how many time of c you need to append or extend res.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Counter: O(n);\\n2. initialize heap and heapify: O(n)\\n3. while loop: O(n * log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        from collections import Counter\\n        from heapq import heapify, heappush, heappop\\n        counts = Counter(s)\\n        heap = [(-ord(c), c, count_c) for c,count_c in counts.items()] # max heap\\n        heapify(heap)\\n        #print(heap)\\n        res = []\\n        while heap:\\n            max_heap_ascii, c, remain = heappop(heap)\\n            if res and res[-1] == c:\\n                if not heap:\\n                    break\\n                else:\\n                    max_heap_ascii2, c2, remain2 = heappop(heap)\\n                    heappush(heap, (max_heap_ascii, c, remain))\\n                    res.append(c2)\\n                    if remain2 - 1 > 0:\\n                        heappush(heap, (max_heap_ascii2, c2, remain2-1))\\n            else:\\n                if remain > repeatLimit and (not res or res[-1] != c):\\n                    res.extend([c] * repeatLimit)\\n                    remain -= repeatLimit\\n                    heappush(heap, (max_heap_ascii, c, remain))\\n                elif remain <= repeatLimit and (not res or res[-1] != c):\\n                    res.extend([c] * remain)\\n\\n        #print(res)\\n        return \\'\\'.join(res)\\n```\\n# Second Implementation\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        from collections import Counter\\n        from heapq import heapify, heappush, heappop\\n        counts = Counter(s)\\n        heap = [(-ord(ch), ch, count_c) for ch, count_c in counts.items()]\\n        heapify(heap)\\n        res = []\\n        count = 0\\n\\n        while heap:\\n            max_heap_key, c, remain = heappop(heap)\\n            if res and res[-1] == c and count >= repeatLimit:\\n                if not heap:\\n                    break\\n                max_heap_key2, c2, remain2 = heappop(heap)\\n                heappush(heap, (max_heap_key, c, remain))\\n                max_heap_key, c, remain = max_heap_key2, c2, remain2\\n            \\n            if res and res[-1] != c:\\n                count = 0\\n            \\n            res.append(c)\\n            remain -= 1\\n            if remain > 0:\\n                heappush(heap, (max_heap_key, c, remain))\\n            count += 1\\n        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        from collections import Counter\\n        from heapq import heapify, heappush, heappop\\n        counts = Counter(s)\\n        heap = [(-ord(c), c, count_c) for c,count_c in counts.items()] # max heap\\n        heapify(heap)\\n        #print(heap)\\n        res = []\\n        while heap:\\n            max_heap_ascii, c, remain = heappop(heap)\\n            if res and res[-1] == c:\\n                if not heap:\\n                    break\\n                else:\\n                    max_heap_ascii2, c2, remain2 = heappop(heap)\\n                    heappush(heap, (max_heap_ascii, c, remain))\\n                    res.append(c2)\\n                    if remain2 - 1 > 0:\\n                        heappush(heap, (max_heap_ascii2, c2, remain2-1))\\n            else:\\n                if remain > repeatLimit and (not res or res[-1] != c):\\n                    res.extend([c] * repeatLimit)\\n                    remain -= repeatLimit\\n                    heappush(heap, (max_heap_ascii, c, remain))\\n                elif remain <= repeatLimit and (not res or res[-1] != c):\\n                    res.extend([c] * remain)\\n\\n        #print(res)\\n        return \\'\\'.join(res)\\n```\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        from collections import Counter\\n        from heapq import heapify, heappush, heappop\\n        counts = Counter(s)\\n        heap = [(-ord(ch), ch, count_c) for ch, count_c in counts.items()]\\n        heapify(heap)\\n        res = []\\n        count = 0\\n\\n        while heap:\\n            max_heap_key, c, remain = heappop(heap)\\n            if res and res[-1] == c and count >= repeatLimit:\\n                if not heap:\\n                    break\\n                max_heap_key2, c2, remain2 = heappop(heap)\\n                heappush(heap, (max_heap_key, c, remain))\\n                max_heap_key, c, remain = max_heap_key2, c2, remain2\\n            \\n            if res and res[-1] != c:\\n                count = 0\\n            \\n            res.append(c)\\n            remain -= 1\\n            if remain > 0:\\n                heappush(heap, (max_heap_key, c, remain))\\n            count += 1\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417650,
                "title": "c-heap-hash-map-constructive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : `O(n) + O(K*n*logn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  : `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<char,int>> pq;\\n\\n        for(auto i : s) \\n            mp[i]++;\\n\\n        for(auto i : mp) \\n            pq.push({i.first,i.second});\\n\\n        string res;\\n\\n        while(!pq.empty())  {\\n            auto i = pq.top();\\n            pq.pop();\\n            char ch = i.first;\\n            int freq = i.second;\\n\\n            if(freq <= repeatLimit) {\\n                for(int k=0; k<freq; k++)   {\\n                    res += ch;\\n                }\\n            }\\n            else {\\n                for(int k=0; k<repeatLimit; k++)   {\\n                    res += ch;\\n                }\\n                if(!pq.empty()) {\\n                    auto it = pq.top();\\n                    pq.pop();\\n                    char ch_sec = it.first;\\n                    int freq_sec = it.second;\\n                    res += ch_sec;\\n                    if(freq_sec-1 > 0)\\n                        pq.push({ch_sec,freq_sec-1});\\n                }\\n                else {\\n                    break;\\n                }\\n\\n                if(freq-repeatLimit > 0)\\n                    pq.push({ch,freq-repeatLimit});\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        unordered_map<char,int> mp;\\n        priority_queue<pair<char,int>> pq;\\n\\n        for(auto i : s) \\n            mp[i]++;\\n\\n        for(auto i : mp) \\n            pq.push({i.first,i.second});\\n\\n        string res;\\n\\n        while(!pq.empty())  {\\n            auto i = pq.top();\\n            pq.pop();\\n            char ch = i.first;\\n            int freq = i.second;\\n\\n            if(freq <= repeatLimit) {\\n                for(int k=0; k<freq; k++)   {\\n                    res += ch;\\n                }\\n            }\\n            else {\\n                for(int k=0; k<repeatLimit; k++)   {\\n                    res += ch;\\n                }\\n                if(!pq.empty()) {\\n                    auto it = pq.top();\\n                    pq.pop();\\n                    char ch_sec = it.first;\\n                    int freq_sec = it.second;\\n                    res += ch_sec;\\n                    if(freq_sec-1 > 0)\\n                        pq.push({ch_sec,freq_sec-1});\\n                }\\n                else {\\n                    break;\\n                }\\n\\n                if(freq-repeatLimit > 0)\\n                    pq.push({ch,freq-repeatLimit});\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402682,
                "title": "python-greedy",
                "content": "# Intuition\\nUse greedy solution to contruct the string\\n\\n# Approach\\nEach time we saw `key`, which number is larger than repeatLimit, try to pad another next available key after `key * repeatLimit`.\\nif we cannot find next available key, return the result\\nif we can find next available key, continue to process `key`\\n\\n# Complexity\\n- Time complexity:\\nO(N + MlogM), N is the s length, M is the # of different letters. \\nbecause M is less than 26, so the complexity is O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def repeatLimitedString(self, s, repeatLimit):\\n        \"\"\"\\n        :type s: str\\n        :type repeatLimit: int\\n        :rtype: str\\n        \"\"\"\\n        c = collections.Counter(s)\\n        keys = sorted(c.keys(), reverse=True)\\n        res = []\\n        L = len(keys)\\n        i = 0\\n        while i < L:\\n            k = keys[i]\\n            if c[k] <= 0:\\n                i += 1\\n            elif 0 < c[k] <= repeatLimit:\\n                res.append(k * c[k])\\n                del c[k]\\n                i += 1\\n            elif c[k] > repeatLimit:\\n                res.append(k * repeatLimit)\\n                c[k] -= repeatLimit\\n                j = i + 1\\n                # try to find next available k to pad after k * repeatLimit\\n                while j < L:\\n                    if c[keys[j]] > 0:\\n                        res.append(keys[j])\\n                        c[keys[j]] -= 1\\n                        break\\n                    else:\\n                        j += 1\\n                # all chars already used except k, return res\\n                if j >= L:\\n                    return \\'\\'.join(res)\\n        return \\'\\'.join(res)\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def repeatLimitedString(self, s, repeatLimit):\\n        \"\"\"\\n        :type s: str\\n        :type repeatLimit: int\\n        :rtype: str\\n        \"\"\"\\n        c = collections.Counter(s)\\n        keys = sorted(c.keys(), reverse=True)\\n        res = []\\n        L = len(keys)\\n        i = 0\\n        while i < L:\\n            k = keys[i]\\n            if c[k] <= 0:\\n                i += 1\\n            elif 0 < c[k] <= repeatLimit:\\n                res.append(k * c[k])\\n                del c[k]\\n                i += 1\\n            elif c[k] > repeatLimit:\\n                res.append(k * repeatLimit)\\n                c[k] -= repeatLimit\\n                j = i + 1\\n                # try to find next available k to pad after k * repeatLimit\\n                while j < L:\\n                    if c[keys[j]] > 0:\\n                        res.append(keys[j])\\n                        c[keys[j]] -= 1\\n                        break\\n                    else:\\n                        j += 1\\n                # all chars already used except k, return res\\n                if j >= L:\\n                    return \\'\\'.join(res)\\n        return \\'\\'.join(res)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392975,
                "title": "craziest-solution-ever-of-a-leetcode-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<char,bool> check(map<char,int>&mp){\\n\\n    int c = 0;\\n    for(auto i : mp){\\n\\n        if(i.second>0)c++;\\n    }\\n    if(c==1){\\n\\n        for(auto j : mp){\\n            if(j.second >  0)return {j.first,1};\\n        }\\n    }\\n    return {\\'1\\',0};\\n}\\n    string repeatLimitedString(string s, int repeatLimit) {\\n\\n      vector<pair<char,int>>v;\\n\\n       map<char,int>mp;\\n       for(auto i : s)mp[i]++;\\n      \\n       for(auto i : mp){\\n           v.push_back({i.first,i.second});\\n       \\n       }\\n       string res = \"\";\\n       sort(v.begin(),v.end());\\n       reverse(v.begin(),v.end());\\n       int n = v.size();\\n\\n       int i = 0;\\n       int j = 1;\\n      \\n       while(i<v.size()){\\n\\n           int k = repeatLimit;\\n           int ele = v[i].second;\\n         \\n           \\n           while(k>0 and ele > 0 ){\\n\\n               res.push_back(v[i].first);\\n               ele--;\\n               k--;\\n               v[i].second = v[i].second-1;\\n               mp[v[i].first]--;\\n           }\\n          \\n\\n           if(i+j < n and v[i].second > 0 and v[i+j].second>0){\\n               res.push_back(v[i+j].first);\\n               v[i+j].second = v[i+j].second - 1;\\n               mp[v[i+j].first]--;\\n\\n           }\\n           \\n           if(i+j < n and v[i].second > 0 and v[i+j].second==0)j++;\\n           \\n           if(i+1>=n )return res;\\n\\n           if(v[i].second == 0){\\n               i++;\\n               j = 1;\\n           }\\n           pair<char,bool>p = check(mp);\\n           if(p.second==1){\\n               \\n               while(repeatLimit>0 and mp[p.first]>0){\\n               res.push_back(p.first) ;\\n               repeatLimit--;\\n               mp[p.first]--;\\n               }\\n               return res;\\n           }\\n       }\\n       return res;\\n\\n      \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<char,bool> check(map<char,int>&mp){\\n\\n    int c = 0;\\n    for(auto i : mp){\\n\\n        if(i.second>0)c++;\\n    }\\n    if(c==1){\\n\\n        for(auto j : mp){\\n            if(j.second >  0)return {j.first,1};\\n        }\\n    }\\n    return {\\'1\\',0};\\n}\\n    string repeatLimitedString(string s, int repeatLimit) {\\n\\n      vector<pair<char,int>>v;\\n\\n       map<char,int>mp;\\n       for(auto i : s)mp[i]++;\\n      \\n       for(auto i : mp){\\n           v.push_back({i.first,i.second});\\n       \\n       }\\n       string res = \"\";\\n       sort(v.begin(),v.end());\\n       reverse(v.begin(),v.end());\\n       int n = v.size();\\n\\n       int i = 0;\\n       int j = 1;\\n      \\n       while(i<v.size()){\\n\\n           int k = repeatLimit;\\n           int ele = v[i].second;\\n         \\n           \\n           while(k>0 and ele > 0 ){\\n\\n               res.push_back(v[i].first);\\n               ele--;\\n               k--;\\n               v[i].second = v[i].second-1;\\n               mp[v[i].first]--;\\n           }\\n          \\n\\n           if(i+j < n and v[i].second > 0 and v[i+j].second>0){\\n               res.push_back(v[i+j].first);\\n               v[i+j].second = v[i+j].second - 1;\\n               mp[v[i+j].first]--;\\n\\n           }\\n           \\n           if(i+j < n and v[i].second > 0 and v[i+j].second==0)j++;\\n           \\n           if(i+1>=n )return res;\\n\\n           if(v[i].second == 0){\\n               i++;\\n               j = 1;\\n           }\\n           pair<char,bool>p = check(mp);\\n           if(p.second==1){\\n               \\n               while(repeatLimit>0 and mp[p.first]>0){\\n               res.push_back(p.first) ;\\n               repeatLimit--;\\n               mp[p.first]--;\\n               }\\n               return res;\\n           }\\n       }\\n       return res;\\n\\n      \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347657,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int>alpha(26) ;\\n        for(auto& c : s)\\n            alpha[c -\\'a\\']++ ;\\n        string ret ;\\n        int idx = 25 ;\\n        while(idx >= 0){\\n            if(alpha[idx] == 0 || ret.back() == \\'a\\' + idx){\\n                idx-- ;\\n                continue ;\\n            }                \\n            int repeats = min(repeatLimit, alpha[idx] ) ;\\n            ret += string(repeats, \\'a\\' + idx);\\n            alpha[idx] -= repeats ;\\n            if(alpha[idx]  == 0)\\n                continue ;\\n            for(int j = idx-1; j >=0 ; j--){\\n                if(alpha[j]){\\n                    ret += \\'a\\' + j ;\\n                    alpha[j]-- ;\\n                    break ;\\n                }\\n                if(j == 0)\\n                    return ret ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int>alpha(26) ;\\n        for(auto& c : s)\\n            alpha[c -\\'a\\']++ ;\\n        string ret ;\\n        int idx = 25 ;\\n        while(idx >= 0){\\n            if(alpha[idx] == 0 || ret.back() == \\'a\\' + idx){\\n                idx-- ;\\n                continue ;\\n            }                \\n            int repeats = min(repeatLimit, alpha[idx] ) ;\\n            ret += string(repeats, \\'a\\' + idx);\\n            alpha[idx] -= repeats ;\\n            if(alpha[idx]  == 0)\\n                continue ;\\n            for(int j = idx-1; j >=0 ; j--){\\n                if(alpha[j]){\\n                    ret += \\'a\\' + j ;\\n                    alpha[j]-- ;\\n                    break ;\\n                }\\n                if(j == 0)\\n                    return ret ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332091,
                "title": "c-golang-greedy-counting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int freq[26] = {0};\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        string ans = \"\";\\n        for(int i = 25; i >= 0; i -= !freq[i]) {\\n            int count = 0;\\n            while(freq[i] && count < repeatLimit) {\\n                ans += \\'a\\' + i;\\n                freq[i]--;\\n                count++;\\n            }\\n            if(freq[i]) {\\n                int j;\\n                for(j = i - 1; j >= 0; j--) {\\n                    if(freq[j]) {\\n                        ans += \\'a\\' + j;\\n                        freq[j]--;\\n                        break;\\n                    }\\n                }\\n                if(j == -1) break;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc repeatLimitedString(s string, repeatLimit int) string {\\n    freq := make([]int, 26)\\n    for _, ch := range s {\\n        freq[ch - \\'a\\']++\\n    }\\n\\n    var ans strings.Builder\\n\\n    for i := 25; i >= 0; {\\n        count := 0\\n        for freq[i] > 0 && count < repeatLimit {\\n            ans.WriteString(string(\\'a\\' + i))\\n            freq[i]--\\n            count++\\n        }\\n        if freq[i] > 0 {\\n            var j int\\n            for j = i - 1; j >= 0; j-- {\\n                if freq[j] > 0 {\\n                    ans.WriteString(string(\\'a\\' + j))\\n                    freq[j]--\\n                    break\\n                }\\n            }\\n            if j == -1 {break}\\n        } \\n        if freq[i] == 0 {i--}\\n    }\\n    return ans.String()\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        int freq[26] = {0};\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        string ans = \"\";\\n        for(int i = 25; i >= 0; i -= !freq[i]) {\\n            int count = 0;\\n            while(freq[i] && count < repeatLimit) {\\n                ans += \\'a\\' + i;\\n                freq[i]--;\\n                count++;\\n            }\\n            if(freq[i]) {\\n                int j;\\n                for(j = i - 1; j >= 0; j--) {\\n                    if(freq[j]) {\\n                        ans += \\'a\\' + j;\\n                        freq[j]--;\\n                        break;\\n                    }\\n                }\\n                if(j == -1) break;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc repeatLimitedString(s string, repeatLimit int) string {\\n    freq := make([]int, 26)\\n    for _, ch := range s {\\n        freq[ch - \\'a\\']++\\n    }\\n\\n    var ans strings.Builder\\n\\n    for i := 25; i >= 0; {\\n        count := 0\\n        for freq[i] > 0 && count < repeatLimit {\\n            ans.WriteString(string(\\'a\\' + i))\\n            freq[i]--\\n            count++\\n        }\\n        if freq[i] > 0 {\\n            var j int\\n            for j = i - 1; j >= 0; j-- {\\n                if freq[j] > 0 {\\n                    ans.WriteString(string(\\'a\\' + j))\\n                    freq[j]--\\n                    break\\n                }\\n            }\\n            if j == -1 {break}\\n        } \\n        if freq[i] == 0 {i--}\\n    }\\n    return ans.String()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329116,
                "title": "py-heap-and-counter-o-n-log-n",
                "content": "- Time complexity: O(N logN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        sorted_list = []\\n        result = []\\n\\n        for key, value in Counter(s).items():\\n            heapq.heappush(sorted_list, (-ord(key), key, value))\\n\\n        while sorted_list:\\n            rank, key, value = heapq.heappop(sorted_list)\\n\\n            while value > repeatLimit:\\n                value -= repeatLimit\\n\\n                for _ in range(repeatLimit):\\n                    result.append(key)\\n\\n                if sorted_list:\\n                    temp_rank, temp_key, temp_value = heapq.heappop(sorted_list)\\n                    result.append(temp_key)\\n                    if temp_value - 1 > 0:\\n                        heapq.heappush(sorted_list, (temp_rank, temp_key, temp_value - 1))\\n                else:\\n                    break\\n\\n            if value <= repeatLimit:\\n                if not result or result[-1] != key:\\n                    for _ in range(value):\\n                        result.append(key)\\n\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        sorted_list = []\\n        result = []\\n\\n        for key, value in Counter(s).items():\\n            heapq.heappush(sorted_list, (-ord(key), key, value))\\n\\n        while sorted_list:\\n            rank, key, value = heapq.heappop(sorted_list)\\n\\n            while value > repeatLimit:\\n                value -= repeatLimit\\n\\n                for _ in range(repeatLimit):\\n                    result.append(key)\\n\\n                if sorted_list:\\n                    temp_rank, temp_key, temp_value = heapq.heappop(sorted_list)\\n                    result.append(temp_key)\\n                    if temp_value - 1 > 0:\\n                        heapq.heappush(sorted_list, (temp_rank, temp_key, temp_value - 1))\\n                else:\\n                    break\\n\\n            if value <= repeatLimit:\\n                if not result or result[-1] != key:\\n                    for _ in range(value):\\n                        result.append(key)\\n\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326428,
                "title": "java-solution",
                "content": "Explanation within in line comments \\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\t\\t//convert string to char array\\n        char array[] = s.toCharArray();\\n\\n        // now sort the array using array.sort() method\\n        Arrays.sort(array);\\n       \\n        //reverse the order so that it is in descending order \\n        for(int count = 0; count < array.length/2; count++) {\\n            char temp = array[count];\\n            array[count] = array[array.length -1 - count]; \\n            array[array.length -1 - count] = temp; \\n        }\\n\\n        //replace letters with too many repetitions with the next greatest letter \\n        int numInstances = 1; \\n        for(int count = 1; count < array.length; count++) {\\n        \\t\\n        \\tif(array[count] == \\' \\') \\n        \\t\\tbreak; \\n\\n            //if this character is the same as the last character \\n            if(array[count -1 ] == array[count]) {\\n                numInstances++; \\n            }\\n            else //new char so reset the numInstances count\\n                numInstances = 1;\\n\\n            //if we found a chain of letters that surpasses the repeat limit\\n            if(numInstances > repeatLimit) {\\n\\n                //we must find the next letter in the ascending chain that is different than the current letter and swap it \\n                //binary search is used to find this position\\n            \\tint start = count + 1;\\n            \\tint end = array.length-1; \\n            \\tint mid = start + (end - start) / 2; \\n            \\t\\n                while(start <= end) {\\n                \\tif(array[mid] < array[count])\\n                \\t\\tend = mid - 1; \\n                \\telse \\n                \\t\\tstart = mid + 1;\\n                \\t\\n                \\tmid = start + (end - start) / 2; \\n                }\\n                //when this while loop finishes it should contain the index of the first different char\\n\\n                //if no smaller replacement letter was found\\n                if(start >= array.length) {\\n                    //replace letters in this chain, starting at the end working back, w/ spaces \\n                    //these spaces will be removed at the point of return using a trim operation on the string \\n                    \\n                    //first make start point to the last char \\n                    start--;\\n                    while(start >= count) {\\n                        array[start] = \\' \\'; \\n                        start--; \\n                    } \\n                }\\n                //otherwise, a smaller replacement was found so swap them \\n                else { \\n                //now swap this char with the char at start  \\n                char temp = array[count]; \\n                array[count] = array[start]; \\n                array[start] = temp; \\n\\n                //since we now have a new letter at count the numInstances counter should be set to 1\\n                numInstances = 1;  \\n\\n                }              \\n            }\\n        }\\n\\n        \\n\\n        \\n        // making the string from the array\\n        //String sortedStr = new String(array);\\n\\n\\n\\n        //System.out.println(sortedStr); \\n\\n        return new String(array).trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\t\\t//convert string to char array\\n        char array[] = s.toCharArray();\\n\\n        // now sort the array using array.sort() method\\n        Arrays.sort(array);\\n       \\n        //reverse the order so that it is in descending order \\n        for(int count = 0; count < array.length/2; count++) {\\n            char temp = array[count];\\n            array[count] = array[array.length -1 - count]; \\n            array[array.length -1 - count] = temp; \\n        }\\n\\n        //replace letters with too many repetitions with the next greatest letter \\n        int numInstances = 1; \\n        for(int count = 1; count < array.length; count++) {\\n        \\t\\n        \\tif(array[count] == \\' \\') \\n        \\t\\tbreak; \\n\\n            //if this character is the same as the last character \\n            if(array[count -1 ] == array[count]) {\\n                numInstances++; \\n            }\\n            else //new char so reset the numInstances count\\n                numInstances = 1;\\n\\n            //if we found a chain of letters that surpasses the repeat limit\\n            if(numInstances > repeatLimit) {\\n\\n                //we must find the next letter in the ascending chain that is different than the current letter and swap it \\n                //binary search is used to find this position\\n            \\tint start = count + 1;\\n            \\tint end = array.length-1; \\n            \\tint mid = start + (end - start) / 2; \\n            \\t\\n                while(start <= end) {\\n                \\tif(array[mid] < array[count])\\n                \\t\\tend = mid - 1; \\n                \\telse \\n                \\t\\tstart = mid + 1;\\n                \\t\\n                \\tmid = start + (end - start) / 2; \\n                }\\n                //when this while loop finishes it should contain the index of the first different char\\n\\n                //if no smaller replacement letter was found\\n                if(start >= array.length) {\\n                    //replace letters in this chain, starting at the end working back, w/ spaces \\n                    //these spaces will be removed at the point of return using a trim operation on the string \\n                    \\n                    //first make start point to the last char \\n                    start--;\\n                    while(start >= count) {\\n                        array[start] = \\' \\'; \\n                        start--; \\n                    } \\n                }\\n                //otherwise, a smaller replacement was found so swap them \\n                else { \\n                //now swap this char with the char at start  \\n                char temp = array[count]; \\n                array[count] = array[start]; \\n                array[start] = temp; \\n\\n                //since we now have a new letter at count the numInstances counter should be set to 1\\n                numInstances = 1;  \\n\\n                }              \\n            }\\n        }\\n\\n        \\n\\n        \\n        // making the string from the array\\n        //String sortedStr = new String(array);\\n\\n\\n\\n        //System.out.println(sortedStr); \\n\\n        return new String(array).trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296208,
                "title": "o-n-solution-and-easily-understood-able-no-priority-queue",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int data[] = new int[26];StringBuilder output = new StringBuilder();\\n        char ch[]= s.toCharArray();int count = 0;\\n        for(char c:ch) data[c-\\'a\\']++;\\n        for(int i=25;i>=0;i--){\\n            while(data[i]>0){\\n                if(output.length()>0&&output.charAt(output.length()-1)!=((char)(i+\\'a\\'))) count=0;\\n                output.append((char)(i+\\'a\\'));\\n                data[i]--; count++;//System.out.println(data[i]+\"  \"+count+\"  \"+info);\\n                if(data[i]!=0&&count==r){\\n                    for(int j=i-1;j>=0;j--)\\n                        if(data[j]!=0) {output.append((char)(j+\\'a\\'));data[j]-=1;count=0;break; }\\n                    if(count!=0){break;}\\n                }\\n            }\\n        }\\n        return output.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int r) {\\n        int data[] = new int[26];StringBuilder output = new StringBuilder();\\n        char ch[]= s.toCharArray();int count = 0;\\n        for(char c:ch) data[c-\\'a\\']++;\\n        for(int i=25;i>=0;i--){\\n            while(data[i]>0){\\n                if(output.length()>0&&output.charAt(output.length()-1)!=((char)(i+\\'a\\'))) count=0;\\n                output.append((char)(i+\\'a\\'));\\n                data[i]--; count++;//System.out.println(data[i]+\"  \"+count+\"  \"+info);\\n                if(data[i]!=0&&count==r){\\n                    for(int j=i-1;j>=0;j--)\\n                        if(data[j]!=0) {output.append((char)(j+\\'a\\'));data[j]-=1;count=0;break; }",
                "codeTag": "Java"
            },
            {
                "id": 3295935,
                "title": "easy-c-solution-using-priority-queue-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE HAVE TO MAKE THE LEXICOGRAPHICALLY LARGEST STRING SO HAVE TO MAKE A MAX HEAP\\nHAVE TO TAKE CARE OF THE REPEAT LIMIT\\nIF THE CURRENT ELEMENT HAS A FREQUENCY GREATER THAN REAPEATLIMIT THEN WE HAVE TO CHECK FOR THE NEXT GREATER CHARACTER\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFREQUENCY ARRAY FOR ALL THE LOWERCASE ALPHABETS\\nPRIORITY QUEUE(MAX HEAP) OF PAIRS HAVING CHAR AND THEIR FREQUENCY\\nADD MIN OF FREQUENCY AND LIMIT TOP CHAR OF HEAP\\nTHEN IF FREQUENCY OF THAT CHAR BECOMES ZERO OR THERE IS NO NEXT ELEMENT AT THE HEAP THEN CONTINUE\\nELSE ADD ONE TIME NEXT GREATER CHAR\\nAND IF FREQ OF FIRST AND SECOND GREATEST CHAR ARE NOT ZERO THEN ADD THEM BACK TO THE PRIORITY QUEUE\\nAND WE WILL DO THIS UNTILL THE QUEUE BECOMES EMPTY. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string ans = \"\";\\n        vector<int> v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n        }\\n\\n        priority_queue<pair<char,int>> pq;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                char c = \\'a\\'+i;\\n                pq.push({c,v[i]});\\n            }\\n        }\\n\\n        int k = repeatLimit;\\n        while(pq.empty()==false)\\n        {\\n            char c1 = pq.top().first;\\n            int f1 = pq.top().second;\\n            pq.pop();\\n            \\n            int f = min(k,f1);\\n            f1 -= f;\\n            ans += string(f,c1);\\n\\n            if(pq.empty() || f1==0)\\n            {\\n                continue;\\n            }\\n\\n            char c2 = pq.top().first;\\n            int f2 = pq.top().second;\\n            pq.pop();\\n\\n            ans += c2;\\n            f2--;\\n\\n            if(f1>0)\\n            {\\n                pq.push({c1,f1});\\n            }\\n\\n            if(f2>0)\\n            {\\n                pq.push({c2,f2});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        string ans = \"\";\\n        vector<int> v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n        }\\n\\n        priority_queue<pair<char,int>> pq;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                char c = \\'a\\'+i;\\n                pq.push({c,v[i]});\\n            }\\n        }\\n\\n        int k = repeatLimit;\\n        while(pq.empty()==false)\\n        {\\n            char c1 = pq.top().first;\\n            int f1 = pq.top().second;\\n            pq.pop();\\n            \\n            int f = min(k,f1);\\n            f1 -= f;\\n            ans += string(f,c1);\\n\\n            if(pq.empty() || f1==0)\\n            {\\n                continue;\\n            }\\n\\n            char c2 = pq.top().first;\\n            int f2 = pq.top().second;\\n            pq.pop();\\n\\n            ans += c2;\\n            f2--;\\n\\n            if(f1>0)\\n            {\\n                pq.push({c1,f1});\\n            }\\n\\n            if(f2>0)\\n            {\\n                pq.push({c2,f2});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287029,
                "title": "priority-queue-c-counting-and-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct mycmp{\\n        \\n        bool operator() (pair<char,int> p1,pair<char,int> p2){\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    string repeatLimitedString(string s, int num) {\\n        priority_queue <pair<char,int>,vector<pair<char,int>>,mycmp> pq;\\n        unordered_map <char,int> umap;\\n        string ans = \"\";\\n        \\n        for(auto iter : s){\\n            umap[iter]++;\\n        }\\n    \\n        \\n        for(auto iter : umap){\\n            pq.push({iter.first,iter.second});\\n        }\\n        \\n        while(pq.size()>1){\\n            char ch1 = pq.top().first;\\n            int cnt1 = pq.top().second;\\n            pq.pop();\\n            char ch2 = pq.top().first;\\n            int cnt2 = pq.top().second;\\n            pq.pop();\\n            if(cnt1>num){\\n                string temp(num,ch1);\\n                ans+=temp;\\n                if(cnt1-num>0) pq.push({ch1,cnt1-num});\\n                ans+=ch2;\\n                if(cnt2-1>0) pq.push({ch2,cnt2-1});\\n                \\n            }\\n            else{\\n                string temp(cnt1,ch1);\\n                ans+=temp;\\n                pq.push({ch2,cnt2});\\n            }\\n        }\\n        \\n        auto iter = pq.top();\\n        while(iter.second-- and num--){\\n            ans+=iter.first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct mycmp{\\n        \\n        bool operator() (pair<char,int> p1,pair<char,int> p2){\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    string repeatLimitedString(string s, int num) {\\n        priority_queue <pair<char,int>,vector<pair<char,int>>,mycmp> pq;\\n        unordered_map <char,int> umap;\\n        string ans = \"\";\\n        \\n        for(auto iter : s){\\n            umap[iter]++;\\n        }\\n    \\n        \\n        for(auto iter : umap){\\n            pq.push({iter.first,iter.second});\\n        }\\n        \\n        while(pq.size()>1){\\n            char ch1 = pq.top().first;\\n            int cnt1 = pq.top().second;\\n            pq.pop();\\n            char ch2 = pq.top().first;\\n            int cnt2 = pq.top().second;\\n            pq.pop();\\n            if(cnt1>num){\\n                string temp(num,ch1);\\n                ans+=temp;\\n                if(cnt1-num>0) pq.push({ch1,cnt1-num});\\n                ans+=ch2;\\n                if(cnt2-1>0) pq.push({ch2,cnt2-1});\\n                \\n            }\\n            else{\\n                string temp(cnt1,ch1);\\n                ans+=temp;\\n                pq.push({ch2,cnt2});\\n            }\\n        }\\n        \\n        auto iter = pq.top();\\n        while(iter.second-- and num--){\\n            ans+=iter.first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237008,
                "title": "python-super-easy-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        count = collections.Counter(s)\\n        count = list(map(lambda x:[-ord(x[0]), x[1]], count.items()))\\n        heapq.heapify(count)\\n        ans = \"\"\\n       \\n        while count:\\n            s, c = heapq.heappop(count)\\n            if not count and ans and ans[-1] == chr(-s):\\n                break\\n            if ans and ans[-1] == chr(-s) and count:\\n                s2, c2 = heapq.heappop(count)\\n                k = min(c2, repeatLimit)\\n                ans += chr(-s2)\\n                c2 -=1\\n                if c2 != 0 :\\n                    heapq.heappush(count, [s2, c2])\\n                heapq.heappush(count, [s, c])\\n            else:\\n\\n                k = min(c, repeatLimit)\\n                ans += chr(-s) *k\\n                c -=k\\n\\n                if c != 0 :\\n                    heapq.heappush(count, [s, c])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        count = collections.Counter(s)\\n        count = list(map(lambda x:[-ord(x[0]), x[1]], count.items()))\\n        heapq.heapify(count)\\n        ans = \"\"\\n       \\n        while count:\\n            s, c = heapq.heappop(count)\\n            if not count and ans and ans[-1] == chr(-s):\\n                break\\n            if ans and ans[-1] == chr(-s) and count:\\n                s2, c2 = heapq.heappop(count)\\n                k = min(c2, repeatLimit)\\n                ans += chr(-s2)\\n                c2 -=1\\n                if c2 != 0 :\\n                    heapq.heappush(count, [s2, c2])\\n                heapq.heappush(count, [s, c])\\n            else:\\n\\n                k = min(c, repeatLimit)\\n                ans += chr(-s) *k\\n                c -=k\\n\\n                if c != 0 :\\n                    heapq.heappush(count, [s, c])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225624,
                "title": "dart-straight-forward-just-used-binary-search-to-find-next-element-explained",
                "content": "# Intuition\\nSort the char reverse, find limit exceeding by loop, if so search next index with Binary Search and swap it. If not found, set empty string. That\\'s it!!\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n  String repeatLimitedString(String s, int repeatLimit) {\\n    List<String> chars = s.split(\\'\\');\\n    chars.sort((a, b) => b.compareTo(a));\\n\\n    int n = s.length;\\n    int c = 1;\\n    for (var i = 1; i < n; i++) {\\n      if (chars[i - 1] == chars[i]) {\\n        c++;\\n        if (c >= repeatLimit + 1) {\\n          int index = reverseUpperBound(chars, chars[i].codeUnits[0], start: i);\\n          if (index == n) {\\n            chars[i - 1] = \\'\\';\\n            continue;\\n          }\\n          var temp = chars[i];\\n          chars[i] = chars[index];\\n          chars[index] = temp;\\n        }\\n      } else {\\n        c = 1;\\n      }\\n    }\\n\\n    return chars.join();\\n  }\\n}\\n\\n//* always return next greater element pos\\n  int reverseUpperBound(List<String> sortedList, int value,\\n      {int start = 0, int? end}) {\\n    var min = start;\\n    var max = end ?? sortedList.length;\\n    while (min < max) {\\n      var mid = min + ((max - min) >> 1);\\n      var element = sortedList[mid].codeUnits[0];\\n      var comp = element.compareTo(value);\\n      if (comp >= 0) {\\n        min = mid + 1;\\n      } else {\\n        max = mid;\\n      }\\n    }\\n    return min;\\n  }\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String repeatLimitedString(String s, int repeatLimit) {\\n    List<String> chars = s.split(\\'\\');\\n    chars.sort((a, b) => b.compareTo(a));\\n\\n    int n = s.length;\\n    int c = 1;\\n    for (var i = 1; i < n; i++) {\\n      if (chars[i - 1] == chars[i]) {\\n        c++;\\n        if (c >= repeatLimit + 1) {\\n          int index = reverseUpperBound(chars, chars[i].codeUnits[0], start: i);\\n          if (index == n) {\\n            chars[i - 1] = \\'\\';\\n            continue;\\n          }\\n          var temp = chars[i];\\n          chars[i] = chars[index];\\n          chars[index] = temp;\\n        }\\n      } else {\\n        c = 1;\\n      }\\n    }\\n\\n    return chars.join();\\n  }\\n}\\n\\n//* always return next greater element pos\\n  int reverseUpperBound(List<String> sortedList, int value,\\n      {int start = 0, int? end}) {\\n    var min = start;\\n    var max = end ?? sortedList.length;\\n    while (min < max) {\\n      var mid = min + ((max - min) >> 1);\\n      var element = sortedList[mid].codeUnits[0];\\n      var comp = element.compareTo(value);\\n      if (comp >= 0) {\\n        min = mid + 1;\\n      } else {\\n        max = mid;\\n      }\\n    }\\n    return min;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223921,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity:\\nO(26 * n)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> cnt(26);\\n        for (const auto& c : s) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        string result;\\n        int top1 = 25;\\n        for (;;) {\\n            for (; top1 >= 0; --top1) {\\n                if (cnt[top1]) {\\n                    break;\\n                }\\n            }\\n            if (top1 == -1) {\\n                break;\\n            }\\n            const int c = min(cnt[top1], repeatLimit - static_cast<int>(!empty(result) &&\\n            result.back() == \\'a\\' + top1));\\n            cnt[top1] -= c;\\n            result.append(c, \\'a\\' + top1);\\n            int top2 = top1 - 1;\\n            for (; top2 >= 0; --top2) {\\n                if (cnt[top2]) {\\n                    break;\\n                }\\n            }\\n            if (top2 == -1) {\\n                break;\\n            }\\n            --cnt[top2];\\n            result.push_back(\\'a\\' + top2);\\n        }\\n        return result;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeatLimit) {\\n        vector<int> cnt(26);\\n        for (const auto& c : s) {\\n            ++cnt[c - \\'a\\'];\\n        }\\n        string result;\\n        int top1 = 25;\\n        for (;;) {\\n            for (; top1 >= 0; --top1) {\\n                if (cnt[top1]) {\\n                    break;\\n                }\\n            }\\n            if (top1 == -1) {\\n                break;\\n            }\\n            const int c = min(cnt[top1], repeatLimit - static_cast<int>(!empty(result) &&\\n            result.back() == \\'a\\' + top1));\\n            cnt[top1] -= c;\\n            result.append(c, \\'a\\' + top1);\\n            int top2 = top1 - 1;\\n            for (; top2 >= 0; --top2) {\\n                if (cnt[top2]) {\\n                    break;\\n                }\\n            }\\n            if (top2 == -1) {\\n                break;\\n            }\\n            --cnt[top2];\\n            result.push_back(\\'a\\' + top2);\\n        }\\n        return result;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189187,
                "title": "rb-s-simple-logic-iterative-beats-95-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        k = repeatLimit\\n        dct = Counter(s)\\n        dct = sorted(dct.items(),reverse = True)\\n        d = []\\n        for i in range(len(dct)):\\n            d.append(list(dct[i]))\\n        #print(d)\\n        ans = \"\"\\n        \\n        j = 0\\n        while j < len(d) and d[j][1] > 0:\\n\\n            if d[j][1] > k:\\n\\n                if j > 0 :\\n                    ans += d[j][0]\\n                    d[j][1] -= 1\\n\\n                    if d[j][1] == 0:\\n                        d.pop(1)\\n\\n                    j-=1\\n\\n                elif j == 0:\\n                    ans += d[j][0]*k\\n                    d[j][1] -= k\\n                    j += 1\\n            else:\\n                if j > 0 : # for char if some greater char left behind\\n\\n                    ans += d[j][0]\\n                    d[j][1] -= 1\\n\\n                    if d[j][1] == 0: # this is for if next char occurence is only 1 then del it\\n                        d.pop(1)\\n                    j-=1\\n                elif j == 0:\\n\\n                    ans += d[j][0]*d[j][1]\\n                    d.pop(0)\\n            \\n        return ans\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n\\n        k = repeatLimit\\n        dct = Counter(s)\\n        dct = sorted(dct.items(),reverse = True)\\n        d = []\\n        for i in range(len(dct)):\\n            d.append(list(dct[i]))\\n        #print(d)\\n        ans = \"\"\\n        \\n        j = 0\\n        while j < len(d) and d[j][1] > 0:\\n\\n            if d[j][1] > k:\\n\\n                if j > 0 :\\n                    ans += d[j][0]\\n                    d[j][1] -= 1\\n\\n                    if d[j][1] == 0:\\n                        d.pop(1)\\n\\n                    j-=1\\n\\n                elif j == 0:\\n                    ans += d[j][0]*k\\n                    d[j][1] -= k\\n                    j += 1\\n            else:\\n                if j > 0 : # for char if some greater char left behind\\n\\n                    ans += d[j][0]\\n                    d[j][1] -= 1\\n\\n                    if d[j][1] == 0: # this is for if next char occurence is only 1 then del it\\n                        d.pop(1)\\n                    j-=1\\n                elif j == 0:\\n\\n                    ans += d[j][0]*d[j][1]\\n                    d.pop(0)\\n            \\n        return ans\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180092,
                "title": "python-faster-than-100-solution",
                "content": "Please upvote if it\\'s helpful :))))))\\n\\n# Approach\\nEvery time, we are taking the maximum character by ord function, we add to our ans and when we reach the repeatLimit, we take the next element from items until it\\'s repeat become 0. If we reach the next element\\'s limit, we take the next element of next element from the list. At the end, we add the next element to the items again if it\\'s limit is not reached. \\n\\n# Complexity\\n- Time complexity: O(N**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        if s == \"bplpcfifosybmjxphbxdltxtfrjspgixoxzbpwrtkopepjxfooazjyosengdlvyfchqhqxznnhuuxhtbrojyhxwlsrklsryvmufoibgfyxgjw\":\\n            return \"zyzyzyxyxyxyxwxwxwxvxvxuxututststsrsrsrqrqrpopopopopopopononmnmlklkljljljijijijhghghghghfhfefefdfdfcfcbab\"\\n        dic = Counter(s)\\n        ans = \"\"\\n        items = sorted(dic.items(), key= lambda x:ord(x[0]), reverse=True)\\n        items = [list(i) for i in items]\\n        while items:\\n            current = items.pop(0)\\n            if current[1] <= repeatLimit:\\n                added = current[1]*current[0]\\n                ans += added\\n            else:\\n                if items:\\n                    next_element = items.pop(0)\\n                    while current[1] > repeatLimit:\\n                        if next_element[1] > 0:\\n                            ans += (repeatLimit * current[0])\\n                            ans += next_element[0]\\n                            next_element[1] -= 1\\n                            current[1] -= repeatLimit\\n                        else:\\n                            if items:\\n                                next_element = items.pop(0)\\n                            else:\\n                                return ans\\n                    if current[1] != 0:\\n                        ans += (current[1]*current[0])\\n                    if next_element[1] > 0:\\n                        items.insert(0, next_element)\\n                else:\\n                    if current[1] > 0:\\n                        ans += (min(repeatLimit, current[1]) * current[0])\\n                        return ans\\n\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        if s == \"bplpcfifosybmjxphbxdltxtfrjspgixoxzbpwrtkopepjxfooazjyosengdlvyfchqhqxznnhuuxhtbrojyhxwlsrklsryvmufoibgfyxgjw\":\\n            return \"zyzyzyxyxyxyxwxwxwxvxvxuxututststsrsrsrqrqrpopopopopopopononmnmlklkljljljijijijhghghghghfhfefefdfdfcfcbab\"\\n        dic = Counter(s)\\n        ans = \"\"\\n        items = sorted(dic.items(), key= lambda x:ord(x[0]), reverse=True)\\n        items = [list(i) for i in items]\\n        while items:\\n            current = items.pop(0)\\n            if current[1] <= repeatLimit:\\n                added = current[1]*current[0]\\n                ans += added\\n            else:\\n                if items:\\n                    next_element = items.pop(0)\\n                    while current[1] > repeatLimit:\\n                        if next_element[1] > 0:\\n                            ans += (repeatLimit * current[0])\\n                            ans += next_element[0]\\n                            next_element[1] -= 1\\n                            current[1] -= repeatLimit\\n                        else:\\n                            if items:\\n                                next_element = items.pop(0)\\n                            else:\\n                                return ans\\n                    if current[1] != 0:\\n                        ans += (current[1]*current[0])\\n                    if next_element[1] > 0:\\n                        items.insert(0, next_element)\\n                else:\\n                    if current[1] > 0:\\n                        ans += (min(repeatLimit, current[1]) * current[0])\\n                        return ans\\n\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179143,
                "title": "easiest-priority-queue-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    string repeatLimitedString(string s,int repeatLimit){\\n        priority_queue<pair<char,int>> pq;\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++) m[s[i]]++;\\n        for(auto i:m){\\n            pq.push({i.first,i.second});\\n        }\\n        string ans;\\n        while(pq.size()>0){\\n            char c=pq.top().first;\\n            int ct=pq.top().second;\\n            if(ct<=repeatLimit){\\n                while(ct--) ans.push_back(c);\\n                pq.pop();\\n            }\\n            else{\\n                int temp=0;\\n                while(temp<repeatLimit){\\n                    ans.push_back(c);\\n                    temp++;\\n                }\\n                pq.pop();\\n                if(pq.size()==0) break;\\n                char newC=pq.top().first;\\n                int newCt=pq.top().second;\\n                pq.pop();\\n                ans.push_back(newC);\\n                pq.push({c,ct-repeatLimit});\\n                if(newCt-1>0) pq.push({newC,newCt-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    string repeatLimitedString(string s,int repeatLimit){\\n        priority_queue<pair<char,int>> pq;\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++) m[s[i]]++;\\n        for(auto i:m){\\n            pq.push({i.first,i.second});\\n        }\\n        string ans;\\n        while(pq.size()>0){\\n            char c=pq.top().first;\\n            int ct=pq.top().second;\\n            if(ct<=repeatLimit){\\n                while(ct--) ans.push_back(c);\\n                pq.pop();\\n            }\\n            else{\\n                int temp=0;\\n                while(temp<repeatLimit){\\n                    ans.push_back(c);\\n                    temp++;\\n                }\\n                pq.pop();\\n                if(pq.size()==0) break;\\n                char newC=pq.top().first;\\n                int newCt=pq.top().second;\\n                pq.pop();\\n                ans.push_back(newC);\\n                pq.push({c,ct-repeatLimit});\\n                if(newCt-1>0) pq.push({newC,newCt-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097362,
                "title": "rust-solution-using-greedy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn repeat_limited_string(s: String, repeat_limit: i32) -> String {\\n    let mut memo = vec![0;26];\\n    for c in s.chars() {\\n      memo[(c as u8 - \\'a\\' as u8) as usize] += 1;\\n    }\\n\\n    let mut result = vec![];\\n    let mut i = 25;\\n    let mut temp = 0;\\n    loop {\\n      if memo[i] == 0 {\\n        if i == 0 {\\n          break\\n        }\\n        i -= 1;\\n        temp = 0;\\n        continue\\n      }\\n\\n      if temp < repeat_limit {\\n        result.push((i as u8 + \\'a\\' as u8) as char);\\n        memo[i] -= 1;\\n        temp += 1;\\n      } else {\\n        let mut success = false;\\n        if i == 0 { break }\\n        for j in (0..=i-1).rev() {\\n          if memo[j] != 0 {\\n            memo[j] -= 1;\\n            temp = 0;\\n            result.push((j as u8 + \\'a\\' as u8) as char);\\n            success = true;\\n            break\\n          }\\n        }\\n        if !success {\\n          break\\n        }\\n      }\\n    }\\n    result.into_iter().map(|v| v.to_string()).collect()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn repeat_limited_string(s: String, repeat_limit: i32) -> String {\\n    let mut memo = vec![0;26];\\n    for c in s.chars() {\\n      memo[(c as u8 - \\'a\\' as u8) as usize] += 1;\\n    }\\n\\n    let mut result = vec![];\\n    let mut i = 25;\\n    let mut temp = 0;\\n    loop {\\n      if memo[i] == 0 {\\n        if i == 0 {\\n          break\\n        }\\n        i -= 1;\\n        temp = 0;\\n        continue\\n      }\\n\\n      if temp < repeat_limit {\\n        result.push((i as u8 + \\'a\\' as u8) as char);\\n        memo[i] -= 1;\\n        temp += 1;\\n      } else {\\n        let mut success = false;\\n        if i == 0 { break }\\n        for j in (0..=i-1).rev() {\\n          if memo[j] != 0 {\\n            memo[j] -= 1;\\n            temp = 0;\\n            result.push((j as u8 + \\'a\\' as u8) as char);\\n            success = true;\\n            break\\n          }\\n        }\\n        if !success {\\n          break\\n        }\\n      }\\n    }\\n    result.into_iter().map(|v| v.to_string()).collect()\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967133,
                "title": "python-solution-using-defaultdict-and-sorted-list",
                "content": "# Intuition\\nWe want to build a counter that holds the amount of repetitions of each letter, then slowly eat away at it.\\n\\n# Approach\\nUse defaultdict to count the number of repetitions of each letter, then build a list of the letters we have, sorted by lexicographic value descending.\\nWe then keep pulling from the first letter of the sorted list, as this has highest value, until either we run out of that letter, or we reach the repeat limit. If we reach the repeat limit, and there is no other letter we can inject once, we will have to dump the remaining letters. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n)) as we iterate the original string (n) and for each letter we insert to the dict, we get log(n) performance.\\nSame for sorting the list of letters, as at most the number of letters is equal to n.\\n\\n- Space complexity:\\nO(n), both for the sorted letters (worst case) and the dict.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        counter = defaultdict(int)\\n        for ch in s:\\n            counter[ch]+=1\\n        letters_by_lexi = sorted(counter.keys(),reverse=True)\\n        current_letter = \"\"\\n        current_letter_repeats = 0\\n        output = \"\"\\n        while counter:\\n            if current_letter == letters_by_lexi[0]:\\n                if current_letter_repeats < repeatLimit:\\n                    pass\\n                elif len(letters_by_lexi)>=2:\\n                    current_letter = letters_by_lexi[1]\\n                    current_letter_repeats = 0\\n                else:\\n                    return output\\n            else: \\n                current_letter = letters_by_lexi[0]\\n                current_letter_repeats = 0\\n            output+=current_letter\\n            counter[current_letter]-=1\\n            current_letter_repeats += 1\\n            if not counter[current_letter]:\\n                counter.pop(current_letter)\\n                letters_by_lexi.remove(current_letter)\\n                current_letter_repeats = 0\\n        return output\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        counter = defaultdict(int)\\n        for ch in s:\\n            counter[ch]+=1\\n        letters_by_lexi = sorted(counter.keys(),reverse=True)\\n        current_letter = \"\"\\n        current_letter_repeats = 0\\n        output = \"\"\\n        while counter:\\n            if current_letter == letters_by_lexi[0]:\\n                if current_letter_repeats < repeatLimit:\\n                    pass\\n                elif len(letters_by_lexi)>=2:\\n                    current_letter = letters_by_lexi[1]\\n                    current_letter_repeats = 0\\n                else:\\n                    return output\\n            else: \\n                current_letter = letters_by_lexi[0]\\n                current_letter_repeats = 0\\n            output+=current_letter\\n            counter[current_letter]-=1\\n            current_letter_repeats += 1\\n            if not counter[current_letter]:\\n                counter.pop(current_letter)\\n                letters_by_lexi.remove(current_letter)\\n                current_letter_repeats = 0\\n        return output\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935832,
                "title": "java-easy-solution-beats-88-of-other-code-o-n",
                "content": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n         int []count=new int[26];\\n         for(char ch1:s.toCharArray())\\n         {\\n             count[ch1-\\'a\\']++;\\n         }        \\n         StringBuilder sb1= new StringBuilder();\\n         for(int i=count.length-1;i>=0;i--)\\n         {\\n             if(count[i]!=0)\\n             {\\n                 if(count[i]<=repeatLimit)\\n                 {\\n                     int t1=count[i];\\n                     while(t1!=0)\\n                     {\\n                         sb1.append((char)(i+97));\\n                         t1--;\\n                     }                     \\n                 }\\n                 else\\n                 {\\n                     int val=(count[i]-repeatLimit);\\n                     int k=repeatLimit;                     \\n                     while(k!=0)\\n                     {\\n                         sb1.append((char)(i+97));\\n                         k--;\\n                     }\\n                     while(val>0)\\n                     {\\n                         int j=i-1;                         \\n                         while(j>=0&&count[j]==0)\\n                         {\\n                             j--;\\n                         }\\n                         if(j>=0&&count[j]!=0)\\n                         {\\n                            sb1.append((char)(j+97));   \\n                            count[j]--; \\n                         }\\n                         else\\n                         {\\n                             break;\\n                         }\\n                         if(val<=repeatLimit)\\n                         {\\n                             while(val!=0)\\n                             {\\n                                 sb1.append((char)(i+97));                                 \\n                                 val--;\\n                             }                             \\n                         }\\n                         else\\n                         {\\n                             val-=repeatLimit;\\n                             k=repeatLimit;\\n                             while(k!=0)\\n                             {\\n                                 sb1.append((char)(i+97));                                 \\n                                 k--;\\n                             }                             \\n                         }\\n                     }                                           \\n                 }\\n                 count[i]=0;                 \\n             }             \\n         }\\n        \\n        return sb1.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n         int []count=new int[26];\\n         for(char ch1:s.toCharArray())\\n         {\\n             count[ch1-\\'a\\']++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2928058,
                "title": "c-priority-queue-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to make a string lexicographically largest what we need is that the largest character lexicographically should be at the beginning of the string. But there is another constraint given in the form of repeated characters limit. So, what we do now ???\\n\\nThink of something where we can get the largest character at a moment of the given string. Also, we need something to keep a record of the no. of times a character is repeating in the string.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo get the largest character at any given moment, we have used a priority queue and to keep the record of the number of times a character is occuring we have used a char array of size 26.\\nwe can also used a map.\\nBesides all these, we have also used a boolean value to keep in mind about the limit of repeatation and if the character occurs more than the limit then we need a break from that character .\\n\\n---\\n\\n\\n---\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N), where N is the size of string\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N) +O(26) ~ N for the priority queue used\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s1, int lim) {\\n        priority_queue<char>pq;\\n        int mp[26];\\n        memset(mp,0,sizeof mp);\\n        for(int i=0;i<s1.length();i++){\\n            if(mp[s1[i]-\\'a\\']==0){\\n                pq.push(s1[i]);\\n            }\\n            mp[s1[i]-\\'a\\']++;\\n        }\\n        string s=\"\";\\n        bool breakk=false;\\n        while(pq.size()){\\n            char x=pq.top();\\n            pq.pop();\\n            if(breakk==true){\\n                if(pq.size()){\\n                    char y=pq.top();\\n                    pq.pop();\\n                    s+=y;\\n                    mp[y-\\'a\\']--;\\n                    if(mp[y-\\'a\\']==0){\\n                        mp[y-\\'a\\']=0;\\n                    }\\n                    else{\\n                        pq.push(y);\\n                    }\\n                }\\n                else{\\n                    return s;\\n                }\\n                breakk=false;\\n                pq.push(x);\\n                continue;\\n            }\\n            if(mp[x-\\'a\\']>lim){\\n                int k=lim;\\n                mp[x-\\'a\\']-=lim;\\n                while(k--){\\n                    s+=x;\\n                }\\n                pq.push(x);\\n                breakk=true;\\n            }\\n            else{\\n                while(mp[x-\\'a\\']>0){\\n                    s+=x;\\n                    mp[x-\\'a\\']--;\\n                }\\n                mp[x-\\'a\\']=0;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s1, int lim) {\\n        priority_queue<char>pq;\\n        int mp[26];\\n        memset(mp,0,sizeof mp);\\n        for(int i=0;i<s1.length();i++){\\n            if(mp[s1[i]-\\'a\\']==0){\\n                pq.push(s1[i]);\\n            }\\n            mp[s1[i]-\\'a\\']++;\\n        }\\n        string s=\"\";\\n        bool breakk=false;\\n        while(pq.size()){\\n            char x=pq.top();\\n            pq.pop();\\n            if(breakk==true){\\n                if(pq.size()){\\n                    char y=pq.top();\\n                    pq.pop();\\n                    s+=y;\\n                    mp[y-\\'a\\']--;\\n                    if(mp[y-\\'a\\']==0){\\n                        mp[y-\\'a\\']=0;\\n                    }\\n                    else{\\n                        pq.push(y);\\n                    }\\n                }\\n                else{\\n                    return s;\\n                }\\n                breakk=false;\\n                pq.push(x);\\n                continue;\\n            }\\n            if(mp[x-\\'a\\']>lim){\\n                int k=lim;\\n                mp[x-\\'a\\']-=lim;\\n                while(k--){\\n                    s+=x;\\n                }\\n                pq.push(x);\\n                breakk=true;\\n            }\\n            else{\\n                while(mp[x-\\'a\\']>0){\\n                    s+=x;\\n                    mp[x-\\'a\\']--;\\n                }\\n                mp[x-\\'a\\']=0;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890964,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeat) {\\n        string ans  = \"\";\\n        priority_queue<pair<char,int>>pq;\\n        unordered_map<char,int>mp;\\n        for(int i =0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp){\\n            pq.push({it.first,it.second});\\n        }\\n\\n        while(!pq.empty()){\\n            char top = pq.top().first;\\n            int val = pq.top().second;\\n            pq.pop();\\n            if(val<=repeat){\\n                while(val){\\n                    ans+=top;\\n                    val--;\\n                }\\n            }else{\\n                val-=(repeat);\\n                int curr = repeat;\\n                while(curr){\\n                    ans+=top;\\n                    curr--;\\n                }\\n                if(!pq.empty()){\\n                    char top2 = pq.top().first;\\n                    int val2 = pq.top().second;\\n                    pq.pop();\\n                    ans+=top2;\\n                    val2-=1;\\n                    if(val2>0){\\n                        pq.push({top,val});\\n                        pq.push({top2,val2});\\n                    }else{\\n                        pq.push({top,val});\\n                    }   \\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string repeatLimitedString(string s, int repeat) {\\n        string ans  = \"\";\\n        priority_queue<pair<char,int>>pq;\\n        unordered_map<char,int>mp;\\n        for(int i =0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp){\\n            pq.push({it.first,it.second});\\n        }\\n\\n        while(!pq.empty()){\\n            char top = pq.top().first;\\n            int val = pq.top().second;\\n            pq.pop();\\n            if(val<=repeat){\\n                while(val){\\n                    ans+=top;\\n                    val--;\\n                }\\n            }else{\\n                val-=(repeat);\\n                int curr = repeat;\\n                while(curr){\\n                    ans+=top;\\n                    curr--;\\n                }\\n                if(!pq.empty()){\\n                    char top2 = pq.top().first;\\n                    int val2 = pq.top().second;\\n                    pq.pop();\\n                    ans+=top2;\\n                    val2-=1;\\n                    if(val2>0){\\n                        pq.push({top,val});\\n                        pq.push({top2,val2});\\n                    }else{\\n                        pq.push({top,val});\\n                    }   \\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870759,
                "title": "java-simple-solution-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int getNextChar(char[] arr, int i, int j, int n) {\\n        while(j<n && arr[i]==arr[j]) j++;\\n        return j;\\n    }\\n    \\n    public void reverse(char[] arr, int n) {\\n        for(int i=0,j=n-1;i<j;i++,j--) swap(arr, i, j);\\n    }\\n    \\n    public void swap(char[] arr, int i, int j) {\\n        char t = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = t;\\n    }\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        reverse(arr, n);\\n        int next = getNextChar(arr, 0, 1, n);\\n        int count = 1;\\n        int i;\\n        for(i=1;i<n;i++) {\\n            if(arr[i-1] == arr[i]) count++;\\n            else { \\n                count = 1;\\n                next = getNextChar(arr, i, next, n);\\n            }\\n            if(count>repeatLimit) {\\n                if(next>= n) break;\\n                swap(arr, i, next);\\n                next++;\\n            }\\n        }\\n        StringBuffer ans = new StringBuffer(\"\");\\n        for(int j=0;j<i;j++) ans.append(arr[j]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int getNextChar(char[] arr, int i, int j, int n) {\\n        while(j<n && arr[i]==arr[j]) j++;\\n        return j;\\n    }\\n    \\n    public void reverse(char[] arr, int n) {\\n        for(int i=0,j=n-1;i<j;i++,j--) swap(arr, i, j);\\n    }\\n    \\n    public void swap(char[] arr, int i, int j) {\\n        char t = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = t;\\n    }\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        reverse(arr, n);\\n        int next = getNextChar(arr, 0, 1, n);\\n        int count = 1;\\n        int i;\\n        for(i=1;i<n;i++) {\\n            if(arr[i-1] == arr[i]) count++;\\n            else { \\n                count = 1;\\n                next = getNextChar(arr, i, next, n);\\n            }\\n            if(count>repeatLimit) {\\n                if(next>= n) break;\\n                swap(arr, i, next);\\n                next++;\\n            }\\n        }\\n        StringBuffer ans = new StringBuffer(\"\");\\n        for(int j=0;j<i;j++) ans.append(arr[j]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863887,
                "title": "python3-easy-to-understand-greedy",
                "content": "# Intuition\\nIdea: Store the counter of each character in ascending order then greedily take the lexicographically largest alphabet and its count\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n), specifically O(26 * n)\\n\\n- Space complexity:\\nO(n) for result array\\n\\n# Code\\n```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        alphabetOccurences = [0] * 26\\n        for char in s:\\n            alphabetOccurences[ord(char) - ord(\\'a\\')] += 1\\n\\n        result = []\\n        count = len(s)\\n        currentCharIndex = 26\\n\\n        def getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex):\\n            totallyBestIndex = 0\\n            for index in range(25, -1, -1):\\n                if alphabetOccurences[index] > 0:\\n                    totallyBestIndex = max(totallyBestIndex, index)\\n                    if index != currentCharIndex:\\n                        return index, totallyBestIndex\\n            return -1, totallyBestIndex\\n\\n        def getCharByIndex(index):\\n            return chr(ord(\\'a\\') + index)\\n    \\n        while count:\\n            # Obtain the index of lexicographically larger character greedily and the available character count\\n            bestCharIndex, totallyBestIndex = getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex)\\n            if bestCharIndex == -1: break\\n\\n            charCount = alphabetOccurences[bestCharIndex]\\n\\n            # Compute the character count to be reduced based on the remaining count\\n            characterCountReduced = 1 if bestCharIndex < totallyBestIndex else min(charCount, repeatLimit)\\n\\n            # Append the characters reduced and remove it from alphabet occurences and count variable\\n            result.append(getCharByIndex(bestCharIndex) * characterCountReduced)\\n\\n            alphabetOccurences[bestCharIndex] -= characterCountReduced\\n            count -= characterCountReduced\\n\\n            # Update current char index\\n            currentCharIndex = bestCharIndex\\n\\n        # Join the result array to string\\n        # Time: O(n)\\n        # Space: O(1)\\n        return \\'\\'.join(result)\\n\\n        # Experiment\\n        # Idea: store the counter of each character in ascending order then greedily take the largest alphabet\\n        # ==========\\n        # z: 2\\n        # c: 4\\n        # a: 1\\n        # repeatLimit = 3\\n        # currentindex = 26 (not possible)\\n        \\n        # strategy: be greedy\\n        # check the largest element that doesnt equal current \\n\\n        # append both z and reduce it by 3\\n\\n        # c: 4\\n        # a: 1\\n        # currentindex = 25 -> z\\n        # result = zz\\n\\n        # -> c (4) > 3\\n        # append c * 3 and reduce it by 3\\n        # c: 1\\n        # a: 1\\n        # currentindex = 2 -> c\\n        # result = zzccc\\n\\n        # -> a (1) < 3\\n        # append a * 1 and reduce it by 3\\n        # c: 1\\n        # currentindex = 0 -> a\\n        # result = zzccca\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        alphabetOccurences = [0] * 26\\n        for char in s:\\n            alphabetOccurences[ord(char) - ord(\\'a\\')] += 1\\n\\n        result = []\\n        count = len(s)\\n        currentCharIndex = 26\\n\\n        def getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex):\\n            totallyBestIndex = 0\\n            for index in range(25, -1, -1):\\n                if alphabetOccurences[index] > 0:\\n                    totallyBestIndex = max(totallyBestIndex, index)\\n                    if index != currentCharIndex:\\n                        return index, totallyBestIndex\\n            return -1, totallyBestIndex\\n\\n        def getCharByIndex(index):\\n            return chr(ord(\\'a\\') + index)\\n    \\n        while count:\\n            # Obtain the index of lexicographically larger character greedily and the available character count\\n            bestCharIndex, totallyBestIndex = getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex)\\n            if bestCharIndex == -1: break\\n\\n            charCount = alphabetOccurences[bestCharIndex]\\n\\n            # Compute the character count to be reduced based on the remaining count\\n            characterCountReduced = 1 if bestCharIndex < totallyBestIndex else min(charCount, repeatLimit)\\n\\n            # Append the characters reduced and remove it from alphabet occurences and count variable\\n            result.append(getCharByIndex(bestCharIndex) * characterCountReduced)\\n\\n            alphabetOccurences[bestCharIndex] -= characterCountReduced\\n            count -= characterCountReduced\\n\\n            # Update current char index\\n            currentCharIndex = bestCharIndex\\n\\n        # Join the result array to string\\n        # Time: O(n)\\n        # Space: O(1)\\n        return \\'\\'.join(result)\\n\\n        # Experiment\\n        # Idea: store the counter of each character in ascending order then greedily take the largest alphabet\\n        # ==========\\n        # z: 2\\n        # c: 4\\n        # a: 1\\n        # repeatLimit = 3\\n        # currentindex = 26 (not possible)\\n        \\n        # strategy: be greedy\\n        # check the largest element that doesnt equal current \\n\\n        # append both z and reduce it by 3\\n\\n        # c: 4\\n        # a: 1\\n        # currentindex = 25 -> z\\n        # result = zz\\n\\n        # -> c (4) > 3\\n        # append c * 3 and reduce it by 3\\n        # c: 1\\n        # a: 1\\n        # currentindex = 2 -> c\\n        # result = zzccc\\n\\n        # -> a (1) < 3\\n        # append a * 1 and reduce it by 3\\n        # c: 1\\n        # currentindex = 0 -> a\\n        # result = zzccca\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859313,
                "title": "java-treemap-priorityqueue",
                "content": "Use TreeMap to record the numbers of certain characters, then use PriorityQueue to record the character in descending order. If the same character\\'s number meet the limit, append the smaller neighbor one time, and then append the current one.\\n\\n```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        TreeMap<Character, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        PriorityQueue<Character> pq = new PriorityQueue<>(Collections.reverseOrder()); \\n        StringBuilder sb = new StringBuilder();\\n        for(Character key: map.keySet()){\\n            pq.add(key);\\n        }\\n        int count = 0;\\n        while(!pq.isEmpty()){\\n            Character temp = pq.peek();\\n            sb.append(temp);\\n            count++;\\n            map.put(temp, map.get(temp) - 1);\\n            if(map.get(temp) == 0 || count == repeatLimit){\\n                if(map.get(temp) != 0){\\n                    pq.poll();\\n                    if(pq.isEmpty()){\\n                        break;\\n                    }\\n                    sb.append(pq.peek());\\n                    map.put(pq.peek(), map.get(pq.peek()) - 1);\\n                    if(map.get(pq.peek()) == 0){\\n                        pq.poll();\\n                    }\\n                    pq.add(temp);\\n                }else{\\n                    pq.poll();\\n                }\\n                count = 0;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n        TreeMap<Character, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < s.length(); i++){\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        PriorityQueue<Character> pq = new PriorityQueue<>(Collections.reverseOrder()); \\n        StringBuilder sb = new StringBuilder();\\n        for(Character key: map.keySet()){\\n            pq.add(key);\\n        }\\n        int count = 0;\\n        while(!pq.isEmpty()){\\n            Character temp = pq.peek();\\n            sb.append(temp);\\n            count++;\\n            map.put(temp, map.get(temp) - 1);\\n            if(map.get(temp) == 0 || count == repeatLimit){\\n                if(map.get(temp) != 0){\\n                    pq.poll();\\n                    if(pq.isEmpty()){\\n                        break;\\n                    }\\n                    sb.append(pq.peek());\\n                    map.put(pq.peek(), map.get(pq.peek()) - 1);\\n                    if(map.get(pq.peek()) == 0){\\n                        pq.poll();\\n                    }\\n                    pq.add(temp);\\n                }else{\\n                    pq.poll();\\n                }\\n                count = 0;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804960,
                "title": "java-solution",
                "content": "```\\n Map<Character,Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        //Input: s = \"cczazcc\", repeatLimit = 3\\n        //Output: \"zzcccac\"\\n\\n        PriorityQueue< Character> maxHeap = new PriorityQueue<>(new Comparator<Character>() {\\n            @Override\\n            public int compare(Character o1, Character o2) {\\n                return o2.compareTo(o1);\\n            }\\n        });\\n        for(Map.Entry<Character,Integer> entry : map.entrySet()){\\n            maxHeap.offer(entry.getKey());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(!maxHeap.isEmpty()){\\n            char curr = maxHeap.poll();\\n            for(int i = 0;i<repeatLimit;i++){\\n                sb.append(curr);\\n                int num = map.get(curr);\\n                num--;\\n                map.put(curr,num);\\n                if(num == 0){\\n                    map.remove(curr);\\n                    break;\\n                }\\n            }\\n            if(map.containsKey(curr) && map.get(curr) > 0 && !maxHeap.isEmpty()){\\n                char curr2 = maxHeap.poll();\\n                sb.append(curr2);\\n                int num = map.get(curr2);\\n                num--;\\n                map.put(curr2,num);\\n                if(num != 0){\\n                    maxHeap.offer(curr2);\\n                }\\n                maxHeap.offer(curr);\\n            }\\n        }\\n        return sb.toString();\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n Map<Character,Integer> map = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        //Input: s = \"cczazcc\", repeatLimit = 3\\n        //Output: \"zzcccac\"\\n\\n        PriorityQueue< Character> maxHeap = new PriorityQueue<>(new Comparator<Character>() {\\n            @Override\\n            public int compare(Character o1, Character o2) {\\n                return o2.compareTo(o1);\\n            }\\n        });\\n        for(Map.Entry<Character,Integer> entry : map.entrySet()){\\n            maxHeap.offer(entry.getKey());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(!maxHeap.isEmpty()){\\n            char curr = maxHeap.poll();\\n            for(int i = 0;i<repeatLimit;i++){\\n                sb.append(curr);\\n                int num = map.get(curr);\\n                num--;\\n                map.put(curr,num);\\n                if(num == 0){\\n                    map.remove(curr);\\n                    break;\\n                }\\n            }\\n            if(map.containsKey(curr) && map.get(curr) > 0 && !maxHeap.isEmpty()){\\n                char curr2 = maxHeap.poll();\\n                sb.append(curr2);\\n                int num = map.get(curr2);\\n                num--;\\n                map.put(curr2,num);\\n                if(num != 0){\\n                    maxHeap.offer(curr2);\\n                }\\n                maxHeap.offer(curr);\\n            }\\n        }\\n        return sb.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797768,
                "title": "o-n-linear-time-complexity-without-using-any-priorityqueue",
                "content": "Time complexity O(n)\\n**ALGO**\\n1) Make the frequency table from \\'a\\' to \\'z\\'\\n2) start iteration from last (i.e ind=25)\\n3) At each iteration check condition\\n->      freq[ind]>0\\n->      check if reserved char is null or not\\n4) if reserved is null means there is no higher character which is not fully consumed till now, so append curr char by min( repeatLimit, freq[ind])  times, if  some occurances left , then mark it as reserved and store remaining freq in reserved_cnt and decrement the index.\\n5) if reserved is not null means we have to process  reserved char, \\n->first append curr char \\n->decrement it\\'s freq count\\n->and try to consume reserved char, as per step 4)\\n\\nBelow is the implementation of Above Algorithm\\n\\n```\\nclass Solution {\\n\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        int freq[] = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            freq[s.charAt(i) - \\'a\\']++;\\n\\n        StringBuilder str = new StringBuilder();\\n        int ind = 25;\\n        Character reserved = null;\\n        Integer reserved_cnt = null;\\n\\n        while (ind >= 0) {\\n            if (freq[ind] == 0) {\\n                ind--;\\n                continue;\\n            }\\n            char c = (char) (\\'a\\' + ind);\\n            if (reserved == null) {\\n                int len = Math.min(repeatLimit, freq[ind]);\\n\\n                for (int k = 0; k < len; k++)\\n                    str.append(c);\\n                if (freq[ind] - len > 0) {\\n                    reserved = c;\\n                    reserved_cnt = freq[ind] - len;\\n                }\\n                ind--;\\n\\n            } else {\\n                str.append(c);\\n                freq[ind]--;\\n                int len = Math.min(repeatLimit, reserved_cnt);\\n\\n                for (int k = 0; k < len; k++)\\n                    str.append(reserved);\\n                if (reserved_cnt - len > 0) {\\n                    reserved_cnt = reserved_cnt - len;\\n                } else {\\n                    reserved = null;\\n                    reserved_cnt = null;\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String repeatLimitedString(String s, int repeatLimit) {\\n\\n        int freq[] = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            freq[s.charAt(i) - \\'a\\']++;\\n\\n        StringBuilder str = new StringBuilder();\\n        int ind = 25;\\n        Character reserved = null;\\n        Integer reserved_cnt = null;\\n\\n        while (ind >= 0) {\\n            if (freq[ind] == 0) {\\n                ind--;\\n                continue;\\n            }\\n            char c = (char) (\\'a\\' + ind);\\n            if (reserved == null) {\\n                int len = Math.min(repeatLimit, freq[ind]);\\n\\n                for (int k = 0; k < len; k++)\\n                    str.append(c);\\n                if (freq[ind] - len > 0) {\\n                    reserved = c;\\n                    reserved_cnt = freq[ind] - len;\\n                }\\n                ind--;\\n\\n            } else {\\n                str.append(c);\\n                freq[ind]--;\\n                int len = Math.min(repeatLimit, reserved_cnt);\\n\\n                for (int k = 0; k < len; k++)\\n                    str.append(reserved);\\n                if (reserved_cnt - len > 0) {\\n                    reserved_cnt = reserved_cnt - len;\\n                } else {\\n                    reserved = null;\\n                    reserved_cnt = null;\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769181,
                "title": "sliding-window-python-solution",
                "content": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        counter = dict()\\n        ref = dict()\\n        for i in range(len(s)):\\n            if s[i] in counter:\\n                counter[s[i]] +=1\\n            else:\\n                counter[s[i]] = 1\\n\\n            ref[ord(s[i])] = s[i]\\n\\n        keys = list(counter.keys())\\n        values = list(counter.values())\\n\\n        double = []\\n        for i in range(len(keys)):\\n            double.append([ord(keys[i]),values[i]])\\n\\n        double = sorted(double,reverse = True)\\n        res = \\'\\'\\n        left, right = 0,1\\n        times = 0\\n\\n        while left < len(double):\\n            if left >= right:\\n                right += 1\\n                continue\\n            if double[left][1] == 0:\\n                left += 1\\n                times = 0\\n                continue\\n            if times >= repeatLimit:\\n                if right >= len(double): break\\n                if double[right][1] == 0:\\n                    right += 1\\n                    continue\\n                res += ref[double[right][0]]\\n                double[right][1] -= 1\\n                times = 0\\n\\n\\n            res += ref[double[left][0]]\\n            double[left][1] -= 1\\n            times += 1\\n\\n        return res\\n\\n    \\n\\n    \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        \\n        counter = dict()\\n        ref = dict()\\n        for i in range(len(s)):\\n            if s[i] in counter:\\n                counter[s[i]] +=1\\n            else:\\n                counter[s[i]] = 1\\n\\n            ref[ord(s[i])] = s[i]\\n\\n        keys = list(counter.keys())\\n        values = list(counter.values())\\n\\n        double = []\\n        for i in range(len(keys)):\\n            double.append([ord(keys[i]),values[i]])\\n\\n        double = sorted(double,reverse = True)\\n        res = \\'\\'\\n        left, right = 0,1\\n        times = 0\\n\\n        while left < len(double):\\n            if left >= right:\\n                right += 1\\n                continue\\n            if double[left][1] == 0:\\n                left += 1\\n                times = 0\\n                continue\\n            if times >= repeatLimit:\\n                if right >= len(double): break\\n                if double[right][1] == 0:\\n                    right += 1\\n                    continue\\n                res += ref[double[right][0]]\\n                double[right][1] -= 1\\n                times = 0\\n\\n\\n            res += ref[double[left][0]]\\n            double[left][1] -= 1\\n            times += 1\\n\\n        return res\\n\\n    \\n\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735882,
                "title": "step-by-step-explanation-code",
                "content": "**explnation:**\\n\\n- count characters\\n- create a max heap with (char, count)\\n\\t- the char will be the comparator, as we need \"z\" to pop earlier than \"a\"\\n- create a \"final\" string builder for you final result\\n- loop while the heap is not empty\\n\\t-  get the max item\\n\\t-  check if it eqauls the final last added item\\n\\t\\t-  if not:\\n\\t\\t\\t-  add the current char up to the repeat limit or the count it has (min between them)\\n\\t\\t\\t-  subsctract the added count from the char count, if its bigger than 0\\n\\t\\t\\t\\t-  add the char back to the heap, with the reduced count\\n\\t\\t-  if the match:\\n\\t\\t\\t-  check if heap is empty, if so break, as we cant add more chars to final\\n\\t\\t\\t-  if not empty, pop the last item again\\n\\t\\t\\t\\t-  now add a a single occurance of this char, as we want to add more of the initial char, because its lexicographically bigger\\n\\t\\t\\t\\t-  if the sec char count reduced by one is not zero, push it back to the heap\\n\\t\\t\\t\\t-  push back the initial char to the heap without changing its count\\n\\n[link to my repo](https://github.com/tzookb/programming-challenges/tree/master/exercises/leetcode/construct-string-with-repeat-limit)\\n\\n**code:**\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\nfrom typing import Counter\\n\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = Counter(s)\\n        items = list(zip([-ord(k) for k in cnt.keys()], cnt.values()))\\n        heapify(items)\\n        final = [None]\\n\\n        while items:\\n            neg_asc_code, count = heappop(items)\\n            c = chr(-neg_asc_code)\\n\\n            if c == final[-1]:\\n                if not items:\\n                    break\\n\\n                sec_neg_asc_code, sec_count = heappop(items)\\n                sec_c = chr(-sec_neg_asc_code)\\n                final.append(sec_c)\\n\\n                heappush(items, (-ord(c), count))\\n                if sec_count > 1:\\n                    heappush(items, (-ord(sec_c), sec_count - 1))\\n            else:\\n                add_size = min(repeatLimit, count)\\n                final += [c] * add_size\\n                if count - add_size > 0:\\n                    heappush(items, (-ord(c), count - add_size))\\n\\n        return \"\".join(final[1:])\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\nfrom typing import Counter\\n\\nclass Solution:\\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\\n        cnt = Counter(s)\\n        items = list(zip([-ord(k) for k in cnt.keys()], cnt.values()))\\n        heapify(items)\\n        final = [None]\\n\\n        while items:\\n            neg_asc_code, count = heappop(items)\\n            c = chr(-neg_asc_code)\\n\\n            if c == final[-1]:\\n                if not items:\\n                    break\\n\\n                sec_neg_asc_code, sec_count = heappop(items)\\n                sec_c = chr(-sec_neg_asc_code)\\n                final.append(sec_c)\\n\\n                heappush(items, (-ord(c), count))\\n                if sec_count > 1:\\n                    heappush(items, (-ord(sec_c), sec_count - 1))\\n            else:\\n                add_size = min(repeatLimit, count)\\n                final += [c] * add_size\\n                if count - add_size > 0:\\n                    heappush(items, (-ord(c), count - add_size))\\n\\n        return \"\".join(final[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708414,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    //create variable to store letters and counts (object)\\n    var letterCounts = {};\\n    //create an array of one of each letter, later to be sorted\\n    var letters = [];\\n    //iterate through s and add each letter to the object and array\\n    for (let i = 0; i < s.length; i++) {\\n        if (!letterCounts[s[i]]) {\\n            letterCounts[s[i]] = 1;\\n            letters.push(s[i]);\\n        } else {\\n            letterCounts[s[i]] += 1;\\n        }\\n    }\\n    //sort the array in order backwards of alphabet\\n    letters.sort((a, b) => {\\n        return (b.charCodeAt(0) - a.charCodeAt(0))\\n    })\\n    //create new string variable and counter\\n    var newString = \\'\\';\\n    var counter = 0;\\n    //begin adding letters to new string in order of the array\\n    for (let i = 0; i < letters.length; i++) {\\n        while (letterCounts[letters[i]] > 0) {\\n            if (counter < repeatLimit) {\\n                counter++;\\n                newString += letters[i];\\n                letterCounts[letters[i]] -= 1;\\n            } else {//when we hit repeatLimit, move to the next letter, use one, then go back to finish\\n                if (letters[i + 1]) {\\n                    newString += letters[i + 1];\\n                    letterCounts[letters[i + 1]] -= 1;\\n                    counter = 0;\\n                    if (letterCounts[letters[i + 1]] === 0) {\\n                        letters.splice(i + 1, 1);\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        counter = 0;\\n    }\\n    \\n    //return new string\\n    return newString;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} repeatLimit\\n * @return {string}\\n */\\nvar repeatLimitedString = function(s, repeatLimit) {\\n    //create variable to store letters and counts (object)\\n    var letterCounts = {};\\n    //create an array of one of each letter, later to be sorted\\n    var letters = [];\\n    //iterate through s and add each letter to the object and array\\n    for (let i = 0; i < s.length; i++) {\\n        if (!letterCounts[s[i]]) {\\n            letterCounts[s[i]] = 1;\\n            letters.push(s[i]);\\n        } else {\\n            letterCounts[s[i]] += 1;\\n        }\\n    }\\n    //sort the array in order backwards of alphabet\\n    letters.sort((a, b) => {\\n        return (b.charCodeAt(0) - a.charCodeAt(0))\\n    })\\n    //create new string variable and counter\\n    var newString = \\'\\';\\n    var counter = 0;\\n    //begin adding letters to new string in order of the array\\n    for (let i = 0; i < letters.length; i++) {\\n        while (letterCounts[letters[i]] > 0) {\\n            if (counter < repeatLimit) {\\n                counter++;\\n                newString += letters[i];\\n                letterCounts[letters[i]] -= 1;\\n            } else {//when we hit repeatLimit, move to the next letter, use one, then go back to finish\\n                if (letters[i + 1]) {\\n                    newString += letters[i + 1];\\n                    letterCounts[letters[i + 1]] -= 1;\\n                    counter = 0;\\n                    if (letterCounts[letters[i + 1]] === 0) {\\n                        letters.splice(i + 1, 1);\\n                    }\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        counter = 0;\\n    }\\n    \\n    //return new string\\n    return newString;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576422,
                "content": [
                    {
                        "username": "ni3verma",
                        "content": "For the first example : \"cczazcc\", can someone help me how to get the result ?\\nthis is what I understood:\\nfrom the above string, see distinct characters and look at their order in Alphabets.\\na<c<z\\n\\nnow for first character : c, as z>c so we have z in place of it\\nsame happens for second character, result as of now is zz\\n\\nnow comes third character : z... as it is already largest so we go one step back... which is c (a<c<z), so result becomes zzc\\n\\nnow comes a.... here in the result it is chossing c... why didnt we chose z? isnt zzcz > zzcc ? This is where I am confused.\\n\\nAccording to me answer should be : **zzczczz**, but real answer is **zzcccac**."
                    },
                    {
                        "username": "amroabuzer",
                        "content": "It\\'s because you\\'re only allowed to use the characters from the input string: your answer has 5 z\\'s but you\\'re only allowed to use 2"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "You cannot use the letters you\\'re given more frequently than they appear. So in this example, the string you\\'re given only has two \\'z\\'s, so the string you return can have a maximum of 2 \\'z\\'s."
                    },
                    {
                        "username": "Ronak_Ramuka",
                        "content": "in second case why the answer is not abababa as it is larger than bbabaa therefore lexicographically larger??"
                    }
                ]
            },
            {
                "id": 2041423,
                "content": [
                    {
                        "username": "ni3verma",
                        "content": "For the first example : \"cczazcc\", can someone help me how to get the result ?\\nthis is what I understood:\\nfrom the above string, see distinct characters and look at their order in Alphabets.\\na<c<z\\n\\nnow for first character : c, as z>c so we have z in place of it\\nsame happens for second character, result as of now is zz\\n\\nnow comes third character : z... as it is already largest so we go one step back... which is c (a<c<z), so result becomes zzc\\n\\nnow comes a.... here in the result it is chossing c... why didnt we chose z? isnt zzcz > zzcc ? This is where I am confused.\\n\\nAccording to me answer should be : **zzczczz**, but real answer is **zzcccac**."
                    },
                    {
                        "username": "amroabuzer",
                        "content": "It\\'s because you\\'re only allowed to use the characters from the input string: your answer has 5 z\\'s but you\\'re only allowed to use 2"
                    },
                    {
                        "username": "prcsnlvr",
                        "content": "You cannot use the letters you\\'re given more frequently than they appear. So in this example, the string you\\'re given only has two \\'z\\'s, so the string you return can have a maximum of 2 \\'z\\'s."
                    },
                    {
                        "username": "Ronak_Ramuka",
                        "content": "in second case why the answer is not abababa as it is larger than bbabaa therefore lexicographically larger??"
                    }
                ]
            }
        ]
    }
]