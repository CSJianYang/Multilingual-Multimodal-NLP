[
    {
        "title": "Jump Game",
        "question_content": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 20917,
                "title": "linear-and-simple-solution-in-c",
                "content": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "solutionTags": [],
                "code": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20900,
                "title": "simplest-o-n-solution-with-constant-space",
                "content": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "solutionTags": [],
                "code": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20907,
                "title": "1-6-lines-o-n-time-o-1-space",
                "content": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 596454,
                "title": "python-simple-solution-with-thinking-process-runtime-o-n",
                "content": "When I first see this problem, two things pop up in my mind:\\n* Maybe I can do some sort of DFS, BFS (with backtracking?) but there will be a lot of redundancies\\n* Then this begs for Dynamic Programming!\\n\\nBut my gut feeling was saying that this problem has to have a simpler approach.\\n\\nSo, here is my thinking process:\\n* Base case: last index can trivially reach to last index.\\n* **Q1**: How can I reach to the last index (I will call it `last_position`) from a preceding index?\\n\\t* If I have a preceding index `idx` in `nums` which has jump count `jump` which satisfies `idx+jump >= last_position`, I know that this `idx` is good enough to be treated as the last index because all I need to do now is to get to that `idx`. I am going to treat this new `idx` as a new `last_position`.\\n* I ask **Q1** again.\\n\\nSo now, here are two important things:\\n* If we have indices which are like **sinkholes**, those with 0 as jump and every other preceding index can only jump to that sinkhole, our `last_position` will not be updated anymore because `idx+jump >= last_position` will not be satisfied at that sinkhole and every other preceding index cannot satisfy the `idx+jump >= last_position` condition since their jumps are not big enough.\\nE.g. ```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\\n* If we have **barriers**, those indices with 0 as jump, but the preceding indices contain jumps which can go beyond those barriers, `idx+jump >= last_position` will be satisfied and `last_position` will be updated.\\nE.g. ```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\\n\\nFinally ask this question when we have finished looping\\n* Is the last position index of 0? (i.e, have we reached to the beginning while doing the process of jumping and updating the `last_position`?)\\n* If we have sinkholes in `nums`, our `last_position` will not be 0. Thus, `False` will be retured.\\n\\nThat\\'s all!\\n\\nThis is what I have in mind when I was thinking of this approach :D\\n![image](https://assets.leetcode.com/users/arkaung/image_1587809403.png)\\n\\n## Python\\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```\\n\\nBut in the interview, this approach may not be apparent or maybe the interviewer is looking for something. \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\n```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20932,
                "title": "6-line-java-solution-in-o-n",
                "content": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 520481,
                "title": "c-easy-o-n-solution-with-detailed-explanation",
                "content": "The idea is to iterate backwards, i.e., right to left, and keep track of the minimum jump length required, i.e., `minjump`, at a position. \\n\\nFor the last index, the minimum jump length required would be zero because you have reached the last index. For each index or position that we go backwards(since we are iterating right to left), the minimum jump length required increases by 1. \\n\\nWe start from the second last index and increase `minjump` by 1 for each position. If at a particular index, the maximum jump length at that position is greater than or equal to the minimum jump length required, i.e., `nums[i]>=minjump`, then we can say that we can reach the last index from that position. Thus, we reduce the minimum jump length required to zero if the condition is satisfied so that for the next position when iterating backwards the minimum jump length required is 1 after incrementation. \\n\\nOur objective now is to check if the minimum jump length required, i.e., value of `minjump`, after iterating through the entire array is zero which would indicate that the last index can be reached from the first index of the array. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```\\n\\n#### Complexity Analysis\\n\\n* Time complexity : O(n).   \\nWe are iterating through the *nums* array only once. The length of *nums* array is *n*. Thus, time complexity = *O(n)*.\\n\\n* Space complexity : O(1). \\nWe are not using any extra memory. Thus, space complexity = *O(1).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375320,
                "title": "interview-scenario-recursion-memoization-dp-greedy",
                "content": "Suppose you get this question during an interview, let\\'s do a walk-through.\\nInterviewer : Quotes the question...\\n\\n***let\\'s get started***\\nAsk clarifying questions,  examples, and scenarios. The more you ask, interviewer gets more and more intrigued, for good.\\n\\numm, at every index starting from the 0th, you can make jumps ranging from 1 till nums[index]. Greedily making a choice of jump won\\'t work in subtle cases, for example, if from 0th index I take a jump to the index with maximum jump value, it might lead me to a postion with value of jumps equal to 0, and I\\'ll be stuck.\\nAs I\\'ve got a lot of options to make a jump, I\\'d love to the explore the recurring idea behind this question(i.e. I can make a jump ranging from index(idx) to postions ranging from : (idx + 1 *till* idx + nums[idx]), and the same thing can be done from all these indexes. \\nIf by following any route I reach last index, I\\'ll return true. Otherwise if none of the index can lead me to last index, I\\'ll return a false. \\n\\nWhile solving the problem, think out loud and let the interviewer know what you are thinking.\\nrecursion approach : \\ntc : O(N^N) ~ exponential\\nsc : O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\\n\\nThere\\'s no chance that this question will not give a T.L.E,  it\\'s exponential,  it\\'ll have many overlapping subproblems, and hence I can memoize it using a 1d dp array.\\n\\nmemoized : \\ntc : O(N* N) -> for each  index, I can have at max N jumps, hence O(N* N).\\nsc : O(N) + O(N) -> stack space plus dp array size.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\\n\\n*I\\'m not a huge fan of that extra stack space, let me just convert this whole soution into a dp(tabulation)  solution, so that extra O(N) space can be chucked  out.*\\n\\ntc : O(N* N)\\nsc : O(N) -> dp array size\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\\n\\n\\n**Bonus**, I can also think of a solution that kinda resembles Kadane\\'s algorithm. For every index, I\\'m checking the max reach  I can have till that element, if that reach is less than the value of my index, that means I can never reach this particular index and my  answer should be false. \\n\\ntc : O(N)\\nsc : O(1)\\n\\nThe comments that I\\'ve made show my entire thought process that I\\'d be delivering to the interviewer.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```\\n\\n\\nThank you, if you enjoyed this approach of writing soutions do give me an upvote, and please feel free to add suggestions. Viva - La - Vida.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20923,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758301,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150021,
                "title": "c-solutions-greedy-recursive-dp",
                "content": "1. Linear\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\n2. Recursive\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\\n3. Recursive+Memoization\\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\\n4. DP (Updated)\\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21121,
                "title": "c-elegant-solution-o-n-time",
                "content": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1443541,
                "title": "python-3-approaches-top-down-dp-bottom-up-dp-max-pos-so-far-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP (Sometime TLE)**\\n- Let `dp(i)` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp(0)` is our result.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top down DP**\\n- Let `dp[i]` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp[0]` is our result.\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Max Pos So Far**\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336291,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\\n\\n# **C Language:**\\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273641,
                "title": "javascript-simple-o-n-greedy-solution",
                "content": "**Explaination**\\n\\nIt\\'s a typical problem that can be solved by ***Greedy*** algorithm, which is an algorithm **makes the optimal choice at each step** as going forward.\\n\\nYou will need to iterate over the `nums` starting from 0 to the last, and **keep updating** `max` to record how far you can jump so far.\\n` max = Math.max(max, idx + nums[idx]);`\\nAnd check if the `max` is greater or equal to the `target` at each step.\\n\\nThat\\'s pretty much it!\\n\\nBut we still can add a bit of **optimization** by checking an early exit condition when there is no way to move forward. \\nIf a current value is 0, you cannot jump to the next. But there might be a way to jump farther from the previous step. How can we check that? `max` again!\\n`max > idx` then we can conclude we can go further from the previous step. Otherwise, it\\'s impossible.\\n\\nSo the early exit condition is \\n`if (max <= idx && nums[idx] === 0) { return false; }`\\n\\n\\n**Code**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452807,
                "title": "python-dp-o-n-with-explanation",
                "content": "- DP definition: The farthest index we can reach given allowed steps from 0 to `i`\\n- DP decision & relationship: It\\'s either the `dp[i - 1]` or `i + nums[i]` whichever one is larger\\n- DP condition:\\n\\t- If at any moment, dp[i] = 0, that means there is no way it can reach any further, return `False` immediately.\\n\\t- If at any moment, dp[i] >= last index, that means it can already reach the end of the array given the steps allowed from 0 to `i`, return `True` immediately.\\n\\n\\n```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20944,
                "title": "java-98-percentile-solution",
                "content": "The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. \\n\\n    public class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 2951773,
                "title": "java-easy-time-o-n-space-o-1",
                "content": "# Code\\n#100% faster.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\\n#Another Approach\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21064,
                "title": "5-line-python-solution",
                "content": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "codeTag": "Python3"
            },
            {
                "id": 20974,
                "title": "3ms-simple-java-solution",
                "content": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3592600,
                "title": "most-easy-c-code",
                "content": "# Approach \\n For each element, it checks if the current index i is greater than maxReach. If it is, then it means that it is not possible to reach the current index from any of the previous indices, so the function returns false. Otherwise, it updates maxReach to be the maximum of its current value and i + nums[i], which represents the maximum index that can be reached from the current index.\\n\\nAfter iterating over all elements, if no false value has been returned, then it means that it is possible to reach the last index, so the function returns true.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194131,
                "title": "java-simple-and-easy-greedy-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500445,
                "title": "don-t-make-question-difficult-using-dp-t-c-o-n-s-c-o-1-c-greedy-code-with-explanation",
                "content": "easy to approach:\\n1. if any time your nums value becomes zero then it will not be able to take next step then your expected ans should be wrong .\\n2. you don\\'t have to check for thn exact last index if you cross thn last index thn obiously you can end at last index .\\n\\nIt does\\'t need dynamic programming  always try to approach which is easy to understand.\\n\\n**T.C->O(N)**\\n**S.C.->0(1)**\\n\\n**DO UP VOTE PLESE IF YOU LIKED THE CONCEPT **\\n\\nHAPPY CODING \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500227,
                "title": "python-2-lines-greedy-o-n-solution-explained",
                "content": "There are two algorithms: one is dp with complexity O(n^2), where dp(i) is the minimum number of steps to reach position i and on each step we need to check potentially O(n) jumps.\\n\\nHowever there is a solution with better complexity, using greedy idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then we check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\nWe can look at our process like this: what is the biggest index we can reach after say i jumps. Then if we have new index to traverse we update our range. For example for nums = [2, 3, 0, 1, 4] we have t = [2, 4, 4, 4, 8] and after 1 jump we can reach index 2 and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything. In this problem we do not need number of steps, but this idea can be used in problem **0045 Jump game II**.\\n\\n#### Complexity\\nTime and space complexity is O(n).\\n\\n#### Code\\n```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774588,
                "title": "python-easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly. If we reach the maxium reachable index we get out of loop.\\n3. At last, if maxium reachable index is greater than or equal to last index of the array, means we can reach the last element else return false.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591224,
                "title": "recursive-memoizaton-tabulation-o-n-solution-with-constant-space",
                "content": "# Recursive\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\\n\\n# Memoization\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\\n\\n# Tabulation\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435741,
                "title": "simple-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I was confused with this question since it is considered to be a DP problem, but I found that the DP solution was not very intuitive. For me it was much simpler and faster to solve this using greedy.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each position of the array, we are given a choice of either taking the steps from that point, or continuing with the steps we took previously. \\n\\nAt the start, we know we have nums[0] steps, and hence our steps left should = nums[0].\\n\\nAs we traverse through the array, we update our steps left to be the maximum of (nums[index], stepsleft - 1), ensuring that we always have the most possible steps left. If we reach the last index, we know that we can reach the end and return true.\\n\\nIf we ever run out of steps, then we know we can\\'t reach the last index and thus stop the loop and return false.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271858,
                "title": "python-greedy",
                "content": "We can use a pointer ```j``` to indicate the farthest index we can reach. \\nAs any index within ```j``` can be chosen to jump from, we can use a heuristic that for each index ```i``` whose jump length is ```x```, ```j = max(j, i+x)```. If ```i+x > j```, we just jump from ```i``` to increase our jump range from ```j``` to ```i+x```.\\nBut we should ensure that ```i``` is reachable. So if ```j<i```, it\\'s not reachable even with our best effort. We return ```False```.\\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```j```\n```j```\n```i```\n```x```\n```j = max(j, i+x)```\n```i+x > j```\n```i```\n```j```\n```i+x```\n```i```\n```j<i```\n```False```\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 21193,
                "title": "how-about-my-solution",
                "content": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158292,
                "title": "c-easiest-beginner-friendly-sol-greedy-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a variable reach to 0, which represents the farthest index that can be reached so far.\\n2. Loop through the array nums and for each index i, do the following:\\n    - a. If i is greater than reach or reach is greater than or equal to nums.length - 1, break the loop as it means reaching the last index is not possible.\\n    - b. Update the value of reach as the maximum of reach and i + nums[i].\\n1. Return reach >= nums.length - 1, which means that the last index can be reached or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the array nums. This is because we are looping through the entire nums array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are using a single integer variable reach.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755056,
                "title": "o-n-greedy-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21146,
                "title": "c-smiple-and-easy-to-understand-o-n-time-4-lines",
                "content": "    class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 21185,
                "title": "another-way-of-looking-at-the-problem",
                "content": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "solutionTags": [],
                "code": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2060972,
                "title": "c-easy-explanation-dp-tabulation-bottoms-up",
                "content": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```\\nIf you like the above explanation do upvote \\uD83D\\uDC4Dand if there is any scope of improvement or query do comment\\uD83D\\uDE01.\\n\\n**Thank You For Reading!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912523,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321112,
                "title": "java-solution-1ms-runtime-greedy-approach",
                "content": "**Problem Link :** https://leetcode.com/problems/jump-game/?envType=study-plan&id=algorithm-ii\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm traverse from the end upto 0. Initially we set the last index as our `goal` then if we can reach the goal from  `i`th index , then we set our goal index to `i`th index.\\nEventually if goal reaches to `0` then we know we can reach the last index from starting point (`0`th index).\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```\\n\\nThank You\\n\\nPlease Do Upvote!!!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285632,
                "title": "golang-o-n-o-1-solution-with-images",
                "content": "The idea of this solution is pretty simple once you understand it. \\n\\nThe idea of this solution is:\\n\\n* We get the maximum index we can go up to by getting the maximum of `i + nums[i]` and `max`.\\n* Then, if `i` has surpassed the maximum index, we can return `false`.\\n* Otherwise return `true`.\\n\\nIf you don\\'t understand why this works, look at the following example:\\n\\ninput: `[3, 2, 1, 0, 4]`\\nexpected output: `false`\\n\\n![image](https://assets.leetcode.com/users/images/2aa23e13-7f07-44ef-bd8f-2b50ed3305b2_1624199132.427165.jpeg)\\n\\n\\n**The Code:**\\n\\n``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656772,
                "title": "solution-swift-jump-game-test-cases",
                "content": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b>  Executed 2 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300303,
                "title": "efficient-logic-in-c",
                "content": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 349913,
                "title": "simple-python-solution",
                "content": "Solution 1: dynamic programing from the end to the start\\nTime complexity: O(n^2) (Time Limit Exceeded, 74 / 75 test cases passed)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n\\nSolution 2: time complexity O(n)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133302,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20963,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion**https://discuss.leetcode.com/topic/80174/python-solution-with-detailed-explanation\\n\\n**Jump Game** https://leetcode.com/problems/jump-game/?tab=Description\\n\\n**Memoization Solution**\\n* Draw the recursion tree. Notice we can have stack overflow for an exremely large input. MLE\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\\n\\n**Dynamic Programming Solution**\\n* Complexity is order n^2. We have an issue here - TLE.\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n**Linear - Ladders and Stairs Solution**\\n* Linear complexity\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\\n\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953864,
                "title": "easy-explanation-which-beats-98-c-users-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust assume we are standing on the last index\\nAim: to somehow reach 0th index as **if we can reach last to zero we can reach zero to last index also**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.just maintain a (last_pos) variable that **keeps a track of your last position** you were able to travell from last index.\\n\\n2.if current position(i) + value of current position(nums[i]) is grater then our last position(last_pos) that means we can reach to our last position(last_pos) from our current(i) position\\n\\n3.And now if ***i + nums[i] >= curr_pos our curr_pos becomes i*** this means we can travell till i from the last index or we can successfully travell to last index from that position(i).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are iterating every element only once time complexity is O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe have just used 2 extra variables n and last_pos that is constant which makes tc = O(1)\\n\\n# hope this brings a smile on your face.......\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887273,
                "title": "beats-98-mind-blowing-intuition-explained",
                "content": "# Intuition\\nChange the destination point backwards. \\n# Approach\\nInitially, first destination point is last index. Change destination point to index of first previous element that can jump to current goal. That way we can, tecnically, consider this new goal as destination point cause once we can reach to it we can automatically get to original goal as well. In the end, if last updated goal happens to be very first element or zero index then it means that we can get to the original last index destination point from zero index.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987629,
                "title": "c-solution-very-simple-to-understand-o-n-time-o-1-space",
                "content": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493351,
                "title": "java-memoization-solution",
                "content": "I initially wrote the solution using a hashmap as memoization object but was getting TLE. So changed it to dp array.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21080,
                "title": "greedy-14ms-o-n-o-1-easy-c-solution-easy-understanding",
                "content": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2225627,
                "title": "python-3-brute-force-dp-greedy",
                "content": "**Brute Force Approach (TLE)**\\n\\\\\\nThe brute-force approach is to visit all possible paths (which can be achieved by using the DFS algorithm). The idea is to create a recursive function that accepts one parameter: `i`. It keeps track of the current index we\\'re in.\\n\\\\\\nWe\\'ll need to handle the following scenarios explicitly:\\n\\u2022 When `nums[i] == 0`\\n\\u2022\\xA0When `i == N - 1`\\n\\\\\\nIf `nums[i] == 0`, this implies we can no longer move forward b/c we have 0 jump - hence we\\'ll return false. If `i == N - 1`, this implies we\\'ve found a path that reaches the final element - hence we\\'ll return true.\\n\\nIt seems like there are `nums[i]` choices we can make per recursive function. We can jump from `i` to `i + 1` ~ `i + nums[i] `inclusive. We can use a for-loop to attempt all the possible jumps. *FYI: Its lowerbound is `i + 1` & its upperbound is `min(i + nums[i], N - 1) + 1`. This allows us to reduce the total # of iterations.*\\n\\\\\\nFor each iteration:\\n1) we\\'ll make a recursive call: `dfs(j)` (where `j` is an index of the for-loop)\\n2) If `dfs(j) == True` , then it implies the current element leads to the final element. Hence, we\\'ll immediately return true.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^N) b/c we must jump at most N times per recursive function. \\nThe space complexity is O(N) b/c we must store a reference of N recursive-calls in a call-stack.\\n\\n---\\n\\\\\\n**Top-down DP (Memoization) (TLE)**\\n\\\\\\nThe above solution seems to be inefficient b/c we\\'re visiting the same sub-paths on multiple occasions. To remedy this issue, we can store a precomputed value of the visited sub-paths into a dictionary or a list. *FYI: I\\'ll be using a dictionary for this example.*\\n\\nThe idea is to add an additional parameter, that stores a reference of the dictionary, in a recursive function. After the existing base cases, we\\'ll add a new conditional statement that checks whether the key: `i` already exists in the dictionary. If that\\'s the case, then it implies we\\'ve already visited the current path. Hence, we\\'ll return its precomputed value as an answer.\\n\\nOtherwise, we\\'ll compute the current path\\'s answer and store it in the dictionary.\\n\\\\\\n*Implementation w/ a dictionary*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\\n\\\\\\n*implementation w/ a list*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\\n\\\\\\n*implementation w/ the lru_cache decorator*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we still need to jump at most N times per recursive function. However, we won\\'t need to visit the same path again b/c we\\'re storing the precomputed value (of the paths) in a dictionary (or a list). \\n\\nThe space complexity is O(N) b/c we must store N key-value pairs into the dictionary. *FYI: If we\\'re using a list, then we must allocate N additional space to initialize an N-sized list.*\\n\\n---\\n\\n\\\\\\n**Bottom-up DP (Iterative DP) (occasionally passes but TLE for the most part)**\\n\\\\\\nWe can convert the top-down DP into its iterative alternative. First, we\\'ll initialize an N-sized list and we\\'ll set the final element as true. Next, we\\'ll use a nested for-loop to visit all the paths - where the outer-loop iterates N times and an inner-loop iterates at most N times.\\n\\nBefore we execute the inner-loop, we\\'ll check whether `nums[i] == 0`. If that\\'s the case, then it implies we have 0 jump - which prevents us from moving any further. Hence, we\\'ll immediately skip to the next iteration.\\n\\nFor each iteration of the inner-loop, we\\'ll check whether `dp[j]` (where` j` is an index of the inner-loop) equals true. If that\\'s the case, then it implies the path reaches to the last element. Hence, we\\'ll assign true to `dp[i]` and break the inner-loop.\\n\\nAfter we finish executing the nested for-loop, we\\'ll return `dp[0] `as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we must execute a nested for-loop where an outer-loop iterates N times. For each iteration of the outer-loop, we must execute an inner-loop that iterates at most N times.\\n\\nThe space complexity is O(N) b/c we must initialize an N-sized list.\\n\\n---\\n\\\\\\n**Greedy Approach**\\n\\\\\\nIf we look closely at the problem, we don\\'t necessarily have to visit all the paths to verify whether a valid path exists. As long as we can jump to the element t*hat ultimately leads to the final element,* then we should be able to verify whether the valid path exists.\\n\\nThe idea is to iterate through `nums` from right to left, and for each iteration, we\\'ll check whether `i + nums[i]` >= index of the element that leads to the final element (I\\'ll call it `valid_idx` for brevity\\'s sake). If that\\'s true, then it implies the current element leads to the final element. Hence, we\\'ll update `valid_idx` to store `i`. \\n\\nAfter we finish iterating through `nums`, we\\'ll check whether `valid_idx == 0`. If that\\'s true, then it implies the first element leads to the final element. Therefore, we\\'ll return true as an answer. Otherwise, we\\'ll return false as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```\\n\\\\\\nThe time complexity is O(N) b/c we must iterate through `nums` once.\\nThe space complexity is O(1) b/c we\\'re only initializing few variables throughout the implementation.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723975,
                "title": "jump-game-building-to-jump-game-2-c-solutions",
                "content": "(1) Jump Game 1\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n(2) Jump Game 2\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21010,
                "title": "this-can-be-solved-by-using-car-and-fuel-tank-analogy",
                "content": "Lets rephrase the question, \\nWe want to reach the end of the road(end of the array), the numbers in the Array are fuelTanks one the road.\\nFor tarvelling to the next fuelTank(number) we will lose a fuel unit in your current tank.\\n\\nAns:\\nAt each number(fuel tank), we pick up whichever is highest our current fuelTank in the car OR the fuel tank that is in the road\\n\\n```\\npublic class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }\\n        //there is no need for the fuel at the end- this just messes with my code, so making it zero\\n        fuelRoad[fuelRoad.length-1]=0;\\n        //lets initilize the car with the firstfuel tank in the road\\n        int carPosition=1, fuelTank=fuelRoad[0]-1;\\n        while(carPosition<fuelRoad.length && \\n            //there has to be fuel to travel\\n            fuelTank>=0){\\n            //this is just small optimization,checks whether we will have enough fuel to reach the end\\n            if(carPosition+fuelTank >= fuelRoad.length-1){\\n                return true;\\n            }\\n            //check which is bigger the fuel in the road or our tank\\n            if(fuelRoad[carPosition]>fuelTank){\\n                fuelTank=fuelRoad[carPosition];\\n            }\\n            carPosition++;\\n            fuelTank--;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21156,
                "title": "simple-python-solution-o-n-1-55ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def canJump(self, nums):\\n            stepsLeft = nums[0]\\n    \\n            if not stepsLeft and len(nums) > 1:\\n                return False\\n    \\n            for num in nums[1:-1]:\\n                stepsLeft = max(stepsLeft - 1, num)\\n                if not stepsLeft:\\n                    return False\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3144678,
                "title": "c-easy-to-understand-dynamic-programming-tabulation-method-o-n-runtime",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming using Tabulation Method.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) {Extra space for DP array}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952469,
                "title": "brute-dp-o-n-greedy-w-images-explained",
                "content": "# Intuition & Approach [BRUTE]\\nFor Brute:\\nSo this part is pretty simple brute force approach. We recursively try to jump at every location we can starting from the first and see if we ever get at the target position which is `length of nums -1` or `len(nums)-1` as seen in python.\\n\\n\\nHere is a brute force code for the same.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\\nAbove Code Explanation:\\n- Our dfs function is recursive.\\n- It returns `True` if current index, `ind` in code is `greater than or equal to our target_index` because it means we can reach it.\\n- It returns `False` if steps at cur index is 0, which means we cannot go any further.\\n- Lastly, we use dictionary/hashmap named `memo` to cache/memoize the path. Basic `caching/memoization`.\\n\\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n# Approach [Greedy]\\n\\nOkay so here we basically traverse reverse and keep shifting our Goal like so:\\n- if we can reach our current Goal from our current position then, we can shift our goal to current position because we no longer need to check if we can get to previous Goal because if we can get to the current position we can get to goal as well hence we can overall shift the goal itself.\\nWish I could say it better. LOL\\n\\n\\n# Code Explanation:\\nSo we start with Goal as `len(nums)-1`.\\n\\nConsider this pic:\\n - Goal marked with Green BOX.\\n - Indeces writeen with blue.\\n![jump1.PNG](https://assets.leetcode.com/users/images/3950dc19-e9c7-477f-849b-56bef24c6fa4_1672037205.3182197.png)\\n- So here we start with goal at INDEX 5.\\n- We Traverse from index 4 to 0.\\n- At Index 4 we see, Oh we can get to goal INDEX 5 from here so we set our new goal to Index 4.\\n![jump2.PNG](https://assets.leetcode.com/users/images/3323373d-d0c5-43b0-8b34-08959c72f096_1672037320.1121492.png)\\n- Again we check at Index 3, Oh we ca get to goal Index 4 from here, so we set our goal to Index 3.\\n![jump3.PNG](https://assets.leetcode.com/users/images/a4b46cd5-7b0f-4593-bb5f-ab9a5597a0bb_1672037373.798035.png)\\nAnd we keep moving on till the end of our traversal.\\nIf we end with Goal at 0, then we know oh yes we can actually reach the end. If not then NO.\\n\\n\\nConsider Example 2 of Example Testcases and we will see that we cannot reach the Goal and so our Goal does end at 0. Hence False.\\n\\nAlso, to check if we can get to a Goal or not we just check if the maximum number of steps from current position will lead us to position greater than or equal to our goal or not.\\nwritten in PYTHON as:\\n`if nums[ind]+ind >= goal:\\n    goal = ind`\\nBasically just shifting our GOAL if max capacity of cu rindex takes us on or farther than our GOAL.\\n\\n\\n# Code Python and JS\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```\\n\\n# Time complexity:\\nBRUTE:\\n- O(n^2) after memoization O(a^n) before memo if a is avg of all elements in nums\\n\\nGreedy:\\n- O(n)\\n\\n# Space complexity:\\nIDK, O(1) for Greedy cause no extra space used, NOT SURE LOL!!\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833942,
                "title": "python-a-walrus-approved-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** One-liner with walrus operator `:=` used to update state.\\n```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\\n\\n**Python #2.** The same logic, but using imperative style.\\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045294,
                "title": "every-possible-simple-c-solution-additional-python-and-java-solutions-as-well",
                "content": "### Approach 1 : Brute Force\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K^N) where k is the max value in the array\\nSpace Complexity - O(N) - Recursive Stack Space\\n\\n### Approach 2 : Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N + N) - Recursive Stack Space + Memoization table\\n\\n### Approach 3 : Tabulation\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N) - Dp Table\\n\\n### Approach 4 : Greedy\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N) \\nSpace Complexity - O(1)\\n\\n## **Java And Python Solutions**\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732617,
                "title": "very-simple-and-fast-greedy-solution-with-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can found many Recursion with dp and tabulation solutions. But here we will discuss an ***very simple greedy solution that does not require any dynamic programming*** you just need a simple observation.\\n\\n---\\n\\n- Observation\\nfor any index ***i*** in the given array, if i know the nearest index value (*let it be **x***) from where i can reach to my destination then the only thing i need to check now is that\\nCan i reach at index ***x*** from my current position (that is index ***i***)?.\\n->this question can easily answered by checking a condition is ***(i+nums[i]>=x)*** true?\\n{\\nhere ***i+nums[i]*** -> the maximum distance(index value) that you can reach from ***i***th index. \\n}\\n- if the above condition is true -> then we can easily reach to x from our current index i and so on our destination.\\n- if the above condition is false -> then we can\\'t reach on our destination from our current index i.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nn=size of the given vector nums\\nOur destination is ***n-1***th index.\\n- Basic Fact -> we can always reach at ***n-1***th index from ***n-1***th index itself irrespective of value in ***nums[n-1]***\\n\\n- **Steps** :-\\n\\n1) We will maintain a variable (***x***) that stores the value of nearest index from which we can reach at n-1th index and initialize it with ***n-1***.\\n2) We will also maintain a *bool variable* (***ans***) that stores the truth value that can we reach at our destination from the current index? (initialize ans with value 0).\\n2) Now We will start a for loop from ***i=n-1*** to ***i=0*** and for each i we do :\\n    - if we can reach at ***x*** from ***i*** then we assign ***ans=1*** and update value of x as ***x=i***\\n    - else assign ***ans=0***\\n\\n\\n4. Finally return the ans.\\n\\n# Complexity\\n- Time complexity:\\n***O(n)***\\nAs we are Running a for loop from i=n-1 to i=0 So time complexity = O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n***Any Query/Suggestions are welcome***\\n\\n***\\uD83D\\uDC4D Upvote if you like***\\n\\n*for getting this code in other programming language you can comment here i will provide that ASAP.*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703697,
                "title": "c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- It passes **151 test cases** but ***Gives WRONG ANSWER!***\\n- This was the first approach that came to my mind.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- We took a variable temp to store the max jump possible.\\n- If at any point temp became equal to the current index ***i*** that means we can\\u2019t go to next position from here, simply return false.\\n- Any point if temp crosses the size of the given array, then simply return true.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545232,
                "title": "java-easy-to-understand-jump-game",
                "content": "Key for this problem **Think it from last index**, like we want to reach at last we can start from last and if reach at 0 or -ve index that means we find solution\\n\\n\\n```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500036,
                "title": "being-greedy-is-rewarding-sometimes-easy-to-understand-concise",
                "content": "## Approach 1:\\nThese type of problem can be solved using segmented bfs taking maximum element from a range it can go. Here my approach is to go as far as possible and once our index crosses the farthest then we return False as its not possible to reach the end.\\n\\n### Code\\n``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\\n\\n## Approach 2:\\nSimilar to problem 0045 Jump Game II, but here we need to check if we can reach the end. As in problem 0045 we can create cumulative maximum of i + nums[i] and check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\n### Code:\\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\nCerdits : [@Dmitry](https://leetcode.com/DBabichev/) \\n\\n## Approach 3:\\nI found it while searching for other answers and found it interesting \\nIdea:\\nConsider nums[i] to be the amount of fuel in the tank sitting at i that we can switch to. As moving from left to right, we lose 1 unit of fuel per step. At each index, we switch to the new tank if it has more fuel than what we have left. If the amount of fuel goes to zero somewhere in the middle, return False.\\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```\\n\\nCredits :- [Link Of Solution](https://leetcode.com/problems/jump-game/discuss/1500014/Python-O(N)-time-O(1)-space.-Switch-to-the-new-tank-whenever-you-can-gain-fuel.) \\n[Profile](https://leetcode.com/hkwu6013)\\n\\n## Complexity Analysis:\\nTime Complexity For Both is O(N)\\nSpace Complexity For approach 1 is O(1) and for Approach 2 is O(N)\\n\\n## Note:\\nIf You have any other answer in a different approach feel free to comment it down , I will add it and like you profile or page to the answer . **Hope you find it help full . If yes please Upvote it if no , feel free to place it down in the comment section.**",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208231,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541554,
                "title": "dp-and-greedy",
                "content": "### DP\\n**state(i)** as whether we can jump to i.\\n**state(i) is true if any state(j) is true for j can jump to i.**\\nGoal state is **state(nums.length - 1)**.\\n```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump to the furthest place able to reach.\\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153033,
                "title": "3-approaches-in-python-explained-clean",
                "content": "1) DP Recursive \\nResult: Ran out of stack space for this case\\n              [1,1,1,1,1,1,1...................................................................,1,1]\\nIdea is that from any given index say \\'idx\\' we can move to a next index in the range(1,nums[idx]+1) so we try all of them for all idx and check whether we can reach the last index. Since we may arrive at the same index  more than once, we memoize.\\n```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\\n2) BFS\\nResult: Time Limist Exceeded (71/75 test cases passed)\\nIt is tempting to see that this just a search problem in an implicit graph. The nodes being indexes and edges connect one node to the next candidate neighboring (or) \"can jump to\" indexes. So we just perform a BFS carefully by not repeating ourselves, there is no need to construct the graph.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\\n 3) Key observation that it is okay to overshoot in jumping process since we can easily choose to jump less. The only way you do not reach the end is when you do not have sufficient jumping capability or \\'jumpingPower\\' and that\\'s exactly what we check for.\\nResult: Accepted, beats 58%\\n ```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\n```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20894,
                "title": "c-simple-greedy-and-optimized",
                "content": "This one was fun.  I went from an O(N^2) algorithm to O(N) and learned how to be \"greedy\" :-)\\n\\nHere the difference from the other posts is that in for loop, the condition is optimized.  If we are going to check two conditions in the for loop, why not make sure those are optimal?  I believe the code is still readable but now the loop condition is optimized.\\n***\\n    /// <summary>\\n    /// Given an array of non-negative integers, you are initially positioned at \\n    /// the first index of the array. Each element in the array represents your \\n    /// maximum jump length at that position. Determine if you are able to reach\\n    /// the last index.\\n    /// </summary>\\n    /// <example>\\n    /// A = [2,3,1,1,4], return true.\\n    /// A = [3,2,1,0,4], return false.\\n    /// </example>\\n    public class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }\\n            }\\n\\n            return maxJump >= lenMinus1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 21093,
                "title": "one-pass-solution-java",
                "content": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 21096,
                "title": "c-o-n-solution-with-comments",
                "content": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3573168,
                "title": "python-simple-solution-beats-81-14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI can start from the finish line and problems only appear when there is a zero\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a greedy approach to iterate from the last index `j` towards the first index. It starts with `j` set to the last index of `nums`.\\n\\nIn each iteration, it checks if the element at index `j-1` is greater than 0. If it is, it means we can jump from index `j-1` to index `j`. In this case, it decrements `j` by 1 and continues to the next iteration.\\n\\nIf the element at index `j-1` is 0, it means we cannot jump from index `j-1` to index `j`. In this case, it enters a nested loop starting from index `i` set to `j-1` and iterates towards the first index (`i <= 0`).\\n\\nWithin the nested loop, it checks if the value at index `i` (`nums[i]`) is less than the distance between `j` and `i` (`j-i`). If it is, it means it is not possible to jump from index `i` to index `j` based on the value at index `i`. In this case, it decrements `i` by 1 and continues to check the previous indices.\\n\\nIf the nested loop reaches the first index (`i <= 0`) without finding a suitable index to jump from, it means it is not possible to reach the last index of `nums`. In this case, the code returns `False`.\\n\\nIf the outer loop completes and exits without encountering any issues, it means it is possible to reach the last index of `nums` based on the given jump values. The code then returns `True`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817477,
                "title": "c-5-lines-code-4-approaches-dp-easy-analysis-100",
                "content": "# Approach: Recursion\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n^10e5) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Recursion with DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Iterative DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 18%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n# Approach: Same concept no DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 100%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310838,
                "title": "python3-solution-with-detailed-explanation-o-n-o-1",
                "content": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1255164,
                "title": "c-4-solutions-recursion-top-down-dp-bottom-up-dp-optimised-bottom-up-dp",
                "content": "**Solution 1 : Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 : Top Down DP**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 3 : Bottom Up Way 1**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 4 : Bottom Up Dp Way 2**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596403,
                "title": "python-really-kiss-solution",
                "content": "I started thinking of Dynamic Programming solution but in this case after re-reading the problem, I noticed that three interesting bits: \\n1. **non-negative integers** and \\n2. **Each element represents your maximum jump.** and \\n3. I only had to return **if I am able to find *a* solution** to the problem.\\n\\nThat means that I don\\'t really care about those values if they provide me enough *credit* to jump to the next cell.\\nGoing backwards, I always increment the `debit` of my cost to jump.\\nAs soon as I have a value that offsets my debit, I don\\'t really care of it\\'s value, and I can keep going.\\nOtherwise means that that cell doesn\\'t provide me enough `credits` to offset the `debit`, so I treat it as a `0 credit`: it\\'s a dead end.\\nIf I don\\'t have debit when I reach my first position, I know that there is A path.\\n\\nIf the problem wanted for example to count how many paths, then I was forced to do something more complex but we need to remember to KISS.\\nDynamic Programming is very powerful but also we shouldn\\'t immediately reach the most powerful tool for the job.\\n\\n-sorry, end of my preaching-\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182034,
                "title": "difference-between-dp-and-greedy",
                "content": "### Dynamic Programming\\nLooking from the end and at each point ahead checking the best possible way to reach the end\\n```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\\n\\n\\n### Greedy\\n[Reference](leetcode.com/problems/jump-game/discuss/20900/Simplest-O(N)-solution-with-constant-space/20948)\\nLooking from the start and selecting the locally optimum in the hope of reaching global optimum\\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```\\n\\n\\n\\n\\n\\n\\n## Example\\n\\n\\t\\n![image](https://assets.leetcode.com/users/sohammehta/image_1539664091.png)\\n\\nIf we have a Greedy Approach here then we will take the path 1+99+1 as we select local optimum from the beggining\\n\\nBut if we take DP Approach then we start from back and find the cost of `reaching end` from `that specific node`. So when we reach the first node we will have two options\\n1. 99+1 path\\n2. 5+1 path\\nNow we simply have to decide between (1+(99+1)) and (20+(5+1)) path\\n\\n",
                "solutionTags": [],
                "code": "```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20897,
                "title": "recursive-and-non-recursive-solution-in-python-faster-than-100-python-solutions",
                "content": "At first I came up with this recursive solution, it is not difficult to think\\n```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\\nIt is like every time you look from the tail to see whether current index can get you into the last index and if we can reach last index from the current index, then current index becomes a new last index, we do the check again. \\n\\nThen I think it is not difficult to come up with the Non-recursive version evolved from the above solution:\\n\\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "solutionTags": [],
                "code": "```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21165,
                "title": "easy-java-code-accepted-with-comments-for-understanding",
                "content": "just for record\\n\\n    public class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }\\n        //loop finished, the last grid can be reached\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3541893,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "# #do upvote if u like solution #\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159874,
                "title": "c-greedy-dp-memiozation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is we can do recursion and check all the possiblities whther we are able to reach at the end or not. Then for optimization we can use DP or Memoization.\\nAlso there is a greedy apprpoach in which we check the maximum we can reach from an index . And using that we will check whther we can reach the end or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy Appraoch:**\\n- We will keep track of max so far and also keep an end varaible which will be updated after checkig all the possiblites between curr and maxi beacuse  we are not sure initially what can be length of the jump we take . So after keeping track of max_so_far  and end we will check if our end >= n-1 i.e reached at the end or not and return true if reached else false.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**DP --> O(n^2) and O(n)**\\n```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\\n**Greedy approach O(N) and O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693089,
                "title": "c-easy-fast-and-clean-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367910,
                "title": "java-simple-5-lines-code-o-n-faster-than-100-o-1-space",
                "content": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179976,
                "title": "straightforward-python-dp-accepted-and-recursive-mem-tle-solns-with-explanation",
                "content": "__DP:__\\nPretty straightforward dp case here, the main ideas:\\n-  We track that we can get to point dp[i] in our dp table.\\n-  To make it do dp[i] we search backward from the corresponding point nums[i] looking for a value that is >= the dist between the points.\\n-  If we find a point that contains such a value (```nums[j] >= (i-j)```) and has been reached (```dp[j]```) we know we can make this location.\\n-  We mark that we can make it and break the inner look to check the next location.\\n-  If ```dp[-1] == True``` it means that we can make it to the end.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n__Recurison + Memoization (TLE):__\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```nums[j] >= (i-j)```\n```dp[j]```\n```dp[-1] == True```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883692,
                "title": "python-dp-solution-with-explanation-for-time-limit-exceeded",
                "content": "This is an interesting problem. The DP solution is quite straight forward. \\n\\n**Idea:**\\n\\n- At pos `i`, check if there is a pos `j` (where `0<=j<i`), from where we can jump to pos `i`\\n\\n![image](https://assets.leetcode.com/users/images/980c7c13-abfb-4b76-bc70-899e26086894_1602089061.8129.png)\\n\\n\\nThe below solution is correct but it will throw `time limit exceeded` for the last test case which is a very large array of `1`s \\n\\n**Correct solutin but time limit exceeded**\\n\\nThe below solution is correct but due to `# line A` we encounter `time limit exceeded`. So we need to optimize there. \\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n**Observation:**\\n\\n- As soon as `cond` (condition) is `True`, no need to iterate the inner loop.  `# line C`\\n- Run the `inner for loop` backward, thus you will encounter the required `True` condition earlier.  `# line B`\\n\\n**Final accepted solution**\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n_happy coding !!_",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420615,
                "title": "javascript-solution-greedy",
                "content": "### The Idea\\n1. keep a record of the maximum feasible index\\n2. if an index is unfeasible, return false\\n\\n```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20898,
                "title": "java-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20904,
                "title": "c-dp-solution-o-n",
                "content": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "solutionTags": [],
                "code": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21075,
                "title": "short-c-implementation",
                "content": "Thanks the post from top voted solution.\\n\\nHere is the AC c++ implementation \\n\\n       class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21127,
                "title": "python-different-solutions",
                "content": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3653785,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing information whether you can get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our boolean array.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952145,
                "title": "java-simple-100-faster-video-explanation",
                "content": "\\nLook at the video to understand the approach[https://youtu.be/aeohnY2FQBI]()\\n\\n# Code\\n```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n-> Make sure to Upvote , it keeps me motivated.\\uD83D\\uDCAA \\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```\\n- Time complexity : O(n)\\n- Space complexity : O(1)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951793,
                "title": "greedy-o-n",
                "content": "```farthestPos``` represent the farthest position we can go\\nAt each position (index) in ```nums```, we find the farthest position we can go by comparing the ```farthestPos``` with the current position + jumpLength.\\nAt any time, if the ```farthestPos``` is larger than the last position (index) in ```nums```, return True\\nAt any time, if the ```farthestPos``` is smaller than the current position (index) in ```nums```, return False\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```farthestPos```\n```nums```\n```farthestPos```\n```farthestPos```\n```nums```\n```farthestPos```\n```nums```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260211,
                "title": "2-solutions-dp-greedy",
                "content": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\\n\\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500046,
                "title": "c-greedy-approach-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889494,
                "title": "easiest-code-u-can-get",
                "content": "\\n# Approach\\nIterating from the End: The algorithm starts iterating through the array from the end towards the beginning. The variable index is used to keep track of the last known position that can reach the end of the array.\\n\\nUpdating index: For each element in reverse order, check if the sum of the current element\\'s value (nums[i]) and its index (i) is greater than or equal to the current value of index. If it is, update index to the current index i.\\n\\nFinal Check: After the loop finishes, if index is at the beginning (index 0), it means that you can jump from the start to the end of the array using the given jump values. In this case, return true, indicating that it\\'s possible to reach the end. Otherwise, return false\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500987,
                "title": "cool-c-o-n-o-1-in-5-lines-i-call-it-momentum",
                "content": "# Intuition\\nmaybe the easiest way?\\n\\n# Approach\\nmomentum: how further i can go\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952081,
                "title": "c-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866646,
                "title": "golang-simple-solution",
                "content": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825025,
                "title": "java-3-approaches-recursion-visited-bottom-up-dp-no-dp-explained",
                "content": "**What does the question ask for?**\\nThe question asks us to determine whether the end index is reachable from index 0.\\n\\n**How may we approach this problem?**\\nThe basic idea for this problem is to check the reachability of intermediate indexes to determine the reachability of some index\\n\\n# Approach #1 : Recursion + Visited\\n\\nWrite another method wherein we check whether the end index is reachable from the current index\\nIf we can reach to the current index from 0 and then from current index to end index,\\nthen we can surely reach from 0 to end index (0-> current index -> end index)\\n\\n**What is the purpose of visited?**\\nWhile calculating the reach. we may end up at the same index multiple times. If that index has been processed earlier -> Either it would have returned true, in which case, no more calculations would have been done, but since we encountered this index again, means that its result was false.\\n\\n```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Approach #2 : Bottom-up DP/Tabulation\\n\\n**How else can we solve the problem?**\\nIf the problem is solvable recursively, there will be an iterative solution as well.\\nThe idea for this approach is:\\nMaintain an array to check whether the current index is reachable from zero\\n\\n**How will we update reachable array?**\\nWe will use the idea of intermediate indexes:\\nSay we want to update index i\\nWe will consider some intermediate index j, s.t., 0<=j<i\\nThen:\\na) We will check that j is reachable from zero (using our reachable array)\\nb) We will check that i is reachable from j (Maximum index reachable from j = j+nums[j], if i<=max_index, then i is reachable otherwise not)\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\\n\\n# Approach #3: No DP\\n**What can we improve in the previous approach?**\\nWhat if instead of maintaining an array to check the reachability, we maintain a single variable that determines the maximum reachable index from 0 at a given iteration? In that case, we can simply check if the current index is within reach or out of reach, all the while updating max reach if current index is within reach.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**References:**\\n1.  https://leetcode.com/problems/jump-game/discuss/1819771/C%2B%2B-Memoization-(Top-Down)-and-Tabulation-(Bottom-Up)\\n2. https://leetcode.com/problems/jump-game/discuss/1820513/C%2B%2B-No-DP-Needed-Single-Traversal",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668712,
                "title": "dp-greedy-c-soln-two-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576539,
                "title": "simple-python-solution-with-explanation",
                "content": "**explanation :** **https://github.com/midnightbot/leetcode_solutions/blob/main/55.%20Jump%20Game.pdf**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557203,
                "title": "c-easy-solution-96-fast-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501210,
                "title": "c-recursive-memoization-dp-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362214,
                "title": "two-solutions-using-dp-and-pointer",
                "content": "using dp and inserting index at most one can jump\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\\nusing a pointer to keep data that index is reachable or not in reverse direction \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087640,
                "title": "recursive-dp-bfs-greedy",
                "content": "recursion, time = exponential\\n```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\\ndp, time = O(n^2), space = O(n)\\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\nbfs, time = O(V+E) = O(n^2), space= O(n)\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\noptimized bfs, time = O(V+E) = O(n), space= O(n) \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\n\\ngreedy- maxReach/globalMaxReach approach, time O(n), space O(1), \\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596250,
                "title": "c-o-n-time-o-1-space",
                "content": "At first I submitted a *O(N^2)* DP solution. However it will TLE.\\nIn fact, you only need to greedily keep updating the rightmost position you can jump to.\\n```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443266,
                "title": "dp-or-top-down-memoized-solution-tles",
                "content": "Unlike what the solution may suggest DP or top down memoized solution TLEs in C++. \\n\\nI wasted a lot of time trying to figure out if there is a bug in my code and there isn\\'t. They just want it in o(n) time.\\n\\nThe only o(n^2) dp that worked for me is the following code\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\\n\\nAnd even still slight modifications won\\'t allow this to work, like when I changed the ```vector<int>``` to ```vector<bool>```\\n\\nEdit:\\nDP solutioon that beats 97% in time complexity\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\n```vector<int>```\n```vector<bool>```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414459,
                "title": "c-o-n-iterative",
                "content": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114802,
                "title": "python-dp-o-n-solution-accepted",
                "content": "Here, I share my python solution using dynamic programing. The key to reduce the time complexity from ```O(n^2)``` to ```O(n)``` is to define the state ```dp[i]``` as the maximum index one can jump after reach index ```i```. \\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "solutionTags": [],
                "code": "```O(n^2)```\n```O(n)```\n```dp[i]```\n```i```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20896,
                "title": "python-and-91-fast-time-idon-t-know-if-it-s-greedy-maybe-not",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 4018177,
                "title": "use-a-counter-to-count-on-your-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key mindset here is to use a counter to count on residual steps.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake k as your residual steps. Everytime you move, k-1. If nums[i] offers you more steps, take it! If you run out of your move and can\\'t move to finishing line, you fail. Otherwise, return True.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779748,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652039,
                "title": "beats-99-runtime-and-80-memory-very-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGoing from the backward. If you can reach the final point from right before one, replace the goal with the index of the right before point.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078478,
                "title": "very-easy-c-solution-in-o-n-time-beats-99-12",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951498,
                "title": "python-3-7-lines-iteration-w-explanation-t-m-94-98",
                "content": "The problem reduces to whether there is a zero in any position other than position n[-1], and if so, whether there is a reachable cell beyond each such zero. \\n```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```\\n[https://leetcode.com/problems/jump-game/submissions/865477602/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) .\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531333,
                "title": "simple-ts-with-explanation",
                "content": "Practically speaking, if the array contains no stopping points (`nums[i] = 0 ` for any `i`) then we can always reach the end index by always jumping 1 step forward regardless of the value we are standing at \\nFor example: `[2, 3, 4, 5, 1, 6, 7]` we can always just use 1 step at each point to reach the end\\nWith that being said, the tricky part is when zeroes are involved, and that is basically the whole point of the problem\\nLet us say we want to move one step at a time and store how many steps are left to carry us forward, and if we have none left then we break early and return false\\nCan we skip past **all** zeroes with the number of steps we have left? If so then we return true\\nLet us store how many steps are `left` for the previous index, and if we are standing on a new index whose `nums[i]` value gives us more steps, then we \"reimburse\" ourselves with that new value by replacing `left`  with `nums[i]`\\nIf `left == 0` then there are no ways to move forward and we have ran out of steps because we must have encountered a zero value that stops us dead in our tracks with no more steps in the \"bank\"\\n```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488405,
                "title": "python-backtracking-greedy-interview-pov",
                "content": "Intutions that pops up during an interview:\\nIf we are not able to think about the solutions right off the bat , think about base cases/invalid cases. \\nPoints to consider : \\n1. The only hurdle that stops us moving towards the destination is \"0\" ,So we can check if the value at 0th index is 0 then directly return False as we cannot move ahead.\\n2. How about checking 0s on every index before taking a call to jump? will it work? lets see\\n [1,2,0,1,1]\\nFrom 2nd position(1 based index) you either need to jump 1 step or 2 steps , since 1 step is giving you 0, you have to **BackTrack** and jump 2 steps to reach the destination. \\n\\nHence from the above 2 points we can say that from every step we need to decide and consider all the paths by BackTracking \\nGood , atleast we were able to give some bruteforce algo now, Lets code it up with some help :\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```\\nNow , The above solution works perfectly in the case of smaller inputs , what if the values are 10^something then we end up looping /backTracking every value to reach the destination which is very expensive .\\nCan we think of something else ?\\nhmmmm.....\\n.hmmmm....\\n.hmmm...\\nAt this moment inteviwer would give some hints : \\n1. Why dont you try from the last ?\\n2. Do you really need backTracking if you try from the last ? \\n\\n\\nOhhh, okay Lemme think ...\\nif i get to try from the last position (ie my destination) , i will jus have to validate if am able to reach the destination by visting destination-1 th position\\n for eg : \\n [4,2,3,1,5] ---> 1 based index\\n To reach 5th position, i will jus have to validate if am able to reach5th index from 4th index , by checking if the (value at 4th index+4th index ) should be equal or greater than than the destination position ie 5th index here  Hence for the above example i would be checking \\n \\n 1(value at 4th index)+4(index) >= destination index(5) \\n Yeah am able to reach , okay now change the destionation to 4th position and redo the same for every value and finally return True if your destination is at 0th index after all the movements else return False \\n ```\\n  currDestination=len(nums)-1\\n        for i in range(len(nums)-2,-1,-1):\\n            if (i+nums[i])>=currDestination:\\n                currDestination=i\\n        return True if currDestination==0 else False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381515,
                "title": "o-n-python-solution",
                "content": "Please Upvote if you like the solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188884,
                "title": "java-in-depth-explanation-o-n-time-and-o-1-space",
                "content": "I have my solution in Java here w/  **O(n) time** and **O(1) space**. I think my solution is much easier to understand and implement. \\n\\n  The first step is to declare a int variable `max_reach` to track what\\'s the max index we can reach to. Eventually, we know we can return true once `max_reach >= nums.length - 1`. Hence, we can use a for-loop to update `max_reach`. \\n\\n  (1) if `max_reach < i` then return **false**. We do so because if max_reach is smaller than i, that means we are not able to reach to `idx i`. Then we return false for sure.\\n\\n  (2) `max_reach = Math.max(max_reach, i + nums[i])`. When come to here, we know that we are able to reach `idx i` already. Now we want to update our `max_reach`. We are at `idx i` so let\\'s compare `max_reach` and `i + nums[i]`. Why it\\'s `i + nums[i]` ? We are at `idx i` so `i + nums[i]` would be the max index we can reach at `idx i`. \\n\\n```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043503,
                "title": "weeb-explains-python-c-dp-o-n-time-o-1-space",
                "content": "I will explain my thought process on how i solved this problem.\\n\\n# Understanding the question:\\nOur goal is to check whether we can reach the **last index**, given that we start on the **first index**\\nEach nums[i] represents the **maximum** jump distance from i to some index j.\\n\\n# Observations:\\n***1st Observation***\\nMy first thought was that **if a path exists**, then that means there must be **at least one** possible path to reach the last index.\\nSince we just want to know whether we can reach the last index, then **it does not matter which path we take to reach the last index**, we **only need to reach the last index, regardless of which path we take**.\\n\\n***2nd Observation***\\nWe now know that it doesn\\'t matter which path we take to reach the last index. This subproblem is solved.\\nSo, **what is the next subproblem?**\\nFor me, the question was,**how do we figure out which path(out of all the valid paths) do we take to reach the last index?**\\nLets assume that a path exists, we shall represent the path as some nodes.\\nlet the nodes be A, B, C, D, E respectively. Where **A is the first index**, and **E is the last index**, **B, C, and D are some nodes in between to contribute the the path to reach the last index**.\\nI noticed that, to go from A to E, we need to go through B, C and D.\\nThen, that means **D is dependent on E, and C is dependent on D, and B is dependent on C.**\\nIn simpler terms, **to get to E, we need to start on D, to get to D, we need to start on C, to get to C, we need to start on B and so on.**\\nSo, A -> B -> C -> D -> E.\\nfrom this, I deduced that the the **current node is dependent on the on the previous node**, which leads to the **idea of backtracking from the last index to the first index.**\\n\\n***3rd Observation***\\nNotice that, if nums does not contain a 0, that is, nums[i] != 0 for 0<=i<=len(nums)-1, then **there is always a path**.\\nWhy? Because from the 1st observation , we deduced that it we **only need to reach the last index, regardless of which path we take**.\\nBut, what if nums[i] == 0?\\n\\n***4th Observation***\\nThe idea is to check whether its possible to  **\"skip\"** nums[i] == 0. But how?\\nLet nums = [2,0,1,0], the result for this is True\\nwe know that the path is 2 -> 1 -> 0\\nSince, **from the 2nd observation**, we know that we need to use **backtracking**, we woud\\'nt know that \\n2->1->0 is valid path without iterating through nums[1], which is 0.\\nFor me, i thought of the idea **using a count, and to accumulate this count to compare it the previous indexes, i.e index 0 to index i**\\nWhen we encounter a number greater than or equal to count, i.e **nums[j] >= count**. We **reset the count**, and repeat this step again when we encounter another nums[i] == 0.\\nif **nums[j] < count**, then we still continue until we reach the last index(**while adding count by 1 for each iteration**), if count is still > 0 at the first index, then we cannot skip that nums[i] == 0, so we **return False**\\n\\n**Why do we add 1 to count for each iteration?** \\nBecause, as we backtrack by 1 step for each iteration, we need 1 more step to skip nums[i] == 0.\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn (count == 0) ? true : false;\\n\\t\\t}\\n\\t};\\n\\nTake a break from dp, watch some anime instead\\nCheck out **\\u65F6\\u5149\\u4EE3\\u7406\\u4EBA (Link Click)**\\n\\n# Episodes: 11\\n# Genres: Drama, Supernatural\\n# Theme: Time Travel\\n\\nThis show is a good one, pls watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737483,
                "title": "fast-c-simple-tc-o-n-sc-o-1-single-loop",
                "content": "- we find the max reach distance at every point\\n- if at any point less then last index, max-reach point is 0, we return \"false\"\\n\\n```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```\\n\\n- please upvote my solution if you like it, as it motivates a lot. THANK YOU",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734799,
                "title": "brute-force-recursion-both-explained",
                "content": "**!!!!!!...Please upvote if you like it/........**\\n**Brute force:**\\n```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\\n**-------------------------------------------------**\\n**Recursion+Memorisation**\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1558758,
                "title": "super-easy-c-solution-100-speed-greedy",
                "content": "**Intuition:**\\nCan  anyone reach to lastindex - starting from lastindex itself\\n\\n**Technique - Greedy**\\nUsing index+nums[i] >= lastindex, then true;\\n        \\n**CODE with Explaination**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520508,
                "title": "any-beginner-looking-for-recursive-top-down-approach-dynamic-programming",
                "content": "just reverse the array and follow it up recursively\\n```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```\\nIt\\'s not the best optimised version . But I think it\\'s good for any beginner who is looking for dp solution but not able to find it . It\\'s also called Dynamic programming solution since we have memosized the recursive solution.\\nThanks",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429371,
                "title": "java-1ms-faster-than-100-o-n-with-comment",
                "content": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378537,
                "title": "simple-easy-c-solution",
                "content": "1. \\tWe just need to chec our itreter is reach at last poistion or not.\\n2. \\tso,we make one tamparary varieble r \\n3. \\tnow we traverse into vector frome 0 index to last.\\n4. \\tand update our r with max valur of vector[i] or previous r.\\n5. \\tand check if we reach or not \\n6. \\tif we reach at vector[i] with value 0 than direct false Bcz we dont have any forther move!\\n\\n```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233260,
                "title": "easy-python-solution",
                "content": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854051,
                "title": "simple-2-pointer-approach-using-java",
                "content": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 829178,
                "title": "python-in-place-dp",
                "content": "Using the input array itself to keep track of the available jump at current index (memoization):\\n- If the previous index has 0, then there\\'s no way to reach the current index, so update current index to eqaul to 0.\\n- Else we can make at least one jump from previous index, store the max jump available at current index.\\n- Lastly check the 2nd to last index(right before the target) should has available jump >= 1 else it can\\'t jump one more to reach the end\\n\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769699,
                "title": "quick-and-simple-c-solution-with-explanations-o-n",
                "content": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 713591,
                "title": "python-linear-constant-space",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```\\n\\nthe idea is we initialize a variable, current_max, which keeps track of the maximum index we can reach in the array. Through each pass of the loop, we check if the index i of the array can be reached. If not, we can terminate early. Otherwise, we check the current_max vs the current element of the array. For example, we have:\\n\\n[2,0,6,8,1,2]\\n\\nAt i = 0, our curent_max is 2 - we can reach up to index 2 in the array\\nAt i = 1, our current_max is max(2, 1 + 0) = 2, meaning we can still only reach index 2\\nAt i = 2, our current_max is max(2, 2 + 6) = 8, so we can reach up to index 8\\n\\nWe can also terminate early if our current max is greater than the array length minus one, because we are dealing with indices. \\n\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669672,
                "title": "javascript-recursive-dp-memoization-top-down-approach",
                "content": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596976,
                "title": "o-n-c-better-than-99-81-with-o-1-with-explanation",
                "content": "This guy explains each and every concept and logic behind any question so clearly.\\nYou will definately like it.\\nhttps://www.youtube.com/watch?v=muDPTDrpS28\\n\\nComment if you have any question\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596291,
                "title": "javascript-javascript-minimum-variables",
                "content": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215616,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "codeTag": "Java"
            },
            {
                "id": 20899,
                "title": "fastest-python-o-n-constant-space-solution-6-lines",
                "content": "Checking the range of the current element, decreasing by 1 and comparing to the next element. Currently the fastest Python solution.\\n\\n``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21017,
                "title": "python-4-liner-beats-96-other-solutions",
                "content": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "solutionTags": [],
                "code": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "codeTag": "Java"
            },
            {
                "id": 21117,
                "title": "java-4-line-solution-can-you-beat-it",
                "content": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21120,
                "title": "clear-greedy-solution-for-c",
                "content": "    class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }\\n           return step != 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 21177,
                "title": "my-5-lines-dp-solution-in-o-n-time-with-constant-space-19ms",
                "content": "This a DP solution, and the idea is to save the maximum jump length every time, if the maximum length be zero, than return false.\\n\\n    class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21197,
                "title": "5-lines-code-solution-with-o-n",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21211,
                "title": "help-me-improve-it-thx",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }\\n            }\\n            return max>n-2;\\n        }\\n    };\\ntried my best. but i think its not good enough.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4049323,
                "title": "easy-c-solution-beat-97",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976142,
                "title": "python-every-possible-solution-greedy-dp-recurssive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n### Greedy TO(n) SO(1)\\nMaintain a reachable variable and update it on every iteration, if we are ahead of reachable that means it\\'s not possible. else reachle will be equal to n\\n\\n### DP TO(n^2) SO(n)\\nUsing a 1d array to mark evry reachable destination by True and then check if we reached on then end or not.\\n\\n\\n### Recurssive TO(n^n) SO(1)\\nTry running DFS on every possible value and check if reached in the end or not.\\n\\n\\n\\n# Code\\n```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```\\n\\n# Upvote if it\\'s helpfulll.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664370,
                "title": "java-greedy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use a greedy approach to determine if it is possible to reach the last index of the array nums using the maximum jump length at each position. The idea is to iteratively update the maximum reachable index while traversing the array from left to right. If the maximum reachable index ever reaches or exceeds the last index, it means we can reach the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the variable last as the index of the last element in the array (nums.length - 1).\\n- Initialize the variable maxReach as 0, representing the maximum index we can currently reach from the starting position.\\n- Iterate through the array nums from left to right using the loop variable i.\\n    - Update maxReach using the expression Math.max(maxReach, i + nums[i]). This calculates the maximum index we can reach by taking a jump from the current position i.\\n    - If maxReach ever reaches or exceeds the last index, return true as we can reach the end.\\n- If the loop finishes without returning true, it means we cannot reach the last index. In this case, return false.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579417,
                "title": "best-solution-only-by-basic-array",
                "content": "# Intuition\\nI solve this question only by some basic array.\\n\\n# Approach\\nWe have to find zeo in the array after that go back in array and check if element is greater than predefined variable than index should pass that zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258854,
                "title": "greedy-algorithm-python3",
                "content": "# 1.Simple Start and End Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\\n# 2.Greedy Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233306,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161183,
                "title": "solution",
                "content": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\\n\\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3153958,
                "title": "java-4-solutions-with-clear-explanation-and-real-life-application-brute-force-dp-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Jump Game is a type of dynamic programming problem. The purpose is to determine if it is possible to reach the index in an array by jumping from index to index. The number at each index represents the maximum steps that can be jump from that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are many approaches to this problem. The most simple and efficience approach is to use `Greedy Algorithm`. If you want to check out for different approach please check the code and explanation in the #Code Section\\n\\n1. Create a variable called `lastPos` initialized to last index of the array. \\n2. Iterate the array from the second last index to the first index, checking if the current index `k` + `nums[k]` is greater than or equal to the distance to the `lastPos` index. If so, update the `lastPos` index to the current index.\\n3. Return true if the first index is greater than or equal to the distance to the `lastPos` index, else return false.\\n\\n\\n\\n# Code\\n#### **1) Brute force solution (Recursive) [TLE] \\u274C**\\nThe idea is to start from the first index and try every possible jump from that index, checking if the jump leads to the end of the array. The`DFS` takes in 2 parameters, the `nums` array and the current index position `index`. \\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\\n- Time complexity: $$O(2^n)$$ in the worst case, where n is the number of elements in the array. For each jump, the algorithm tries every possible jump length and this leads to an exponential number of possible paths to explore.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n#### **Optimized version:**\\nUsing the same code above, instead of storing the current index in variable `jump`, I decrement the `nums[index]` after checking it. The reason is if that index position has been checked for all possible jumps, the value in the array will be set to 0. Which will not be checked later if we backtrack to try another jump from the previous index.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the number of elements in the array. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n#### **2) Dynamic programming solutions**\\n##### 1. Recursive - Memoization - Top Down \\u2705\\n\\nWhen calculating, we might end up at the same index again. By creating an array call `dp`, we store `true` if that index has been processed earlier. In the case which we encountered this index again, we will return false.\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the length of the nums array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array. This is because we need to store the dp array which has n elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n##### 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\nThe dea behind this solution is to iterate through the `nums` array from the end to the start and keep track of the last position that can be reach. \\n\\nHere a steps to understand this problem:\\n\\nStep 1 - First, we initialize a boolean array `dp` of length `nums.length` with the last element of the dp array set to true.\\n\\nStep 2 - Next, a loop is used to iterate backwards from the second to last element `nums.length-2` to the first element `0`.\\n\\nStep 3 - For each iteration, a variable `furthestJump` is intialized to hold the maximum jump possible from the current position. You may ask why it compares the min of `k + nums[k]` and `nums.length - 1`. Think about an array containing [1,4,1,1]. At position `k = 1`, the maximum jump distance is `1 + nums[1] = 1 + 4 = 5`. However this distance goes beyond the length of they array (4). So the actual maximum jump distance from position `k = 1` is `4`. The distance is stored in the `furthestJump` variable and used to control the range of the inner loop.\\n\\nStep 4 - A nested loop is then used to iterate from `k + 1` to `furthestJump`. If dp[j] is true (meaning it is possible to reach the end of the array from position j), then set dp[k] to true (since it is now possible to reach the end of the array from position k), and break out of the nested loop.\\n\\nStep 5 - Finally, return the value of dp[0] which indicates whether it is possible to reach the end of the array from the start (dp[0] being true means it is possible, dp[0] being false means it is not possible).\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n^2)$$ where n is the length of the array. This is because we make two passes through the array, one from `nums.length-2` to 0 and one inner loop that goes from `k + 1` to the `furthestJump`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n i s the length of the array because we use a `dp` array of length `n` to keep track of the result.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n##### 3. Greedy Solution \\u2705\\n\\nThis solution is built on top of the previous solution. This one has a time complexity of $$O(n)$$ and a space complexity of $$O(1)$$.\\n\\nBy keeping track of the last position that can be reached by starting from the end of the array. We can return true if the last position that can be reached is the first index (which is 0). Otherwise, we can just return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n)$$ where n is the length of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ because we only need to store a single variable `lastPos` to keep track of the last position that can be reached.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Application\\n\\n###### The Jump Game problem have several real-life applications, including the following: \\n1. Game Development: model the movement of a character in a 2D game, where the character need to jump over an obstacle to reach the end of the level.\\n2. Robotics: the Jump Game problem can be applied to robotic motion planning, where a robot needs to determine the optimal path to reach a destination by jumping over obstacles.\\n3. Network Routing: model the process of finding a path in a network, for example, computer network or a transportation network, where nodes represent the index of the array and edges represent the jumps between nodes.\\n4. Financial Investment: whenever an investor needs to determine if they can reach the target value by making a series of investments, with each investment representing a jump in the array.\\n\\n\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124885,
                "title": "95-javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/miUgur9WUCc\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954777,
                "title": "java-0ms-fast-solution-with-mountain-and-valley-approach",
                "content": "**Aprroach:**\\nWe will keep counting the reach from each index and check whether we can cross the zeros (valleys) or not.\\nFor every projectile if reach is able to get to the last index we will return true and if index exceeds reach we will return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953407,
                "title": "c-solution-beats-95",
                "content": "# Approach\\nIterate the nums array from the start and always jump the maximum value i.e nums[i].\\n\\nAs soon as you encounter a 0, start moving backward till you find a position from where you can cross that 0 you encountered.\\n\\nIf there is a nums[x] which can cross the 0, then move i to that index. If while backtracking the count pointer reaches -1 means no other way is possible.\\n\\ncount indicates number of backward jumps.\\nflag is used to mark if last index is unreachable.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952650,
                "title": "java-o-n-tc-o-1-sc-fully-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/31149a94-94d4-4c1f-974e-1fc6bd560f88_1672041162.8356094.png)\\n\\n\\n\\n# Intuition\\nThe idea is to continuously improve the position we can jump to.\\n\\nInitially, we  can think of jumping to all available `k` position from each index where `k = nums[i]`, because we want to find the best reach from any index.\\n\\nInstead of doing that we can simply pass all the elements in nums and see what is the furthest reach any of them places us at. If we step on an index we can\\'t reach because the previous elements don\\'t allow us to get there, then we exist by returning `false`. Otherwise we greedily update the best index we can reach until we can reach the end of the array.\\n\\nThe code is super simple and readable.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952386,
                "title": "simple-solution-c-greedy-easy-to-understand",
                "content": "# Intuition\\n\\n\\n# Approach\\nEdge case: check if first element itself is 0 that means it can not take a move further and size of nums is greater than 1----> in this case return false\\n\\nstore first element of the array in a variable jump=nums[0];\\n\\nafter that iterate over a loop and decrement jump by -1 and check jump is lesser than the current value if so then assign jump to the current value;\\n\\nin case if jump becomes 0 and you have not reached at the end point then return false\\n\\nif false statement doesn\\'t execute then true statemnt automatically will be executed just after completion of the loop\\n\\n# Complexity\\n- Time complexity:\\nO(nums.size())---->as we are only iterating through a loop of vector nums\\n\\n\\n- Space complexity:\\nO(1)--->constant space there is no auxillary space as we are not using any othe data structure\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931403,
                "title": "simple-python-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1950634,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1573636,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1817005,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1575624,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1574057,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1571133,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 2013967,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1999361,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1956248,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1909957,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1885550,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1876186,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1716792,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1715657,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571131,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571136,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571137,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571135,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1570631,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1728755,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571134,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2071226,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2066762,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2061211,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2056179,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2055277,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2052657,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2043836,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2041386,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2037473,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2035614,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2025633,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2019101,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2009316,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999890,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999790,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999365,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1997192,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1993904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1992904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1967563,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1963454,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1958989,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1953532,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1949988,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1941195,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939852,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939688,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1938777,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1936621,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1928861,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1922826,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1921105,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1914294,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1889410,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1888207,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1887591,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883647,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883460,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1879418,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1863355,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1833843,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1822608,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1821171,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1814185,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1809557,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798533,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798323,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1793397,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1790352,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1776260,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1771623,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1766844,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1749261,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1744459,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1741937,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1740711,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734900,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734596,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1730109,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1729283,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729235,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729219,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729162,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729002,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728842,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728768,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728663,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728638,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728546,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            }
        ]
    }
]