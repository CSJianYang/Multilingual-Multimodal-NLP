[
    {
        "title": "Shift 2D Grid",
        "question_content": "Given a 2D grid of size m x n&nbsp;and an integer k. You need to shift the grid&nbsp;k times.\nIn one shift operation:\n\n\tElement at grid[i][j] moves to grid[i][j + 1].\n\tElement at grid[i][n - 1] moves to grid[i + 1][0].\n\tElement at grid[m&nbsp;- 1][n - 1] moves to grid[0][0].\n\nReturn the 2D grid after applying shift operation k times.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[9,1,2],[3,4,5],[6,7,8]]\n\nExample 2:\n\nInput: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\nOutput: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\nExample 3:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\n\n&nbsp;\nConstraints:\n\n\tm ==&nbsp;grid.length\n\tn ==&nbsp;grid[i].length\n\t1 <= m <= 50\n\t1 <= n <= 50\n\t-1000 <= grid[i][j] <= 1000\n\t0 <= k <= 100",
        "solutions": [
            {
                "id": 1934961,
                "title": "c-simple-clean-code-with-explanation",
                "content": "***It is a observation based question.***\\n\\nIf **k** is **1** then new column is **(j+1)** and if **k** is **k** then new column is **(j+k)** and new column should in range **[0,m-1]**. So new column is **(j+k)%m**.\\n\\nFor row, we have to first **find the number of rows added to previous row** which is equal to the **number of times (j+k) exceeds m**. So, number of rows added is **(j+k)/m**.\\n\\nSo, new row is **(i + (j+k)/m)** and new row should in range **[0,n-1]**. So new row is **(i + (j+k)/m)%n**.\\n\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934848,
                "title": "easy-java-code-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N+N)=O(2N)=O(N)\\nSpace Complexity=O(N)***\\n\\n<hr>\\n<hr>\\n\\n***UPVOTE if you like the post(^///^)***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431225,
                "title": "python-functional-programming-3-lines",
                "content": "shift all the numbers `k` steps, is the same idea as, moving last `k` numbers to head of the list: `nums = nums[-k:] + nums[:-k]`\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\\n# Functional Programming, 3 lines:\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458848,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere are some similar matrix(2D Grid) problems.\\n* 498 [Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)\\n* 566 [Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/)\\n* 867 [Transpose Matrix](https://leetcode.com/problems/transpose-matrix/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934852,
                "title": "python-3-lines-3-steps-clean-and-simple-solution",
                "content": "\\n**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060180,
                "title": "java-100-1ms-o-m-n-matrix-to-matrix-copy-optimized-for-speed-explanation",
                "content": "This code is optimized for speed.  It usually runs in 1ms, although sometimes 2ms, as of Feb 10, 2021.  May be slower in future years if more test cases are added or running on different server.\\n\\nThis algorithm first creates a result matrix the same size as `grid[][]`, then uses two loops to copy-and-shift from `grid[][]` to the result matrix.  The result matrix is converted to a `List<List<Integer>>` in the return statement, by using the `Arrays.asList()` method.\\n\\nFor copying from the input matrix `grid[][]` to the output `result[][]` matrix, first calculate the row and column of the `grid[][]` value that will be copied to `result[0][0]` in the output result matrix.  The start row and column to copy from `grid[][]` with be the `k`th value from the rottom right end of the `grid[][]` matrix.  This start row and column are the variables `kRow` and `kCol`.  The start row and column to the output `result[][]` matrix, are `r=0` and `c=0`.  While copying, `kCol` will advance along the columns in a row, until the end of the row, then start copying from column 0 in the next row.\\n![image](https://assets.leetcode.com/users/images/16a7cd10-62f3-4410-b697-bbe760e4bbd3_1614849399.1848493.png)\\n\\nTo make the copying of each numeric value faster, the current rows of `grid` and `result` are referenced by one-dimensional array variables.  The one-dimensional array variables `innRow[]` and `outRow` are references to a single row of the matrix `grid[][]` and `result[][]` respectively.  So changing a value in `outRow[]` also changes the corresponding value in a row of `result[][]` because the changed value is actually the same memory location within both variables.  The one-dimensional arrays `innRow[]` and `outRow[]` are simply short-cuts to a single row of `grid[][]` or `result[][]`.   These one-dimensional array variables for the current rows are changed when advancing to a new row in either `grid` or `result`.  The one-dimensional array variables make the copying faster because each time a single numeric value is copied from `grid` to `result`, the compiled code only has to calculate one-dimensional references within the rows (i.e. `innRow[kCol]` or `outRow[r]`), instead repeatedly calculating two-dimensional references within a matrix (i.e. `grid[kRow][kCol]` or `result[r][c]`).\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\\n--- Update ---:\\nAfter a question about the `\"return (List)Arrays.asList(result);\"` statement in the above code, asking how this statement works, I decided to explain this further.  The `Arrays.asList(result)` is used to supposedly create a List from `result`, by creating a `List<List<Integer>>` from the `int[][] result`.  But the `List<List<Integer>>` is **not** a copy of the `result` array, but instead is a `List` that contains **references into** the `result` array.  Changing a value in the `result` array will change the corresponding value in the `List`, and changing a value in the `List` will change the corresponding value in `result`, because both of these are the same value stored in a single memory location, with two different paths to access that value.  The `List` created by `Arrays.asList(...)` is also a **fixed** size `List` which cannot be added to and cannot be removed from.  In other words, the `List` resulting from `Arrays.asList(...)` is not a normal simple `List`.\\n\\nI am not completely sure why the cast `(List)` is needed before the `Arrays.asList`, but the compiler is unhappy without this cast.\\n\\nI used `(List)Arrays.asList(result)` because I assumed `Arrays.asList` could create the List of Lists faster than writing my own code to create the Lists one value at a time.  I have not tested to see if this method is faster than writing my own code to create the List of Lists.\\n\\nAnother curious thing is inserting the following lines before the `return` statement in the code above:\\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```\\nThese inserted lines of code will print the following output:\\n\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.ArrayList`\\n\\nWhich shows that the `List` created by `Arrays.asList` is not quite the same as a `List` created in the more normal way.  I do not yet understand enough of the internal details of Java to explain this difference, and I cannot explain why the cast of `(List)` is needed to make the compiler happy.  If someone knows why the cast `(List)` is needed, or how Lists created by `Arrays.asList(...)` are different than normal Lists, please inform us in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734727,
                "title": "javascript-es6-simple-solution",
                "content": "Brief explanation: \\n1. Convert the matrix to an array \\n2. Move the array bottom to the start K times\\n3. Convert the array back to a matrix and return \\n\\n```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434335,
                "title": "python3-2-simple-approaches-with-explanations-by-creating-a-vector",
                "content": "# **Algorithm:**\\n1)  put the matrix row by row to a vector.\\n2)  rotate the vector k times.\\n3)  put the vector to the matrix back the same way.\\n\\nThe **second step** is the same as problem [#189 (Rotate an Array)](https://leetcode.com/problems/rotate-array/), and can be solved in many ways, but here we consider **two approaches** that are simple and have reasonable time and space complexities: \\n**(a) direct shift approach**\\n**(b) reverse approach**\\n\\nAs an example of **Approach (a)**, imagine we want to rotate the vector [1, 2, 3, 4, 5, 6, 7] for k = 3 times. We just need to add these two subsets of the vector, respectively: last k elements and first len(vec)-k elements:\\n[5, 6, 7] +  [1, 2, 3, 4] = [5, 6, 7, 1, 2, 3, 4]\\n\\nAn example of **Approach (b)**:\\nreverse all elements     : [7, 6, 5, 4, 3, 2, 1]\\nreverse first k elements : [5, 6, 7, 4, 3, 2, 1]\\nreverse last len(vec)-k elements : [5, 6, 7, 1, 2, 3, 4]\\n\\nAlthough approach (a) seems simpler, it take additional space (needs an extra vector in addition to the vector created in step 1). Approach (b) might need extra code lines, but does not take additional space.\\n\\n# **Python3 codes:**\\n\\n**Approach (a), direct shift:**\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\\n\\n\\n**Approach (b), reverse method**: (Note that only step 2 has changed):\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1934644,
                "title": "c-flatten-array-then-convert-back-to-2d-struggled-live-on-stream",
                "content": "This one was tricky for me, had to get lots of help from chat.\\n\\nWe stream everyday 6PM PT.  There are dozens of us.  Link in profile.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937723,
                "title": "python-2-solutions-clean-concise-easy-o-1-in-space-complexity",
                "content": "- If we treat grid as an array, we can solve this problem as the same idea with **[189. Rotate Array](https://leetcode.com/problems/rotate-array/discuss/258789/)** problem.\\n- That is, the index of the array `idx`, will be map with the grid cell at `grid[idx // nCols][idx % nCols]`.\\n\\n**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(nRows * nCols)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse in splace**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934795,
                "title": "c-two-approaches-with-intuition",
                "content": "# Shift 2D Grid\\nThe problem at hand requires us to shift a 2D grid to the right cyclically k times. It is the equivalent of applying right shift operation k times.\\nOne right shift operation does the following:\\n(i,j) becomes (i, j+1)\\nif j == n-1, then it becomes (i+1, 0)\\nif j == n-1 and i == m-1, then it becomes (0, 0)\\n\\n## Approach 1 Calculate Indices for each element\\nIn this approach, we make a copy of the entire matrix, and then fill it with the corresponding elements according to the shifted coordinates.\\n```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\\nThe above function gives the shifted coordinates given the original coordinates and the shifted amount. We could call this function at every (i,j) in the matrix and fill the corresponding place.\\n\\nBut this approach would be slow, as we would have to make O(m*n) calls just to this function.\\nA better way to do this is to just call it once for the starting point, and then keep right shifting once for every subsequent element.\\n\\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\\n\\nThis code calculates the next position given the new position of the previous point (ni, nj)\\n\\nSo the full code for this approach is as follows:\\n### Code (C++)\\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(m * n) (for returning the new matrix)\\n\\n## Approach 2: Treat Matrix as Array and Right Shift k Times\\nWe already have a good approach for right shifting an array k times;\\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\\nIf we can treat the whole matrix as a flat array, we can apply the same algorithm and solve this question very easily.\\nTo do this, we can\\'t use the normal reverse function, as it warrants flattening the matrix, which we actually don\\'t need. We just need to *pretend* that the matrix is flattened..\\nThis is accomplished by taking the array coordinates and mapping them to row and column indices underneath.\\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\\nOnce this modification is made, the whole problem reduces to just three more statements\\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\\n\\n### Code (C++) \\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```\\n\\n### Caution!\\nThis code modifies the input matrix itself.\\nI regard this as a *hacky* way of achieving O(1) extra space, since one is bound to require some space for storing the output of the program. Plus this approach can lead to loss of information if implemented incorrectly. So take care while using it, or just make a copy of the input matrix and apply this algorithm on it instead.\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(1) (see above Caution)\\n\\n\\n**Upvote** if you liked this post and would like to see more of these in the future. Leave any doubts or suggestions in the comments.\\nDo you agree with the notion of modifying the input itself in order to get O(1) space?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708897,
                "title": "java-simple-one-loop",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935498,
                "title": "c-intuitive-approach-clean-solution-with-comments",
                "content": "Make a 1-D vector and push all element in that\\nNow calculate the index from which the modified grid will be started and then update the grid\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934690,
                "title": "very-simple-solution",
                "content": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516488,
                "title": "c-clean-code-98-runtime-100-space",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934572,
                "title": "java-simple-solution-time-o-n-space-o-1-faster-than-95-74",
                "content": "If the return ArrayList does not count space then its space complexity is O(1).\\nThe time complexity is O(n) where n is the count of all grid items.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936908,
                "title": "conceptually-straightforward-javascript-solution-nested-unshift-pop-76ms",
                "content": "My first concrete idea was a map adding each element by k % n or some sort of length but then the pop push shift came to mind and was more straight forward for me to implement. \\n\\nIt works the way I visualize the matrix to shift in the example. The element at the end of each row is popped off and unshifted to the beginning of the next. The last row wraps around to the first row with the modulo. \\n\\nMy fastest submission was 68ms - 100% \\n```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```\\n\\nMy fastest submission was 78ms -- 100% as of 4/11\\n\\n![image](https://assets.leetcode.com/users/images/794f6eed-1983-4020-8bd8-68d7cb788a37_1649695793.5833466.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934734,
                "title": "python-in-place-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven a 2D array `grid`, we want to return the array after its elements have been shifted to the right (wrapped by rows) by `k` positions.\\n\\nMany solutions involve initialising the resultant array and mapping each element in the original array to its final position in the resultant array. However, these solutions require O(mn) space (note: O(1) auxiliary space, but O(mn) space), where `m` is the number of rows in `grid` and `n` is the number of columns in `grid`.\\n\\nThis post presents an in-place solution; we are able to get the resultant array by modifying the original array. And yes, this will be done in the most optimal way possible; the time complexity for this solution is O(mn), which is comparable to many other solutions.\\n\\n---\\n\\n### Explanation\\n\\nThe main logic behind how the code operates is as follows: Upon mapping an element from its original index to its resultant index, **we will swap the element at the current index with the resultant element, and continue by finding the resultant index for the new element**. We do this until either 1) all the elements have been swapped; or 2) we reaxh the initial index. To illustrate, the following sequence is for one shift operation, i.e., `k = 1`:\\n\\n```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\\n\\nSometimes, we will end up on the initial index before all the elements have been successfully swapped. Take for example:\\n\\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\\n\\nIn such instances, **we would need to increment the initial index by 1 and continue with the next element**. Note that if we know that some elements have not yet been swapped, then we know that the element after the index has incremented by 1 has not been swapped, since if `k = 1`, all the elements would have been swapped before the initial index has been reached.\\n\\n---\\n\\n### Approach 1: GCD\\n\\nHow then do we know if the loop will reach the initial index before all elements are swapped, and how many times do we need to increment the initial index? **One way is to use the greatest common divisor (GCD) between the number of elements in `grid` and `k`, which gives us the number of times we need to increment the initial index**.\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\\n \\n **TC: O(mn)**, since each index is looped through only once.\\n Note: for time complexity of `math.gcd()`, you can read more [here](https://codility.com/media/train/10-Gcd.pdf).\\n **SC: O(1)**, as discussed previously.\\n \\n ---\\n \\n ### Approach 2: Counter\\n \\n A simpler way to determine if all elements have been swapped is to **have a counter for the number of elements that have been swapped so far**. If there are elements left to swap, increment the initial index; otherwise, return the resultant array.\\n \\n ```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```\\n\\n**TC: O(mn)**, as discussed previously.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [],
                "code": "```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\n```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431311,
                "title": "easy-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934602,
                "title": "4-liner-code-of-c-without-k-times-rotation",
                "content": "**C++ Easy Solution Without Actually Rotating Matrix K times \\n4 Liner Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n**Please Upvote and Like**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935964,
                "title": "python-o-mn-solution-explained",
                "content": "Let us create `ans` with zeroes. Then for each element we calculate where it should go and fill this element.\\n\\n#### Complexity\\nIt is `O(mn)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935910,
                "title": "just-flatten-and-rotate-the-array",
                "content": "**OBSERVATION:**\\nIf we trace the path of any number/index as we do the operation multiple times we find that the number is merely traversing the matrix row-wise. Take 1 for example and look at its path.\\n\\n1. This gives us an idea to flatten out the array and rotate it k times to get the final matrix in Row Major Order. \\n2. One other thing to notice is that after M X N number of operations, the resulting matrix is the original matrix. Hence we can update k as **`k = k % ( m * n )`.** \\n3. The rotation algorithm can be practiced from [Leetcode 189. Rotate Array](https://leetcode.com/problems/rotate-array/).\\n\\n![image](https://assets.leetcode.com/users/images/9d02625d-10dc-4598-88d5-0ae7d26efc96_1649671829.3801272.png)\\n\\n**STEPS:**\\n1. Flatten out the array.\\n2. Rotate the array k times.\\n3. Resulting list is a Row Major representation of our answer array. So convert this 1d Array to 2d Matrix.\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\\n**NOTE:** \\n**`grid = [[arr[i*n+j] for j in range(n)] for i in range(m)]`** is just a shorter way for doing the following:\\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598647,
                "title": "c-neat-easily-understandable-indented-code",
                "content": "I have used deque from the STL library.\\n\\n```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 488404,
                "title": "python-simple-o-m-n-95-100-extra-space-used",
                "content": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 433298,
                "title": "javascript-solution-with-comments",
                "content": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "solutionTags": [],
                "code": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1937275,
                "title": "c-very-easy-to-logic",
                "content": "I would suggest just dry run the code and you will get the intution.\\n\\n```class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n            for(int i=row-1;i>=1;i--)\\n            {\\n                swap(grid[i][0],grid[i-1][0]);\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1934777,
                "title": "java-easy-to-understand-explanation-iterate-and-add-as-though-a-1d-array",
                "content": "**Understanding the fundamentals**\\n\\nConsider a single dimensional array of size n :\\na[[1,2,3,4,5,6,7,8,9]. Here n = 9\\nFor instance, we have k=2 which means that the array should rotate clockwise twice,\\nthen array would become\\n[8,9,1,2,3,4,5,6,7]\\nyou would notice that there is a pattern while rotating.\\na[0] will be a[7] which can also be written as a[9 - 2 + 0]\\na[1] will be a[8], which can also be written as a[9 - 2 + 1]\\na[2] will be a[0] , which can also be written as a[9 - 2 + 2] - but a[9] is not there, so we need to do a modulus on 9 to get a[0]\\n... and so on,\\n\\nWe need to concentrate on the pivot position to arrive at the generalized formula to find the value at given index after rotation\\nIn a nutshell, if you need to rotate an array k elements in clockwise direction, you need to apply the formula\\n*a[i] = a[(n - k + i) % n] ---- > formula 1*\\n\\nSimilarly, if you need to rotate the array in anticlockwise direction, that is left shift twice in the above example, \\n\\nthe array [1,2,3,4,5,6,7,8,9] would become [3,4,5,6,7,8,9,1,2]\\nHere a[0] = a[2] which can also be written as a[(9 + 2 + 0) % 9]\\na[1] = a[3], which can also be written as a[(9 + 2 + 1)% 9]...\\nand so on,\\na[7] = a[0] which can also be written as a[(9 + 2 + 7) % 9]\\nthus, general formula in this case can be written as \\n*a[i] = a[(n + k + i ) % n]*\\n\\n**Applying 1D array rotation  logic to 2D array**\\nNow that you have understood how the array rotation in 1D array works, lets apply the logic on 2D array of size m*n;\\nHere, total number of elements would be m * n\\neach row will contain n elements\\nSo, to find out where the xth element in the 1D representation would fit in,\\n*m = x/n; --- > formula 2*\\n*n = x%n; ---- > formula 3*\\n\\nNow in the given question, you are expecting an arraylist which in turn contains arraylist representing each row,\\n\\nSo, first we create the arraylist for each row.\\n\\nNow we apply formula 1 to get the index variable value.\\n\\nThen we use formula for getting the mth arraylist to add the grid item calculated using formula 2 and formula 3.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934646,
                "title": "java-brute-froce-slow-but-intuitive",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462152,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506983,
                "title": "easy-to-follow-go-solution",
                "content": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639737,
                "title": "99-time-99-21-memory-flatten-the-matrix-and-then-use-rotate-c",
                "content": "Space and time-complexity: O(N)\\nThis algorithm is significantly fast due to fewer cache misses/crimes. \\n\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462852,
                "title": "java-99-100-17-lines-solution",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431111,
                "title": "simple-to-understand-java",
                "content": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937480,
                "title": "c-matrix-o-mxn-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936023,
                "title": "cpp-easy-manipulation-without-mod-with-intuition",
                "content": "```\\n step 1:  for k=1, store the last column in vector.\\n step 2:  take temp variable to store bottom right corner element \\n step 3:  simply right rotate every row of the \\n\\t\\t\\t matrix by 1.\\n step 4: copy temp variable to top left element.\\n step 5: copy the elements stored in vector in the first column\\n step 6: repeat the above steps k times.\\n\\t\\t\\t \\nclass Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }\\n            int temp = grid[n-1][m-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>0;j--){\\n                grid[i][j] = grid[i][j-1];\\n            }\\n        }\\n        grid[0][0] = temp;\\n        for(int r=1;r<n;r++){\\n            grid[r][0] = v[r-1];\\n        }\\n        }  \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1934599,
                "title": "python-easy-to-understand",
                "content": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "solutionTags": [],
                "code": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1934598,
                "title": "python-2-approach-with-example-shown",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660025,
                "title": "c-linear-2-pointer-in-place-solution-explained-99-time-16ms-100-space-13-7mb",
                "content": "Really funny problem; and a bit more challenge can be given to us if we try to do it in linear time and in place - is it possible to do both at once?\\n\\nI would say so; let\\'s consider the problem with a 1D array for simplicity first, assuming we have `{1,2,3,4,5,6,7}` as an array to shift by `4` positions. In order to do it linearly and in constant space, we can keep writing a value in its future place, keeping track of the previous value of the target slot and then repeat the operation over and over again with the value we stored.\\n\\nIn our example, we would have (the commented number is the one we store somewhere and write at the next round):\\n\\n```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\\n\\nA tricky part here is to notice that once the length of our array and `k` are not co-primes, we will have some loop that will NOT include all the elements as it happened before (try for example with `k` still equal to `4`, but with `8` elements to shift); we can easily fix it running our main shifting algorithm `gcd(nums.size(), k)` times, with a starting value of `0` and it will just work fine :)\\n\\nAnother optimisation trick might be to reduce `k` by the total of all the elements (shifting a grid of `100` elements by `100` will just give us the starting grid!) and, of course, to return the base grid itself for `k == 0`.\\n\\nNow, time to put all of this into code, first of all with a few support variables to help us:\\n* `w` and `h` will store the width (number of columns) and height (numbers of rows) of the grid, respectively;\\n* `tot`, computed as the product of the above variables, to store the overall number of elements;\\n* `target`, of type `div_t` (an object that will store `quot`ient and `rem`inder of a division with `div`), which will help us move later in our shifting/juggling logic.\\n\\nWe will then potentially reduce `k` to be the modulo of `tot`, and, in case it is `0`, directly `return` `grid`, as explained above.\\n\\nTime for our main loop, that will go with `i` as our starting point from `0` to `gcd(tot, k)` (excluded), using also `tmp` and `j` as loop variables; we will then:\\n* assign `i` as initial value to `j`;\\n* the result of `div(j, w)` to target, since we will have to convert our 1D example above to a 2D scenario, where each index will be converted to be the row number (`target.quot`) and the column number (`target.rem`) - in a grid of `3` rows and `4` columns, for example, the index `7` would give us `1` as a row number (the quotient) and `3` as column number (the reminder);\\n* get the initial value of `tmp`, taken as the `j`th element in our grid, using `target.quot` and `target.rem` as explained in the bullet point above;\\n* loop while`j != i` (but it is a do...while, so we will ignore the condition at the first run) and:\\n\\t* increase `j` by `k`;\\n\\t* check if `j` went over `tot`, in which case we will subtract it from `j` (which is basically equivalent of doing `j &= tot`, just way cheaper);\\n\\t* update `target` to be the current result of `div(j, w)`;\\n\\t* `swap` `tmp` and `grid[target.quot][target.rem]`.\\n\\nOnce done, we can just `return` `grid` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\nAnd since I forgot about having solved this problem already, I came up with a slightly different solution today, that I prefer somehow a bit more; also, not using modulo boosted the speed significantly:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491883,
                "title": "python-3-in-one-line",
                "content": "# Explanation\\n\\nThere is a clear one-to-one mapping for every element in the grid to its new location. We just need to figure out that mapping.. it\\'s a bit of math involving modulo and division.\\n\\nFrom grid -> shifted location:\\n```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\\nIn reverse, from shifted location -> original location:\\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\\nNote that in Python, `-1 % 3` is `2` and not `-1` like in Java / C / etc.\\n\\n# Two lines\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\\n\\n# One line\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "solutionTags": [],
                "code": "```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452350,
                "title": "straight-forward-c-with-linq",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432357,
                "title": "fast-java-with-reverse-function",
                "content": "Shift by k is equivalent with the following:\\n1. reverse whole array\\n2. reverse first subarray of k elements\\n3. reverse the remaining subarray\\n\\nCheck out similar question: https://leetcode.com/problems/rotate-array/\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516657,
                "title": "c-no-extra-memory-solution",
                "content": "This is slow, but if you want in-place (no extra memory), then this is viable solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099596,
                "title": "best-o-m-n-time-complexity-o-m-n-space-complexity-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeemed Truly Easy At First, Turned Out To Be Easier.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach Taken Is Explained Below :-\\n\\n(1) Initialise A Single Dimensional Array Of Size m*n and Pass Each Value Of The Matrix Sequentially Into The Single Dimensional Array.\\n\\n(2) Rotate The Array K Times Using The Following Algorithm :-\\n\\nStep (i) - Reverse The Entire Array\\nStep (ii) - Reverse The First K Elements (From Indexes 0 To K-1)\\nStep (iii) - Reverse The Rest of The Elements (From Indexes K To arr.length-1)\\n\\n(3) Store Each Element Of The Rotated Array In an ArrayList Of Size Equal To Number of Columns In Each Row. After Each Row, Pass The ArrayList Into an ArrayList<ArrayList<Integer>> Which Will Hold The Values Of All Rows Respectively.\\n\\n(4) Return The ArrayList<ArrayList<Integer>>.\\n\\nGood Luck!\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937545,
                "title": "python-solution-using-simple-methods-just-8-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720118,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937662,
                "title": "c-1-liner-just-for-fun",
                "content": "This is actually pretty efficient due to lazy evaluation, but admittingly not the most intuitive solution. Commented for readability.\\n\\n```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936825,
                "title": "kotlin-beats-98-april-2022",
                "content": "\\n\\tclass Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 } } \\n\\t\\t\\n        for (i in grid.indices) { \\n            for (j in grid[0].indices) {\\n                val n = (i + (j + k) / grid[0].size) % grid.size\\n                val m = (j + k) % grid[0].size\\n\\n                result[n][m] = grid[i][j]\\n            }\\n        }\\n        \\n        return result\\n    }\\n\\t}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 1936818,
                "title": "c-29ms-faster-than-80-easy-solution",
                "content": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1936444,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/924e5ed5-c56a-4f93-bfd3-5cad4ddedd6a_1649685169.9793317.png)\\n\\n```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936378,
                "title": "c-solution-runtime-160-ms-faster-than-96-00-of-c-online-submissions",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936052,
                "title": "c-time-o-n-space-o-1-explanation",
                "content": "The final solution is here. \\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\\nspace complexity O (1), time complexity O(N).  \\nN is mean rows * cols  here. \\n\\n# Explanation\\n\\nThe above solution is optimized from following code\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\\nThis code using time O(N) and space O(N). \\nAnd the idea of this code is to represent two dimension into one dimension array. \\nProcess it in. one dimension array and problem become easy. \\n\\nAnd this is a rorate array problem now. \\nThen we need to optimize this solution from this article\\nhttps://leetcode.com/problems/rotate-array/discuss/1729976/C%2B%2B-or-O(N)-or-GCD\\nIn this article, it solve rorate array problem by this way. \\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\nThen I adjust this code to become our solution.  \\nThat\\'s how I solve this problem in Time O(N) & Space O(1) in the final solution.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935848,
                "title": "convert-grid-into-1d-list-and-then-make-it-simpler",
                "content": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        Collections.rotate(temp,k);\\n        \\n        for(int j=0;j<m*n;j+=n){\\n            List<Integer> my=new ArrayList<>();\\n            for(int p=j;p<j+n;p++){\\n                my.add(temp.get(p));\\n            }\\n            ans.add(my);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935176,
                "title": "c-easy-understanding",
                "content": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1934883,
                "title": "javascript",
                "content": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756166,
                "title": "python3-simple-solution-linear-index-to-array-index",
                "content": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "codeTag": "Java"
            },
            {
                "id": 529823,
                "title": "1260-javascript-solution-with-comments",
                "content": "I tried *other* ways of doing it, but none of them seemed really *better*.\\n\\nThis isn\\'t a 1-line solution, but each operation in the solution is only 1 line.\\n\\n> Runtime: **92 ms**, faster than *100.00%* of JavaScript online submissions\\n> Memory Usage: **45.3 MB**, less than *35.62%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437060,
                "title": "python-o-1-space-rotate-virtual-1d-array",
                "content": "Assuming you already know how to rotate a 1D array by \"k\" steps in O(1) space:\\n1. Swap all elements on the left side: arr[:k], \\n2. Swap all element on the right side: arr[k:]\\n3. Swap all element in the whole array: arr[::]\\n\\nThis problem is 2D array, not 1D array. But we can solve it the same way as 1D array, just by presenting the 2D array as a \"virtual\" 1D array.\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431163,
                "title": "c-brute-force-o-k-m-n-by-storing-prev",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848373,
                "title": "easiest-solution-c-plusplus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658087,
                "title": "js-very-easy-solution",
                "content": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937545,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1937314,
                "title": "c-simple-solution",
                "content": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937282,
                "title": "python-super-simple-solution",
                "content": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "codeTag": "Java"
            },
            {
                "id": 1937050,
                "title": "two-js-solutions",
                "content": "1. Flatten the matrix and move k elements from the back to the front\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\\n2. Flatten and reverse the array, reverse the first k elements, and then reverse the rest\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936979,
                "title": "extremely-easy-and-clean-code-c-recursive",
                "content": "[](http://)\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936822,
                "title": "c-with-diagram-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8ac1f774-8ece-41ea-be5b-7f6ddfa9a71a_1649693338.3010826.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936721,
                "title": "c-simple-clean-code-with-explanation",
                "content": "\\n1. Convert (row,col) into 1d array. `index =  (currRow * number of elements in each column + currentColum)`\\n2. Now add k to index and mod it by number of elements in matrix to avoid going out of bounds. `index = (index + k) % (no of rows * no of cols)`\\n3. now we have calculated the index, we just have to convert this index to (row,col) format. `newRow = (index / no of columns)`\\nand `newCol = (index %  no of columns)`\\n4. now copy (row,col) to (newRow,newCol).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity = O(n * m)\\nSpace Complexity = O(n * m)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936433,
                "title": "c-easy-solution-explaining-similar-to-1-d-shifting-clean-code-with-explanation",
                "content": "**Solution using 1-D array Rotation Tricks in the 2-D Like we Did in *Search in 2-D Matrix* (Binary Search Solution)**\\n\\n**TC :** ***O(n x m)***\\n**SC :** ***O(1)***\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```\\n\\n**Please UPVOTE If you Like the Clear Solution With Simple Explained Intuition**\\n\\n***Thank You***\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935977,
                "title": "python-fastest-solution-using-simple-mathematical-formulation-o-n-m-time",
                "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1935716,
                "title": "c-vector-push-pop-simple-solution-explained",
                "content": "1. `` First of all I just convert the matrix into a linear vector``\\n2. `` Then the last element have inserted into the first position of the vector and poped out the last element from it``\\n3. `` Then again have made the matrix from the vector and returned it``\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1935669,
                "title": "c-simple-observation-based-solution-with-explanation",
                "content": "To solve this question we required two observations.\\n**Observation 1:-** If k is linear multiple of row(r in code) and column(c in code) than we get initial grid after shifting.Means answer after k shift=answer after k%(r*c).\\n**Observation 2:-**  At every n * c shifting(linear multiple of length of column) , we are shifting  whole row with other row.\\n\\nAfter these two observations only column shifting is remain.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935303,
                "title": "easy-c-solution-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935270,
                "title": "easy-to-understand-cpp-solution-same-concept-as-rotate-array-problem",
                "content": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935255,
                "title": "most-simplest-and-easiest-solution-c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL , PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935247,
                "title": "c-brute-force-approach-dlc-april-11",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1934978,
                "title": "simple-self-understanding-c-solution",
                "content": "If we linearly arrange all the elements of each row of a matrix , we will have an array. \\nAdd k to the current index of the array and convert that index to represent grid indices.\\n\\nA m*n matrix can be converted into an array or matrix can be represented in the form of a long array\\n\\t\\t\\tmatrix[ i ][ j ] = arr[ i*n + j ]\\nAn element in the long array of size m*n , can be taken into the form of matrix or into matrices indices using\\n\\t\\t\\tarr[ i ] = matrix[ i / n ][ i % n ];\\nTime Complexity of below code: O( m * n )\\nSpace Complexity of below code : O( m * n )\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```\\nPlease upvote if u find it helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934975,
                "title": "c-time-o-n-and-space-o-1-in-place-solution",
                "content": "It\\'s same idea as 189.rotate array, just convert to grid type!\\n\\nif we want to take the k last to the begin, we have to do 3 steps:\\n(1) rotate  whole list\\n(2) rotate the first k elements\\n(3) rotate else elements\\n\\nWe can change the position in list to grid by simply divide column number and module column number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```\\n\\nIf this solution is helpful, please upvote!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934967,
                "title": "c-simple-approach-beginner-friendly-neat-and-clean-code",
                "content": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "codeTag": "Unknown"
            },
            {
                "id": 1934551,
                "title": "python",
                "content": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934534,
                "title": "easy-to-comprehend-js-solution",
                "content": "Going backwards column wise shift one time over.\\nThen going backwards row wise move one up.\\nThats one rotation.\\nThen increment down k, do that however many times.\\nThere can be probably be a check for k where it would return the same solutions if its a a certian mod of a the size of the \\ngrid.\\n```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615647,
                "title": "java-easy-to-understand-using-modulo-arithmetic",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451785,
                "title": "c-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419979,
                "title": "ez-solution-c-single-loop-sanyam-shah",
                "content": "# EZ Solution C++\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269002,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/81a94899-35d9-4f72-abdf-cc0d37ae83e6_1623567794.6917243.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144081,
                "title": "c-solution",
                "content": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015725,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008659,
                "title": "using-k-rotations-on-1d-vector-o-m-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910356,
                "title": "python-deque-rotate",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883235,
                "title": "simple-python-solution-which-beats-99-84-of-submissions-by-using-the-deque-object",
                "content": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594791,
                "title": "easy-java-solution",
                "content": "This problem has horrible return type for java! I guess in-place way would be simpler than returning List<List<>>.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552572,
                "title": "c-one-pass-solution-2-d-array-to-1-d-array",
                "content": "**1-dimensional array index to 2-dimensional array index**\\nFor a given 1-dimensional array element **array[i]**, the corresponding row and column in 2-dimensional array will be **(i / n)** and **(i % n)**, where n is the number of columns of the 2-dimensional array. \\n\\n**2-dimensional array index to 1-dimensional array index**\\nFor a given  2-dimensional array element **array[i][j]**, the corresponding index of 1-dimensional array will be **(i * n + j)** , where n is the number of columns of the 2-dimensional array. \\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\nApproach 2: Reverse\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466350,
                "title": "concise-o-m-n-rust-solution",
                "content": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437034,
                "title": "three-solutions-in-python-3-two-lines-beats-98",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 433799,
                "title": "java-100-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431470,
                "title": "python-4-lines-beat-100-speed-and-space-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/koten0224/image_1573995656.png)\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918501,
                "title": "easy-c-solution-easy-to-understand-simple-clean-code-with-explanationeasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the last column into a vector\\n2. Move the values of (i-1) th column to i th column\\n3. Move the element at grid[m - 1][n - 1] to grid[0][0] from \"tmp\"\\n4. Replace the rest of the column-1 with the stored values from \"tmp\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3075497,
                "title": "beats-99-43-python3",
                "content": "# Approach\\nFirst of all accessing each list of grid through index, popping the last element and inserting it to the starting of next list. \\n\\nFinally, accessing the last list popping the last element and inserting it to the first list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689101,
                "title": "o-1-space-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446323,
                "title": "no-extra-space-taken-in-place-time-k-o-n-m-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444389,
                "title": "js-two-solutions-offset-in-place-runtime-83-58-memory-98-51",
                "content": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\\n\\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440236,
                "title": "c-solution-beats-96-21-of-cpp-submissions",
                "content": "The problem is similar to right rotating a 1d array k times. We can implement the same in this problem. Reverse the last k elements of the flattened version of the input array, and reverse the first n-k elements of the input array.  Then Reverse the whole 2d array. This solution does the job in-place.\\n\\n```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023525,
                "title": "c-flatten-rotate-locate",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941495,
                "title": "c-clean-code-simple-concise-easy",
                "content": "**Runtime: 16 ms**\\n***Faster than 90% solution in c++***\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937791,
                "title": "python-pop-insert-in-next-row",
                "content": "Remove the last element in each row and insert it at the beggining of the next row. \\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937731,
                "title": "c-simple-solution-with-explanation-o-n-m-100-faster",
                "content": "The idea is to map the two dimensional array position to a postion in an imaginary one dimensional array from (0 to m*n -1).\\nIt can be done with i * n + j. \\nThen sum k to get the 1d array new position and get module to avoid having a number greater than the max length of the imaginary 1d array.\\nLast, convert the 1d new position to the 2d array postions with the x = newPosition/n and y = newPosition%n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/236a29de-fbe5-48ac-847c-01a10f7994fa_1649719535.5562575.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937678,
                "title": "python-3-inplace-triple-reverse-doug-mcilroy-and-gcd-solutions",
                "content": "Straightforward solution is very boring, how could we do that inplace?\\n\\nAnother boring thing is Programming Pearls solution (page 33) aka triple reverse (by Doug Mcilroy). Even if it\\'s 1D you can easlily remap it to 2D grid:\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\\n\\nIt\\'s very suboptimal though, because you have to address every element at least twice not counting the swaps. There\\'s an optimal solution that works in O(n) for 1D, or O(n x m) for 2D grid mentioned here: https://stackoverflow.com/questions/876293/fastest-algorithm-for-circle-shift-n-sized-array-for-m-position\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937599,
                "title": "javascript-neat-3-methods-flat-flat-in-place-in-place",
                "content": "## 1. Flat\\nComplexity: time **O(3mn)**, extra space **O(2mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 2. Flat In Place\\nComplexity: time **O(4mn)**, extra space **O(mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 3. In Place\\nComplexity: time **O(2mn)**, extra space **O(1)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937582,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1937552,
                "title": "kotlin-100-time-and-space-easy-solution-with-explanation",
                "content": "At first, I was trying an approach where I calculate a toRow and toCol, but had difficulty getting them right without a paper and pencil.  Then I realized it\\'s much easier to just have a one-dimensional array for the elements, start at the kth position (called \"to\"), and just copy the items from the beginning of the grid to \"to\" and keep incrementing \"to\" by 1.\\n\\n\"to\" starts at k % size (# of rows * # of columns), which automatically makes is zero-based.  To save time, the first check is to see if k % size is 0, in which case nothing needs to be shifted, just turn the rows into lists and add them to the output list, and return.\\n\\nThe second speed saving is if the size of each row is 1.  In that case, still create an output array the size of the grid and copy the items in, starting at to, always column 0 in th grid.  Then, each item is its own list, so go through the array and add each one as a list, and return.\\n\\nWhenever \"to\" reaches the end of the list ( == size), reset to 0.\\n\\nFinally, starting at the begining of the output grid (to = 0), create a new list for each row, and add column number of items to the list, and then add that list to the out list.\\n\\n```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937526,
                "title": "golang-o-1-space",
                "content": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937511,
                "title": "python-short-functional-programming-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937476,
                "title": "rust-rotate-in-place-same-as-189-rotate-array",
                "content": "The \"shift\" steps describe how to \"rotate\" a 1-D array by 1 element to the right by using its 2-d representation. Take the first example - if we convert the 2D matrix to 1D array:`[[1,2,3],[4,5,6],[7,8,9]] => [1,2,3,4,5,6,7,8,9]` and then rotate the 1D array by 1 element to the right we will get `[9, 1,2,3,4,5,6,7,8]` and then in order to get the answer we have to convert it back to a 2D representation: `[[9,1,2],[3,4,5],[6,7,8]]` \\n\\nIf we execute the steps of the \"shift\" algorithm we find out that it actually shifts all cells by 1 to the right. So doing the \"shift\" operation K times is equivalient to shiftingk by K positons only once. \\n\\nFrom  [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md) we have already learned how to rorate (shift) a 1D array. We just have to apply that knowledge by extending it to a 2D array. This can be done by finding out how to go from 1D index, to a 2D index and vice cersa:\\n\\n* The formula to convert from 2D index to 1D index is `row * columns + column`\\n* The formula to convert from 1D index to 2D index is:\\n    * `row = index / columns`\\n    * `col = index % columns`\\n\\n\\n\\nNow we know that we can go from 2D to 1D matrix, rotate it, and then go back to 2D matrix.This means that we can use the same approach as in [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md):\\n\\n```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937433,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937377,
                "title": "c-easy-solution-using-extra-and-without-extra-space",
                "content": "**Method 1:**\\nTime Complexity : O(n*m)\\nSpace Complexity : O(m*n)\\n\\n\\n```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\\n\\n**Method 2:\\nTime Complexity: O(n*m*k)**\\n**Space Complexity : O(k)**\\n\\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937351,
                "title": "c-2-approach-with-extra-space-without-extra-space",
                "content": "**First Approach :** Without extra space (Optimal Solution)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\\n\\n**Second Approach :** Here extra space used and call the recursion for k-1 steps.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\\n\\nIf anyone didn\\'t understand how  the recursion works they can understand the concept by the below code.\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937324,
                "title": "c-clean",
                "content": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937312,
                "title": "c-solution-no-extra-space-hard-solution",
                "content": "Maybe the hardest solution but I found this approach a little intresting....\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                    else{\\n\\t\\t\\t\\t\\t\\n                        prev=grid[i][j];\\n                        grid[i][j]=temp;\\n                        temp=prev;\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n\\t\\t\\t\\t\\n                else{\\n\\t\\t\\t\\t\\n                    prev=grid[i][j];\\n                    grid[i][j]=temp;\\n                    temp=prev;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n           \\t}\\n\\t\\t\\t\\n            k--;\\n\\t\\t\\t\\n        }\\n\\t\\t\\n        return grid;      \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1937310,
                "title": "simple-code-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }\\n        }\\n        int k1=k;\\n      \\n        k=k%(m*n);\\n           for(int j=v.size()-1; j>=v.size()-k; j--)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n        reverse(ans.begin(),ans.end());\\n        for(int j=0; j<v.size()-k; j++)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n         \\n        int j=1;\\n        vector<int>v3;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(j%m==0)\\n            {   v3.push_back(ans[i]);\\n                res.push_back(v3);\\n                v3.clear();\\n            }\\n            else\\n                v3.push_back(ans[i]);\\n            j++;\\n            \\n            \\n        }\\n              \\n     return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1937228,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic static void shift(int[][] grid) {\\n\\t\\tList<Integer> lastElements = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tlastElements.add(grid[i][grid[i].length - 1]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\n\\t\\t\\tfor (int j = grid[i].length - 1; j > 0; j--) {\\n\\t\\t\\t\\tgrid[i][j] = grid[i][j - 1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tif (i != grid.length - 1)\\n\\t\\t\\t\\tgrid[i + 1][0] = lastElements.get(i);\\n\\n\\t\\tgrid[0][0] = lastElements.get(lastElements.size() - 1);\\n\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1937118,
                "title": "c-easy-understanding-algorithm-explanation",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* **Store all the values** in a **vector** temporary\\n\\n* Then maintain the **order that vector** \\n* Put **k values at the start from behind**\\n* Then after maintaining the order **make the pairs** according to the **size of column** \\n* after storing just **return** that \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937111,
                "title": "clean-code-c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937107,
                "title": "c-simple-solution-single-traversal-m-n-extra-to-make-new-matrix",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937009,
                "title": "java-easy-beginner-less-complexity-based-on-o-1-space-solution",
                "content": "If you are familiar with [RotateArray](https://leetcode.com/problems/rotate-array/submissions/) and  [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) this is using concept of both .\\n\\njust assuming matrix as 1D array using arr[i/lenOfRow][i%lenOfRow] and reverse the array and fill the matrix into arraylist and return \\nTC:O(N*M)    SC:O(1)\\nComment if needed improvements ;)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936874,
                "title": "java-faster-than-98-right-rotation-of-array",
                "content": "**Flatten 2D Array to 1D Array and apply right rotation. Then convert back to 2D Array.**\\n\\n```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936841,
                "title": "c-90-faster-41-space-8-lines",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936727,
                "title": "js-modulo-arithmetic-no-stdlib-methods-faster-than-98",
                "content": "This solution is based on a circular list approach, where we \"connect\" the end to the beginning. Knowing dimensions of a matrix, we can work with it as a 1-dimensional array, where iterating all elements looks like `rowIndex * rowSize + columnIndex`. This also means that given an element index `i`, we can find row and column indices - `rowIndex = i / rowSize` (as an integer), `columnIndex = i mod rowSize`.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```\\n\\nI\\'m new to Leetcode and I don\\'t understand how performance measurement works but the best run was **80ms with 47MB** of memory used, which is **faster than 98.7% and takes less memory than 93.51%** of solutions at the time of submission.",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936571,
                "title": "js-time-o-mn-space-o-1-in-place-operations",
                "content": "The main idea of the solution is to count greatest common divisor between number of shifts we need to make and the total amount of elements. gcd here will show us the number of operations, before our algorithm starts to cycle. After each cycle we will start to proceed the remaining elements. And so on.\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(1)\\nFeature: In-place",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936568,
                "title": "a-in-place-solution",
                "content": "It consists of two concepts:\\n1. In-place array shifting/rotating can be decomposed into 3 reverse operations.\\n\\te.x.\\n\\t\\t[1, 2, 3, 4, 5] right rotate 2  => [4, 5, 1, 2, 3]\\n\\tequals to \\n\\t\\t[1, 2, 3, 4, 5] reverse  =>  [5, 4, 3, 2, 1] reverse first 2  => [<u>4, 5</u>, 3, 2, 1] reverse rest of the elements  =>  [4, 5, <u>1, 2, 3</u>]\\n2. The coordinate conversion between 1D and 2D can be achieved by \\'/\\' and \\'%\\' operators with the width n of the 2D matrix.\\n```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936555,
                "title": "c-3-approaches-in-decreasing-order-of-intuitiveness",
                "content": "### **Approach 1:** Brute Force Shifting using temp matrix\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 2:** Convert Matrix to 1-D Array (Brute Force)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 3:** Calculate New Position of each element(Better Version of Approach 2)\\nFor an M*N matrix \\\\-\\n- 1-D index for [i, j] = `i*N + j`\\n- Shift 1-D index : `index = (index+k)%(M*N)`\\n- Calculate shifted 2-D coordinates : `[index/N, index%N]`\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936534,
                "title": "simple-python-using-deque",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936475,
                "title": "python3-shifting-in-2d-simple",
                "content": "Here I have shifted in 2D List in an extended manner (without using any list comprehension or one liner). It can also be done in shorter and more efficient manner.\\n**Logic:** Pop the last element from each sub list and insert it at 0 index in another sub list and for last sub list pop the last element and insert it at 0 index in first sub list.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```\\n**Please upvote if the solution helps**\\n**Feel free to ask any question**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936463,
                "title": "c-solution-basic-optimized",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++)temp[i+1][0]=grid[i][n-1];\\n            temp[0][0]=grid[m-1][n-1];\\n            grid=temp;\\n        }\\n        return temp;\\n    }\\n};\\n(Optimized)\\nClass Solution {\\npublic:\\n    \\n\\tvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n\\t          {   \\n\\t        int m=grid.size();\\n            int n=grid[0].size();\\n           vector<vector<int>>temp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                temp[(i+(j+k)/n)%m][(j+k)%n]=grid[i][j];\\n        }\\n        return temp;\\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1936392,
                "title": "python-flatten-array-and-convert-back-2d",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936366,
                "title": "python-simple-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936342,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936218,
                "title": "python-very-easy-o-1-space",
                "content": "**Solution 1**\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(N*M)```\\n***\\n\\n\\n**Solution 2**\\nSame approach as this question  [Click](https://leetcode.com/problems/rotate-array/)\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(N*M)```\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1936191,
                "title": "c-o-1-space-solution",
                "content": "# **Non Constant Space Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n# **O(1) Space Solution**\\nThe Testcase: \\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\\n**The Explanation:**\\nThe idea is simple, let\\'s assume that the given array grid is 1D array, to rotate it, we will just need to do 3 reverse operations:\\n1. reverse the whole array:\\n2. reverse the values before k [0, k - 1]\\n3. reverse the values from k to the end [k, n * m - 1]\\n\\nAfter the first reverse operation (reverse the whole array):\\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAfter the second reverse operation (reverse the values before k):\\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAnd finally, after the third operation (reverse the values from k to the end) we get:\\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\\nWhich is the right answer!\\n\\nHere is the **implementation**: \\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```\\n\\n**Hope it helped! Your Upvote can make my day :D**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936181,
                "title": "daily-leetcoding-challenge-april-day-11-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n            for(int i=0;i<k;i++){\\n                a = v[m*n - 1];\\n                v.pop_back();\\n                v.insert (v.begin(), a);\\n            }\\n            int x = 0;\\n            for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j] = v[x];\\n                x++;\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936143,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936041,
                "title": "c-100-faster-than-all-bruteforce-single-pass-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1936035,
                "title": "daily-challenge-11-04-2022-faster-than-99-solution",
                "content": "The trick is to make a function for shifting grid by 1 position.\\nAfter that is done, just run a loop K times calling that function and return the answer!\\n\\n```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935927,
                "title": "c-o-m-n",
                "content": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935923,
                "title": "171ms-solution-easiest-explanation-python",
                "content": "The trickiest part in this problem is to handle the edge elements. If the value is at the last column of a row, then we have to shift it to the first column of the next row. Interestingly using this approach is the key to this problem.\\n\\n---\\nLet\\'s only focus on a matrix of two rows for now.\\n\\nWhat we need to do is \\'pop\\' the element from the second row and \\'insert\\' it at the first index of the first row.\\nNow if `m` is the number of elements in a row(or columns in the matrix), then after this operation the first row has `m+1` elements and the second row has `m-1` elements.\\nBut we still have to `pop` the last element of the first row and insert it the `0`<sup>th</sup> index of the second one to complete the iteration.\\nOn doing this operation, both our rows have the same number of elements, `m`, and our matrix is successfully shifted by one.\\n\\nWe need to repeat this cycle `k` times to arrive at the expected output.\\nFor a generalized solution for matrices with more than 2 rows, check out the well-documented python code below.\\n\\n---\\n**Time Complexity: O(kmn)** where **k** is the number of elements, **m** is the number of columns and **n** is the number of rows\\n\\n**Space Complexity: O(1)** as no extra space is required\\n\\n*Do upvote if you found the explanation deserving enough. Thanks for reading!*\\n\\n---\\nPython code:\\n```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1935919,
                "title": "simple-solution-c",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935728,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935704,
                "title": "c-simplest-solution-convert-to-1d-array",
                "content": "**Time Complexity :** ```O(m*n)```\\n\\n**Space Complexity :** ```O(m*n)```\\n\\n\\n**APPROACH :**\\n\\n* Convert the array into a 1D array ```v```.\\n\\n* Reverse the array from index ```0``` to index ```v.size() - k - 1```.\\n\\n* Then reverse the array from index ```v.size() - k``` to ```v.size() - 1```.\\n\\n* Then reverse the whole array.\\n\\n** ( Do a dry run on 1 of the examples to understand)\\n\\n**Code :**\\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**Do upvote if you like my solution :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```O(m*n)```\n```O(m*n)```\n```v```\n```0```\n```v.size() - k - 1```\n```v.size() - k```\n```v.size() - 1```\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935646,
                "title": "easy-c-o-k-m-n-solution",
                "content": "**Algorithm**\\n\\n* Preserve the last index element.\\n* copy all index to their next\\n* Copy the saved last element to first\\n* Apply a set of if-else blocks for boundary conditions\\n* Repeat the above 3 steps k times.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935613,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }\\n        }\\n        \\n        List<Integer> a = new ArrayList();\\n        for(int i=0;i<total;i++){\\n            a.add(ans[i]);\\n            if(a.size() == n){         \\n                System.out.println(a);\\n                list.add(a);\\n                a = new ArrayList();\\n            } \\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935549,
                "title": "c-reversal-algorithm-to-rotate-an-array",
                "content": "**Optimal Approach (Reversal Algorithm)**\\n```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```\\n**Time - O(M.N)\\nSpace - O(1)**\\n\\n`As we are changing our input matrix loss of information happens, to prevent that we can make another \\'ans\\' matrix and in this case the space complexity would be O(M.N)`\\n\\n*NB: If I could help you a little consider upvoting the solution and comment your doubts and thoughts for this problem*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566057,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2012899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753271,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739733,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]