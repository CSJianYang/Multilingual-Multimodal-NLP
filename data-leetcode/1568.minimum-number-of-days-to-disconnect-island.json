[
    {
        "title": "Minimum Number of Days to Disconnect Island",
        "question_content": "You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.\nThe grid is said to be connected if we have exactly one island, otherwise is said disconnected.\nIn one day, we are allowed to change any single land cell (1) into a water cell (0).\nReturn the minimum number of days to disconnect the grid.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 2\nExplanation: We need at least 2 days to get a disconnected grid.\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n\nExample 2:\n\nInput: grid = [[1,1]]\nOutput: 2\nExplanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 30\n\tgrid[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 819303,
                "title": "python-you-need-at-most-2-days",
                "content": "The tricky part of this question is to notice that, you can disconnect any given island formation in at most 2 days (and you need to convince yourself that this is true).\\nExample: Imagine we have 30-by-30 array of all 1\\'s. For the top left corner, just remove the one to the right and below. And you are done.\\n\\n**Day 0:** Check islands at day 0, return 0 if you have less than or greater than one island.\\n\\n**Day 1**: If not, try to add water at any given location, and check if that gives you a valid island formation.\\n\\n**Day 2:** Else, just return 2!\\n\\n```\\nimport copy\\nclass Solution:\\n\\t#this is just a helper function for the no_islands function below\\n    def no_islands_recur(self, grid, i, j, m, n):\\n        if grid[i][j]==0:\\n            return\\n        grid[i][j]=0\\n        if i-1>=0:\\n            self.no_islands_recur(grid, i-1, j, m, n)\\n        if i+1<m:\\n            self.no_islands_recur(grid, i+1, j, m, n)\\n        if j-1>=0:\\n            self.no_islands_recur(grid, i, j-1, m, n)\\n        if j+1<n:\\n            self.no_islands_recur(grid, i, j+1, m, n)\\n    \\n\\t\\n    #find how many islands the given grid has        \\n    def no_islands(self, grid):\\n        ret = 0\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    ret += 1\\n                    self.no_islands_recur(grid, i, j, m, n)\\n        return ret\\n    \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        #if we have 0 or more than 1 islands at day 0, return day 0\\n        time = 0\\n        grid_copy = copy.deepcopy(grid)\\n        n = self.no_islands(grid_copy)\\n        if n!=1:\\n            return time\\n        \\n\\t\\t#try to remove any land any see if it works\\n        time = 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid_copy = copy.deepcopy(grid)\\n                grid_copy[i][j] = 0\\n                n = self.no_islands(grid_copy)\\n                if n!=1:\\n                    return time\\n        \\n\\t\\t#well then just return 2\\n        time = 2\\n        return time\\n```\\n\\n**Edit:** I sincerely appreciate all the kindness in the comments. One thing I noticed time over time, over the solutions of many amazing people here, when a problem looks too difficult to be solved, often there is a catch that lands itself to easy coding. For this one it was the limited number of iterations one would need. So overall it might be a good strategy to think about this, which can save time and coding effort.",
                "solutionTags": [],
                "code": "```\\nimport copy\\nclass Solution:\\n\\t#this is just a helper function for the no_islands function below\\n    def no_islands_recur(self, grid, i, j, m, n):\\n        if grid[i][j]==0:\\n            return\\n        grid[i][j]=0\\n        if i-1>=0:\\n            self.no_islands_recur(grid, i-1, j, m, n)\\n        if i+1<m:\\n            self.no_islands_recur(grid, i+1, j, m, n)\\n        if j-1>=0:\\n            self.no_islands_recur(grid, i, j-1, m, n)\\n        if j+1<n:\\n            self.no_islands_recur(grid, i, j+1, m, n)\\n    \\n\\t\\n    #find how many islands the given grid has        \\n    def no_islands(self, grid):\\n        ret = 0\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    ret += 1\\n                    self.no_islands_recur(grid, i, j, m, n)\\n        return ret\\n    \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        #if we have 0 or more than 1 islands at day 0, return day 0\\n        time = 0\\n        grid_copy = copy.deepcopy(grid)\\n        n = self.no_islands(grid_copy)\\n        if n!=1:\\n            return time\\n        \\n\\t\\t#try to remove any land any see if it works\\n        time = 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid_copy = copy.deepcopy(grid)\\n                grid_copy[i][j] = 0\\n                n = self.no_islands(grid_copy)\\n                if n!=1:\\n                    return time\\n        \\n\\t\\t#well then just return 2\\n        time = 2\\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819296,
                "title": "dfs-c-clean-code-with-explanation",
                "content": "# Observation\\n## **ans <= 2**\\nans is always less-equal to 2\\n## **why?**\\nfor any island we can remove the two blocks around the bottom left corner to make it disconnected\\n```\\nx x x\\nx . x\\nx x x\\n```\\ncan be changed to\\n```\\nx x x\\nx . .\\nx . x\\n```\\nif you still don\\'t get it read this: [comment](https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819296/DFS-c++-clean-code-with-explanation/679802)\\nwe need to check for only when ans is 1 or 0\\n## **ans = 1**\\nwe remove a block and check if it disconnects the islands\\n## **ans = 0**\\nwe check if there are > 1 islands already\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```\\n### Time Complexity: O((m*n)^2)",
                "solutionTags": [],
                "code": "```\\nx x x\\nx . x\\nx x x\\n```\n```\\nx x x\\nx . .\\nx . x\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819342,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        if(noOfIsland(grid) != 1){\\n            return 0;\\n        }\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(noOfIsland(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int noOfIsland(int [][]grid){\\n        int ans = 0;\\n        boolean [][]visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    ans ++;\\n                    dfs(visited, grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(boolean [][]visited, int [][]grid,int i, int j){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0){\\n            return ;\\n        }\\n        visited[i][j] = true;\\n        dfs(visited, grid, i-1, j);\\n        dfs(visited, grid, i+1, j);\\n        dfs(visited, grid, i, j-1);\\n        dfs(visited, grid, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        if(noOfIsland(grid) != 1){\\n            return 0;\\n        }\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(noOfIsland(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int noOfIsland(int [][]grid){\\n        int ans = 0;\\n        boolean [][]visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    ans ++;\\n                    dfs(visited, grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(boolean [][]visited, int [][]grid,int i, int j){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0){\\n            return ;\\n        }\\n        visited[i][j] = true;\\n        dfs(visited, grid, i-1, j);\\n        dfs(visited, grid, i+1, j);\\n        dfs(visited, grid, i, j-1);\\n        dfs(visited, grid, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819277,
                "title": "python-golang-there-are-only-3-possible-answers",
                "content": "\\n## Idea\\n**How to make the grid disconnected?**\\nWe can tell from the first official example that, the worst situation we may get into is to take 2 steps and separate a single island out.\\nMore specifically, there are 3 situation.\\n1. The number of island on the grid is not 1.\\n\\t- return 0\\n1. The number of island on the grid is 1, and we can break them into 2 islands within 1 step.\\n\\t- return 1\\n1. The number of island on the grid is 1, and we cannot break them into 2 islands within 1 step.\\n\\t- return 2, because no matter what, we can always separate 1 island out within 2 steps\\n\\n\\n**How to count the number of islands on the grid**\\nThere are many different ways like DFS, Union Find. I use union find here.\\n\\n## Complexity\\n- Time: O(n^4)\\n- Space: O(n^2)\\n\\n## Python\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def countIsland():\\n            roots = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n            def find(i):\\n                if roots[i] != i: roots[i] = find(roots[i])\\n                return roots[i]                    \\n            \\n            def unite(i, j):\\n                roots[find(i)] = find(j)\\n                \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]:\\n                        if i < m - 1 and grid[i + 1][j]:\\n                            unite((i, j), (i + 1, j))\\n                        if j < n - 1 and grid[i][j + 1]:\\n                            unite((i, j), (i, j + 1))\\n            return len(set(find((i, j)) for i in range(m) for j in range(n) if grid[i][j]))                            \\n        \\n        if countIsland() != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countIsland() != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n```\\n\\n## Golang\\n```\\nimport \"fmt\"\\n\\nfunc minDays(grid [][]int) int {\\n    if countIslands(grid) != 1 {\\n        return 0\\n    }\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                grid[i][j] = 0\\n                if countIslands(grid) != 1 {\\n                    return 1\\n                }\\n                grid[i][j] = 1\\n            }\\n        }\\n    }\\n    return 2\\n}\\n\\nvar roots [][][2]int\\n\\nfunc countIslands(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n    roots = make([][][2]int, m)\\n    for i := range grid {\\n        roots[i] = make([][2]int, n)\\n        for j := range roots[i] {\\n            roots[i][j] = [2]int {i, j}\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                if i < m - 1 && grid[i + 1][j] == 1 {\\n                    unite(i, j, i + 1, j)\\n                }\\n                if j < n - 1 && grid[i][j + 1] == 1 {\\n                    unite(i, j, i, j + 1)\\n                }\\n            }\\n        }\\n    }\\n    set := make(map[int]bool)\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                tmp := find(i, j)\\n                set[tmp[0] * n + tmp[1]] = true\\n            }\\n        }\\n    }\\n    return len(set)\\n}\\n\\nfunc find(i, j int) [2]int {\\n    if roots[i][j] != [2]int {i, j} {\\n        tmp := roots[i][j]\\n        roots[i][j] = find(tmp[0], tmp[1])\\n    }\\n    return roots[i][j]\\n}\\n\\nfunc unite(xi, xj, yi, yj int) {\\n    x := find(xi, xj)\\n    roots[x[0]][x[1]] = find(yi, yj)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def countIsland():\\n            roots = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n            def find(i):\\n                if roots[i] != i: roots[i] = find(roots[i])\\n                return roots[i]                    \\n            \\n            def unite(i, j):\\n                roots[find(i)] = find(j)\\n                \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]:\\n                        if i < m - 1 and grid[i + 1][j]:\\n                            unite((i, j), (i + 1, j))\\n                        if j < n - 1 and grid[i][j + 1]:\\n                            unite((i, j), (i, j + 1))\\n            return len(set(find((i, j)) for i in range(m) for j in range(n) if grid[i][j]))                            \\n        \\n        if countIsland() != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countIsland() != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n```\n```\\nimport \"fmt\"\\n\\nfunc minDays(grid [][]int) int {\\n    if countIslands(grid) != 1 {\\n        return 0\\n    }\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                grid[i][j] = 0\\n                if countIslands(grid) != 1 {\\n                    return 1\\n                }\\n                grid[i][j] = 1\\n            }\\n        }\\n    }\\n    return 2\\n}\\n\\nvar roots [][][2]int\\n\\nfunc countIslands(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n    roots = make([][][2]int, m)\\n    for i := range grid {\\n        roots[i] = make([][2]int, n)\\n        for j := range roots[i] {\\n            roots[i][j] = [2]int {i, j}\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                if i < m - 1 && grid[i + 1][j] == 1 {\\n                    unite(i, j, i + 1, j)\\n                }\\n                if j < n - 1 && grid[i][j + 1] == 1 {\\n                    unite(i, j, i, j + 1)\\n                }\\n            }\\n        }\\n    }\\n    set := make(map[int]bool)\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                tmp := find(i, j)\\n                set[tmp[0] * n + tmp[1]] = true\\n            }\\n        }\\n    }\\n    return len(set)\\n}\\n\\nfunc find(i, j int) [2]int {\\n    if roots[i][j] != [2]int {i, j} {\\n        tmp := roots[i][j]\\n        roots[i][j] = find(tmp[0], tmp[1])\\n    }\\n    return roots[i][j]\\n}\\n\\nfunc unite(xi, xj, yi, yj int) {\\n    x := find(xi, xj)\\n    roots[x[0]][x[1]] = find(yi, yj)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819428,
                "title": "c-at-most-2-removal-try-removing-each-one-and-see-if-the-graph-is-disconnected",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nYou need at most two days to separate out a `1` at the corner with all other `1`s. So the answer is one of `0`, `1`, `2`.\\n\\nIf the graph is already disconnected, return `0`.\\n\\nFor each `1`, see if removing it can disconnect the graph. If yes, then return `1`.\\n\\nOtherwise return `2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n// Author: github.com/lzl124631x\\n// Time: O((MN)^2)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    void dfs(vector<vector<int>> &G, int i, int j,vector<vector<int>> &seen) {\\n        seen[i][j] = true;\\n        for (auto &[dx, dy] : dirs) {\\n            int x = dx + i, y = dy + j;\\n            if (x < 0 || x >= M || y < 0 || y >= N || G[x][y] != 1 || seen[x][y]) continue;\\n            dfs(G, x, y, seen);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>> &G) {\\n        vector<vector<int>> seen(M, vector<int>(N, false));\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1 || seen[i][j]) continue;\\n                if (++cnt > 1) return true;\\n                dfs(G, i, j, seen);\\n            }\\n        }\\n        return cnt == 0;\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& G) {\\n        M = G.size(), N = G[0].size();\\n        if (disconnected(G)) return 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1) continue;\\n                G[i][j] = 0;\\n                if (disconnected(G)) return 1;\\n                G[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n// Author: github.com/lzl124631x\\n// Time: O((MN)^2)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    void dfs(vector<vector<int>> &G, int i, int j,vector<vector<int>> &seen) {\\n        seen[i][j] = true;\\n        for (auto &[dx, dy] : dirs) {\\n            int x = dx + i, y = dy + j;\\n            if (x < 0 || x >= M || y < 0 || y >= N || G[x][y] != 1 || seen[x][y]) continue;\\n            dfs(G, x, y, seen);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>> &G) {\\n        vector<vector<int>> seen(M, vector<int>(N, false));\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1 || seen[i][j]) continue;\\n                if (++cnt > 1) return true;\\n                dfs(G, i, j, seen);\\n            }\\n        }\\n        return cnt == 0;\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& G) {\\n        M = G.size(), N = G[0].size();\\n        if (disconnected(G)) return 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1) continue;\\n                G[i][j] = 0;\\n                if (disconnected(G)) return 1;\\n                G[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821143,
                "title": "java-o-mn-2ms-articulation-point-bridge-approach",
                "content": "All the posted solutions are using the similar basic flow: \\n1. If there is no island or more than 1 island, return 0;\\n2. If there is only one land, return 1;\\n3. If any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n4. Otherwise, return 2 ( I haven\\'t found a formal proof yet).\\n\\nThe major difference is how to find single cut point. Solutions like BFS/DFS/UnionFind all have to try each and every land cell, resulting in **O(M^2N^2)** worst case time complexity. We could use Tarjan\\'s algorithm to find the articulation point with **O(MN)** time complexity(https://en.wikipedia.org/wiki/Biconnected_component). It\\'s similar to my original bridge solution, except that it\\'s shorter and more intuitive.\\n\\n```\\nclass Solution {\\n    boolean ap; //articulation point\\n    int time; //visit time\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        ap = false;\\n        time = 0;\\n        int lands = 0, islands = 0;\\n        int[][] depth = new int[n][m];\\n        int[][] low = new int[n][m];\\n        int[][] parent = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(depth[i], -1);\\n            Arrays.fill(low[i], -1);\\n            Arrays.fill(parent[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    lands++;\\n                    if (depth[i][j] == -1) {\\n                        apDFS(grid, i, j, depth, low, parent);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (islands == 0 || islands >= 2) return 0;\\n        if (lands == 1) return 1;\\n        if (ap) return 1;\\n        return 2;\\n    }\\n\\n    private void apDFS(int[][] grid, int i, int j, int[][] depth, int[][] low, int[][] parent) {\\n        int n = grid.length, m = grid[0].length;\\n        depth[i][j] = time++;\\n        low[i][j] = depth[i][j];\\n        int children = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (depth[ni][nj] == -1) {\\n                    children++;\\n                    parent[ni][nj] = i*m + j;\\n                    apDFS(grid, ni, nj, depth, low, parent);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] >= depth[i][j] && parent[i][j] > -1) {\\n                        ap = true;\\n                    }\\n                } else if (ni*m + nj != parent[i][j]) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], depth[ni][nj]);\\n                }\\n            }\\n        }\\n        if (parent[i][j] == -1 && children > 1) {\\n            ap = true;\\n        }\\n    }\\n}\\n```\\n\\n#### Original bridge solution\\n<details>\\n  <summary>Click to expand!</summary>\\nHere is a solution using Tarjan\\'s algorithm to find the bridge in **O(MN)** time. See [**here**](https://stackoverflow.com/questions/28917290/how-can-i-find-bridges-in-an-undirected-graph) for details. \\n\\nOne minor difference between our solution and the original algorithm (https://algs4.cs.princeton.edu/41graph/Bridge.java.html) is: we\\'re not trying to cut the connection (the boundary between cells with value 1), we\\'re trying to cut a cell, which might have 4 connections. So it\\'s not done when we find a bridge, we also need to make sure either cell of the bridge has other connections. E.g. in case of `[[1,1]]`, we do have a bridge, but removing either cell of the bridge doesn\\'t make it 2 islands.\\n\\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int c = getIslands(grid);\\n        if (c == 0 || c >= 2) return 0;\\n        if (hasOneLand(grid)) return 1;\\n        if (hasBridge(grid)) return 1;\\n        return 2;\\n    }\\n\\n    private boolean hasOneLand(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && ++c > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return c == 1;\\n    }\\n\\n    boolean found = false;//whether there\\'s a bridge\\n    int cnt = 0;//node dfs visit sequence number\\n    private boolean hasBridge(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        found = false;\\n        cnt = 0;\\n        int[][] pre = new int[n][m];\\n        int[][] low = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(pre[i], -1);\\n            Arrays.fill(low[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && pre[i][j] == -1) {\\n                    bridgeDFS(grid, i, j, i, j, pre, low);\\n                    if (found) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     *\\n     * @param i1 from row\\n     * @param j1 from column\\n     * @param i current row\\n     * @param j current column\\n     * @param pre array that keeps track of current cnt during dfs; -1 means not visited\\n     * @param low lowest pre order that\\'s connected to the current node\\n     */\\n    private void bridgeDFS(int[][] grid, int i1, int j1, int i, int j, int[][] pre, int[][] low) {\\n        int n = grid.length, m = grid[0].length;\\n        pre[i][j] = cnt++;\\n        low[i][j] = pre[i][j];\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (pre[ni][nj] == -1) {\\n                    bridgeDFS(grid, i, j, ni, nj, pre, low);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] == pre[ni][nj]) {\\n                        //i,j to ni, nj is bridge. (i,j) or (ni,nj) must have other neighbors for the cell to be the cut point\\n                        if (hasMoreNeighbors(grid, i, j) || hasMoreNeighbors(grid, ni, nj)) {\\n                            //shortcut, no need to search any more\\n                            found = true;\\n                            return;\\n                        }\\n                    }\\n                } else if (ni != i1 || nj != j1) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], pre[ni][nj]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether the cell has 2 or more neighbors\\n     */\\n    private boolean hasMoreNeighbors(int[][] grid, int i, int j) {\\n        int c = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                c++;\\n            }\\n        }\\n        return c > 1;\\n    }\\n\\n    /**\\n     * Gets number of islands\\n     */\\n    private int getIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] v = new boolean[n][m];\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !v[i][j]) {\\n                    dfsIslands(grid, i, j, v);\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfsIslands(int[][] grid, int i, int j, boolean[][] v) {\\n        if (v[i][j]) return;\\n        v[i][j] = true;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                dfsIslands(grid, ni, nj, v);\\n            }\\n        }\\n    }\\n\\n}\\n```\\n  \\n  </details>\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean ap; //articulation point\\n    int time; //visit time\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        ap = false;\\n        time = 0;\\n        int lands = 0, islands = 0;\\n        int[][] depth = new int[n][m];\\n        int[][] low = new int[n][m];\\n        int[][] parent = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(depth[i], -1);\\n            Arrays.fill(low[i], -1);\\n            Arrays.fill(parent[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    lands++;\\n                    if (depth[i][j] == -1) {\\n                        apDFS(grid, i, j, depth, low, parent);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (islands == 0 || islands >= 2) return 0;\\n        if (lands == 1) return 1;\\n        if (ap) return 1;\\n        return 2;\\n    }\\n\\n    private void apDFS(int[][] grid, int i, int j, int[][] depth, int[][] low, int[][] parent) {\\n        int n = grid.length, m = grid[0].length;\\n        depth[i][j] = time++;\\n        low[i][j] = depth[i][j];\\n        int children = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (depth[ni][nj] == -1) {\\n                    children++;\\n                    parent[ni][nj] = i*m + j;\\n                    apDFS(grid, ni, nj, depth, low, parent);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] >= depth[i][j] && parent[i][j] > -1) {\\n                        ap = true;\\n                    }\\n                } else if (ni*m + nj != parent[i][j]) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], depth[ni][nj]);\\n                }\\n            }\\n        }\\n        if (parent[i][j] == -1 && children > 1) {\\n            ap = true;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int c = getIslands(grid);\\n        if (c == 0 || c >= 2) return 0;\\n        if (hasOneLand(grid)) return 1;\\n        if (hasBridge(grid)) return 1;\\n        return 2;\\n    }\\n\\n    private boolean hasOneLand(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && ++c > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return c == 1;\\n    }\\n\\n    boolean found = false;//whether there\\'s a bridge\\n    int cnt = 0;//node dfs visit sequence number\\n    private boolean hasBridge(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        found = false;\\n        cnt = 0;\\n        int[][] pre = new int[n][m];\\n        int[][] low = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(pre[i], -1);\\n            Arrays.fill(low[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && pre[i][j] == -1) {\\n                    bridgeDFS(grid, i, j, i, j, pre, low);\\n                    if (found) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     *\\n     * @param i1 from row\\n     * @param j1 from column\\n     * @param i current row\\n     * @param j current column\\n     * @param pre array that keeps track of current cnt during dfs; -1 means not visited\\n     * @param low lowest pre order that\\'s connected to the current node\\n     */\\n    private void bridgeDFS(int[][] grid, int i1, int j1, int i, int j, int[][] pre, int[][] low) {\\n        int n = grid.length, m = grid[0].length;\\n        pre[i][j] = cnt++;\\n        low[i][j] = pre[i][j];\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (pre[ni][nj] == -1) {\\n                    bridgeDFS(grid, i, j, ni, nj, pre, low);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] == pre[ni][nj]) {\\n                        //i,j to ni, nj is bridge. (i,j) or (ni,nj) must have other neighbors for the cell to be the cut point\\n                        if (hasMoreNeighbors(grid, i, j) || hasMoreNeighbors(grid, ni, nj)) {\\n                            //shortcut, no need to search any more\\n                            found = true;\\n                            return;\\n                        }\\n                    }\\n                } else if (ni != i1 || nj != j1) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], pre[ni][nj]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether the cell has 2 or more neighbors\\n     */\\n    private boolean hasMoreNeighbors(int[][] grid, int i, int j) {\\n        int c = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                c++;\\n            }\\n        }\\n        return c > 1;\\n    }\\n\\n    /**\\n     * Gets number of islands\\n     */\\n    private int getIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] v = new boolean[n][m];\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !v[i][j]) {\\n                    dfsIslands(grid, i, j, v);\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfsIslands(int[][] grid, int i, int j, boolean[][] v) {\\n        if (v[i][j]) return;\\n        v[i][j] = true;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                dfsIslands(grid, ni, nj, v);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494932,
                "title": "articulation-point",
                "content": "there are only 3 possible cases:\\n\\n* **if the graph already has more than 1 components**\\n* **if the graph has atleast one articulation point**\\n* **if the graph does\\'t follow those two rules**\\n\\n\\n<br>\\n<br>\\n<br>\\nin the first case the ans is 0 becuse we don\\'t need to convert any 1 to 0 because graph is already disconnected<br>\\nin the second case the ans is 1 because by removing that point graph will be divided into two components<br>\\nin the third case we will make any of the boundry 1 as a seperate componet.<br>\\n\\n**e.g.**<br>\\nin this case the ans is 1 because if we remove any of those nodes graph is divided into two components.<br>\\n\\n![image](https://assets.leetcode.com/users/images/40b6c039-50a7-4e41-b1e7-1cd1f37cad52_1661680065.8876095.png)\\n\\nin that case if we make the boundry 1 as seprate component by removing red cells the graph is disconnected,because either the rest two cells are not valid or it has water in those cells.\\n\\n![image](https://assets.leetcode.com/users/images/0d8af90f-33d0-49b4-9646-4358d43e561d_1661680427.3998525.png)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        //if the graph has already greater than 1 components than ans is 0\\n        //if the graph has any articulation point than ans is 1\\n        //else ans is 2\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count = 0;\\n        //discovery time\\n        vector<vector<int>> disc(n,vector<int>(m,0));\\n        //low time\\n        vector<vector<int>> low(n,vector<int>(m,0));\\n        //visited array\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        //direction array\\n        int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        //if ok is true means there is a articulation point in the graph\\n        bool ok = false;\\n        //dfs call\\n        function<void(int,int,int&,int)> dfs = [&](int x,int y,int &time,int p){\\n            //mark the nodes as visited and update their low and disc time\\n            visited[x][y] = true;\\n            disc[x][y] = low[x][y] = time++;\\n            //for root if there are more than 1 recursive tree than root is a articulation point\\n            int rootCall = 0;\\n            //going in all direction and making a dfs call\\n            for(int i = 0 ; i < 4 ; i++){\\n                int newX = x+dir[i][0];\\n                int newY = y+dir[i][1];\\n                //if child cordinates are valid and there is a 1 at that point ans also it is not parent\\n                if(newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1 && newX*m+newY != p){\\n                    if(!visited[newX][newY]){\\n                        dfs(newX,newY,time,x*m+y);\\n                        //update the low time\\n                        low[x][y] = min(low[x][y],low[newX][newY]);\\n                        //checking whether [x,y] is articulation point or not\\n                        if(p == -1){\\n                            rootCall++;\\n                        }else if(disc[x][y] <= low[newX][newY]){\\n                            ok = true;\\n                        }\\n                    }else{\\n                        //updating the low time\\n                        low[x][y] = min(low[x][y],disc[newX][newY]);\\n                    }\\n                }\\n            }\\n            //if root and more than 1 recurive tree formed than articulation point\\n            if(p == -1 && rootCall > 1){\\n                ok = true;\\n            }\\n        };\\n        //counting the number of 1\\'s and making dfs call\\n        int to1 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 1){\\n                    to1++;\\n                    if(!visited[i][j]){\\n                        int time = 1;\\n                        dfs(i,j,time,-1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(count > 1){\\n            //if more than one components are formed\\n            return 0;\\n        }else if(ok){\\n            //if onlu one component is formed and there is a articulation point\\n            return 1;\\n        }else{\\n            //if total number of 1 is 1\\n            if(to1 == 1){\\n                return 1;\\n            }else if(to1 == 0){\\n                //if total number of 1 is 0\\n                return 0;\\n            }\\n            //else\\n            return 2;\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        //if the graph has already greater than 1 components than ans is 0\\n        //if the graph has any articulation point than ans is 1\\n        //else ans is 2\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count = 0;\\n        //discovery time\\n        vector<vector<int>> disc(n,vector<int>(m,0));\\n        //low time\\n        vector<vector<int>> low(n,vector<int>(m,0));\\n        //visited array\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        //direction array\\n        int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        //if ok is true means there is a articulation point in the graph\\n        bool ok = false;\\n        //dfs call\\n        function<void(int,int,int&,int)> dfs = [&](int x,int y,int &time,int p){\\n            //mark the nodes as visited and update their low and disc time\\n            visited[x][y] = true;\\n            disc[x][y] = low[x][y] = time++;\\n            //for root if there are more than 1 recursive tree than root is a articulation point\\n            int rootCall = 0;\\n            //going in all direction and making a dfs call\\n            for(int i = 0 ; i < 4 ; i++){\\n                int newX = x+dir[i][0];\\n                int newY = y+dir[i][1];\\n                //if child cordinates are valid and there is a 1 at that point ans also it is not parent\\n                if(newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1 && newX*m+newY != p){\\n                    if(!visited[newX][newY]){\\n                        dfs(newX,newY,time,x*m+y);\\n                        //update the low time\\n                        low[x][y] = min(low[x][y],low[newX][newY]);\\n                        //checking whether [x,y] is articulation point or not\\n                        if(p == -1){\\n                            rootCall++;\\n                        }else if(disc[x][y] <= low[newX][newY]){\\n                            ok = true;\\n                        }\\n                    }else{\\n                        //updating the low time\\n                        low[x][y] = min(low[x][y],disc[newX][newY]);\\n                    }\\n                }\\n            }\\n            //if root and more than 1 recurive tree formed than articulation point\\n            if(p == -1 && rootCall > 1){\\n                ok = true;\\n            }\\n        };\\n        //counting the number of 1\\'s and making dfs call\\n        int to1 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 1){\\n                    to1++;\\n                    if(!visited[i][j]){\\n                        int time = 1;\\n                        dfs(i,j,time,-1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(count > 1){\\n            //if more than one components are formed\\n            return 0;\\n        }else if(ok){\\n            //if onlu one component is formed and there is a articulation point\\n            return 1;\\n        }else{\\n            //if total number of 1 is 1\\n            if(to1 == 1){\\n                return 1;\\n            }else if(to1 == 0){\\n                //if total number of 1 is 0\\n                return 0;\\n            }\\n            //else\\n            return 2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820434,
                "title": "python-o-n-m-articulation-points-beats-100",
                "content": "This question can be divided into 3 cases :\\n\\n1) The most number of cells to be removed in the worst case will be 2, explained later.\\n2) If there is an articulation point, the answer will be 1.\\n3) The matrix is already divided or there are no 1\\'s, the answer is 0.\\n\\n\\nSo, if you didnt understand the worst case scenario, \\nhere is an example:\\n```\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n\\nwe just change two 1\\'s\\n\\n1 0 1 1 1 1\\n0 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n```\\nSo, the answer will be always 2 at max.\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    cnt += 1 # count the number of elements\\n                    root = (i, j) # assign the root node for the graph\\n                    \\n        if cnt <= 1 :  return cnt # no elements in the map\\n        \\n        vis, low, time, res = {root}, {}, {}, []\\n        \\n        # find whether articulation points are present in the matrix\\n        def articulation_points(curr, parent): \\n            low[curr] = time[curr] = len(vis)\\n            children = 0\\n            i, j = curr\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if (x, y) == parent : continue\\n                    \\n                if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]:\\n                    if (x, y) not in vis:\\n                        vis.add((x,y))\\n                        articulation_points((x,y), curr)\\n                        low[curr] = min(low[curr], low[(x, y)])\\n                        children += 1\\n                        if low[(x, y)] >= time[(curr)] and parent!=(-1, -1):\\n                            res.append([i, j])\\n                    else:\\n                        low[curr] = min(low[curr], time[(x, y)])\\n                        \\n                if parent == (-1, -1) and children > 1:\\n                    res.append([x, y])\\n\\n        articulation_points(root, (-1, -1))\\n\\n        if len(vis) != cnt: # if the matrix is disconnected beforehand\\n            return 0\\n        elif res: # if there are any articulation points\\n            return 1\\n        else: # worst case, no articulation points\\n            return 2\\n            \\n```\\n\\nTime = Space = O(N* M)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n\\nwe just change two 1\\'s\\n\\n1 0 1 1 1 1\\n0 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n```\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    cnt += 1 # count the number of elements\\n                    root = (i, j) # assign the root node for the graph\\n                    \\n        if cnt <= 1 :  return cnt # no elements in the map\\n        \\n        vis, low, time, res = {root}, {}, {}, []\\n        \\n        # find whether articulation points are present in the matrix\\n        def articulation_points(curr, parent): \\n            low[curr] = time[curr] = len(vis)\\n            children = 0\\n            i, j = curr\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if (x, y) == parent : continue\\n                    \\n                if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]:\\n                    if (x, y) not in vis:\\n                        vis.add((x,y))\\n                        articulation_points((x,y), curr)\\n                        low[curr] = min(low[curr], low[(x, y)])\\n                        children += 1\\n                        if low[(x, y)] >= time[(curr)] and parent!=(-1, -1):\\n                            res.append([i, j])\\n                    else:\\n                        low[curr] = min(low[curr], time[(x, y)])\\n                        \\n                if parent == (-1, -1) and children > 1:\\n                    res.append([x, y])\\n\\n        articulation_points(root, (-1, -1))\\n\\n        if len(vis) != cnt: # if the matrix is disconnected beforehand\\n            return 0\\n        elif res: # if there are any articulation points\\n            return 1\\n        else: # worst case, no articulation points\\n            return 2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 822726,
                "title": "java-clean-tarjan-o-mn",
                "content": "This question is similar to question 1192 https://leetcode.com/problems/critical-connections-in-a-network/description/\\nwe use tarjan\\'s algorithm to record (every node) id and the (lowest id it can reach), if we find a critical edge, which means we can cut the island two parts by one cut.\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    Map<Integer, Integer> timeMap = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n\\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        tarjan(-1, root, 0, new HashSet<>());       //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int parent, int cur, int time, Set<Integer> visited) {\\n        visited.add(cur);\\n        timeMap.put(cur, time);\\n        for (int nei : graph.get(cur)) {\\n            if (nei == parent) continue;\\n            if (!visited.contains(nei)) tarjan(cur, nei, time + 1, visited);\\n            if (time < timeMap.get(nei)) foundCriticalEdge = true;\\n            timeMap.put(cur, Math.min(timeMap.get(cur), timeMap.get(nei)));            \\n        }\\n    }\\n    \\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```\\n\\n\\n\\n\\nOr if you prefer the text book version, which is directly transfered from pseudo code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n]; //Trajan\\'s algorithm\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);                            //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n        for (int nei : graph.get(cur)) {\\n            if (nei == prev) continue;\\n            if (dfn[nei] == -1) {\\n                tarjan(cur, nei);\\n                if (low[nei] > dfn[cur]) {\\n                    foundCriticalEdge = true;\\n                    // return;\\n                }\\n            }\\n            low[cur]=Math.min(low[cur],low[nei]);\\n        }\\n    }\\n    \\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    Map<Integer, Integer> timeMap = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n\\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        tarjan(-1, root, 0, new HashSet<>());       //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int parent, int cur, int time, Set<Integer> visited) {\\n        visited.add(cur);\\n        timeMap.put(cur, time);\\n        for (int nei : graph.get(cur)) {\\n            if (nei == parent) continue;\\n            if (!visited.contains(nei)) tarjan(cur, nei, time + 1, visited);\\n            if (time < timeMap.get(nei)) foundCriticalEdge = true;\\n            timeMap.put(cur, Math.min(timeMap.get(cur), timeMap.get(nei)));            \\n        }\\n    }\\n    \\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n]; //Trajan\\'s algorithm\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);                            //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n        for (int nei : graph.get(cur)) {\\n            if (nei == prev) continue;\\n            if (dfn[nei] == -1) {\\n                tarjan(cur, nei);\\n                if (low[nei] > dfn[cur]) {\\n                    foundCriticalEdge = true;\\n                    // return;\\n                }\\n            }\\n            low[cur]=Math.min(low[cur],low[nei]);\\n        }\\n    }\\n    \\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819572,
                "title": "c-easy-to-understand-with-explanation-bfs",
                "content": "Looking at the question, it might give an impression as a very difficult question. This question actually is lot easier than it looks. On careful observation, you can notice that the answer can only lie between 0 and 2. \\n\\nWhen does answer can be 0? If the given matrix already contains more than one island or if the matrix doesn\\'t contain any island. When can the answer be 1 or 2 and why can\\'t it be greater than 2?\\n\\nNotice that the question just wants you to disconnect the grid. It doesn\\'t matter how many elements are present in the islands that are formed after disconnecting the original grid. We can disconnect the corners from the island and can achieve a disconnected grid. Disconnecting corners from the original grid require at max 2 operations. Consider the following examples:\\n```\\n0 1 1 0\\n0 1 1 0\\n0 0 0 0\\n```\\nDisconecting the corner (0,1) in the above example requires two operations. grid[0][2]=0 and grid[1][1]=0. Sometimes it requires just one operation like in the following case:\\n```\\n0 1 1 0\\n0 0 1 0\\n0 0 0 0\\n```\\nNote that I am talking about corners of the grid. Corners are connected to a grid in atmax two directions only out of 4 possible directions. But what about the following cases \\n\\n```\\n0 1 1 1 0                     1 1 1 1 1\\n                              1 1 1 0 1\\n```\\nAbove two examples require just one move and that move in both the cases is not a corner. \\nWhat we can do is change one 1 in the entire grid to 0 and check if two islands are formed. If formed, then the answer is 1. If two islands can\\'t be formed by changing just one 1 to 0, then answer is 2. Consider the following algorithm for clear understanding.\\n\\n```\\n1. Check if given grid contains 0 or more than 1 island using bfs. If yes, return 0.\\n2. For each element having value 1 present in the grid, change it to 0 and apply bfs. If more than two islands are formed, then the answer is 1.\\n3. If there is no way we can change just one element to 0 and get a disconnected grid, then the answer is 2.\\n````\\n\\nCheck the following code for clearer understanding:\\n\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&grid)\\n    {\\n        int num_islands=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        unordered_set<int>set;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0 || set.find(i*n+j)!=set.end())\\n                    continue;\\n                num_islands++;\\n                if(num_islands>1)\\n                    return 2;\\n                queue<int>q;\\n                q.push(i*n+j);\\n                set.insert(i*n+j);\\n                while(!q.empty())\\n                {\\n                    int temp=q.front();\\n                    q.pop();\\n                    int x=temp/n;\\n                    int y=temp%n;\\n                    if(x<m-1 && grid[x+1][y]==1 && set.find((x+1)*n+y)==set.end())\\n                    {\\n                        set.insert((x+1)*n+y);\\n                        q.push((x+1)*n+y);\\n                    }\\n                    if(x>0 && grid[x-1][y]==1 && set.find((x-1)*n+y)==set.end())\\n                    {\\n                        set.insert((x-1)*n+y);\\n                        q.push((x-1)*n+y);\\n                    }\\n                    if(y<n-1 && grid[x][y+1]==1 && set.find(x*n+y+1)==set.end())\\n                    {\\n                        set.insert(x*n+y+1);\\n                        q.push(x*n+y+1);\\n                    }\\n                    if(y>0 && grid[x][y-1]==1 && set.find(x*n+y-1)==set.end())\\n                    {\\n                        set.insert(x*n+y-1);\\n                        q.push(x*n+y-1);\\n                    }\\n                }\\n            }\\n        }\\n        return num_islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if(bfs(grid)!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                grid[i][j]=0;\\n                if(bfs(grid)!=1)\\n                    return 1;\\n                grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n};\\n\\n```\\n\\nComplexity analysis:\\nSince we are performing bfs repeatedly, time complexity of O(m^2 * n^2)\\n```\\nTime complexity: O(m^2 * n^2)\\nSpace complexity: O(m*n)\\n```\\n\\nUpvote if you found the solution useful. If you found any difficulty in understanding the explanation or the code, or if you want to suggest any improvements, please comment.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n0 1 1 0\\n0 1 1 0\\n0 0 0 0\\n```\n```\\n0 1 1 0\\n0 0 1 0\\n0 0 0 0\\n```\n```\\n0 1 1 1 0                     1 1 1 1 1\\n                              1 1 1 0 1\\n```\n```\\n1. Check if given grid contains 0 or more than 1 island using bfs. If yes, return 0.\\n2. For each element having value 1 present in the grid, change it to 0 and apply bfs. If more than two islands are formed, then the answer is 1.\\n3. If there is no way we can change just one element to 0 and get a disconnected grid, then the answer is 2.\\n```\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&grid)\\n    {\\n        int num_islands=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        unordered_set<int>set;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0 || set.find(i*n+j)!=set.end())\\n                    continue;\\n                num_islands++;\\n                if(num_islands>1)\\n                    return 2;\\n                queue<int>q;\\n                q.push(i*n+j);\\n                set.insert(i*n+j);\\n                while(!q.empty())\\n                {\\n                    int temp=q.front();\\n                    q.pop();\\n                    int x=temp/n;\\n                    int y=temp%n;\\n                    if(x<m-1 && grid[x+1][y]==1 && set.find((x+1)*n+y)==set.end())\\n                    {\\n                        set.insert((x+1)*n+y);\\n                        q.push((x+1)*n+y);\\n                    }\\n                    if(x>0 && grid[x-1][y]==1 && set.find((x-1)*n+y)==set.end())\\n                    {\\n                        set.insert((x-1)*n+y);\\n                        q.push((x-1)*n+y);\\n                    }\\n                    if(y<n-1 && grid[x][y+1]==1 && set.find(x*n+y+1)==set.end())\\n                    {\\n                        set.insert(x*n+y+1);\\n                        q.push(x*n+y+1);\\n                    }\\n                    if(y>0 && grid[x][y-1]==1 && set.find(x*n+y-1)==set.end())\\n                    {\\n                        set.insert(x*n+y-1);\\n                        q.push(x*n+y-1);\\n                    }\\n                }\\n            }\\n        }\\n        return num_islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if(bfs(grid)!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                grid[i][j]=0;\\n                if(bfs(grid)!=1)\\n                    return 1;\\n                grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n};\\n\\n```\n```\\nTime complexity: O(m^2 * n^2)\\nSpace complexity: O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819426,
                "title": "java-remove-at-most-two",
                "content": "The trick is maximum remove 2 points can get more than two islands.... - -\\nThere is always one node in the cornor, for example:\\n0 1 1 1 0\\n0 1 1 1 0\\n0 1 1 ***1*** 0\\n0 0 0 0 0\\nwe can always remove the point next to the right-bottom 1 to get more than 2 island, this case we remove [1,3],[2,2]\\n0 1 1 1 0\\n0 1 1 0 0\\n0 1 0 ***1*** 0\\n0 0 0 0 0\\nSo only need remove at most 2\\n\\nspecial case, \\n0 1s, then return 0;\\n1 1s, then return 1;\\n\\nJust need to verify the remove 1 point case... \\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        Set<Integer> ones = new HashSet<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    ones.add(i * grid[0].length + j);\\n                }\\n            }\\n        }\\n        if(ones.size() == 0) return 0;\\n        if(ones.size() == 1) return 1;\\n        if(moreThanOneIsland(grid, ones)) return 0;\\n        \\n        Set<Integer> tmp = new HashSet<>(ones);\\n        for(int one : ones){\\n            tmp.remove(one);\\n            if(moreThanOneIsland(grid, tmp)) return 1;\\n            tmp.add(one);\\n        }\\n        return 2;\\n    }\\n    private int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n    //if can\\'t access all island, means more than 2 island, O(K)\\n    private boolean moreThanOneIsland(int[][] grid,  Set<Integer> ones){\\n        Queue<Integer> queue = new LinkedList<>();\\n        int start = ones.iterator().next();\\n        queue.offer(start);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int point = queue.poll();\\n            visited.add(start);\\n            int x = point / grid[0].length;\\n            int y = point % grid[0].length;\\n            for(int[] dir : dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(newX >=0 && newX < grid.length && newY >=0 && newY < grid[0].length){\\n                    int key = newX * grid[0].length + newY;\\n                    if(!visited.contains(key) && ones.contains(key)){\\n                        visited.add(key);\\n                        queue.offer(key);\\n                    }\\n                }\\n            }\\n        }\\n        return visited.size() < ones.size();\\n    }\\n}\\n```\\nTime complexity O(MN + K^2), K is the number of ones\\nSpace O(K)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        Set<Integer> ones = new HashSet<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    ones.add(i * grid[0].length + j);\\n                }\\n            }\\n        }\\n        if(ones.size() == 0) return 0;\\n        if(ones.size() == 1) return 1;\\n        if(moreThanOneIsland(grid, ones)) return 0;\\n        \\n        Set<Integer> tmp = new HashSet<>(ones);\\n        for(int one : ones){\\n            tmp.remove(one);\\n            if(moreThanOneIsland(grid, tmp)) return 1;\\n            tmp.add(one);\\n        }\\n        return 2;\\n    }\\n    private int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n    //if can\\'t access all island, means more than 2 island, O(K)\\n    private boolean moreThanOneIsland(int[][] grid,  Set<Integer> ones){\\n        Queue<Integer> queue = new LinkedList<>();\\n        int start = ones.iterator().next();\\n        queue.offer(start);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int point = queue.poll();\\n            visited.add(start);\\n            int x = point / grid[0].length;\\n            int y = point % grid[0].length;\\n            for(int[] dir : dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(newX >=0 && newX < grid.length && newY >=0 && newY < grid[0].length){\\n                    int key = newX * grid[0].length + newY;\\n                    if(!visited.contains(key) && ones.contains(key)){\\n                        visited.add(key);\\n                        queue.offer(key);\\n                    }\\n                }\\n            }\\n        }\\n        return visited.size() < ones.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819849,
                "title": "python-easy",
                "content": "The answer can be atmost 2 as \\n--->For example number of islands are not 1 we can return 0 as there is no need to do anything\\n--->If there is 1 island we can return 1 as 1 step will be sufficient to break them into\\n--->If there is 1 island and we cannot break them into 2 islands in 1 day we are left with only one option which 2 so return 2\\n\\nActually this question can be divided into 2 parts one is [Count islands](https://leetcode.com/problems/number-of-islands/) and next part is as mentioned above\\n\\n\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        \\n        def countislands(grid):\\n            islands = 0\\n            visited = set()\\n\\n            def dfs(grid,row,col,visited):\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1 and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    dfs(grid,row+1,col,visited)\\n                    dfs(grid,row-1,col,visited)\\n                    dfs(grid,row,col+1,visited)\\n                    dfs(grid,row,col-1,visited)\\n\\n\\n            for row in range(len(grid)):\\n                for col in range(len(grid[0])):\\n                    if grid[row][col] == 1 and (row,col) not in visited:\\n                        islands += 1\\n                        dfs(grid,row,col,visited)\\n            \\n            return islands\\n        \\n        if countislands(grid) != 1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countislands(grid) != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n\\t\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "The answer can be atmost 2 as \\n--->For example number of islands are not 1 we can return 0 as there is no need to do anything\\n--->If there is 1 island we can return 1 as 1 step will be sufficient to break them into\\n--->If there is 1 island and we cannot break them into 2 islands in 1 day we are left with only one option which 2 so return 2\\n\\nActually this question can be divided into 2 parts one is [Count islands](https://leetcode.com/problems/number-of-islands/) and next part is as mentioned above\\n\\n\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        \\n        def countislands(grid):\\n            islands = 0\\n            visited = set()\\n\\n            def dfs(grid,row,col,visited):\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1 and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    dfs(grid,row+1,col,visited)\\n                    dfs(grid,row-1,col,visited)\\n                    dfs(grid,row,col+1,visited)\\n                    dfs(grid,row,col-1,visited)\\n\\n\\n            for row in range(len(grid)):\\n                for col in range(len(grid[0])):\\n                    if grid[row][col] == 1 and (row,col) not in visited:\\n                        islands += 1\\n                        dfs(grid,row,col,visited)\\n            \\n            return islands\\n        \\n        if countislands(grid) != 1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countislands(grid) != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n\\t\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 819643,
                "title": "java-tarjan-4ms-with-explain",
                "content": "**Explanation**\\n1. First let\\'s construc a graph\\n2. You want to make at least 2 component (if already more than one, just return 0 by doing a simple DFS/BFS check)\\n3. You want to find a cut point (use tarjan algorithm),the cutpoint is the point where it can split the graph if you remove it and all its adjeccent edges\\n4. What about the graph is a strong component(without cut point)? We can think it as a cycle (circle), which means we need to remove at least 2 points to cut the cycle (circle)\\n\\n```\\nclass Solution {\\n    int cnt=0;\\n    boolean visit[][];\\n    int graph[][];\\n    List<Integer>adjecent[];\\n    int dis[],low[];\\n    int time=1;\\n    boolean cut=false;int root=-1;\\n    public int minDays(int[][] grid) {\\n        \\n        int r=grid.length,c=grid[0].length;\\n        adjecent=new ArrayList[r*c];\\n        dis=new int[r*c];low=new int[r*c];\\n        for(int i=0;i<adjecent.length;i++)adjecent[i]=new ArrayList<>();\\n        visit=new boolean[r][c];\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                sum+=grid[i][j];\\n                if(grid[i][j]==0||visit[i][j])continue;\\n                if(root==-1)root=i*grid[0].length+j;\\n                cnt++;\\n                dfs(grid,i,j);\\n            }\\n        }\\n        \\n        if(cnt>1)return 0;\\n        if(sum<=2)return sum;\\n\\t\\t\\n        for(int i=0;i<grid.length;i++){//build the graph\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)continue;\\n                mark(grid,i,j,i+1,j);\\n                mark(grid,i,j,i-1,j);\\n                mark(grid,i,j,i,j+1);\\n                mark(grid,i,j,i,j-1);\\n            }\\n        }\\n        tarjan(-1,root);\\n        \\n        if(cut)return 1;\\n        return 2;\\n        \\n       \\n    }\\n    \\n        public void tarjan(int p,int r){\\n            if(cut)return;\\n            List<Integer>childs=adjecent[r];\\n            dis[r]=low[r]=time;\\n            time++;\\n\\n            //core for tarjan, finding critical point\\n            int son=0;\\n            for(int c:childs){\\n                if(c==p)continue;\\n                if(dis[c]==0){\\n                    son++;\\n                    tarjan(r,c);\\n                    low[r]=Math.min(low[r],low[c]);\\n                    if((r==root&&son>1)||(low[c]>=dis[r]&&r!=root)){\\n                        cut=true;\\n                        return;\\n                    }\\n                }else{\\n                    if(c!=p){\\n                        low[r]=Math.min(low[r],dis[c]);\\n                    }\\n                }\\n            }\\n\\n        }\\n    \\n    public void mark(int grid[][],int r,int c,int r1,int c1){\\n        if(r1<0||c1<0||r1>=grid.length||c1>=grid[0].length)return;\\n        if(grid[r1][c1]==0)return;\\n        \\n        int id1=r*grid[0].length+c;\\n        int id2=r1*grid[0].length+c1;\\n        adjecent[id1].add(id2);\\n        adjecent[id2].add(id1);\\n        \\n    }\\n    \\n    public void dfs(int grid[][],int i,int j){\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length)return;\\n        if(grid[i][j]==0)return;\\n        if(visit[i][j])return;\\n        visit[i][j]=true;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt=0;\\n    boolean visit[][];\\n    int graph[][];\\n    List<Integer>adjecent[];\\n    int dis[],low[];\\n    int time=1;\\n    boolean cut=false;int root=-1;\\n    public int minDays(int[][] grid) {\\n        \\n        int r=grid.length,c=grid[0].length;\\n        adjecent=new ArrayList[r*c];\\n        dis=new int[r*c];low=new int[r*c];\\n        for(int i=0;i<adjecent.length;i++)adjecent[i]=new ArrayList<>();\\n        visit=new boolean[r][c];\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                sum+=grid[i][j];\\n                if(grid[i][j]==0||visit[i][j])continue;\\n                if(root==-1)root=i*grid[0].length+j;\\n                cnt++;\\n                dfs(grid,i,j);\\n            }\\n        }\\n        \\n        if(cnt>1)return 0;\\n        if(sum<=2)return sum;\\n\\t\\t\\n        for(int i=0;i<grid.length;i++){//build the graph\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)continue;\\n                mark(grid,i,j,i+1,j);\\n                mark(grid,i,j,i-1,j);\\n                mark(grid,i,j,i,j+1);\\n                mark(grid,i,j,i,j-1);\\n            }\\n        }\\n        tarjan(-1,root);\\n        \\n        if(cut)return 1;\\n        return 2;\\n        \\n       \\n    }\\n    \\n        public void tarjan(int p,int r){\\n            if(cut)return;\\n            List<Integer>childs=adjecent[r];\\n            dis[r]=low[r]=time;\\n            time++;\\n\\n            //core for tarjan, finding critical point\\n            int son=0;\\n            for(int c:childs){\\n                if(c==p)continue;\\n                if(dis[c]==0){\\n                    son++;\\n                    tarjan(r,c);\\n                    low[r]=Math.min(low[r],low[c]);\\n                    if((r==root&&son>1)||(low[c]>=dis[r]&&r!=root)){\\n                        cut=true;\\n                        return;\\n                    }\\n                }else{\\n                    if(c!=p){\\n                        low[r]=Math.min(low[r],dis[c]);\\n                    }\\n                }\\n            }\\n\\n        }\\n    \\n    public void mark(int grid[][],int r,int c,int r1,int c1){\\n        if(r1<0||c1<0||r1>=grid.length||c1>=grid[0].length)return;\\n        if(grid[r1][c1]==0)return;\\n        \\n        int id1=r*grid[0].length+c;\\n        int id2=r1*grid[0].length+c1;\\n        adjecent[id1].add(id2);\\n        adjecent[id2].add(id1);\\n        \\n    }\\n    \\n    public void dfs(int grid[][],int i,int j){\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length)return;\\n        if(grid[i][j]==0)return;\\n        if(visit[i][j])return;\\n        visit[i][j]=true;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293931,
                "title": "simplest-explanation-with-diagram-articulation-point-tarjan-algo-faster-than-100",
                "content": "# Now, first of all how many solutions can be there, I will say only 0,1 and 2, **why** ?\\n\\n### 1. for \\'0\\'\\na. there is a initially more than one connected components.\\nwhich is quite easy to find, just using a dfs/bfs.\\nb. there is no land (all zeroes in grid).\\n\\n### 2. for \\'2\\'\\n\\n at max you can remove 2 connecting node of any **corner node**(as there always be a corner) to make it disconnected.\\n![image](https://assets.leetcode.com/users/images/158b1e1f-1dc5-49f8-8230-e6791805e69a_1624527641.3018715.png)\\n\\n### 3. for \\'1\\' (most important case)\\na. if there is only one node of land, i.e. only one \\'1\\' in the grid.\\n#### b. if there is any articulation point present in the grid.\\nArticulation point is a point in a graph, which on removing increases the number of connected conponents of that graph.\\nex. **(articulation point marked in red)**\\n1. ![image](https://assets.leetcode.com/users/images/a4a8e3cc-86c1-4534-b318-6e27f68bdd16_1624528648.7351217.png)\\n2. ![image](https://assets.leetcode.com/users/images/514d83a2-da9c-4409-a3c3-8e90bdb1c61c_1624528665.6771123.png)\\n\\nSo what I did is first find that if there is only:\\n1. one \\'1\\': return 1;\\n2. all \\'0\\': return 0;\\n3. all \\'1\\': return 2;\\n\\nThen applied simple tarjan algo to find articulation point(explaining it here is just useless as there are some very nice videos out there on youtube) to find if there is any articuation point or not. And as tarjan algo is just a dfs traversal, it will traverse all the nodes in **one connected component\".** So, if there is any node which is \\'1\\' and not visited yet, then that means that there is more than one connected component (just return 0;). after that if there is any articulation point in the graph, return 1. Otherwise return 2.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int t = 0;\\n    bool isArticulation = 0;\\n    vector<pair<int, int>>moves = {{ -1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    bool check(int r, int c, int n, int m) {\\n        return (r<n and r >= 0 and c<m and c >= 0);\\n    }\\n\\n    void tarjan(int r, int c, vector<vector<int>>&a, vector<vector<int>>&visit_time, vector<vector<int>>&low_time, vector<vector<pair<int, int>>>&parent, int parR, int parC, int n, int m) {\\n        visit_time[r][c] = low_time[r][c] = t;\\n        parent[r][c] = {parR, parC};\\n        t += 1;\\n        int child = 0;\\n        for (auto x : moves) {\\n            if (check(r + x.first, c + x.second, n, m) and a[r + x.first][c + x.second] == 1) {\\n                if (visit_time[r + x.first][c + x.second] == -1) {\\n                    child += 1;\\n                    tarjan(r + x.first, c + x.second, a, visit_time, low_time, parent, r, c, n, m);\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n\\n                    if (child > 1 and parent[r][c].first == -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n\\n                    if (low_time[r + x.first][c + x.second] >= visit_time[r][c] and parent[r][c].first != -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n                }\\n                else if (r + x.first != parent[r][c].first or c + x.second != parent[r][c].second) {\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n                }\\n            }\\n        }\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int zeroSum = 0, oneSum = 0;\\n        for (auto x : grid) {\\n            for (auto y : x) {\\n                if (y == 0) zeroSum += 1;\\n                if (y == 1) oneSum += 1;\\n            }\\n        }\\n        if (oneSum == 1) {\\n            return 1;\\n        }\\n\\n        if (zeroSum == n * m) {\\n            return 0;\\n        }\\n        if (oneSum == n * m) {\\n            return 2;\\n        }\\n        vector<vector<int>>visit_time(n, vector<int>(m, -1));\\n        vector<vector<int>>low_time(n, vector<int>(m, INT_MAX));\\n        vector<vector<pair<int, int>>>parent(n, vector<pair<int, int>>(m));\\n        bool tarjanDone = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1 and !tarjanDone) {\\n                    tarjan(i, j, grid, visit_time, low_time, parent, -1, -1, n, m);\\n                    tarjanDone = 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1) {\\n                    return 0;\\n                }\\n            }\\n        }\\n\\n        if (isArticulation) {\\n            return 1;\\n        }\\n        return 2;\\n        // return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t = 0;\\n    bool isArticulation = 0;\\n    vector<pair<int, int>>moves = {{ -1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    bool check(int r, int c, int n, int m) {\\n        return (r<n and r >= 0 and c<m and c >= 0);\\n    }\\n\\n    void tarjan(int r, int c, vector<vector<int>>&a, vector<vector<int>>&visit_time, vector<vector<int>>&low_time, vector<vector<pair<int, int>>>&parent, int parR, int parC, int n, int m) {\\n        visit_time[r][c] = low_time[r][c] = t;\\n        parent[r][c] = {parR, parC};\\n        t += 1;\\n        int child = 0;\\n        for (auto x : moves) {\\n            if (check(r + x.first, c + x.second, n, m) and a[r + x.first][c + x.second] == 1) {\\n                if (visit_time[r + x.first][c + x.second] == -1) {\\n                    child += 1;\\n                    tarjan(r + x.first, c + x.second, a, visit_time, low_time, parent, r, c, n, m);\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n\\n                    if (child > 1 and parent[r][c].first == -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n\\n                    if (low_time[r + x.first][c + x.second] >= visit_time[r][c] and parent[r][c].first != -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n                }\\n                else if (r + x.first != parent[r][c].first or c + x.second != parent[r][c].second) {\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n                }\\n            }\\n        }\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int zeroSum = 0, oneSum = 0;\\n        for (auto x : grid) {\\n            for (auto y : x) {\\n                if (y == 0) zeroSum += 1;\\n                if (y == 1) oneSum += 1;\\n            }\\n        }\\n        if (oneSum == 1) {\\n            return 1;\\n        }\\n\\n        if (zeroSum == n * m) {\\n            return 0;\\n        }\\n        if (oneSum == n * m) {\\n            return 2;\\n        }\\n        vector<vector<int>>visit_time(n, vector<int>(m, -1));\\n        vector<vector<int>>low_time(n, vector<int>(m, INT_MAX));\\n        vector<vector<pair<int, int>>>parent(n, vector<pair<int, int>>(m));\\n        bool tarjanDone = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1 and !tarjanDone) {\\n                    tarjan(i, j, grid, visit_time, low_time, parent, -1, -1, n, m);\\n                    tarjanDone = 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1) {\\n                    return 0;\\n                }\\n            }\\n        }\\n\\n        if (isArticulation) {\\n            return 1;\\n        }\\n        return 2;\\n        // return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638094,
                "title": "easy-java-solution-clean-code",
                "content": "# Java Code\\n---\\n> #### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---\\n```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public boolean isSafe(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<grid.length  && j<grid[0].length && visited[i][j] == false && grid[i][j] == 1);\\n    }\\n    public void islandCount(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        visited[i][j] = true;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(isSafe(grid,newRow,newCol,visited))\\n            {\\n                islandCount(grid,newRow,newCol,visited);\\n            }\\n        }\\n    }\\n    public int CountLand(int[][] grid,boolean[][] visited)\\n    {\\n        int count = 0;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    islandCount(grid,i,j,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int minDays(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = CountLand(grid,visited);\\n        if(count > 1 || count == 0) return 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    boolean[][] mat = new boolean[rows][cols];\\n                    int count2 = CountLand(grid,mat);\\n                    grid[i][j] = 1;\\n                    if(count2 > 1 || count2 == 0)\\n                    {\\n                        return 1;   \\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```\\n---\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public boolean isSafe(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<grid.length  && j<grid[0].length && visited[i][j] == false && grid[i][j] == 1);\\n    }\\n    public void islandCount(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        visited[i][j] = true;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(isSafe(grid,newRow,newCol,visited))\\n            {\\n                islandCount(grid,newRow,newCol,visited);\\n            }\\n        }\\n    }\\n    public int CountLand(int[][] grid,boolean[][] visited)\\n    {\\n        int count = 0;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    islandCount(grid,i,j,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int minDays(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = CountLand(grid,visited);\\n        if(count > 1 || count == 0) return 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    boolean[][] mat = new boolean[rows][cols];\\n                    int count2 = CountLand(grid,mat);\\n                    grid[i][j] = 1;\\n                    if(count2 > 1 || count2 == 0)\\n                    {\\n                        return 1;   \\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724195,
                "title": "java-2-methods-brute-force-and-articulation-point",
                "content": "```\\n    // b <================= Minimum Number of Days to Disconnect Island ==========>\\n    // https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n\\n    // ! Brute Force, passed since the test case and constraints are small.\\n\\n    public static void dfs_numsIsland(int sr, int sc, int[][] grid, int[][] dir, boolean[][] vis) {\\n        vis[sr][sc] = true;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r][c]) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n            }\\n        }\\n    }\\n\\n    public static int numOfIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n\\n        int noOfIslands = 0;\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n            if (!vis[r][c] && grid[r][c] == 1) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n                noOfIslands++;\\n            }\\n        }\\n\\n        return noOfIslands;\\n    }\\n\\n    public int minDays_(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int initialComponents = numOfIslands(grid);\\n        if (initialComponents > 1 || initialComponents == 0)\\n            return 0;\\n\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1) {\\n                grid[r][c] = 0;\\n                int noOfComponents = numOfIslands(grid);\\n                if (noOfComponents > 1 || noOfComponents == 0)\\n                    return 1;\\n                grid[r][c] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n\\n    // B Optimized using the articulation Point\\n\\n    private static int[] low, disc;\\n    private static int time = 0;\\n    private static boolean[] vis;\\n\\n    public static int dfs_size(int idx, int[][] grid, boolean[] vis) {\\n        int n = grid.length, m = grid[0].length;\\n        int sr = idx / m, sc = idx % m;\\n\\n        vis[idx] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        int count = 0;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r * m + c]) {\\n                count += dfs_size(r * m + c, grid, vis);\\n            }\\n        }\\n\\n        return count + 1;\\n    }\\n\\n    public static boolean tarjans(int src, int par, int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        disc[src] = low[src] = time++;\\n        vis[src] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\n        boolean res = false;\\n        for (int d = 0; d < dir.length; d++) {\\n            int sr = src / m, sc = src % m;\\n\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 1) {\\n                int nbr = r * m + c;\\n                if (!vis[nbr]) {\\n                    res = res || tarjans(nbr, src, grid);\\n                    if (disc[src] < low[nbr]) { // Yahan pe equal to sign nhi kiya use. Why? ==> Kyunki hume cycle wale\\n                                                // structure ke liye bhi true return karna tha kyunki wahan pe do vertex\\n                                                // ko nikal ke graph disconnected ban sakta hai. Example is of a square,\\n                                                // removing the diagonal vertex will make component disconnected.\\n                        return true;\\n                    }\\n                    low[src] = Math.min(low[nbr], low[src]);\\n                } else if (nbr != par) {\\n                    low[src] = Math.min(low[src], disc[nbr]);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n\\n        disc = new int[n * m];\\n        low = new int[n * m];\\n        vis = new boolean[n * m];\\n        int root = -1;\\n        int noOfComponents = 0, size = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1 && !vis[i]) {\\n                root = i;\\n                size += dfs_size(i, grid, vis);\\n                noOfComponents++;\\n            }\\n        }\\n\\n        if (noOfComponents == 0 || noOfComponents > 1) // Agar mera component 0 hai ya 1 ha se bada hai to mai already\\n                                                       // disconnected hun, to 0 retun kardo\\n            return 0;\\n        else if (size <= 2) // Ab kyunki mai uper component ka check karke aaya hun to mai sure hun ki ab ek\\n                            // he single component hai graph mai. To agar component ka size 1 ya 2 hua, to\\n                            // ` utne he din lagte use disconnect karne mai jitna size hota.\\n            return size;\\n\\n        vis = new boolean[n * m];\\n        boolean res = tarjans(root, -1, grid);\\n        return res ? 1 : 2; // Ab agar mujhe articulation point milta hai to mai to mai 1 return kardunga,\\n                            // aur agar nhi milta hai to mai 2 return kardunga kyunki at most mera answer 2\\n                            // ho sakta hai.\\n\\n    }\\n```\\n\\n## Answer to Why at most can be the answer : \\n\\n![image](https://assets.leetcode.com/users/images/e7c2d449-7122-4bb0-84cc-d9f854f02171_1666238915.071379.png)\\n\\n## Some Notes on Articulation Point :\\n\\n![image](https://assets.leetcode.com/users/images/364a8186-0c6a-40bd-b668-e696974e870c_1666184295.366266.png)\\n\\n![image](https://assets.leetcode.com/users/images/7d7dc322-047e-487d-b119-4affda0b7218_1666184270.9859486.png)\\n\\n![image](https://assets.leetcode.com/users/images/64503ae8-9afa-4965-9c71-3e548078c34b_1666184306.0032978.png)\\n\\n![image](https://assets.leetcode.com/users/images/3203bb2a-2d07-451d-959d-7338615c71b8_1666184313.2574124.png)\\n\\n![image](https://assets.leetcode.com/users/images/73439563-4253-400b-a360-a8066971a046_1666184332.6346247.png)\\n\\n![image](https://assets.leetcode.com/users/images/247c2009-b1d0-4155-942b-0e4a33eeee1e_1666184337.7150605.png)\\n\\n![image](https://assets.leetcode.com/users/images/e3a120a6-fa89-4815-b820-f12cf4d7aae1_1666184358.489158.png)\\n\\n![image](https://assets.leetcode.com/users/images/25d779a5-e6ff-4c93-9618-bb7a37904be0_1666184372.5872371.png)\\n\\n![image](https://assets.leetcode.com/users/images/b8efccce-1fec-4cbc-ab90-4d10760b55da_1666184388.2051961.png)\\n\\n![image](https://assets.leetcode.com/users/images/9c68a388-9d6e-44f5-8cc4-f3a4268e9f4f_1666184408.4437969.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // b <================= Minimum Number of Days to Disconnect Island ==========>\\n    // https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n\\n    // ! Brute Force, passed since the test case and constraints are small.\\n\\n    public static void dfs_numsIsland(int sr, int sc, int[][] grid, int[][] dir, boolean[][] vis) {\\n        vis[sr][sc] = true;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r][c]) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n            }\\n        }\\n    }\\n\\n    public static int numOfIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n\\n        int noOfIslands = 0;\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n            if (!vis[r][c] && grid[r][c] == 1) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n                noOfIslands++;\\n            }\\n        }\\n\\n        return noOfIslands;\\n    }\\n\\n    public int minDays_(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int initialComponents = numOfIslands(grid);\\n        if (initialComponents > 1 || initialComponents == 0)\\n            return 0;\\n\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1) {\\n                grid[r][c] = 0;\\n                int noOfComponents = numOfIslands(grid);\\n                if (noOfComponents > 1 || noOfComponents == 0)\\n                    return 1;\\n                grid[r][c] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n\\n    // B Optimized using the articulation Point\\n\\n    private static int[] low, disc;\\n    private static int time = 0;\\n    private static boolean[] vis;\\n\\n    public static int dfs_size(int idx, int[][] grid, boolean[] vis) {\\n        int n = grid.length, m = grid[0].length;\\n        int sr = idx / m, sc = idx % m;\\n\\n        vis[idx] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        int count = 0;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r * m + c]) {\\n                count += dfs_size(r * m + c, grid, vis);\\n            }\\n        }\\n\\n        return count + 1;\\n    }\\n\\n    public static boolean tarjans(int src, int par, int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        disc[src] = low[src] = time++;\\n        vis[src] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\n        boolean res = false;\\n        for (int d = 0; d < dir.length; d++) {\\n            int sr = src / m, sc = src % m;\\n\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 1) {\\n                int nbr = r * m + c;\\n                if (!vis[nbr]) {\\n                    res = res || tarjans(nbr, src, grid);\\n                    if (disc[src] < low[nbr]) { // Yahan pe equal to sign nhi kiya use. Why? ==> Kyunki hume cycle wale\\n                                                // structure ke liye bhi true return karna tha kyunki wahan pe do vertex\\n                                                // ko nikal ke graph disconnected ban sakta hai. Example is of a square,\\n                                                // removing the diagonal vertex will make component disconnected.\\n                        return true;\\n                    }\\n                    low[src] = Math.min(low[nbr], low[src]);\\n                } else if (nbr != par) {\\n                    low[src] = Math.min(low[src], disc[nbr]);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n\\n        disc = new int[n * m];\\n        low = new int[n * m];\\n        vis = new boolean[n * m];\\n        int root = -1;\\n        int noOfComponents = 0, size = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1 && !vis[i]) {\\n                root = i;\\n                size += dfs_size(i, grid, vis);\\n                noOfComponents++;\\n            }\\n        }\\n\\n        if (noOfComponents == 0 || noOfComponents > 1) // Agar mera component 0 hai ya 1 ha se bada hai to mai already\\n                                                       // disconnected hun, to 0 retun kardo\\n            return 0;\\n        else if (size <= 2) // Ab kyunki mai uper component ka check karke aaya hun to mai sure hun ki ab ek\\n                            // he single component hai graph mai. To agar component ka size 1 ya 2 hua, to\\n                            // ` utne he din lagte use disconnect karne mai jitna size hota.\\n            return size;\\n\\n        vis = new boolean[n * m];\\n        boolean res = tarjans(root, -1, grid);\\n        return res ? 1 : 2; // Ab agar mujhe articulation point milta hai to mai to mai 1 return kardunga,\\n                            // aur agar nhi milta hai to mai 2 return kardunga kyunki at most mera answer 2\\n                            // ho sakta hai.\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896493,
                "title": "c-islands-problems-medium-hard",
                "content": "**PLEASE UPVOTE IF YOU FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool vis[31][31];\\n    int noOfIslands(vector<vector<int>>& grid,int &n,int &m)\\n    {\\n       int islands=0;\\n       memset(vis,0,sizeof(vis));\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j])\\n               {\\n                   islands++;\\n                   dfs(grid,i,j,n,m);\\n               }\\n           }\\n       }\\n       \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n               grid[i][j]=vis[i][j]?1:0;\\n       }\\n        \\n        return islands;\\n    }\\n    void dfs(vector<vector<int>>& grid,int i,int j,int &n,int &m)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||!grid[i][j])return;\\n        vis[i][j]=1;\\n        grid[i][j]=0;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            dfs(grid,ni,nj,n,m);\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        //we can disconnect the island into 2 from the corner by at most 2 changes\\n        //00000     00000\\n        //01110     01010\\n        //01110---->00110\\n        //01110     01110\\n        //00000     00000\\n        \\n        //so basically in the worst case we need 2 steps-->ans can be 0,1,2\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        \\n         //edge cases\\n        if(n==1&&m==1)\\n            return grid[0][0];\\n        \\n        if(n*m==2)\\n        {\\n            int countOnes=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {if(grid[i][j]==1)countOnes++;}\\n          }\\n            return countOnes;\\n        }\\n        \\n        int initialIslands=noOfIslands(grid,n,m);\\n\\n        //made mistake in the checking condition dumbo :\\'( islands must not be one that is it\\n        //zero islands are considered valid cases\\n        \\n        if(initialIslands!=1)return 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int islands=0;\\n                if(grid[i][j])\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0;\\n                    \\n                   islands=noOfIslands(grid,n,m);\\n                  if(islands!=1)return 1; \\n                    \\n                    grid[i][j]=temp;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool vis[31][31];\\n    int noOfIslands(vector<vector<int>>& grid,int &n,int &m)\\n    {\\n       int islands=0;\\n       memset(vis,0,sizeof(vis));\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j])\\n               {\\n                   islands++;\\n                   dfs(grid,i,j,n,m);\\n               }\\n           }\\n       }\\n       \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n               grid[i][j]=vis[i][j]?1:0;\\n       }\\n        \\n        return islands;\\n    }\\n    void dfs(vector<vector<int>>& grid,int i,int j,int &n,int &m)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||!grid[i][j])return;\\n        vis[i][j]=1;\\n        grid[i][j]=0;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            dfs(grid,ni,nj,n,m);\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        //we can disconnect the island into 2 from the corner by at most 2 changes\\n        //00000     00000\\n        //01110     01010\\n        //01110---->00110\\n        //01110     01110\\n        //00000     00000\\n        \\n        //so basically in the worst case we need 2 steps-->ans can be 0,1,2\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        \\n         //edge cases\\n        if(n==1&&m==1)\\n            return grid[0][0];\\n        \\n        if(n*m==2)\\n        {\\n            int countOnes=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {if(grid[i][j]==1)countOnes++;}\\n          }\\n            return countOnes;\\n        }\\n        \\n        int initialIslands=noOfIslands(grid,n,m);\\n\\n        //made mistake in the checking condition dumbo :\\'( islands must not be one that is it\\n        //zero islands are considered valid cases\\n        \\n        if(initialIslands!=1)return 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int islands=0;\\n                if(grid[i][j])\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0;\\n                    \\n                   islands=noOfIslands(grid,n,m);\\n                  if(islands!=1)return 1; \\n                    \\n                    grid[i][j]=temp;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394064,
                "title": "c-articulation-point-o-m-n",
                "content": "Guys, Comment me if you have any questions, Approach is pretty similar to AP but we need to consider some corner cases as well, \\nCase 1 : there is only one island and one land return 1\\nCase 2 : if no of islands are more than one -> in this case we need to return 0;\\nCase 3: there is only one island and two lands return 2;\\nCase 4:  if there is an AP present return 1;\\nCase 5:  No Island return 0;\\nAll other cases:  return 2;\\n\\n\\n```\\nclass Solution {\\n    void dfs(list<int>* adj, vector<bool>& visited, vector<int>& discTime, vector<int>& lowTime, int& ap, int parent, int u){\\n        visited[u] = true;\\n        static int time = 0;\\n        discTime[u] = lowTime[u] = ++time;\\n        \\n        list<int>:: iterator itr;\\n        \\n        for(itr = adj[u].begin(); itr != adj[u].end(); itr++ ){\\n            int v = *itr;\\n            \\n            if(!visited[v]){\\n                dfs(adj, visited, discTime, lowTime, ap, u, v);\\n                lowTime[u] = min(lowTime[u], lowTime[v]);\\n                \\n                if(lowTime[v] > discTime[u]){\\n                    ap++;\\n                }\\n            }\\n            else if(parent != v){\\n                lowTime[u] = min(lowTime[u], discTime[v]);\\n            }\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        if(grid.size() == 0) return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int size = m*n;\\n        int count = 0;\\n        vector<int> disc(size, 0);\\n        vector<int> low(size, 0);\\n        vector<bool> visited(size, false);\\n        int ap = 0;\\n        list<int> adj[size];\\n        int ones = size;\\n        \\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++  ){\\n                if(grid[i][j]){\\n                    if(i+1 < m && grid[i+1][j]){\\n                        adj[i*n + j].push_back((i+1)*n + j);\\n                        adj[(i+1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j]){\\n                        adj[i*n + j].push_back((i-1)*n + j);\\n                        adj[(i-1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(j+1 < n && grid[i][j+1]){\\n                        adj[i*n + j].push_back(i*n + (j+1));\\n                        adj[(i*n + (j+1))].push_back(i*n + j);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1]){\\n                        adj[i*n + j].push_back(i*n + (j-1));\\n                        adj[(i*n + (j-1))].push_back(i*n + j);\\n                     }         \\n                }\\n                else{\\n                    visited[i*n + j] = true;\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        // Case 1 : there is only one island and one land\\n        if(ones == 1) return 1;\\n        \\n        for(int i = 0; i < size; i++ ){\\n            if(!visited[i]){\\n               dfs(adj, visited, disc, low, ap, -1, i);\\n               count++;\\n            }\\n        }\\n        \\n        \\n        // Case 2: island are more than 1 \\n        if(count > 1) return 0;\\n        \\n        // Case 3: there is only one island and two lands\\n        if(ones == 2) return 2;\\n        \\n        // Case 4: if there is an AP present\\n        if(ap) return 1;\\n        \\n\\t\\t// Case 5: No Island\\n        if(count == 0) return 0;\\n        \\n        // All other cases \\n        return 2;\\n    \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(list<int>* adj, vector<bool>& visited, vector<int>& discTime, vector<int>& lowTime, int& ap, int parent, int u){\\n        visited[u] = true;\\n        static int time = 0;\\n        discTime[u] = lowTime[u] = ++time;\\n        \\n        list<int>:: iterator itr;\\n        \\n        for(itr = adj[u].begin(); itr != adj[u].end(); itr++ ){\\n            int v = *itr;\\n            \\n            if(!visited[v]){\\n                dfs(adj, visited, discTime, lowTime, ap, u, v);\\n                lowTime[u] = min(lowTime[u], lowTime[v]);\\n                \\n                if(lowTime[v] > discTime[u]){\\n                    ap++;\\n                }\\n            }\\n            else if(parent != v){\\n                lowTime[u] = min(lowTime[u], discTime[v]);\\n            }\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        if(grid.size() == 0) return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int size = m*n;\\n        int count = 0;\\n        vector<int> disc(size, 0);\\n        vector<int> low(size, 0);\\n        vector<bool> visited(size, false);\\n        int ap = 0;\\n        list<int> adj[size];\\n        int ones = size;\\n        \\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++  ){\\n                if(grid[i][j]){\\n                    if(i+1 < m && grid[i+1][j]){\\n                        adj[i*n + j].push_back((i+1)*n + j);\\n                        adj[(i+1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j]){\\n                        adj[i*n + j].push_back((i-1)*n + j);\\n                        adj[(i-1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(j+1 < n && grid[i][j+1]){\\n                        adj[i*n + j].push_back(i*n + (j+1));\\n                        adj[(i*n + (j+1))].push_back(i*n + j);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1]){\\n                        adj[i*n + j].push_back(i*n + (j-1));\\n                        adj[(i*n + (j-1))].push_back(i*n + j);\\n                     }         \\n                }\\n                else{\\n                    visited[i*n + j] = true;\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        // Case 1 : there is only one island and one land\\n        if(ones == 1) return 1;\\n        \\n        for(int i = 0; i < size; i++ ){\\n            if(!visited[i]){\\n               dfs(adj, visited, disc, low, ap, -1, i);\\n               count++;\\n            }\\n        }\\n        \\n        \\n        // Case 2: island are more than 1 \\n        if(count > 1) return 0;\\n        \\n        // Case 3: there is only one island and two lands\\n        if(ones == 2) return 2;\\n        \\n        // Case 4: if there is an AP present\\n        if(ap) return 1;\\n        \\n\\t\\t// Case 5: No Island\\n        if(count == 0) return 0;\\n        \\n        // All other cases \\n        return 2;\\n    \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340328,
                "title": "c-2-solutions-clean-code-and-detailed-explanation",
                "content": "The idea:\\nFirst thing to notice is that we need atmost two days to disconnect an island. The intuition is that since diagonal does not count as a connection, given a corner of the island, we can disconnect two of its connections (in fact it only has two connections) to seperate it. Notice that we can do this to any corner of an island.\\n\\nThe intuitive idea is to simply brute force our way through this question. Using a simple dfs, we can count the number of islands. If that number is larger than 1 we know that the island is disconnected. Therefore, let us count the number of island first without doing anything, if the grid is already disconnected, return 0. If the grid is not, we will remove every `1` in the grid and count the number of islands. If that number increase after 1 removal, we know that we can remove only 1 piece. Therefore, we can return 1. However, if removing any `1` won\\'t give us a disconnected grid, we can safely return `2`.\\n\\nThis idea should be alot clearer once you see the implementation:\\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true && found;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    bool yes = one_islands(grid);\\n                    if(!yes) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```\\nCouple of implementation details to address. First, notice that `one_islands` method return `true && found`. This is to account for cases where there is a single `1` in the entire grid. When that happens, we want to make sure that an empty grid is counted as disconnected. Counting the number of islands takes `O(n * m)` worst case we need to count it `n * m` times (a full grid of `1`). Therefore, the time complexity is `O((nm)^2)`, space complexity is `O(nm)` (`visited` array and call stack)\\n\\nThe second idea(Tarjan/Articulation point):\\nSo time complexity of `O((nm)^2)` is not exactly thrilling. Is there a way we can improve this?\\n\\nThink of the grid as an undirected graph. If there is a way for us to remove 1 vertex to disconnect the graph, then we can safely return 1. This \"critical\" vertex is the `Articulation point`. As it turns out, this is a well known problem in finding vulnerabilities in networks and we can use Tarjan\\'s Algorithm to solve this question. \\n\\nShort introduction to Tarjan\\'s algorithm. Tarjan\\'s algorithm is a single pass DFS algorithm that can find all strongly connected components. Tarjan mainly work by keeping track of the highest ancestor a vertex can reach in the DFS tree. This value is often kept within the array `low`. To do this we also need to keep track of the array `disc` which records the discovery time of each vertex. The array `parent` is also important for reasons we will discuss later, but it keeps track of the parent of a vertex in the DFS tree.\\n\\nHow can we use Tarjan to find the articultion point? Well, suppose we are on vertex `u` and we are process one of our children vertex `v`. After we recursived called on it if `low[v] <= disc[u]` it means that there is a path from `v` to a vertex above `u` in the DFS tree, confirming that `u` cannot be the articualtion point (we can reach `v` from that vertex above `u` by reversing the back edge, remember that this is a undirected graph). If `low[v] > disc[u]`, this means that `u` is a \"choke point\" for `v`, making `u` an articulation point. Similary, if `u` is the root of the DFS tree, if it has more than 2 children, it must be an articulation point too. \\n\\nIf you are confused, don\\'t worry, Tarjan\\'s algorithm is not friendly to people who don\\'t understand them fully. I recommend goolging it and watching a few tutorials explaining Tarjan\\'s. In addition, you can try this simmilar question in finding \"bridge\" of a network https://leetcode.com/problems/critical-connections-in-a-network/. Anyways, here is the implementation:\\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    int time = 0;\\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    bool ap(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<vector<int>>& low,\\n            vector<vector<int>>& disc, vector<vector<int>>& parent, int i, int j, bool is_parent) {\\n        int children = 0;\\n        visited[i][j] = true;\\n        \\n        disc[i][j] = low[i][j] = ++time;\\n        \\n        for(int k = 0; k < 4; k++) {\\n            int ci = i + offset[k][0];\\n            int cj = j + offset[k][1];\\n            \\n            if(ci < 0 || ci >= n || cj < 0 || cj >= m || grid[ci][cj] == 0) continue;\\n            \\n            if(!visited[ci][cj]) {\\n                children++;\\n                parent[ci][cj] = i * m + j;\\n                bool terminate = ap(grid, visited, low, disc, parent, ci, cj, false);\\n                if(terminate) return true;\\n                \\n                low[i][j] = min(low[i][j], low[ci][cj]);\\n                \\n                if(is_parent && children > 1) return true;\\n                \\n                if(!is_parent && low[ci][cj] >= disc[i][j]) return true;\\n            } else if (ci != parent[i][j] / m || cj != parent[i][j] % m) {\\n                low[i][j] = min(low[i][j], disc[ci][cj]);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> parent(n, vector<int>(m, 0));\\n        \\n        int start_i = 0;\\n        int start_j = 0;\\n        for(; start_i < n; start_i++) {\\n            for(start_j = 0; start_j < m; start_j++) {\\n                if(grid[start_i][start_j] != 0) goto OUT;\\n            }\\n        }\\n        \\n        OUT:\\n        \\n        test = ap(grid, visited, low, disc, parent, start_i, start_j, true);\\n        if(test || time == 1) return 1;\\n        \\n        return 2;\\n    }\\n};\\n```\\nNotice that we have to check `ci != parent[i][j] / m || cj != parent[i][j] % m` to make sure that we don\\'t use an edge twice. Tarjan has the time complexity of `O(nm)`, therefore the entire algorithm has the time complexity of `O(nm)`. The space complexity is also `O(nm)` but with a lot more hidden constants.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true && found;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    bool yes = one_islands(grid);\\n                    if(!yes) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    int time = 0;\\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    bool ap(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<vector<int>>& low,\\n            vector<vector<int>>& disc, vector<vector<int>>& parent, int i, int j, bool is_parent) {\\n        int children = 0;\\n        visited[i][j] = true;\\n        \\n        disc[i][j] = low[i][j] = ++time;\\n        \\n        for(int k = 0; k < 4; k++) {\\n            int ci = i + offset[k][0];\\n            int cj = j + offset[k][1];\\n            \\n            if(ci < 0 || ci >= n || cj < 0 || cj >= m || grid[ci][cj] == 0) continue;\\n            \\n            if(!visited[ci][cj]) {\\n                children++;\\n                parent[ci][cj] = i * m + j;\\n                bool terminate = ap(grid, visited, low, disc, parent, ci, cj, false);\\n                if(terminate) return true;\\n                \\n                low[i][j] = min(low[i][j], low[ci][cj]);\\n                \\n                if(is_parent && children > 1) return true;\\n                \\n                if(!is_parent && low[ci][cj] >= disc[i][j]) return true;\\n            } else if (ci != parent[i][j] / m || cj != parent[i][j] % m) {\\n                low[i][j] = min(low[i][j], disc[ci][cj]);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> parent(n, vector<int>(m, 0));\\n        \\n        int start_i = 0;\\n        int start_j = 0;\\n        for(; start_i < n; start_i++) {\\n            for(start_j = 0; start_j < m; start_j++) {\\n                if(grid[start_i][start_j] != 0) goto OUT;\\n            }\\n        }\\n        \\n        OUT:\\n        \\n        test = ap(grid, visited, low, disc, parent, start_i, start_j, true);\\n        if(test || time == 1) return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910145,
                "title": "c-bfs-islands-problems-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the posted solutions are using the similar basic flow:\\n\\n- If there is no island or more than 1 island, return 0;\\n- If there is only one land, return 1;\\n- If any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n- Otherwise, return 2 \\n\\n# Approach\\nUsing BFS to find number of island after replacing land to water\\n\\n<!-- Time Complexity: O((m*n)^2) -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(q.empty()==false)\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n                                if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(q.empty()==false)\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n                                if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385133,
                "title": "java-easy-dfs-using-number-of-islands",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int n = grid.length ;\\n        int m = grid[0].length ;\\n        if(numIslands(grid) != 1){\\n          return 0;\\n        }\\n        for(int i = 0; i < n;i++ ){\\n          for(int j = 0 ; j < m ; j++){\\n              if(grid[i][j] == 1){\\n                 grid[i][j] = 0;\\n                \\n                 if(numIslands(grid) != 1){\\n                   return 1;\\n                 }\\n                 \\n                 grid[i][j] = 1;\\n              }\\n          }\\n        }\\n      return 2;\\n    }\\n  public int numIslands(int[][] grid) {\\n        int count = 0;\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0 && visited[i][j] == false){\\n                   \\n                    count++;\\n                    countIslands(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n  private void countIslands(int grid[][],int i,int j,boolean visited[][]){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || visited[i][j] == true){\\n        return;    \\n        } \\n         visited[i][j] = true;\\n         countIslands(grid,i - 1,j,visited);\\n         countIslands(grid,i + 1,j,visited);\\n         countIslands(grid,i,j - 1,visited);\\n         countIslands(grid,i,j + 1,visited);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int n = grid.length ;\\n        int m = grid[0].length ;\\n        if(numIslands(grid) != 1){\\n          return 0;\\n        }\\n        for(int i = 0; i < n;i++ ){\\n          for(int j = 0 ; j < m ; j++){\\n              if(grid[i][j] == 1){\\n                 grid[i][j] = 0;\\n                \\n                 if(numIslands(grid) != 1){\\n                   return 1;\\n                 }\\n                 \\n                 grid[i][j] = 1;\\n              }\\n          }\\n        }\\n      return 2;\\n    }\\n  public int numIslands(int[][] grid) {\\n        int count = 0;\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0 && visited[i][j] == false){\\n                   \\n                    count++;\\n                    countIslands(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n  private void countIslands(int grid[][],int i,int j,boolean visited[][]){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || visited[i][j] == true){\\n        return;    \\n        } \\n         visited[i][j] = true;\\n         countIslands(grid,i - 1,j,visited);\\n         countIslands(grid,i + 1,j,visited);\\n         countIslands(grid,i,j - 1,visited);\\n         countIslands(grid,i,j + 1,visited);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951870,
                "title": "bfs-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    bool safe(int x,int y,int m,int n)\\n    {\\n        return (x>=0&&x<m&&y>=0&&y<n);\\n    }\\n    void travel(int i,int j,vector<vector<int> > &grid,vector<vector<int> > &visited)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int > >q;\\n        q.push({i,j});\\n        visited[i][j]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nx=x+dx[k];\\n                int ny=y+dy[k];\\n                                  \\n                if(safe(nx,ny,m,n)&&!visited[nx][ny]&&grid[nx][ny]==1)\\n                {\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return ;\\n    }\\n    int bfs(vector<vector<int> > &grid)\\n    {\\n        //number of connected component\\n        int count=0;\\n        int m=grid.size();\\n        if(m==0)\\n            return 0;\\n        int n=grid[0].size();\\n        vector<vector<int> > visited(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1&&!visited[i][j])\\n                {\\n                    count++;\\n                    travel(i,j,grid,visited);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int count=bfs(grid);\\n        if(count!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    \\n                    count=bfs(grid);\\n                    if(count!=1)\\n                        return 1;\\n                    \\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    bool safe(int x,int y,int m,int n)\\n    {\\n        return (x>=0&&x<m&&y>=0&&y<n);\\n    }\\n    void travel(int i,int j,vector<vector<int> > &grid,vector<vector<int> > &visited)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int > >q;\\n        q.push({i,j});\\n        visited[i][j]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nx=x+dx[k];\\n                int ny=y+dy[k];\\n                                  \\n                if(safe(nx,ny,m,n)&&!visited[nx][ny]&&grid[nx][ny]==1)\\n                {\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return ;\\n    }\\n    int bfs(vector<vector<int> > &grid)\\n    {\\n        //number of connected component\\n        int count=0;\\n        int m=grid.size();\\n        if(m==0)\\n            return 0;\\n        int n=grid[0].size();\\n        vector<vector<int> > visited(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1&&!visited[i][j])\\n                {\\n                    count++;\\n                    travel(i,j,grid,visited);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int count=bfs(grid);\\n        if(count!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    \\n                    count=bfs(grid);\\n                    if(count!=1)\\n                        return 1;\\n                    \\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819402,
                "title": "java-bfs",
                "content": "If you look carefully, the result is 0, 1, or 2;\\n1, if num of islands not 1, reutrn 0;\\n2, special cases, only one 1 or two 1s;\\n3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n4, otherwise return 2;\\n\\n```\\nclass Solution {\\n    Queue<int[]> connects;\\n    public int minDays(int[][] g) {\\n        int m = g.length, n = g[0].length, ones = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        connects = new LinkedList<>();\\n        if (getNumOfIslandsAndConnects(g) != 1) return 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) ones += g[i][j];\\n        if (ones <= 2) return ones;\\n        while(!connects.isEmpty()) {  // only check ones with neigs > 1, which potentially connects 2 islands\\n            int[] curr = connects.poll();\\n            g[curr[0]][curr[1]] = 0;\\n            if (getNumOfIslandsOnly(g) > 1) return 1;\\n            g[curr[0]][curr[1]] = 1;\\n        }\\n        return 2;\\n    }\\n    \\n    private int getNumOfIslandsAndConnects(int[][] g){\\n        return getNumOfIslands(g, true);\\n    }\\n    \\n    private int getNumOfIslandsOnly(int[][] g){\\n        return getNumOfIslands(g, false);\\n    }\\n    \\n    private int getNumOfIslands(int[][] g, boolean setConnects){\\n        int m = g.length, n = g[0].length, islands = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == 0 || vs[i][j]) continue;\\n                islands++;\\n                Queue<int[]> q = new LinkedList<>();\\n                q.offer(new int[]{i, j});\\n                vs[i][j] = true;\\n                while (!q.isEmpty()) {\\n                    int[] cur = q.poll();\\n                    int numOfNeigs = 0;\\n                    for(int[] d : dir) {\\n                        int row = cur[0] + d[0], col = cur[1] + d[1];\\n                        if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] == 0) continue;\\n                        numOfNeigs++;\\n                        if (vs[row][col]) continue;\\n                        vs[row][col] = true;\\n                        q.offer(new int[]{row, col});\\n                    }\\n                    if (setConnects && numOfNeigs > 1) connects.offer(cur);   // connects has more than 1 neighbors\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Queue<int[]> connects;\\n    public int minDays(int[][] g) {\\n        int m = g.length, n = g[0].length, ones = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        connects = new LinkedList<>();\\n        if (getNumOfIslandsAndConnects(g) != 1) return 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) ones += g[i][j];\\n        if (ones <= 2) return ones;\\n        while(!connects.isEmpty()) {  // only check ones with neigs > 1, which potentially connects 2 islands\\n            int[] curr = connects.poll();\\n            g[curr[0]][curr[1]] = 0;\\n            if (getNumOfIslandsOnly(g) > 1) return 1;\\n            g[curr[0]][curr[1]] = 1;\\n        }\\n        return 2;\\n    }\\n    \\n    private int getNumOfIslandsAndConnects(int[][] g){\\n        return getNumOfIslands(g, true);\\n    }\\n    \\n    private int getNumOfIslandsOnly(int[][] g){\\n        return getNumOfIslands(g, false);\\n    }\\n    \\n    private int getNumOfIslands(int[][] g, boolean setConnects){\\n        int m = g.length, n = g[0].length, islands = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == 0 || vs[i][j]) continue;\\n                islands++;\\n                Queue<int[]> q = new LinkedList<>();\\n                q.offer(new int[]{i, j});\\n                vs[i][j] = true;\\n                while (!q.isEmpty()) {\\n                    int[] cur = q.poll();\\n                    int numOfNeigs = 0;\\n                    for(int[] d : dir) {\\n                        int row = cur[0] + d[0], col = cur[1] + d[1];\\n                        if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] == 0) continue;\\n                        numOfNeigs++;\\n                        if (vs[row][col]) continue;\\n                        vs[row][col] = true;\\n                        q.offer(new int[]{row, col});\\n                    }\\n                    if (setConnects && numOfNeigs > 1) connects.offer(cur);   // connects has more than 1 neighbors\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819368,
                "title": "easy-c-solution-with-full-explanation",
                "content": "# Connected Components\\n**Look closely, the answer of the question can not be greater than 2.**\\n\\nAlgo:\\n1. First Check if the connected components are already greater than 1, if yes return 0\\n2. Then do the following:\\n    for every grid value of 1, set it up for 0, check connected components, if connect components are now > 1 return ans 1, else set it up for 1 again\\n3. if ans is not returned till now, ans must be 2, so just return 2 ;)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int connected_components(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==false)\\n                {\\n                    count++;\\n                    queue<pair<int,int>>q;\\n                    vis[i][j]=true;\\n                    q.push(make_pair(i,j));\\n                    int dir[]={0,1,0,-1,0};\\n                    while(!q.empty())\\n                    {\\n                        auto p= q.front();\\n                        q.pop();\\n                        int x=p.first, y=p.second;\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int nx= x+dir[k];\\n                            int ny= y+dir[k+1];\\n                            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] && !vis[nx][ny])\\n                            {\\n                                vis[nx][ny]=true;\\n                                q.push(make_pair(nx,ny));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int conn= connected_components(grid);\\n        if(conn>1) return 0;\\n\\t\\t\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n\\t\\t\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    conn= connected_components(grid);\\n                    if(conn>1) return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connected_components(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==false)\\n                {\\n                    count++;\\n                    queue<pair<int,int>>q;\\n                    vis[i][j]=true;\\n                    q.push(make_pair(i,j));\\n                    int dir[]={0,1,0,-1,0};\\n                    while(!q.empty())\\n                    {\\n                        auto p= q.front();\\n                        q.pop();\\n                        int x=p.first, y=p.second;\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int nx= x+dir[k];\\n                            int ny= y+dir[k+1];\\n                            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] && !vis[nx][ny])\\n                            {\\n                                vis[nx][ny]=true;\\n                                q.push(make_pair(nx,ny));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int conn= connected_components(grid);\\n        if(conn>1) return 0;\\n\\t\\t\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n\\t\\t\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    conn= connected_components(grid);\\n                    if(conn>1) return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819295,
                "title": "javascript-find-the-critical-points-and-check-o-mnk-k-number-of-critical-point",
                "content": "The maximum answer could only be 2.\\nEx:\\n0111\\n0111\\n0111\\n0000\\n-->\\n0111\\n0011\\n0101\\n0000\\n\\nSince we know this rule. Now we have to do the following steps:\\n1. Is it only one island?\\n\\tYes: Go next Step\\n\\tNo: return 0\\n2. In the step 1, you can check which land connect 2 lands at most\\n    If connect 1 land, return 1\\n\\tIf connect 2 lands, it is critical point\\n3. Check every case by converting critical point to 0\\n\\n```\\nfunction markIsland(x, y, checked, grid, bridges = []) {\\n    let land = 0;\\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    checked[x][y] = true;\\n    let newi, newj;\\n\\n    for (let move of moves) {\\n        let i = x + move[0],\\n            j = y + move[1];\\n\\n        if (0 <= i && i < grid.length && 0 <= j && j < grid[0].length && grid[i][j] == 1) {\\n            land++;\\n            if (checked[i][j] == false)\\n                markIsland(i, j, checked, grid, bridges);\\n            if (land == 1) {\\n                newi = i;\\n                newj = j;\\n            }\\n        }\\n    }\\n    if (land == 2)\\n        bridges.push([x, y]);\\n    if (land == 1)\\n        bridges.push([newi, newj]);\\n}\\n\\nfunction isOneIsland(grid, bridges) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let islandCount = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (!checked[i][j] && grid[i][j] == 1) {\\n                islandCount++;\\n                markIsland(i, j, checked, grid, bridges);\\n            }\\n        }\\n    }\\n    \\n    return islandCount;\\n}\\n\\nvar minDays = function(grid) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let bridges = [];\\n    let islandCount = isOneIsland(grid, bridges);\\n    if (islandCount !== 1)\\n        return 0;\\n    \\n    for (let [x, y] of bridges) {\\n        grid[x][y] = 0;\\n        if (isOneIsland(grid) !== 1) {\\n            return 1;\\n        }\\n        grid[x][y] = 1;\\n    }\\n    \\n    return 2;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The maximum answer could only be 2.\\nEx:\\n0111\\n0111\\n0111\\n0000\\n-->\\n0111\\n0011\\n0101\\n0000\\n\\nSince we know this rule. Now we have to do the following steps:\\n1. Is it only one island?\\n\\tYes: Go next Step\\n\\tNo: return 0\\n2. In the step 1, you can check which land connect 2 lands at most\\n    If connect 1 land, return 1\\n\\tIf connect 2 lands, it is critical point\\n3. Check every case by converting critical point to 0\\n\\n```\\nfunction markIsland(x, y, checked, grid, bridges = []) {\\n    let land = 0;\\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    checked[x][y] = true;\\n    let newi, newj;\\n\\n    for (let move of moves) {\\n        let i = x + move[0],\\n            j = y + move[1];\\n\\n        if (0 <= i && i < grid.length && 0 <= j && j < grid[0].length && grid[i][j] == 1) {\\n            land++;\\n            if (checked[i][j] == false)\\n                markIsland(i, j, checked, grid, bridges);\\n            if (land == 1) {\\n                newi = i;\\n                newj = j;\\n            }\\n        }\\n    }\\n    if (land == 2)\\n        bridges.push([x, y]);\\n    if (land == 1)\\n        bridges.push([newi, newj]);\\n}\\n\\nfunction isOneIsland(grid, bridges) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let islandCount = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (!checked[i][j] && grid[i][j] == 1) {\\n                islandCount++;\\n                markIsland(i, j, checked, grid, bridges);\\n            }\\n        }\\n    }\\n    \\n    return islandCount;\\n}\\n\\nvar minDays = function(grid) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let bridges = [];\\n    let islandCount = isOneIsland(grid, bridges);\\n    if (islandCount !== 1)\\n        return 0;\\n    \\n    for (let [x, y] of bridges) {\\n        grid[x][y] = 0;\\n        if (isOneIsland(grid) !== 1) {\\n            return 1;\\n        }\\n        grid[x][y] = 1;\\n    }\\n    \\n    return 2;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3593822,
                "title": "c-textbook-tarjan-s",
                "content": "This was a bit nuanced to implement but we can use textbook Tarjan\\'s algorithm. First we find the number of 1s in the graph. We will pick one random poin, and apply Tarjan\\'s articulation point finding algorithm. The algo also keeps track of number of nodes it visited.\\n\\nIf the algorithm didn\\'t visited all 1s in the graph, then there are 2 islands, no need to cut off anything. Ans = 0.\\n\\nOtherwise, if we found an articulation point, then the answer can be 1. Otherwise  2 (except if the graph only has 1 single 1, then it\\'s 1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dirs[5] = { 0, 1, 0, -1, 0 };\\n    int n, m;\\n    int visitedCount = 0;\\n    bool dfs(int i, int j, int pi, int pj, int time, \\n        vector<vector<bool>>& visited,\\n        vector<vector<int>>& tin,\\n        vector<vector<int>>& low,\\n        vector<vector<int>>& grid\\n        )\\n    {\\n        visited[i][j] = true;\\n        visitedCount++;\\n        low[i][j] = tin[i][j] = time++;\\n        int children = 0;\\n        int ans = false;\\n        for (int di = 0; di < 4; di++) {\\n            int ii = i + dirs[di];\\n            int jj = j + dirs[di+1];\\n            if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n            if (grid[ii][jj] == 0) continue;\\n            if (ii == pi && jj == pj) continue;\\n            if (visited[ii][jj]) {\\n                low[i][j] = min(low[i][j], tin[ii][jj]);\\n            } else {\\n                if (dfs(ii, jj, i, j, time, visited, tin, low, grid)) {\\n                    ans = true;\\n                }\\n                low[i][j] = min(low[i][j], low[ii][jj]);\\n                if (low[ii][jj] >= tin[i][j] && pi != -1 && pj != -1) {\\n                    ans = true;\\n                }\\n                children++;\\n            }\\n        }\\n        if (pi == -1 && pj == -1 && children > 1) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        vector<vector<int>> tin(n, vector<int>(m));\\n        vector<vector<int>> low(n, vector<int>(m));\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        int found = 0;\\n        int ones = 0;\\n        int ii, jj;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    ones++;\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n\\n        if (ones == 1) return 1; // edge case\\n        if (ones == 0) return 0; // edge case\\n        bool hasArticulationPoint = dfs(ii, jj, -1, -1, 0, visited, tin, low, grid);\\n        if (ones != visitedCount) {\\n            return 0;\\n        }\\n\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dirs[5] = { 0, 1, 0, -1, 0 };\\n    int n, m;\\n    int visitedCount = 0;\\n    bool dfs(int i, int j, int pi, int pj, int time, \\n        vector<vector<bool>>& visited,\\n        vector<vector<int>>& tin,\\n        vector<vector<int>>& low,\\n        vector<vector<int>>& grid\\n        )\\n    {\\n        visited[i][j] = true;\\n        visitedCount++;\\n        low[i][j] = tin[i][j] = time++;\\n        int children = 0;\\n        int ans = false;\\n        for (int di = 0; di < 4; di++) {\\n            int ii = i + dirs[di];\\n            int jj = j + dirs[di+1];\\n            if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n            if (grid[ii][jj] == 0) continue;\\n            if (ii == pi && jj == pj) continue;\\n            if (visited[ii][jj]) {\\n                low[i][j] = min(low[i][j], tin[ii][jj]);\\n            } else {\\n                if (dfs(ii, jj, i, j, time, visited, tin, low, grid)) {\\n                    ans = true;\\n                }\\n                low[i][j] = min(low[i][j], low[ii][jj]);\\n                if (low[ii][jj] >= tin[i][j] && pi != -1 && pj != -1) {\\n                    ans = true;\\n                }\\n                children++;\\n            }\\n        }\\n        if (pi == -1 && pj == -1 && children > 1) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        vector<vector<int>> tin(n, vector<int>(m));\\n        vector<vector<int>> low(n, vector<int>(m));\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        int found = 0;\\n        int ones = 0;\\n        int ii, jj;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    ones++;\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n\\n        if (ones == 1) return 1; // edge case\\n        if (ones == 0) return 0; // edge case\\n        bool hasArticulationPoint = dfs(ii, jj, -1, -1, 0, visited, tin, low, grid);\\n        if (ones != visitedCount) {\\n            return 0;\\n        }\\n\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237534,
                "title": "simple-dfs-c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[row][col]=1;\\n        int delrow[] = {1, -1, 0, 0};\\n        int delcol[] = {0, 0, 1, -1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\n\\nif(nrow>=0&&nrow<n&&ncol>=0&&ncol<m&&!vis[nrow][ncol]&&grid[nrow][ncol]==1)\\n            {\\n            dfs(nrow,ncol,grid,vis);\\n            }\\n        }\\n    }\\n    int countIsland(vector<vector<int>>& grid)\\n      {  \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int island=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j] && grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,vis);\\n                    island++;\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int islands=countIsland(grid);\\n    //all zero\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = countIsland(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[row][col]=1;\\n        int delrow[] = {1, -1, 0, 0};\\n        int delcol[] = {0, 0, 1, -1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\n\\nif(nrow>=0&&nrow<n&&ncol>=0&&ncol<m&&!vis[nrow][ncol]&&grid[nrow][ncol]==1)\\n            {\\n            dfs(nrow,ncol,grid,vis);\\n            }\\n        }\\n    }\\n    int countIsland(vector<vector<int>>& grid)\\n      {  \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int island=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j] && grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,vis);\\n                    island++;\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int islands=countIsland(grid);\\n    //all zero\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = countIsland(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958195,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n x m x n x m)\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        vector<pair<int, int>>po;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        int cnt=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j] && grid[i][j]){\\n                    po.push_back({i, j});\\n                    cnt++;\\n                    v[i][j]=1;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        q.pop();\\n                        int c[4]={0, -1, 0, 1};\\n                        int r[4]={-1, 0, 1, 0};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                if(!v[row][col] && grid[row][col]){\\n                                    po.push_back({row, col});\\n                                    v[row][col]=1;\\n                                    q.push({row, col});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==0 || cnt>1){return 0;}\\n        else{\\n            for(int i=0; i<po.size(); i++){\\n                v[po[i].first][po[i].second]=0;\\n                vector<vector<int>>chk(v.size(), vector<int>(v[0].size(), 0));\\n                int cnt1=0;\\n                for(int x=0; x<v.size(); x++){\\n                    for(int j=0; j<v[0].size(); j++){\\n                        if(v[x][j] && !chk[x][j]){\\n                            cnt1++;\\n                            //cout<<x<<\" \"<<j<<endl;\\n                            chk[x][j]=1;\\n                            queue<pair<int, int>>q;\\n                            q.push({x, j});\\n                            while(!q.empty()){\\n                                int x=q.front().first, y=q.front().second;\\n                                q.pop();\\n                                int c[4]={0, -1, 0, 1};\\n                                int r[4]={-1, 0, 1, 0};\\n                                for(int k=0; k<4; k++){\\n                                    int row=r[k]+x, col=c[k]+y;\\n                                    if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                        if(!chk[row][col] && v[row][col]){\\n                                            chk[row][col]=1;\\n                                            q.push({row, col});\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                //cout<<cnt1<<endl;\\n                if(cnt1>1 || cnt1==0){return 1;}\\n                else{v[po[i].first][po[i].second]=1;}\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        vector<pair<int, int>>po;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        int cnt=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j] && grid[i][j]){\\n                    po.push_back({i, j});\\n                    cnt++;\\n                    v[i][j]=1;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        q.pop();\\n                        int c[4]={0, -1, 0, 1};\\n                        int r[4]={-1, 0, 1, 0};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                if(!v[row][col] && grid[row][col]){\\n                                    po.push_back({row, col});\\n                                    v[row][col]=1;\\n                                    q.push({row, col});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==0 || cnt>1){return 0;}\\n        else{\\n            for(int i=0; i<po.size(); i++){\\n                v[po[i].first][po[i].second]=0;\\n                vector<vector<int>>chk(v.size(), vector<int>(v[0].size(), 0));\\n                int cnt1=0;\\n                for(int x=0; x<v.size(); x++){\\n                    for(int j=0; j<v[0].size(); j++){\\n                        if(v[x][j] && !chk[x][j]){\\n                            cnt1++;\\n                            //cout<<x<<\" \"<<j<<endl;\\n                            chk[x][j]=1;\\n                            queue<pair<int, int>>q;\\n                            q.push({x, j});\\n                            while(!q.empty()){\\n                                int x=q.front().first, y=q.front().second;\\n                                q.pop();\\n                                int c[4]={0, -1, 0, 1};\\n                                int r[4]={-1, 0, 1, 0};\\n                                for(int k=0; k<4; k++){\\n                                    int row=r[k]+x, col=c[k]+y;\\n                                    if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                        if(!chk[row][col] && v[row][col]){\\n                                            chk[row][col]=1;\\n                                            q.push({row, col});\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                //cout<<cnt1<<endl;\\n                if(cnt1>1 || cnt1==0){return 1;}\\n                else{v[po[i].first][po[i].second]=1;}\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2934372,
                "title": "java-easy-solution-with-visuals-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/993bfbc9-1371-479a-a6d6-15d2a57ebbe3_1671600258.314148.png)\\n![image.png](https://assets.leetcode.com/users/images/9fd4db9f-d8ec-4cf5-8e79-bec571339146_1671600298.5091133.png)\\n![image.png](https://assets.leetcode.com/users/images/ced7c207-456d-4221-b5c3-a800e62df608_1671600374.1280644.png)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/9710faee-4626-4ac4-aefd-cb724ae139d0_1671600333.0815878.png)\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575657,
                "title": "c-dfs-time-o-r-c-r-c-space-o-r-c",
                "content": "DFS solution\\n\\n```\\n// time: O(r * c * r * c)\\n// space: O(r * c)\\n\\nclass Solution {\\npublic:\\n  int minDays(vector<vector<int>>& grid) {\\n    if (numberOfIslands(grid) != 1) // check the initial number of islands\\n      return 0;\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        if (grid[r][c]) {\\n          grid[r][c] = 0; // remove one land to see whether we can disconnect the entire island\\n          if (numberOfIslands(grid) != 1)\\n            return 1;\\n          grid[r][c] = 1; // reset the land\\n        }\\n      }\\n    }\\n    \\n    return 2; // otherwise need at most 2 days to disconnect\\n  }\\n  \\nprivate:\\n  int numberOfIslands(vector<vector<int>>& grid) {\\n    int islands = 0;\\n    char visited[300][300] {};\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        islands += dfs(grid, r, c, visited);\\n      }\\n    }\\n    return islands;\\n  }\\n  \\n  int dfs(vector<vector<int>>& grid, int r, int c, char (*visited)[300]) {\\n    if (r < 0 or r >= grid.size() or c < 0 or c >= grid[0].size() or grid[r][c] == 0 or visited[r][c])\\n      return 0;\\n    \\n    visited[r][c] = 1;\\n    \\n    dfs(grid, r+1, c, visited);\\n    dfs(grid, r-1, c, visited);\\n    dfs(grid, r, c+1, visited);\\n    dfs(grid, r, c-1, visited);\\n    \\n    return 1;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(r * c * r * c)\\n// space: O(r * c)\\n\\nclass Solution {\\npublic:\\n  int minDays(vector<vector<int>>& grid) {\\n    if (numberOfIslands(grid) != 1) // check the initial number of islands\\n      return 0;\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        if (grid[r][c]) {\\n          grid[r][c] = 0; // remove one land to see whether we can disconnect the entire island\\n          if (numberOfIslands(grid) != 1)\\n            return 1;\\n          grid[r][c] = 1; // reset the land\\n        }\\n      }\\n    }\\n    \\n    return 2; // otherwise need at most 2 days to disconnect\\n  }\\n  \\nprivate:\\n  int numberOfIslands(vector<vector<int>>& grid) {\\n    int islands = 0;\\n    char visited[300][300] {};\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        islands += dfs(grid, r, c, visited);\\n      }\\n    }\\n    return islands;\\n  }\\n  \\n  int dfs(vector<vector<int>>& grid, int r, int c, char (*visited)[300]) {\\n    if (r < 0 or r >= grid.size() or c < 0 or c >= grid[0].size() or grid[r][c] == 0 or visited[r][c])\\n      return 0;\\n    \\n    visited[r][c] = 1;\\n    \\n    dfs(grid, r+1, c, visited);\\n    dfs(grid, r-1, c, visited);\\n    dfs(grid, r, c+1, visited);\\n    dfs(grid, r, c-1, visited);\\n    \\n    return 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176459,
                "title": "tarjin-with-c-clean-code-brief-explanation",
                "content": "Intuitives:\\n1. Needs to figure out how many connected islands (classic dfs). If only one island, needs to disconnect.\\n2. At most two steps, the island definitely can be departed. More specificly, is is possible to disconnect with just ONE step?\\n3. Treat the island as a connected graph, and the question transformed to \"find the critical edge in a graph\". For this question,\\n    brutal-force solution is straight forward by cut each graph edge and count the connected components. But to optimize, \\n\\t\"tarjin\" can solve this issue with linear time complexity.\\n\\t \\n\\t\\n        // 1. find all islands\\n        int islands = 0;\\n        int start_x, start_y;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==1) {\\n                    islands++;\\n                    start_x = x;\\n                    start_y = y;\\n                    dfs(grid,x,y);\\n                }\\n            }\\n        }\\n        if (islands != 1) return 0;\\n        \\n        // 2. corner case, one island with 1 or 2 cells. Since tarjin is targeting edges, a minor difference with nodes.\\n        int cnt = 0;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==2) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        if (cnt==2 || cnt==1) return cnt;\\n        \\n        \\n        // 3. disconnect islands. Check if critial edge exist\\n        vector<vector<int>> depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        vector<vector<int>> min_depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        if (tarjin({start_x, start_y}, {-1,-1}, grid, depth, min_depth, 0)) {\\n            return 1;\\n        }\\n        return 2;\\n        }\\n    \\n       bool tarjin(vector<int> cur, vector<int> previous, vector<vector<int>>& grid, \\n                vector<vector<int>>& depth, vector<vector<int>>& min_depth, int cur_depth) {\\n          if (depth[cur[0]][cur[1]]!=-1) return false;\\n          depth[cur[0]][cur[1]] = cur_depth;\\n          min_depth[cur[0]][cur[1]] = cur_depth;\\n          // check child nodes, i.e. the grid neighbors\\n          for (auto& next : nexts) {\\n            int next_x = cur[0]+next[0];\\n            int next_y = cur[1]+next[1];\\n            if (next_x<0 || next_x>=grid.size() || next_y<0 || next_y>=grid[0].size()) continue;\\n            if (grid[next_x][next_y] != 2) continue;\\n            // must ignore parent node.\\n            if (next_x == previous[0] && next_y == previous[1]) continue;  \\n            // calculate child nodes\\' min reachable depth.\\n            if (min_depth[next_x][next_y] == -1) { \\n                if (tarjin({next_x, next_y},cur,grid,depth,min_depth,cur_depth+1)) {\\n                    return true;\\n                }\\n            }\\n            if (min_depth[next_x][next_y] > depth[cur[0]][cur[1]]) {\\n                // critical edge detected.\\n                return true;\\n            }\\n            \\n            min_depth[cur[0]][cur[1]] = min(min_depth[cur[0]][cur[1]], min_depth[next_x][next_y]);\\n        }\\n        return false;\\n       }\\n    \\n    \\n       void dfs(vector<vector<int>>& grid, int x, int y) {\\n        if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y] != 1) return;\\n        grid[x][y] = 2;\\n        for (auto& next : nexts) {\\n           int next_x = x + next[0];\\n           int next_y = y + next[1];\\n           dfs(grid, next_x, next_y);\\n        }\\n       } \\n",
                "solutionTags": [],
                "code": "Intuitives:\\n1. Needs to figure out how many connected islands (classic dfs). If only one island, needs to disconnect.\\n2. At most two steps, the island definitely can be departed. More specificly, is is possible to disconnect with just ONE step?\\n3. Treat the island as a connected graph, and the question transformed to \"find the critical edge in a graph\". For this question,\\n    brutal-force solution is straight forward by cut each graph edge and count the connected components. But to optimize, \\n\\t\"tarjin\" can solve this issue with linear time complexity.\\n\\t \\n\\t\\n        // 1. find all islands\\n        int islands = 0;\\n        int start_x, start_y;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==1) {\\n                    islands++;\\n                    start_x = x;\\n                    start_y = y;\\n                    dfs(grid,x,y);\\n                }\\n            }\\n        }\\n        if (islands != 1) return 0;\\n        \\n        // 2. corner case, one island with 1 or 2 cells. Since tarjin is targeting edges, a minor difference with nodes.\\n        int cnt = 0;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==2) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        if (cnt==2 || cnt==1) return cnt;\\n        \\n        \\n        // 3. disconnect islands. Check if critial edge exist\\n        vector<vector<int>> depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        vector<vector<int>> min_depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        if (tarjin({start_x, start_y}, {-1,-1}, grid, depth, min_depth, 0)) {\\n            return 1;\\n        }\\n        return 2;\\n        }\\n    \\n       bool tarjin(vector<int> cur, vector<int> previous, vector<vector<int>>& grid, \\n                vector<vector<int>>& depth, vector<vector<int>>& min_depth, int cur_depth) {\\n          if (depth[cur[0]][cur[1]]!=-1) return false;\\n          depth[cur[0]][cur[1]] = cur_depth;\\n          min_depth[cur[0]][cur[1]] = cur_depth;\\n          // check child nodes, i.e. the grid neighbors\\n          for (auto& next : nexts) {\\n            int next_x = cur[0]+next[0];\\n            int next_y = cur[1]+next[1];\\n            if (next_x<0 || next_x>=grid.size() || next_y<0 || next_y>=grid[0].size()) continue;\\n            if (grid[next_x][next_y] != 2) continue;\\n            // must ignore parent node.\\n            if (next_x == previous[0] && next_y == previous[1]) continue;  \\n            // calculate child nodes\\' min reachable depth.\\n            if (min_depth[next_x][next_y] == -1) { \\n                if (tarjin({next_x, next_y},cur,grid,depth,min_depth,cur_depth+1)) {\\n                    return true;\\n                }\\n            }\\n            if (min_depth[next_x][next_y] > depth[cur[0]][cur[1]]) {\\n                // critical edge detected.\\n                return true;\\n            }\\n            \\n            min_depth[cur[0]][cur[1]] = min(min_depth[cur[0]][cur[1]], min_depth[next_x][next_y]);\\n        }\\n        return false;\\n       }\\n    \\n    \\n       void dfs(vector<vector<int>>& grid, int x, int y) {\\n        if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y] != 1) return;\\n        grid[x][y] = 2;\\n        for (auto& next : nexts) {\\n           int next_x = x + next[0];\\n           int next_y = y + next[1];\\n           dfs(grid, next_x, next_y);\\n        }\\n       } \\n",
                "codeTag": "Java"
            },
            {
                "id": 2138275,
                "title": "c-the-only-observation-to-solve-the-problem",
                "content": "`You will need at most 2 days.`\\n\\nProof: you can always just isolate the ```1``` in the corner by making his 2 neighbours equal to zero.\\n\\nSo, first we will check the number of islands we have, if it is more than 1 we return 0, because islands are already disconnected. If it is equal to 1, we will replace each of 1\\'s in grid to see if we can create 2 disconnected islands. And if we were not able to divide the island, we return 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m, ones = 0;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int islands(vector<vector<int>>& grid){   \\n        vector<vector<int>> A(grid.begin(), grid.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(A[i][j])\\n                    helper(i, j, A), count++;\\n        return count;\\n    }\\n    void helper(int i, int j, vector<vector<int>>& A){\\n        if(i < 0 || i == n || j < 0 || j == m || !A[i][j])\\n            return;\\n        A[i][j] = 0;\\n        for(int k = 0; k < 4; k++)\\n            helper(i + DIR[k], j + DIR[k + 1], A);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                ones += grid[i][j];\\n        if(islands(grid) > 1) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    if(islands(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return min(2, ones);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```1```\n```\\nclass Solution {\\npublic:\\n    int n, m, ones = 0;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int islands(vector<vector<int>>& grid){   \\n        vector<vector<int>> A(grid.begin(), grid.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(A[i][j])\\n                    helper(i, j, A), count++;\\n        return count;\\n    }\\n    void helper(int i, int j, vector<vector<int>>& A){\\n        if(i < 0 || i == n || j < 0 || j == m || !A[i][j])\\n            return;\\n        A[i][j] = 0;\\n        for(int k = 0; k < 4; k++)\\n            helper(i + DIR[k], j + DIR[k + 1], A);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                ones += grid[i][j];\\n        if(islands(grid) > 1) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    if(islands(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return min(2, ones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950150,
                "title": "beats-100-time-and-100-space",
                "content": "The trick here is that you cannot have more than 2 days as the answer.\\n\\nFirst check whether there are already 2 islands present(return 0) or there is just 1 cell as island(return 1)\\n\\nThen set each cell as water one by one and try to find the number of islands, if it is more than 1, the days needed is 1 else 2.\\n\\n```\\nlet directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nvar minDays = function(grid) {\\n    let colorNumber = 2;\\n    let landCells = [];\\n    \\n    function colorIsland(i, j) {\\n        grid[i][j] = colorNumber;\\n        for(let k = 0; k < directions.length; k++) {\\n            let newI = i + directions[k][0];\\n            let newJ = j + directions[k][1];\\n            \\n            if(newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && grid[newI][newJ] && grid[newI][newJ] != colorNumber) {\\n                colorIsland(newI, newJ);\\n            }\\n        }\\n    }\\n    \\n    function addLandCells() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j]) {\\n                    landCells.push([i, j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function findAnotherIsland() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] && grid[i][j] != colorNumber) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    addLandCells();\\n    \\n    if(landCells.length < 2) {\\n        return landCells.length;\\n    }\\n    \\n    colorIsland(landCells[0][0], landCells[0][1]);\\n    \\n    if(findAnotherIsland()) {\\n        return 0;\\n    }\\n    \\n    colorNumber++;\\n    \\n    for(let i = 0; i < landCells.length; i++) {\\n        grid[landCells[i][0]][landCells[i][1]] = 0;\\n        colorIsland(landCells[(i + 1) % landCells.length][0], landCells[(i + 1) % landCells.length][1]);\\n        if(findAnotherIsland()) {\\n            return 1;\\n        }\\n        grid[landCells[i][0]][landCells[i][1]] = colorNumber;\\n        colorNumber++;\\n    }\\n    \\n    return 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nvar minDays = function(grid) {\\n    let colorNumber = 2;\\n    let landCells = [];\\n    \\n    function colorIsland(i, j) {\\n        grid[i][j] = colorNumber;\\n        for(let k = 0; k < directions.length; k++) {\\n            let newI = i + directions[k][0];\\n            let newJ = j + directions[k][1];\\n            \\n            if(newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && grid[newI][newJ] && grid[newI][newJ] != colorNumber) {\\n                colorIsland(newI, newJ);\\n            }\\n        }\\n    }\\n    \\n    function addLandCells() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j]) {\\n                    landCells.push([i, j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function findAnotherIsland() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] && grid[i][j] != colorNumber) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    addLandCells();\\n    \\n    if(landCells.length < 2) {\\n        return landCells.length;\\n    }\\n    \\n    colorIsland(landCells[0][0], landCells[0][1]);\\n    \\n    if(findAnotherIsland()) {\\n        return 0;\\n    }\\n    \\n    colorNumber++;\\n    \\n    for(let i = 0; i < landCells.length; i++) {\\n        grid[landCells[i][0]][landCells[i][1]] = 0;\\n        colorIsland(landCells[(i + 1) % landCells.length][0], landCells[(i + 1) % landCells.length][1]);\\n        if(findAnotherIsland()) {\\n            return 1;\\n        }\\n        grid[landCells[i][0]][landCells[i][1]] = colorNumber;\\n        colorNumber++;\\n    }\\n    \\n    return 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464631,
                "title": "c-similar-to-finding-articulation-point-explained",
                "content": "I\\'ll tell you the steps:\\n1) Convert the grid into a graph.\\n2) If there is only one 1, then you need to remove it (because connected definition says only 1 island)\\n3) Find number of connected components\\n4) If connected components>1 return 0\\n5) Find articulation point\\n6) If articulation point is present, then return 1, else return 2\\nFor the code part of articulation point, you can refer to any youtube tutorial or cp algorithms\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[904];\\n    vector<int> v;\\n    vector<int> vis;\\n    vector<int> in,low;\\n    int n, m;\\n    int timer;\\n    \\n    void dfsArticulation(int node, int par){\\n        vis[node] = true;\\n        in[node] = low[node] = timer++;\\n        int children=0;\\n        for (int it : adj[node]) {\\n            if (it == par) continue;\\n            if (vis[it]) {\\n                low[node] = min(low[node], in[it]);\\n            } else {\\n                dfsArticulation(it, node);\\n                low[node] = min(low[node], low[it]);\\n                if (low[it] >= in[node] && par!=-1)\\n                    v.push_back(node);\\n                ++children;\\n            }\\n        }\\n        if(par == -1 && children > 1)\\n            v.push_back(node);\\n    }\\n    \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto it: adj[i]){\\n            if(!vis[it]) dfs(it);\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        int l=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) {grid[i][j]=l,l++;}\\n            }\\n        }\\n        if(l==2) return 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int nx=i+dx[k];\\n                    int ny=j+dy[k];\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m) continue;\\n                    if(grid[i][j] && grid[nx][ny]){\\n                        adj[grid[i][j]].push_back(grid[nx][ny]);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        vis.resize(l,false);\\n        int c=0;\\n        for(int i=1;i<l;i++){\\n            if(vis[i]==false){\\n                dfs(i);\\n                c++;\\n            }\\n        }\\n        if(c>1 || c==0) return 0;\\n        \\n        for(int i=0;i<l;i++){\\n            vis[i]=false;\\n        }\\n        in.resize(l,-1);\\n        low.resize(l,-1);\\n        \\n        for (int i = 1; i < l; ++i) {\\n           \\n            if (!vis[i])\\n                dfsArticulation (i,-1);\\n        }\\n        \\n        if(v.size()>0) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[904];\\n    vector<int> v;\\n    vector<int> vis;\\n    vector<int> in,low;\\n    int n, m;\\n    int timer;\\n    \\n    void dfsArticulation(int node, int par){\\n        vis[node] = true;\\n        in[node] = low[node] = timer++;\\n        int children=0;\\n        for (int it : adj[node]) {\\n            if (it == par) continue;\\n            if (vis[it]) {\\n                low[node] = min(low[node], in[it]);\\n            } else {\\n                dfsArticulation(it, node);\\n                low[node] = min(low[node], low[it]);\\n                if (low[it] >= in[node] && par!=-1)\\n                    v.push_back(node);\\n                ++children;\\n            }\\n        }\\n        if(par == -1 && children > 1)\\n            v.push_back(node);\\n    }\\n    \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto it: adj[i]){\\n            if(!vis[it]) dfs(it);\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        int l=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) {grid[i][j]=l,l++;}\\n            }\\n        }\\n        if(l==2) return 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int nx=i+dx[k];\\n                    int ny=j+dy[k];\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m) continue;\\n                    if(grid[i][j] && grid[nx][ny]){\\n                        adj[grid[i][j]].push_back(grid[nx][ny]);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        vis.resize(l,false);\\n        int c=0;\\n        for(int i=1;i<l;i++){\\n            if(vis[i]==false){\\n                dfs(i);\\n                c++;\\n            }\\n        }\\n        if(c>1 || c==0) return 0;\\n        \\n        for(int i=0;i<l;i++){\\n            vis[i]=false;\\n        }\\n        in.resize(l,-1);\\n        low.resize(l,-1);\\n        \\n        for (int i = 1; i < l; ++i) {\\n           \\n            if (!vis[i])\\n                dfsArticulation (i,-1);\\n        }\\n        \\n        if(v.size()>0) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406384,
                "title": "java-dfs-connected-components-with-comments",
                "content": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394785,
                "title": "c-bfs-solution-beginner-friendly-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t//below code for finding number of connected components\\n    int no_of_conn(vector<vector<int>>& grid){\\n        \\n        int visit[30][30] = {0};\\n        int count =0;\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[i].size();j++){\\n                \\n                if(grid[i][j]==1 && visit[i][j]==0){\\n                    count++;\\n                    q.push({i,j});\\n                    visit[i][j] = 1;\\n                    \\n                        while(!q.empty()){\\n                            \\n                            int s = q.size();\\n                            \\n                            for(int i=0;i<s;i++){\\n                                auto p = q.front();\\n                                q.pop();\\n                                int x = p.first;\\n                                int y = p.second;\\n    \\n                                if(x+1<grid.size() && visit[x+1][y]==0 && grid[x+1][y]==1){\\n                                    q.push({x+1,y});\\n                                    visit[x+1][y] = 1;\\n                                }\\n                                if(y+1<grid[0].size() && visit[x][y+1]==0 && grid[x][y+1]==1){\\n                                    q.push({x,y+1});\\n                                    visit[x][y+1] = 1;\\n                                }\\n                                if(x-1>=0 && visit[x-1][y]==0 && grid[x-1][y]==1){\\n                                    q.push({x-1,y});\\n                                    visit[x-1][y] = 1;\\n                                }\\n                                if(y-1>=0 && visit[x][y-1]==0 && grid[x][y-1]==1){\\n                                    q.push({x,y-1});\\n                                    visit[x][y-1] = 1;\\n                                }\\n                            }\\n                        }\\n                        \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return count;\\n       \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int num = no_of_conn(grid);\\n        \\n        if(num!=1){\\n            return 0;\\n        }\\n        \\n        \\n            \\n            vector<pair<int,int>> ind;\\n            \\n            for(int i=0;i<grid.size();i++){\\n                \\n                for(int j=0;j<grid[i].size();j++){\\n                    \\n                    if(grid[i][j]==1){\\n                        grid[i][j] = 0;//make that 0\\n                        \\n\\t\\t\\t\\t\\t\\t// check for number of conn components\\n                        if(no_of_conn(grid)!=1){\\n                            return 1;\\n                        }\\n                        \\n                        grid[i][j] =1;//make that 1 again as it was not the desired land\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            \\n            \\n        return 2; //at max we need only 2 days to disconnect any island ...Thinnk about it. :)\\n        \\n        \\n    }\\n};\\n```\\n**Hit like if you liked my solution .. Happy coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t//below code for finding number of connected components\\n    int no_of_conn(vector<vector<int>>& grid){\\n        \\n        int visit[30][30] = {0};\\n        int count =0;\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[i].size();j++){\\n                \\n                if(grid[i][j]==1 && visit[i][j]==0){\\n                    count++;\\n                    q.push({i,j});\\n                    visit[i][j] = 1;\\n                    \\n                        while(!q.empty()){\\n                            \\n                            int s = q.size();\\n                            \\n                            for(int i=0;i<s;i++){\\n                                auto p = q.front();\\n                                q.pop();\\n                                int x = p.first;\\n                                int y = p.second;\\n    \\n                                if(x+1<grid.size() && visit[x+1][y]==0 && grid[x+1][y]==1){\\n                                    q.push({x+1,y});\\n                                    visit[x+1][y] = 1;\\n                                }\\n                                if(y+1<grid[0].size() && visit[x][y+1]==0 && grid[x][y+1]==1){\\n                                    q.push({x,y+1});\\n                                    visit[x][y+1] = 1;\\n                                }\\n                                if(x-1>=0 && visit[x-1][y]==0 && grid[x-1][y]==1){\\n                                    q.push({x-1,y});\\n                                    visit[x-1][y] = 1;\\n                                }\\n                                if(y-1>=0 && visit[x][y-1]==0 && grid[x][y-1]==1){\\n                                    q.push({x,y-1});\\n                                    visit[x][y-1] = 1;\\n                                }\\n                            }\\n                        }\\n                        \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return count;\\n       \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int num = no_of_conn(grid);\\n        \\n        if(num!=1){\\n            return 0;\\n        }\\n        \\n        \\n            \\n            vector<pair<int,int>> ind;\\n            \\n            for(int i=0;i<grid.size();i++){\\n                \\n                for(int j=0;j<grid[i].size();j++){\\n                    \\n                    if(grid[i][j]==1){\\n                        grid[i][j] = 0;//make that 0\\n                        \\n\\t\\t\\t\\t\\t\\t// check for number of conn components\\n                        if(no_of_conn(grid)!=1){\\n                            return 1;\\n                        }\\n                        \\n                        grid[i][j] =1;//make that 1 again as it was not the desired land\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            \\n            \\n        return 2; //at max we need only 2 days to disconnect any island ...Thinnk about it. :)\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375275,
                "title": "articulation-point-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n        We will never need more than 2 days to disconnect the island.\\n        There will always be atleast 1 land-cell which will have atmost 2 neighbouring land cells(cell 1)\\n        Thus, if that land-cell has 2 neighbouring land-cells, our answer is 2 days.\\n        Else, if that land-cell has only 1 neighbouring land-cell, our answer is 1 day.\\n\\t\\t\\n\\t\\tIf there are any articulation points, days=1.\\n        Else days=2.\\n    */\\n    vector<vector<int>> dir{{-1,0},{0,-1},{1,0},{0,1}};\\n    vector<bool> visited;\\n    vector<int> ids;\\n    vector<int> low_links;\\n    // vector<bool> ap;\\n    int flag = 2;\\n    \\n    /*\\n        We don\\'t need ap vector (Articulation Point vector) here, but I\\'m maintaining it for template code\\n        reference. We won\\'t need flag, islands variables in general Articulation point questions.\\n    */\\n    \\n    void articulationPointsUtil(vector<int> adj[], int id, int parent, int u) {\\n        visited[u] = true;\\n        ids[u] = low_links[u] = id++;\\n        int out = 0;\\n        \\n        for(auto v: adj[u]) {\\n            if(v == parent) continue;\\n            if(!visited[v]) {\\n                out++;\\n                articulationPointsUtil(adj, id, u, v);\\n                low_links[u] = min(low_links[u], low_links[v]);\\n                \\n                if(parent == -1 && out > 1) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n                \\n                if(parent != -1 && ids[u] <= low_links[v]) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n            } else {\\n                low_links[u] = min(low_links[u], ids[v]);\\n            }\\n        }\\n    }\\n    \\n    int articulationPoints(vector<int> adj[], int n) {\\n        visited.resize(n, false);\\n        ids.resize(n);\\n        low_links.resize(n);\\n        // ap.resize(n, false);\\n        \\n        int islands = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                islands++;\\n                articulationPointsUtil(adj, 0, -1, i);\\n            }\\n        }\\n        \\n        return (islands == 1) ? flag : 0;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        map<pair<int,int>, int> map;\\n        int id = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> adj[m*n];\\n        \\n        if(m*n == 1 && grid[0][0] == 0) return 0;\\n        if(m*n == 1 && grid[0][0] == 1) return 1;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    int u = (map.find({i,j}) != map.end()) ? map[{i,j}] : id++;\\n                    map[{i,j}] = u;\\n                    \\n                    for(int k=0; k<4; k++) {\\n                        int nx = i + dir[k][0];\\n                        int ny = j + dir[k][1];\\n                        if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==1) {\\n                            int v = (map.find({nx,ny}) != map.end()) ? map[{nx,ny}] : id++;\\n                            map[{nx,ny}] = v;\\n                            adj[u].push_back(v);\\n                        }\\n                    }\\n                    \\n                    if(u>0 && adj[u].size()==0) return 0;\\n                }\\n            }\\n        }\\n        \\n        if(id==1 && adj[id-1].size()==0) return 1;\\n        \\n        return articulationPoints(adj, id);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n        We will never need more than 2 days to disconnect the island.\\n        There will always be atleast 1 land-cell which will have atmost 2 neighbouring land cells(cell 1)\\n        Thus, if that land-cell has 2 neighbouring land-cells, our answer is 2 days.\\n        Else, if that land-cell has only 1 neighbouring land-cell, our answer is 1 day.\\n\\t\\t\\n\\t\\tIf there are any articulation points, days=1.\\n        Else days=2.\\n    */\\n    vector<vector<int>> dir{{-1,0},{0,-1},{1,0},{0,1}};\\n    vector<bool> visited;\\n    vector<int> ids;\\n    vector<int> low_links;\\n    // vector<bool> ap;\\n    int flag = 2;\\n    \\n    /*\\n        We don\\'t need ap vector (Articulation Point vector) here, but I\\'m maintaining it for template code\\n        reference. We won\\'t need flag, islands variables in general Articulation point questions.\\n    */\\n    \\n    void articulationPointsUtil(vector<int> adj[], int id, int parent, int u) {\\n        visited[u] = true;\\n        ids[u] = low_links[u] = id++;\\n        int out = 0;\\n        \\n        for(auto v: adj[u]) {\\n            if(v == parent) continue;\\n            if(!visited[v]) {\\n                out++;\\n                articulationPointsUtil(adj, id, u, v);\\n                low_links[u] = min(low_links[u], low_links[v]);\\n                \\n                if(parent == -1 && out > 1) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n                \\n                if(parent != -1 && ids[u] <= low_links[v]) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n            } else {\\n                low_links[u] = min(low_links[u], ids[v]);\\n            }\\n        }\\n    }\\n    \\n    int articulationPoints(vector<int> adj[], int n) {\\n        visited.resize(n, false);\\n        ids.resize(n);\\n        low_links.resize(n);\\n        // ap.resize(n, false);\\n        \\n        int islands = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                islands++;\\n                articulationPointsUtil(adj, 0, -1, i);\\n            }\\n        }\\n        \\n        return (islands == 1) ? flag : 0;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        map<pair<int,int>, int> map;\\n        int id = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> adj[m*n];\\n        \\n        if(m*n == 1 && grid[0][0] == 0) return 0;\\n        if(m*n == 1 && grid[0][0] == 1) return 1;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    int u = (map.find({i,j}) != map.end()) ? map[{i,j}] : id++;\\n                    map[{i,j}] = u;\\n                    \\n                    for(int k=0; k<4; k++) {\\n                        int nx = i + dir[k][0];\\n                        int ny = j + dir[k][1];\\n                        if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==1) {\\n                            int v = (map.find({nx,ny}) != map.end()) ? map[{nx,ny}] : id++;\\n                            map[{nx,ny}] = v;\\n                            adj[u].push_back(v);\\n                        }\\n                    }\\n                    \\n                    if(u>0 && adj[u].size()==0) return 0;\\n                }\\n            }\\n        }\\n        \\n        if(id==1 && adj[id-1].size()==0) return 1;\\n        \\n        return articulationPoints(adj, id);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099205,
                "title": "c-following-the-hints",
                "content": "As the hints suggest, if the graph is already disconnected, then return 0.\\n\\nif we can make the graph disconnected by removing one \"1\", return 1.\\n```\\nclass Solution {\\n    vector<int> g;\\n    int find(int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        g[j] = i;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        if(Disconnected(grid)) {\\n            return 0;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if(Disconnected(grid)) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    bool Disconnected(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(i+1 < m && grid[i+1][j] == 1) merge(i * n + j, (i+1) * n + j);\\n                if(j+1 < n && grid[i][j+1] == 1) merge(i * n + j, i * n + j + 1);\\n            }\\n        }\\n        \\n        int res = -1;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(res == -1) {\\n                    res = find(i*n + j);\\n                } else if(res != find(i*n + j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        if(res == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> g;\\n    int find(int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        g[j] = i;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        if(Disconnected(grid)) {\\n            return 0;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if(Disconnected(grid)) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    bool Disconnected(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(i+1 < m && grid[i+1][j] == 1) merge(i * n + j, (i+1) * n + j);\\n                if(j+1 < n && grid[i][j+1] == 1) merge(i * n + j, i * n + j + 1);\\n            }\\n        }\\n        \\n        int res = -1;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(res == -1) {\\n                    res = find(i*n + j);\\n                } else if(res != find(i*n + j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        if(res == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835144,
                "title": "count-number-of-islands-using-both-union-find-and-dfs-python",
                "content": "The algorithm for solving this problem has been articulated in top rated votes. There could only be three possible answers, either 0, 1, 2.\\n\\n(1) if the total number of islands is not 1, we return 0 immediately.\\n(2) if the total number of islands is 1, then we enumerate all cases where we set independently one of the 1s in the orignal grid to 0, and count the number of islands. If any of this operation changes the total number to be diffrent than 1 (i.e. could be 0, 2, 3 etc), we return 1.\\n(3) If not (1) and (2), we return 2 instead. \\n\\nThe code below uses both Union Find and DFS to count the number of islands. \\n```\\nclass DisjointSetUnion:\\n    def __init__(self, matrix):\\n        R, C = len(matrix), len(matrix[0])\\n        size = R * C\\n        self.parent = [0 for i in range(size)]\\n        self.size = [0 for i in range(size)]\\n        self.count = 0\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 1:\\n                    self.parent[i * C + j] = i * C + j\\n                    self.size[i*C + j] = 1\\n                    self.count += 1\\n                \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return py\\n        \\n        if self.size[px] > self.size[py]:\\n            px, py = py, px\\n            \\n        self.parent[px] = py\\n        self.size[py] += self.size[px]\\n        self.count -= 1\\n        return py\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        \\n        def count_number_of_islands(matrix):\\n            R, C = len(matrix), len(matrix[0])\\n            dsu = DisjointSetUnion(matrix)\\n            seen = set()\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1:\\n                        for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                            nr = r + x\\n                            nc = c + y\\n                            if 0<= nr < R and 0<= nc < C and matrix[nr][nc] == 1 and (r*C + c, nr * C + nc) not in seen:\\n                                seen.add((r*C + c, nr * C + nc))\\n                                seen.add((nr * C + nc, r*C + c))\\n                                dsu.union(r*C + c, nr * C + nc)\\n                                \\n            return dsu.count\\n        \\n        def count_number_of_islands_1(matrix):\\n            visited = set()\\n            R, C = len(matrix), len(matrix[0])\\n            def dfs(i,j):\\n                visited.add((i,j))\\n                \\n                for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    nx = i + x\\n                    ny = j + y\\n                    if 0 <= nx < R and 0 <= ny < C and matrix[nx][ny] == 1 and (nx, ny) not in visited:\\n                        dfs(nx, ny)\\n                        \\n            count = 0\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1 and (r,c) not in visited:\\n                        dfs(r,c)\\n                        count += 1\\n                        \\n            return count\\n                \\n        # case 1\\n        num_islands = count_number_of_islands(grid)\\n        if num_islands != 1:\\n            return 0\\n        \\n        # case 2 check if we can disconnect the island in one day\\n        R, C = len(grid), len(grid[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:\\n                    grid_new = copy.deepcopy(grid)\\n                    grid_new[r][c] = 0\\n                    if count_number_of_islands(grid_new) != 1:\\n                        return 1\\n        # case 3     \\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass DisjointSetUnion:\\n    def __init__(self, matrix):\\n        R, C = len(matrix), len(matrix[0])\\n        size = R * C\\n        self.parent = [0 for i in range(size)]\\n        self.size = [0 for i in range(size)]\\n        self.count = 0\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 1:\\n                    self.parent[i * C + j] = i * C + j\\n                    self.size[i*C + j] = 1\\n                    self.count += 1\\n                \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return py\\n        \\n        if self.size[px] > self.size[py]:\\n            px, py = py, px\\n            \\n        self.parent[px] = py\\n        self.size[py] += self.size[px]\\n        self.count -= 1\\n        return py\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        \\n        def count_number_of_islands(matrix):\\n            R, C = len(matrix), len(matrix[0])\\n            dsu = DisjointSetUnion(matrix)\\n            seen = set()\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1:\\n                        for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                            nr = r + x\\n                            nc = c + y\\n                            if 0<= nr < R and 0<= nc < C and matrix[nr][nc] == 1 and (r*C + c, nr * C + nc) not in seen:\\n                                seen.add((r*C + c, nr * C + nc))\\n                                seen.add((nr * C + nc, r*C + c))\\n                                dsu.union(r*C + c, nr * C + nc)\\n                                \\n            return dsu.count\\n        \\n        def count_number_of_islands_1(matrix):\\n            visited = set()\\n            R, C = len(matrix), len(matrix[0])\\n            def dfs(i,j):\\n                visited.add((i,j))\\n                \\n                for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    nx = i + x\\n                    ny = j + y\\n                    if 0 <= nx < R and 0 <= ny < C and matrix[nx][ny] == 1 and (nx, ny) not in visited:\\n                        dfs(nx, ny)\\n                        \\n            count = 0\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1 and (r,c) not in visited:\\n                        dfs(r,c)\\n                        count += 1\\n                        \\n            return count\\n                \\n        # case 1\\n        num_islands = count_number_of_islands(grid)\\n        if num_islands != 1:\\n            return 0\\n        \\n        # case 2 check if we can disconnect the island in one day\\n        R, C = len(grid), len(grid[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:\\n                    grid_new = copy.deepcopy(grid)\\n                    grid_new[r][c] = 0\\n                    if count_number_of_islands(grid_new) != 1:\\n                        return 1\\n        # case 3     \\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828885,
                "title": "java-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int minDays(int[][] grid) {\\n        if (isDisconnected(grid)) {\\n            return 0;\\n        } else if (isStrongConnected(grid)) {\\n            return 2;\\n        } else {\\n            return 1;\\n        }\\n    }\\n    \\n    private boolean isDisconnected(int[][] grid) {\\n        int answer = 0, n = grid.length, m = grid[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dfs(grid, visited, i, j)) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        \\n        return answer != 1;\\n    }\\n    \\n    private boolean dfs(int[][] grid, boolean[][] visited, int y, int x) {\\n        if (y < 0 || y >= grid.length || x < 0 || x >= grid[y].length) {\\n            return false;\\n        }\\n        \\n        if (grid[y][x] == 0) {\\n            return false;\\n        }\\n        \\n        if (visited[y][x]) {\\n            return false;\\n        }\\n        visited[y][x] = true;\\n        \\n        for (int[] move : moves) {\\n            dfs(grid, visited, y + move[0], x + move[1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isStrongConnected(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                \\n                grid[i][j] = 0;\\n                if (isDisconnected(grid)) {\\n                    return false;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int minDays(int[][] grid) {\\n        if (isDisconnected(grid)) {\\n            return 0;\\n        } else if (isStrongConnected(grid)) {\\n            return 2;\\n        } else {\\n            return 1;\\n        }\\n    }\\n    \\n    private boolean isDisconnected(int[][] grid) {\\n        int answer = 0, n = grid.length, m = grid[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dfs(grid, visited, i, j)) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        \\n        return answer != 1;\\n    }\\n    \\n    private boolean dfs(int[][] grid, boolean[][] visited, int y, int x) {\\n        if (y < 0 || y >= grid.length || x < 0 || x >= grid[y].length) {\\n            return false;\\n        }\\n        \\n        if (grid[y][x] == 0) {\\n            return false;\\n        }\\n        \\n        if (visited[y][x]) {\\n            return false;\\n        }\\n        visited[y][x] = true;\\n        \\n        for (int[] move : moves) {\\n            dfs(grid, visited, y + move[0], x + move[1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isStrongConnected(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                \\n                grid[i][j] = 0;\\n                if (isDisconnected(grid)) {\\n                    return false;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820801,
                "title": "c-o-mn-2",
                "content": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] {1, 0},\\n            new int[2] {0, 1},\\n            new int[2] {-1, 0},\\n            new int[2] {0, -1}\\n        };\\n        \\n        if (GetNumberOfIslands(grid, dirs) > 1) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    \\n                    if (GetNumberOfIslands(grid, dirs) > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid, List<int[]> dirs) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        int islandCount = 0;\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (!visited[i, j] && grid[i][j] == 1)\\n                {\\n                    VisitIsland(grid, i, j, visited, dirs);\\n                    islandCount++;\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n    \\n    private void VisitIsland(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs) {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs) {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n\\n            if (IsInBound(grid, nexti, nextj) && !visited[nexti, nextj] && grid[nexti][nextj] == 1)\\n            {\\n                VisitIsland(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBound(int[][] grid, int i, int j){\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] {1, 0},\\n            new int[2] {0, 1},\\n            new int[2] {-1, 0},\\n            new int[2] {0, -1}\\n        };\\n        \\n        if (GetNumberOfIslands(grid, dirs) > 1) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    \\n                    if (GetNumberOfIslands(grid, dirs) > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid, List<int[]> dirs) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        int islandCount = 0;\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (!visited[i, j] && grid[i][j] == 1)\\n                {\\n                    VisitIsland(grid, i, j, visited, dirs);\\n                    islandCount++;\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n    \\n    private void VisitIsland(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs) {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs) {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n\\n            if (IsInBound(grid, nexti, nextj) && !visited[nexti, nextj] && grid[nexti][nextj] == 1)\\n            {\\n                VisitIsland(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBound(int[][] grid, int i, int j){\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820609,
                "title": "python-cutting-points-tarjan-s-algorithm",
                "content": "# Intuition\\n1. Use `union-find` to track the number of connected islands. Return `0` if we started with 0 or more than 1 islands.\\n2. Use `Tarjan\\'s algorithm` to check whether we can solve the problem in `1` day (cutting/articulation point)\\n3. Return `2` if none of above test passed.\\n\\n# Complexity\\nSay it is a M * N matrix\\nTime: O(M * N)   ;   M * N for union-find part, M * N for Tarjan\\'s algorithm\\nSpace: O(M * N)\\n```python\\nclass Solution:\\n    def minDays(self, grid) -> int:\\n        def find_cutting_points(graph):\\n            ids, low = {}, {}\\n            is_cut, id_max = set(), 0\\n\\n            def dfs(u, p, root):\\n                nonlocal out_edge\\n                nonlocal id_max\\n                if p == root: \\n                    out_edge += 1\\n                ids[u] = low[u] = id_max\\n                id_max += 1\\n                \\n                for v in graph[u]:\\n                    if v == p: continue\\n                    if v not in ids:\\n                        dfs(v, u, root)\\n                        low[u] = min(low[u], low[v])\\n                        if low[v] >= ids[u]:\\n                            is_cut.add(u)\\n                    else:\\n                        low[u] = min(low[u], ids[v])\\n\\n            for u in graph.keys():\\n                if u not in ids:\\n                    out_edge = 0\\n                    dfs(u, -1, u)\\n                    if out_edge > 1:\\n                        is_cut.add(u)\\n                    else:\\n                        is_cut.remove(u)\\n            return is_cut\\n\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if uf[x] != x: uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # x-> y\\n            uf[find(x)] = find(y)\\n            \\n        m, n = len(grid), len(grid[0])\\n        graph = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 1: continue\\n                find((i,j))\\n                for rr, cc in [(-1, 0), (0, -1)]:\\n                    r, c = i+rr, j+cc\\n                    if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:\\n                        union((i, j), (r, c))\\n                        graph[(i,j)].add((r,c))\\n                        graph[(r,c)].add((i,j))\\n\\n        if len(set(map(find, uf.keys()))) != 1:\\n            return 0\\n        if find_cutting_points(graph):\\n            return 1\\n        return 2\\n````",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def minDays(self, grid) -> int:\\n        def find_cutting_points(graph):\\n            ids, low = {}, {}\\n            is_cut, id_max = set(), 0\\n\\n            def dfs(u, p, root):\\n                nonlocal out_edge\\n                nonlocal id_max\\n                if p == root: \\n                    out_edge += 1\\n                ids[u] = low[u] = id_max\\n                id_max += 1\\n                \\n                for v in graph[u]:\\n                    if v == p: continue\\n                    if v not in ids:\\n                        dfs(v, u, root)\\n                        low[u] = min(low[u], low[v])\\n                        if low[v] >= ids[u]:\\n                            is_cut.add(u)\\n                    else:\\n                        low[u] = min(low[u], ids[v])\\n\\n            for u in graph.keys():\\n                if u not in ids:\\n                    out_edge = 0\\n                    dfs(u, -1, u)\\n                    if out_edge > 1:\\n                        is_cut.add(u)\\n                    else:\\n                        is_cut.remove(u)\\n            return is_cut\\n\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if uf[x] != x: uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # x-> y\\n            uf[find(x)] = find(y)\\n            \\n        m, n = len(grid), len(grid[0])\\n        graph = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 1: continue\\n                find((i,j))\\n                for rr, cc in [(-1, 0), (0, -1)]:\\n                    r, c = i+rr, j+cc\\n                    if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:\\n                        union((i, j), (r, c))\\n                        graph[(i,j)].add((r,c))\\n                        graph[(r,c)].add((i,j))\\n\\n        if len(set(map(find, uf.keys()))) != 1:\\n            return 0\\n        if find_cutting_points(graph):\\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820446,
                "title": "java-dfs-backtracking-tle-to-smart-answer",
                "content": "When you aren\\'t smart enough to realize the fact answer is at most 2 days. You come up with exponential time complexity solution :(\\n```\\nint res = Integer.MAX_VALUE;\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tList<int[]> cells = new ArrayList<>();\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tcells.add(new int[]{i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cells.size() == 0 || isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tdfs(grid, cells, 0, 0);\\n\\treturn res;\\n}\\nprivate void dfs(int[][] grid, List<int[]> cells, int idx, int cnt) {\\n\\tif (res <= cnt) {\\n\\t\\treturn;\\n\\t}\\n\\tif (isDisconnected(grid)) {\\n\\t\\tres = Math.min(res, cnt);   \\n\\t\\treturn;\\n\\t}\\n\\tif (idx == cells.size()) {\\n\\t\\treturn; \\n\\t}\\n\\n\\tdfs(grid, cells, idx + 1, cnt);\\n\\tint[] cord = cells.get(idx);\\n\\tgrid[cord[0]][cord[1]] = 0; \\n\\tdfs(grid, cells, idx + 1, cnt + 1);\\n\\tgrid[cord[0]][cord[1]] = 1;\\n\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```\\n\\nAnd then when you check out the answer from smart people, you changed your answer to pretend you are smart as well.\\n```\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\t// check if it\\'s initially disconnected\\n\\tif (isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\t// check for 1 day\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (isDisconnected(grid)) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if not 1 day, then it\\'s 2 days \\n\\treturn 2;\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint res = Integer.MAX_VALUE;\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tList<int[]> cells = new ArrayList<>();\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tcells.add(new int[]{i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cells.size() == 0 || isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tdfs(grid, cells, 0, 0);\\n\\treturn res;\\n}\\nprivate void dfs(int[][] grid, List<int[]> cells, int idx, int cnt) {\\n\\tif (res <= cnt) {\\n\\t\\treturn;\\n\\t}\\n\\tif (isDisconnected(grid)) {\\n\\t\\tres = Math.min(res, cnt);   \\n\\t\\treturn;\\n\\t}\\n\\tif (idx == cells.size()) {\\n\\t\\treturn; \\n\\t}\\n\\n\\tdfs(grid, cells, idx + 1, cnt);\\n\\tint[] cord = cells.get(idx);\\n\\tgrid[cord[0]][cord[1]] = 0; \\n\\tdfs(grid, cells, idx + 1, cnt + 1);\\n\\tgrid[cord[0]][cord[1]] = 1;\\n\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```\n```\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\t// check if it\\'s initially disconnected\\n\\tif (isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\t// check for 1 day\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (isDisconnected(grid)) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if not 1 day, then it\\'s 2 days \\n\\treturn 2;\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820411,
                "title": "union-find-at-most-2-days",
                "content": "```\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\nusing vvvi = vector<vvi>;\\nclass Solution {\\n    vvvi ds = vvvi(30, vvi(30, vi(2, 0)));\\n    int n, m;\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n\\n        int islands = getIslands(grid);\\n        if (islands == 0 || islands > 1) return 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    if (getIslands(grid) > 1) {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return 2;\\n    }\\n\\nprivate:\\n    int getIslands(vvi& grid) {\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                ds[i][j][0] = i * m + j, ds[i][j][1] = 0;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    if (j < m - 1 && grid[i][j + 1]) {\\n                        unionSet(findSet(i, j), findSet(i, j + 1));\\n                    }\\n                    if (i < n - 1 && grid[i + 1][j]) {\\n                        unionSet(findSet(i, j), findSet(i + 1, j));\\n                    }\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    set.emplace(findSet(i, j));\\n                }\\n            }\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void unionSet(int p1, int p2) {\\n        int i1 = p1 / m, j1 = p1 % m, i2 = p2 / m, j2 = p2 % m;\\n        if (ds[i1][j1][1] < ds[i2][j2][1]) {\\n            ds[i1][j1][0] = p2;\\n        } else {\\n            ds[i2][j2][0] = p1;\\n            if (ds[i1][j1][1] == ds[i2][j2][1]) {\\n                ++ds[i1][j1][1];\\n            }\\n        }\\n    }\\n\\n    int findSet(int i, int j) {\\n        int p = ds[i][j][0];\\n        if (p == i * m + j) {\\n            return p;\\n        } else {\\n            return ds[i][j][0] = findSet(p / m, p % m);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\nusing vvvi = vector<vvi>;\\nclass Solution {\\n    vvvi ds = vvvi(30, vvi(30, vi(2, 0)));\\n    int n, m;\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n\\n        int islands = getIslands(grid);\\n        if (islands == 0 || islands > 1) return 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    if (getIslands(grid) > 1) {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return 2;\\n    }\\n\\nprivate:\\n    int getIslands(vvi& grid) {\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                ds[i][j][0] = i * m + j, ds[i][j][1] = 0;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    if (j < m - 1 && grid[i][j + 1]) {\\n                        unionSet(findSet(i, j), findSet(i, j + 1));\\n                    }\\n                    if (i < n - 1 && grid[i + 1][j]) {\\n                        unionSet(findSet(i, j), findSet(i + 1, j));\\n                    }\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    set.emplace(findSet(i, j));\\n                }\\n            }\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void unionSet(int p1, int p2) {\\n        int i1 = p1 / m, j1 = p1 % m, i2 = p2 / m, j2 = p2 % m;\\n        if (ds[i1][j1][1] < ds[i2][j2][1]) {\\n            ds[i1][j1][0] = p2;\\n        } else {\\n            ds[i2][j2][0] = p1;\\n            if (ds[i1][j1][1] == ds[i2][j2][1]) {\\n                ++ds[i1][j1][1];\\n            }\\n        }\\n    }\\n\\n    int findSet(int i, int j) {\\n        int p = ds[i][j][0];\\n        if (p == i * m + j) {\\n            return p;\\n        } else {\\n            return ds[i][j][0] = findSet(p / m, p % m);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819610,
                "title": "java-at-most-2-days",
                "content": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private int[][] grid;\\n    \\n    private void dfs(int i, int j, boolean[] visited) {\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] == 0 || visited[i * n + j]) {\\n            return;\\n        }\\n        visited[i * n + j] = true;\\n        dfs(i + 1, j, visited);\\n        dfs(i - 1, j, visited);\\n        dfs(i, j + 1, visited);\\n        dfs(i, j - 1, visited);\\n    }\\n    \\n    private boolean disconnected() {\\n        boolean disconnected = false;\\n        boolean allZeros = true;\\n        boolean[] visited = new boolean[n * m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i * n + j]) {\\n                    allZeros = false;\\n                    if (disconnected) {\\n                        return true;\\n                    }\\n                    dfs(i, j, visited);\\n                    disconnected = true;\\n                }\\n            }\\n        }\\n        return allZeros;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.grid = grid;\\n        \\n        Deque<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(i * n + j);\\n                }\\n            }\\n        }\\n        \\n        if (disconnected()) return 0;\\n        for (int k = queue.size(); k > 0; k--) {\\n            int index = queue.poll();\\n            int i = index / n;\\n            int j = index % n;\\n            grid[i][j] = 0;\\n            if (disconnected()) return 1;\\n            grid[i][j] = 1;\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private int[][] grid;\\n    \\n    private void dfs(int i, int j, boolean[] visited) {\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] == 0 || visited[i * n + j]) {\\n            return;\\n        }\\n        visited[i * n + j] = true;\\n        dfs(i + 1, j, visited);\\n        dfs(i - 1, j, visited);\\n        dfs(i, j + 1, visited);\\n        dfs(i, j - 1, visited);\\n    }\\n    \\n    private boolean disconnected() {\\n        boolean disconnected = false;\\n        boolean allZeros = true;\\n        boolean[] visited = new boolean[n * m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i * n + j]) {\\n                    allZeros = false;\\n                    if (disconnected) {\\n                        return true;\\n                    }\\n                    dfs(i, j, visited);\\n                    disconnected = true;\\n                }\\n            }\\n        }\\n        return allZeros;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.grid = grid;\\n        \\n        Deque<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(i * n + j);\\n                }\\n            }\\n        }\\n        \\n        if (disconnected()) return 0;\\n        for (int k = queue.size(); k > 0; k--) {\\n            int index = queue.poll();\\n            int i = index / n;\\n            int j = index % n;\\n            grid[i][j] = 0;\\n            if (disconnected()) return 1;\\n            grid[i][j] = 1;\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819564,
                "title": "c-using-dfs-video-explanation",
                "content": "Video: https://youtu.be/DHPg2h589MY\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size(), islands = 0, ones = 0;\\n        memset(visited, 0, sizeof(visited));\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) {    // finding out #islands\\n            if(!visited[i][j] && grid[i][j] == 1)\\n                dfs(i, j, grid), islands++;\\n            if(grid[i][j] == 1) ones++;\\n        }\\n        \\n        if(islands != 1) return 0;     // islands = #Connected Components\\n        \\n        if(m == 1 || n == 1 || ones <= 2) return (ones == 2 ? 2: 1);   // #islands = 1\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 1) {\\n            int x = i, y = j; grid[i][j] = 0;\\n            \\n            memset(visited, 0, sizeof(visited));\\n            islands = 0;\\n            \\n             for(int i=0; i<m; i++) for(int j=0; j<n; j++) {     // finding out #islands\\n                if(!visited[i][j] && grid[i][j] == 1)\\n                    dfs(i, j, grid), islands++;\\n            }           \\n            \\n            if(islands > 1) return 1;    // we were able to disconnect the islands\\n            \\n            grid[x][y] = 1;\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<int>> &g) {    // visits all the 1s of 1 island, marks them visited\\n        visited[i][j] = 1; \\n        \\n        if(i && !visited[i-1][j] && g[i-1][j] == 1) dfs(i-1, j, g);\\n        if(j && !visited[i][j-1] && g[i][j-1] == 1) dfs(i, j-1, g);\\n        if(i < m - 1 && !visited[i+1][j] && g[i+1][j] == 1) dfs(i+1, j, g);\\n        if(j < n - 1 && !visited[i][j+1] && g[i][j+1] == 1) dfs(i, j+1, g);\\n    }\\n    \\nprivate:\\n    int m, n, islands, ones, visited[35][35];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size(), islands = 0, ones = 0;\\n        memset(visited, 0, sizeof(visited));\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) {    // finding out #islands\\n            if(!visited[i][j] && grid[i][j] == 1)\\n                dfs(i, j, grid), islands++;\\n            if(grid[i][j] == 1) ones++;\\n        }\\n        \\n        if(islands != 1) return 0;     // islands = #Connected Components\\n        \\n        if(m == 1 || n == 1 || ones <= 2) return (ones == 2 ? 2: 1);   // #islands = 1\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 1) {\\n            int x = i, y = j; grid[i][j] = 0;\\n            \\n            memset(visited, 0, sizeof(visited));\\n            islands = 0;\\n            \\n             for(int i=0; i<m; i++) for(int j=0; j<n; j++) {     // finding out #islands\\n                if(!visited[i][j] && grid[i][j] == 1)\\n                    dfs(i, j, grid), islands++;\\n            }           \\n            \\n            if(islands > 1) return 1;    // we were able to disconnect the islands\\n            \\n            grid[x][y] = 1;\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<int>> &g) {    // visits all the 1s of 1 island, marks them visited\\n        visited[i][j] = 1; \\n        \\n        if(i && !visited[i-1][j] && g[i-1][j] == 1) dfs(i-1, j, g);\\n        if(j && !visited[i][j-1] && g[i][j-1] == 1) dfs(i, j-1, g);\\n        if(i < m - 1 && !visited[i+1][j] && g[i+1][j] == 1) dfs(i+1, j, g);\\n        if(j < n - 1 && !visited[i][j+1] && g[i][j+1] == 1) dfs(i, j+1, g);\\n    }\\n    \\nprivate:\\n    int m, n, islands, ones, visited[35][35];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819559,
                "title": "golang-solution-similar-to-other-solutions",
                "content": "Only two important things to solve this\\n1. Hint/Selfobservation that the answer can be only 0 , 1 or 2\\n2. Convince yourself that using time complexity of O(n^4) and space complexity of O(n^2) is fine here\\n\\nI got the hint for point 1 from discuss\\n\\n```\\nfunc minDays(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\n\\tc := 0\\n\\t// check for answer 0\\n\\t// If already > 1 island then we dont need any days to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif c > 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// check for 1\\n\\t// for all grid values of 1, make it 0 and check no of islands\\n\\t// if anytime you find > 1 island, we need 1 day to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tgrid[i][j] = 0\\n\\t\\t\\t\\tif findNoOfIslands(grid, i, j, m, n) > 1 {\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// answer still not found , ans is 2 because\\n\\t// at max we need to turn only 2 cells (from 1 to 0) to disconnect islands\\n    return 2\\n\\n}\\n\\nfunc findNoOfIslands(grid [][]int, i, j, m, n int) int {\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\tc := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c\\n}\\n\\nfunc dfs(grid [][]int, i, j, m, n int, visited [][]bool) {\\n\\n\\tif i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || visited[i][j] {\\n\\t\\treturn\\n\\t}\\n\\n\\tvisited[i][j] = true\\n\\n\\tdfs(grid, i-1, j, m, n, visited)\\n\\tdfs(grid, i, j+1, m, n, visited)\\n\\tdfs(grid, i+1, j, m, n, visited)\\n\\tdfs(grid, i, j-1, m, n, visited)\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minDays(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\n\\tc := 0\\n\\t// check for answer 0\\n\\t// If already > 1 island then we dont need any days to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif c > 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// check for 1\\n\\t// for all grid values of 1, make it 0 and check no of islands\\n\\t// if anytime you find > 1 island, we need 1 day to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tgrid[i][j] = 0\\n\\t\\t\\t\\tif findNoOfIslands(grid, i, j, m, n) > 1 {\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// answer still not found , ans is 2 because\\n\\t// at max we need to turn only 2 cells (from 1 to 0) to disconnect islands\\n    return 2\\n\\n}\\n\\nfunc findNoOfIslands(grid [][]int, i, j, m, n int) int {\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\tc := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c\\n}\\n\\nfunc dfs(grid [][]int, i, j, m, n int, visited [][]bool) {\\n\\n\\tif i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || visited[i][j] {\\n\\t\\treturn\\n\\t}\\n\\n\\tvisited[i][j] = true\\n\\n\\tdfs(grid, i-1, j, m, n, visited)\\n\\tdfs(grid, i, j+1, m, n, visited)\\n\\tdfs(grid, i+1, j, m, n, visited)\\n\\tdfs(grid, i, j-1, m, n, visited)\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819518,
                "title": "dfs-c-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> rows{-1,0,1,0};\\n    vector<int> cols{0,1,0,-1};\\n    int isSafe(vector<vector<int>>& grid, int i, int j,vector<vector<bool>>& visited){\\n        int row = grid.size();\\n        int col = row ? grid[0].size():0;\\n        return (i<row &&  i>=0 && j >=0 && j<col && (grid[i][j] == 1 && !visited[i][j]));\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i,int j){\\n\\n        \\n        visited[i][j] = true;\\n        \\n        for(int k =0;k<4;++k){\\n            if(isSafe(grid,i+rows[k],j+cols[k],visited)){\\n                dfs(grid,visited,i+rows[k],j+cols[k]);\\n            }\\n        }\\n\\n        \\n    }\\n    \\n    int noOfIslands(vector<vector<int>>& grid){\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :0;\\n        \\n        assert(n>=0);\\n        int count =0;\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        \\n        for(int i =0;i<m;++i){\\n            for(int j =0;j<n ;++j){\\n                if(visited[i][j] == false && grid[i][j] == 1){\\n                        dfs(grid,visited,i,j);\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :m;\\n        int islands = noOfIslands(grid);\\n        if(islands >1 or islands == 0){\\n            return 0;\\n        } else{\\n            for(int i =0;i<m;++i){\\n                for(int j =0;j<n ;++j){\\n                    if(grid[i][j]){\\n                        grid[i][j] =0;\\n                        int islands= noOfIslands(grid);\\n                        grid[i][j] =1;\\n                        if( islands> 1 or islands == 0){\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 2;      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> rows{-1,0,1,0};\\n    vector<int> cols{0,1,0,-1};\\n    int isSafe(vector<vector<int>>& grid, int i, int j,vector<vector<bool>>& visited){\\n        int row = grid.size();\\n        int col = row ? grid[0].size():0;\\n        return (i<row &&  i>=0 && j >=0 && j<col && (grid[i][j] == 1 && !visited[i][j]));\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i,int j){\\n\\n        \\n        visited[i][j] = true;\\n        \\n        for(int k =0;k<4;++k){\\n            if(isSafe(grid,i+rows[k],j+cols[k],visited)){\\n                dfs(grid,visited,i+rows[k],j+cols[k]);\\n            }\\n        }\\n\\n        \\n    }\\n    \\n    int noOfIslands(vector<vector<int>>& grid){\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :0;\\n        \\n        assert(n>=0);\\n        int count =0;\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        \\n        for(int i =0;i<m;++i){\\n            for(int j =0;j<n ;++j){\\n                if(visited[i][j] == false && grid[i][j] == 1){\\n                        dfs(grid,visited,i,j);\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :m;\\n        int islands = noOfIslands(grid);\\n        if(islands >1 or islands == 0){\\n            return 0;\\n        } else{\\n            for(int i =0;i<m;++i){\\n                for(int j =0;j<n ;++j){\\n                    if(grid[i][j]){\\n                        grid[i][j] =0;\\n                        int islands= noOfIslands(grid);\\n                        grid[i][j] =1;\\n                        if( islands> 1 or islands == 0){\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 2;      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819484,
                "title": "python3-solution-easy-to-understand-beats-100-00",
                "content": "```\\n# Key point: The return value can only be 0, 1 or 2\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        N_ones = sum([sum(i) for i in grid])\\n        if(N_ones == 0):\\n            return 0\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n        # This function calculates the area of the first island that we encounter\\n        def count_island_area():\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        g = [a[:] for a in grid]\\n                        area = 1\\n                        q = deque()\\n                        q.append((i,j))\\n                        g[i][j] = 0\\n                        while(q):\\n                            r,c = q.popleft()\\n                            if(r-1 >= 0 and g[r-1][c] == 1):\\n                                area += 1\\n                                g[r-1][c] = 0\\n                                q.append((r-1,c))\\n                            if(r+1 < nRows and g[r+1][c] == 1):\\n                                area += 1\\n                                g[r+1][c] = 0\\n                                q.append((r+1,c))\\n                            if(c-1 >= 0 and g[r][c-1] == 1):\\n                                area += 1\\n                                g[r][c-1] = 0\\n                                q.append((r,c-1))\\n                            if(c+1 < nCols and g[r][c+1] == 1):\\n                                area += 1\\n                                g[r][c+1] = 0\\n                                q.append((r,c+1))\\n                        return area\\n        # If the area of the first island we encounter is smaller than the total area of the island, that means there are more than one island. So we return 0\\n        if(count_island_area() < N_ones):\\n            return 0\\n        # At this point, there is only one island. We try to replace a \\'1\\' in the island with \\'0\\' one by one, and see if we can end up getting two islands.\\n        else:\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        grid[i][j] = 0\\n                        # If there are two islands after replacing a \\'1\\' with \\'0\\', return 1\\n                        if(count_island_area() < N_ones - 1):\\n                            return 1 \\n                        grid[i][j] = 1\\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\n# Key point: The return value can only be 0, 1 or 2\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        N_ones = sum([sum(i) for i in grid])\\n        if(N_ones == 0):\\n            return 0\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n        # This function calculates the area of the first island that we encounter\\n        def count_island_area():\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        g = [a[:] for a in grid]\\n                        area = 1\\n                        q = deque()\\n                        q.append((i,j))\\n                        g[i][j] = 0\\n                        while(q):\\n                            r,c = q.popleft()\\n                            if(r-1 >= 0 and g[r-1][c] == 1):\\n                                area += 1\\n                                g[r-1][c] = 0\\n                                q.append((r-1,c))\\n                            if(r+1 < nRows and g[r+1][c] == 1):\\n                                area += 1\\n                                g[r+1][c] = 0\\n                                q.append((r+1,c))\\n                            if(c-1 >= 0 and g[r][c-1] == 1):\\n                                area += 1\\n                                g[r][c-1] = 0\\n                                q.append((r,c-1))\\n                            if(c+1 < nCols and g[r][c+1] == 1):\\n                                area += 1\\n                                g[r][c+1] = 0\\n                                q.append((r,c+1))\\n                        return area\\n        # If the area of the first island we encounter is smaller than the total area of the island, that means there are more than one island. So we return 0\\n        if(count_island_area() < N_ones):\\n            return 0\\n        # At this point, there is only one island. We try to replace a \\'1\\' in the island with \\'0\\' one by one, and see if we can end up getting two islands.\\n        else:\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        grid[i][j] = 0\\n                        # If there are two islands after replacing a \\'1\\' with \\'0\\', return 1\\n                        if(count_island_area() < N_ones - 1):\\n                            return 1 \\n                        grid[i][j] = 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051729,
                "title": "c-disjoint-set-articulation-point-beats-89-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. If number of components != 1 --> return 0\\n2. Else if #components = 1, and articulation point exists --> return 1\\n3. Else return 2\\n4. Imp observation: Max possible answer is 2 in any case. As even if complete mesh, remove two adjacent nodes of corner cell to make it disconnected.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timer = 0;\\n    bool ap = 0;\\n    void makeset(vector<int> &parent, vector<int> &siz)\\n    {\\n        for(int i = 0 ; i < siz.size() ; i++)\\n        {\\n            parent[i] = i;\\n            siz[i] = 1;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &siz)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n        if(pu == pv)\\n            return;\\n        if(siz[pv] > siz[pu])\\n        {\\n            parent[pu] = pv;\\n            siz[pv] += siz[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            siz[pu] += siz[pv];\\n        }\\n    }\\n    void dfs(int node, int parent, unordered_map<int, set<int>> &adj, vector<int> &disc, vector<int> &low, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        disc[node] = timer;\\n        low[node] = timer;\\n        timer++;\\n        int child = 0;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it, node, adj, disc, low, vis);\\n                low[node] = min(low[node], low[it]);\\n                if(disc[node] <= low[it] && parent != -1)\\n                {\\n                    ap = 1;\\n                }\\n                child++;\\n            }\\n            else\\n                low[node] = min(low[node], disc[it]);\\n        }\\n        if(child > 1 && parent == -1)\\n            ap = 1;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> parent(m*n);\\n        vector<int> siz(m*n);\\n        makeset(parent, siz);\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n + j;\\n                    int l = cell, r = cell, u = cell, d = cell;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        u = (i-1)*n + j;\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        l = (i)*n + j-1;\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        d = (i+1)*n + j;\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        r = (i)*n + j+1;\\n                    Union(cell, l, parent, siz);\\n                    Union(cell, r, parent, siz);\\n                    Union(cell, d, parent, siz);\\n                    Union(cell, u, parent, siz);\\n                }\\n            }\\n        }\\n        int comp = 0;\\n        int store = 0;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1 && findparent(i*n+j, parent) == i*n+j)\\n                {\\n                    store = i*n+j;\\n                    comp++;\\n                }\\n            }\\n        }\\n        if(comp != 1)\\n            return 0;\\n        else if(comp == 1 && siz[store] == 1)\\n            return 1;\\n        \\n        // check if articulation point exists\\n        vector<int> disc(n*m);\\n        vector<int> low(n*m);\\n        vector<int> vis(n*m, 0);\\n        unordered_map<int, set<int>> adj;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n+j;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        adj[cell].insert((i-1)*n+j);\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        adj[cell].insert((i)*n+j-1);\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        adj[cell].insert((i+1)*n+j);\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        adj[cell].insert((i)*n+j+1);\\n                }\\n            }\\n        }\\n        dfs(store, -1, adj, disc, low, vis);\\n        if(ap)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer = 0;\\n    bool ap = 0;\\n    void makeset(vector<int> &parent, vector<int> &siz)\\n    {\\n        for(int i = 0 ; i < siz.size() ; i++)\\n        {\\n            parent[i] = i;\\n            siz[i] = 1;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &siz)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n        if(pu == pv)\\n            return;\\n        if(siz[pv] > siz[pu])\\n        {\\n            parent[pu] = pv;\\n            siz[pv] += siz[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            siz[pu] += siz[pv];\\n        }\\n    }\\n    void dfs(int node, int parent, unordered_map<int, set<int>> &adj, vector<int> &disc, vector<int> &low, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        disc[node] = timer;\\n        low[node] = timer;\\n        timer++;\\n        int child = 0;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it, node, adj, disc, low, vis);\\n                low[node] = min(low[node], low[it]);\\n                if(disc[node] <= low[it] && parent != -1)\\n                {\\n                    ap = 1;\\n                }\\n                child++;\\n            }\\n            else\\n                low[node] = min(low[node], disc[it]);\\n        }\\n        if(child > 1 && parent == -1)\\n            ap = 1;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> parent(m*n);\\n        vector<int> siz(m*n);\\n        makeset(parent, siz);\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n + j;\\n                    int l = cell, r = cell, u = cell, d = cell;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        u = (i-1)*n + j;\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        l = (i)*n + j-1;\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        d = (i+1)*n + j;\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        r = (i)*n + j+1;\\n                    Union(cell, l, parent, siz);\\n                    Union(cell, r, parent, siz);\\n                    Union(cell, d, parent, siz);\\n                    Union(cell, u, parent, siz);\\n                }\\n            }\\n        }\\n        int comp = 0;\\n        int store = 0;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1 && findparent(i*n+j, parent) == i*n+j)\\n                {\\n                    store = i*n+j;\\n                    comp++;\\n                }\\n            }\\n        }\\n        if(comp != 1)\\n            return 0;\\n        else if(comp == 1 && siz[store] == 1)\\n            return 1;\\n        \\n        // check if articulation point exists\\n        vector<int> disc(n*m);\\n        vector<int> low(n*m);\\n        vector<int> vis(n*m, 0);\\n        unordered_map<int, set<int>> adj;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n+j;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        adj[cell].insert((i-1)*n+j);\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        adj[cell].insert((i)*n+j-1);\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        adj[cell].insert((i+1)*n+j);\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        adj[cell].insert((i)*n+j+1);\\n                }\\n            }\\n        }\\n        dfs(store, -1, adj, disc, low, vis);\\n        if(ap)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032134,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool valid (int x,int y,int n,int m)\\n  {\\n      return x>=0 && y>=0 && x<n && y<m;\\n  }\\n  void dfs (int x,int y,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int m)\\n  {\\n     vis[x][y]=1;\\n     int deli[]={0,0,1,-1};\\n     int delj[]={1,-1,0,0};\\n     for (int i=0;i<4;i++)\\n     {\\n         int newi=x+deli[i];\\n         int newj=y+delj[i];\\n         if (valid(newi,newj,n,m) && vis[newi][newj]==0 && grid[newi][newj]==1)\\n         {\\n           dfs(newi,newj,grid,vis,n,m);\\n         }\\n     }\\n  }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==0) continue;\\n                if (vis[i][j]==0) cnt++;\\n                if (cnt>1) return true;\\n                dfs(i,j,grid,vis,n,m);\\n            }\\n        }\\n       if (cnt==0) return true;\\n        return false;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if (disconnected(grid)) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n               if (grid[i][j]==0) continue;\\n               grid[i][j]=0;\\n               if (disconnected(grid)) return 1;\\n               grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool valid (int x,int y,int n,int m)\\n  {\\n      return x>=0 && y>=0 && x<n && y<m;\\n  }\\n  void dfs (int x,int y,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int m)\\n  {\\n     vis[x][y]=1;\\n     int deli[]={0,0,1,-1};\\n     int delj[]={1,-1,0,0};\\n     for (int i=0;i<4;i++)\\n     {\\n         int newi=x+deli[i];\\n         int newj=y+delj[i];\\n         if (valid(newi,newj,n,m) && vis[newi][newj]==0 && grid[newi][newj]==1)\\n         {\\n           dfs(newi,newj,grid,vis,n,m);\\n         }\\n     }\\n  }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==0) continue;\\n                if (vis[i][j]==0) cnt++;\\n                if (cnt>1) return true;\\n                dfs(i,j,grid,vis,n,m);\\n            }\\n        }\\n       if (cnt==0) return true;\\n        return false;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if (disconnected(grid)) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n               if (grid[i][j]==0) continue;\\n               grid[i][j]=0;\\n               if (disconnected(grid)) return 1;\\n               grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032131,
                "title": "dfs-super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        for(auto it: directions)\\n        {\\n            int dr=r+it.first, dc=c+it.second;\\n            if(dr<0 || dc<0 || dr>=rows || dc>=cols || vis[dr][dc] || !grid[dr][dc]) continue;\\n            dfs(dr,dc,grid,vis);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int components=0;\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(grid[x][y] && !vis[x][y])\\n                {\\n                    dfs(x,y,grid,vis);\\n                    components++;\\n                    if(components>1 || components==0) return true;\\n                }\\n            }\\n        }\\n        return (components>1 || components==0);\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        rows=grid.size(), cols=grid[0].size();\\n        if(disconnected(grid)) return 0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(!grid[x][y]) continue;\\n                grid[x][y]=0;\\n                if(disconnected(grid)) return 1;\\n                grid[x][y]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        for(auto it: directions)\\n        {\\n            int dr=r+it.first, dc=c+it.second;\\n            if(dr<0 || dc<0 || dr>=rows || dc>=cols || vis[dr][dc] || !grid[dr][dc]) continue;\\n            dfs(dr,dc,grid,vis);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int components=0;\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(grid[x][y] && !vis[x][y])\\n                {\\n                    dfs(x,y,grid,vis);\\n                    components++;\\n                    if(components>1 || components==0) return true;\\n                }\\n            }\\n        }\\n        return (components>1 || components==0);\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        rows=grid.size(), cols=grid[0].size();\\n        if(disconnected(grid)) return 0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(!grid[x][y]) continue;\\n                grid[x][y]=0;\\n                if(disconnected(grid)) return 1;\\n                grid[x][y]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028419,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971014,
                "title": "java-beats-100-onlyyyyyyy-tarjan-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n\\n  private final int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n  public int minDays(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int numOfIslands = 0;\\n    boolean hasArticulationPoint = false;\\n    int color = 1;\\n    int minIslandSize = m * n;\\n    int[][] time = new int[m][n];\\n    int[][] low = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          numOfIslands++;\\n          color++;\\n          List<Integer> articulationPoints = new ArrayList<>();\\n          int[] islandSize = new int[1];\\n          tarjan(\\n            i,\\n            j,\\n            -1,\\n            -1,\\n            0,\\n            time,\\n            low,\\n            grid,\\n            articulationPoints,\\n            color,\\n            islandSize\\n          );\\n          minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n          if (!articulationPoints.isEmpty()) {\\n            hasArticulationPoint = true;\\n          }\\n        }\\n      }\\n    }\\n    if (numOfIslands >= 2) {\\n      return 0;\\n    }\\n    if (numOfIslands == 0) {\\n      return 0;\\n    }\\n    if (numOfIslands == 1 && minIslandSize == 1) {\\n      return 1;\\n    }\\n    return hasArticulationPoint ? 1 : 2;\\n  }\\n\\n  private void tarjan(\\n    int x,\\n    int y,\\n    int prex,\\n    int prey,\\n    int time,\\n    int[][] times,\\n    int[][] lows,\\n    int[][] grid,\\n    List<Integer> articulationPoints,\\n    int color,\\n    int[] islandSize\\n  ) {\\n    times[x][y] = time;\\n    lows[x][y] = time;\\n    grid[x][y] = color;\\n    islandSize[0]++;\\n    int children = 0;\\n    for (int[] dir : dirs) {\\n      int nx = x + dir[0];\\n      int ny = y + dir[1];\\n      if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n        continue;\\n      }\\n      if (grid[nx][ny] == 1) {\\n        children++;\\n        tarjan(\\n          nx,\\n          ny,\\n          x,\\n          y,\\n          time + 1,\\n          times,\\n          lows,\\n          grid,\\n          articulationPoints,\\n          color,\\n          islandSize\\n        );\\n        lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n        if (prex != -1 && lows[nx][ny] >= time) {\\n          articulationPoints.add(x * grid.length + y);\\n        }\\n      } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n        lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n      }\\n    }\\n    if (prex == -1 && children > 1) {\\n      articulationPoints.add(x * grid.length + y);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n\\n  private final int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n  public int minDays(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int numOfIslands = 0;\\n    boolean hasArticulationPoint = false;\\n    int color = 1;\\n    int minIslandSize = m * n;\\n    int[][] time = new int[m][n];\\n    int[][] low = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          numOfIslands++;\\n          color++;\\n          List<Integer> articulationPoints = new ArrayList<>();\\n          int[] islandSize = new int[1];\\n          tarjan(\\n            i,\\n            j,\\n            -1,\\n            -1,\\n            0,\\n            time,\\n            low,\\n            grid,\\n            articulationPoints,\\n            color,\\n            islandSize\\n          );\\n          minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n          if (!articulationPoints.isEmpty()) {\\n            hasArticulationPoint = true;\\n          }\\n        }\\n      }\\n    }\\n    if (numOfIslands >= 2) {\\n      return 0;\\n    }\\n    if (numOfIslands == 0) {\\n      return 0;\\n    }\\n    if (numOfIslands == 1 && minIslandSize == 1) {\\n      return 1;\\n    }\\n    return hasArticulationPoint ? 1 : 2;\\n  }\\n\\n  private void tarjan(\\n    int x,\\n    int y,\\n    int prex,\\n    int prey,\\n    int time,\\n    int[][] times,\\n    int[][] lows,\\n    int[][] grid,\\n    List<Integer> articulationPoints,\\n    int color,\\n    int[] islandSize\\n  ) {\\n    times[x][y] = time;\\n    lows[x][y] = time;\\n    grid[x][y] = color;\\n    islandSize[0]++;\\n    int children = 0;\\n    for (int[] dir : dirs) {\\n      int nx = x + dir[0];\\n      int ny = y + dir[1];\\n      if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n        continue;\\n      }\\n      if (grid[nx][ny] == 1) {\\n        children++;\\n        tarjan(\\n          nx,\\n          ny,\\n          x,\\n          y,\\n          time + 1,\\n          times,\\n          lows,\\n          grid,\\n          articulationPoints,\\n          color,\\n          islandSize\\n        );\\n        lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n        if (prex != -1 && lows[nx][ny] >= time) {\\n          articulationPoints.add(x * grid.length + y);\\n        }\\n      } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n        lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n      }\\n    }\\n    if (prex == -1 && children > 1) {\\n      articulationPoints.add(x * grid.length + y);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888175,
                "title": "easy-c-articulation-point-check-this-out-by-amazon",
                "content": "# Intuition\\n**easy c++ !! articulation point !! check this out by amazon !!** \\n\\n# Approach\\n**ARTICULATION POINT**\\n\\n# Complexity\\n- Time complexity:\\n**TC = tc of DFS**\\n\\n- Space complexity:\\n**SC = 0(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timer = 1 ; \\n      vector<pair<int,int>>movements ={\\n         {1,0} ,{0,1} ,{-1,0} ,{0,-1}\\n      } ;\\n    void dfs( int x , int y , int px , int py ,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<int>>&entry , vector<vector<int>>&lowtime , vector<vector<bool>>&AP , int nr , int nc )  {\\n        vis[x][y] = true ;\\n        entry[x][y] = timer ;\\n        lowtime[x][y] = timer ; \\n        timer +=1 ; \\n         int childcount = 0 ; \\n        for( auto movement : movements ){\\n            int childx = movement.first + x ;\\n            int childy = movement.second + y ;\\n           if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 ){\\n               //valid cell hai !! \\n               if( grid[childx][childy] == 0 ) continue ; \\n               if( (childx == px) and (childy == py) ) continue ; \\n               if( vis[childx][childy] ) {\\n                   lowtime[x][y] = min( lowtime[x][y] , entry[childx][childy]) ; \\n                   continue ;\\n               }\\n               childcount ++ ;\\n               dfs( childx , childy , x , y , grid , vis , entry , lowtime , AP , nr , nc ) ;\\n               lowtime[x][y] = min( lowtime[x][y] , lowtime[childx][childy] ) ;\\n               // condition !! \\n               if( (entry[x][y] <= lowtime[childx][childy]) and (px != -1 and py != -1) ){\\n                   // x,y vertex is saying , you can reach to me !! BUT NOT BEFORE ME , hence iam the AP \\n                   AP[x][y] = true ;\\n                  continue ; \\n               }\\n           }\\n            \\n        }\\n        if( childcount > 1 and (px==-1 and py == -1 ) )AP[x][y]=true ;\\n        return ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        // if( AP is found ) ans = 1 ; \\n        // else ans = 2 ; \\n        int nr = grid.size() ;\\n         int nc = grid[0].size() ;\\n \\n       vector<vector<bool>>vis(nr,vector<bool>(nc,false));\\n       vector<vector<int>>entry( nr , vector<int>(nc,0)) ;\\n       vector<vector<int>>lowtime( nr , vector<int>(nc,0) ) ;\\n       vector<vector<bool>>AP(nr,vector<bool>(nc,false)) ;\\n       bool dfsdone = false ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( grid[i][j] == 1 ){\\n                    dfsdone = true ;\\n                    dfs( i , j , -1 , -1 , grid , vis , entry , lowtime , AP , nr , nc  ) ;\\n                    break ; \\n                }\\n            }\\n            if( dfsdone == true ) break ;\\n        }\\n\\n// for( int i = 0 ; i < nr ; i++ ){\\n//             for( int j = 0 ; j < nc ; j++ ){\\n//              cout << vis[i][j] <<\" \" ;\\n//             }\\n//             cout <<\"\\\\n\" ;\\n//         }\\n\\n        timer = 1 ;\\n       int ctvis = 0 ;\\n       \\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( vis[i][j] == false and grid[i][j] == 1 ) return  0 ; \\n                if( vis[i][j] == true )ctvis++ ; \\n            }\\n        }\\n        if( ctvis == 1 ) return 1 ; \\n        if( ctvis == 0 ) return 0 ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( AP[i][j] == true ) return 1 ;\\n            }\\n        }\\n\\n        return 2 ; \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Brainteaser",
                    "Matrix",
                    "Iterator",
                    "Biconnected Component",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer = 1 ; \\n      vector<pair<int,int>>movements ={\\n         {1,0} ,{0,1} ,{-1,0} ,{0,-1}\\n      } ;\\n    void dfs( int x , int y , int px , int py ,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<int>>&entry , vector<vector<int>>&lowtime , vector<vector<bool>>&AP , int nr , int nc )  {\\n        vis[x][y] = true ;\\n        entry[x][y] = timer ;\\n        lowtime[x][y] = timer ; \\n        timer +=1 ; \\n         int childcount = 0 ; \\n        for( auto movement : movements ){\\n            int childx = movement.first + x ;\\n            int childy = movement.second + y ;\\n           if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 ){\\n               //valid cell hai !! \\n               if( grid[childx][childy] == 0 ) continue ; \\n               if( (childx == px) and (childy == py) ) continue ; \\n               if( vis[childx][childy] ) {\\n                   lowtime[x][y] = min( lowtime[x][y] , entry[childx][childy]) ; \\n                   continue ;\\n               }\\n               childcount ++ ;\\n               dfs( childx , childy , x , y , grid , vis , entry , lowtime , AP , nr , nc ) ;\\n               lowtime[x][y] = min( lowtime[x][y] , lowtime[childx][childy] ) ;\\n               // condition !! \\n               if( (entry[x][y] <= lowtime[childx][childy]) and (px != -1 and py != -1) ){\\n                   // x,y vertex is saying , you can reach to me !! BUT NOT BEFORE ME , hence iam the AP \\n                   AP[x][y] = true ;\\n                  continue ; \\n               }\\n           }\\n            \\n        }\\n        if( childcount > 1 and (px==-1 and py == -1 ) )AP[x][y]=true ;\\n        return ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        // if( AP is found ) ans = 1 ; \\n        // else ans = 2 ; \\n        int nr = grid.size() ;\\n         int nc = grid[0].size() ;\\n \\n       vector<vector<bool>>vis(nr,vector<bool>(nc,false));\\n       vector<vector<int>>entry( nr , vector<int>(nc,0)) ;\\n       vector<vector<int>>lowtime( nr , vector<int>(nc,0) ) ;\\n       vector<vector<bool>>AP(nr,vector<bool>(nc,false)) ;\\n       bool dfsdone = false ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( grid[i][j] == 1 ){\\n                    dfsdone = true ;\\n                    dfs( i , j , -1 , -1 , grid , vis , entry , lowtime , AP , nr , nc  ) ;\\n                    break ; \\n                }\\n            }\\n            if( dfsdone == true ) break ;\\n        }\\n\\n// for( int i = 0 ; i < nr ; i++ ){\\n//             for( int j = 0 ; j < nc ; j++ ){\\n//              cout << vis[i][j] <<\" \" ;\\n//             }\\n//             cout <<\"\\\\n\" ;\\n//         }\\n\\n        timer = 1 ;\\n       int ctvis = 0 ;\\n       \\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( vis[i][j] == false and grid[i][j] == 1 ) return  0 ; \\n                if( vis[i][j] == true )ctvis++ ; \\n            }\\n        }\\n        if( ctvis == 1 ) return 1 ; \\n        if( ctvis == 0 ) return 0 ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( AP[i][j] == true ) return 1 ;\\n            }\\n        }\\n\\n        return 2 ; \\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3840858,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        int countone =0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    countone++;\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        if(countone==0)return 0;\\n        return 2;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        int countone =0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    countone++;\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        if(countone==0)return 0;\\n        return 2;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834235,
                "title": "c-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n\\n    void dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n    {\\n        vis[row][col]=1;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nr=dx[i]+row;\\n            int nc=dy[i]+col;\\n\\n            if(nr<0 || nr>=n || nc<0 || nc>=m) continue;\\n            //out of bounds then continue\\n\\n            // join the adjacent ones and simply do a dfs to connect the \\n            //remaining ones \\n            if(grid[nr][nc]==1 && vis[nr][nc]==0)\\n            {\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        int count=0;\\n\\n        //if we do a dfs and find out there are more than one conected component then \\n        //we will return 0\\n        //bcz already there are more than one connected component\\n\\n        int cc=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis1(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis1[i][j]==0)\\n                {\\n                    dfs(i,j,vis1,grid);\\n                    cc++;\\n                 }\\n            }\\n        }\\n        if(cc>1 || cc==0) return 0;\\n        //if we do not have any ones to disconnect or if we have the number of connected component as already greater than one then we simply return 0\\n\\n\\n\\n\\n        //if we reach here we have exactly one connected component of 1\\'s\\n        //we have exactly one connected component\\n        //we will try to make one by one cell value as 0 and do a dfs to find how many connected components the graph still has if it is having 0 / >=2 components then it would be having pattern somewhat similar to this\\n\\n         //1111 111\\n        // 11111111   kind of like a start graph then disconnecting the node at the middle would make \\n        // 1111 111   into more than one component so we will simply return 1 in such cases // we are trying to try for such possibilities\\n\\n        //with the loops grid[i][j]=0 made equal to 0 then tried for counting the number of cc \\n        //then made grid[i][j]=1  to try for other one\\'s as to find that one node that diconnects into multiple components\\n        \\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n\\n                  vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n                    grid[i][j]=0;\\n                    int connected=0;\\n\\n                  for(int i=0;i<n;i++)\\n                  {\\n                      for(int j=0;j<m;j++)\\n                      {\\n                          if(grid[i][j]==1 && vis[i][j]==0)\\n                          {\\n                              dfs(i,j,vis,grid);\\n                              connected++;\\n                          }\\n                      }\\n                  \\n                  }\\n                  grid[i][j]=1;\\n\\n                  if(connected==0 || connected>=2) return 1;\\n                }\\n            }\\n        } \\n\\n        return 2;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n\\n    void dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n    {\\n        vis[row][col]=1;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nr=dx[i]+row;\\n            int nc=dy[i]+col;\\n\\n            if(nr<0 || nr>=n || nc<0 || nc>=m) continue;\\n            //out of bounds then continue\\n\\n            // join the adjacent ones and simply do a dfs to connect the \\n            //remaining ones \\n            if(grid[nr][nc]==1 && vis[nr][nc]==0)\\n            {\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        int count=0;\\n\\n        //if we do a dfs and find out there are more than one conected component then \\n        //we will return 0\\n        //bcz already there are more than one connected component\\n\\n        int cc=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis1(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis1[i][j]==0)\\n                {\\n                    dfs(i,j,vis1,grid);\\n                    cc++;\\n                 }\\n            }\\n        }\\n        if(cc>1 || cc==0) return 0;\\n        //if we do not have any ones to disconnect or if we have the number of connected component as already greater than one then we simply return 0\\n\\n\\n\\n\\n        //if we reach here we have exactly one connected component of 1\\'s\\n        //we have exactly one connected component\\n        //we will try to make one by one cell value as 0 and do a dfs to find how many connected components the graph still has if it is having 0 / >=2 components then it would be having pattern somewhat similar to this\\n\\n         //1111 111\\n        // 11111111   kind of like a start graph then disconnecting the node at the middle would make \\n        // 1111 111   into more than one component so we will simply return 1 in such cases // we are trying to try for such possibilities\\n\\n        //with the loops grid[i][j]=0 made equal to 0 then tried for counting the number of cc \\n        //then made grid[i][j]=1  to try for other one\\'s as to find that one node that diconnects into multiple components\\n        \\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n\\n                  vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n                    grid[i][j]=0;\\n                    int connected=0;\\n\\n                  for(int i=0;i<n;i++)\\n                  {\\n                      for(int j=0;j<m;j++)\\n                      {\\n                          if(grid[i][j]==1 && vis[i][j]==0)\\n                          {\\n                              dfs(i,j,vis,grid);\\n                              connected++;\\n                          }\\n                      }\\n                  \\n                  }\\n                  grid[i][j]=1;\\n\\n                  if(connected==0 || connected>=2) return 1;\\n                }\\n            }\\n        } \\n\\n        return 2;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798645,
                "title": "java-tarjan-easier-to-read-than-others",
                "content": "# Intuition\\nAs of now, this should be the easiest Tarjan solution to read in Java.\\n\\n# Approach\\nThere are a lot Tarjan articles and they do better than what I can write. I just have to say that I wasn\\'t able find a good one that explained the scenario when root has two children during DFS is a cut vertex. If anyone can share a good article that can really explain Tarjan this scenario, I will appreciate it.\\n\\nFound some hint from this paper:\\nhttps://arxiv.org/pdf/1805.11864.pdf\\n\"Cut vertices: Output each vertex v in F that has a child w with P(w) = false and is not a root in F or has two or more children.\"\\n\\nIf you speak Chinese, this video has that part explained around 4:30 min:\\nhttps://www.youtube.com/watch?v=-0SmfUw_f4o&ab_channel=latadage\\n\\nI also want to point out that it\\'s a shame that we still know ahead of time that we only need to cut off no more than two lands. Without this assumption ahead of time, there is no tarjan solution.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        // If number of lands is 2, we want to return 2 that will remove all lands from graph.\\n        if (count == 1) return 1;\\n        if (count == 2) return 2;\\n        buildGraph(grid);\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n];\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);\\n        return foundCriticalEdge ? 1 : 2;  // We still know it\\'s only 1 or 2 ahead of time.\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n\\n        int son = 0;\\n        for (int nei : graph.get(cur)) {\\n            //System.out.println(\"nei: \" + nei + \" prev: \" + prev + \" dfn[nei] \" + dfn[nei]);\\n            if (nei == prev) continue;            \\n            if (dfn[nei] == -1) {\\n                son++;\\n                tarjan(cur, nei);\\n                low[cur] = Math.min(low[cur], low[nei]);\\n                if ((cur == root && son > 1) || (low[nei] >= dfn[cur] && cur != root)) {\\n                    //System.out.println(\"foundCriticalEdge cur is \" + cur + \" son \" + son + \" nei \" + nei + \" low[nei] \" + low[nei] + \" dfn[cur] \" + dfn[cur] + \" root \" + root);\\n                    //System.out.println(\" low \" + Arrays.toString(low) + \" dfn \" + Arrays.toString(dfn));\\n                    foundCriticalEdge = true;\\n                    return;\\n                }\\n            } else {\\n                low[cur] = Math.min(low[cur], low[nei]);  //low[nei] or dfn[nei] both work.\\n            }\\n        }\\n    }\\n    /* This is the usecase when (cur == root && son > 1) matters\\n    [0,1,1],\\n    [1,1,1],\\n    [1,1,0]\\n    */\\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        // If number of lands is 2, we want to return 2 that will remove all lands from graph.\\n        if (count == 1) return 1;\\n        if (count == 2) return 2;\\n        buildGraph(grid);\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n];\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);\\n        return foundCriticalEdge ? 1 : 2;  // We still know it\\'s only 1 or 2 ahead of time.\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n\\n        int son = 0;\\n        for (int nei : graph.get(cur)) {\\n            //System.out.println(\"nei: \" + nei + \" prev: \" + prev + \" dfn[nei] \" + dfn[nei]);\\n            if (nei == prev) continue;            \\n            if (dfn[nei] == -1) {\\n                son++;\\n                tarjan(cur, nei);\\n                low[cur] = Math.min(low[cur], low[nei]);\\n                if ((cur == root && son > 1) || (low[nei] >= dfn[cur] && cur != root)) {\\n                    //System.out.println(\"foundCriticalEdge cur is \" + cur + \" son \" + son + \" nei \" + nei + \" low[nei] \" + low[nei] + \" dfn[cur] \" + dfn[cur] + \" root \" + root);\\n                    //System.out.println(\" low \" + Arrays.toString(low) + \" dfn \" + Arrays.toString(dfn));\\n                    foundCriticalEdge = true;\\n                    return;\\n                }\\n            } else {\\n                low[cur] = Math.min(low[cur], low[nei]);  //low[nei] or dfn[nei] both work.\\n            }\\n        }\\n    }\\n    /* This is the usecase when (cur == root && son > 1) matters\\n    [0,1,1],\\n    [1,1,1],\\n    [1,1,0]\\n    */\\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759869,
                "title": "java-with-explanation-dfs",
                "content": "Do upvote (\\uD83D\\uDC4D) if you like the solution. \\n\\n# Approach\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\nbased on above hint, \\n\\n1. Check if graph already diconncted\\n    - do DFS on each node,  if DFS count !=1 then graph is disconected\\n2. Check if removing any node makes graph disconnected\\n    - For each land grid i,j - consider node as \\'x\\'\\n    - if x has minimum 2 adjacent land nodes, then change x\\'s value to water.\\n    - And start from any adjancent land node and do DFS on it. \\n    - If any of the node\\'s adjacent grid is not visited with above DFS, we can treat that our \\'x\\' node disconnected the graph.\\n    - otherwise change back grid value to land;  \\n![Screenshot 2023-07-13 at 8.47.20 PM.png](https://assets.leetcode.com/users/images/2de18acf-e03b-4840-ab11-48d01a093128_1689261519.4931056.png)\\n\\n3. return 2\\n# Code\\n```\\nclass Solution {\\n    int WATER = 0;\\n    int LAND = 1;\\n\\n    /*\\n\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\n    So \\n     > do DFS on any land grid. \\n     > after DFS if we still find any unvisited 1\\'s , then return 0. which mean graph is already diconnected. \\n     > while doig DFS find any land with has only 2 connected lands. if such node exists return 1;\\n     > eles return 2 \\n\\n    */\\n    public int minDays(int[][] grid) {\\n        if(isGraphDisconnected(grid))\\n            return 0;\\n        if(checkIfRemovingOneNodeDisconnectsGraph(grid))\\n            return 1; \\n        return 2;\\n    }\\n\\n    boolean isGraphDisconnected(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        int dfsCount=0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND && !visited[i][j]){\\n                    dfsCount++;\\n                    if(dfsCount>1)\\n                        return true;\\n                    DFS(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return dfsCount!=1;\\n    }\\n\\n    boolean checkIfRemovingOneNodeDisconnectsGraph(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        int landCount =0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND){\\n                    landCount++;\\n                    grid[i][j] = WATER;\\n                    boolean[][] visited = new boolean[M][N];\\n                    int adjacentLandCount=1;\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            adjacentLandCount++;\\n                            if(adjacentLandCount>1){\\n                                DFS(grid, nextRow, nextCol, visited);\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            if(!visited[nextRow][nextCol])\\n                                return true;\\n                        }\\n                    }\\n                    grid[i][j] = LAND;\\n                }\\n            }\\n        }\\n        return landCount==1;\\n    }\\n\\n    boolean isSafe(int row, int col , int M, int N){\\n        return row>=0 && row<M && col>=0 && col<N;\\n    }\\n\\n    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void DFS(int[][] grid, int row, int col, boolean[][] visited){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        if(!isSafe(row, col, M, N) || visited[row][col] || grid[row][col]==0)\\n            return;\\n        visited[row][col]= true;\\n        int visitedCount = 1;\\n        for(int[] dir: dirs){\\n            int newRow = row+dir[0];\\n            int newCol = col+dir[1];\\n            if(isSafe(newRow,newCol, M, N) && !visited[newRow][newCol] && grid[newRow][newCol]==1)\\n                DFS(grid, newRow, newCol, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int WATER = 0;\\n    int LAND = 1;\\n\\n    /*\\n\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\n    So \\n     > do DFS on any land grid. \\n     > after DFS if we still find any unvisited 1\\'s , then return 0. which mean graph is already diconnected. \\n     > while doig DFS find any land with has only 2 connected lands. if such node exists return 1;\\n     > eles return 2 \\n\\n    */\\n    public int minDays(int[][] grid) {\\n        if(isGraphDisconnected(grid))\\n            return 0;\\n        if(checkIfRemovingOneNodeDisconnectsGraph(grid))\\n            return 1; \\n        return 2;\\n    }\\n\\n    boolean isGraphDisconnected(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        int dfsCount=0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND && !visited[i][j]){\\n                    dfsCount++;\\n                    if(dfsCount>1)\\n                        return true;\\n                    DFS(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return dfsCount!=1;\\n    }\\n\\n    boolean checkIfRemovingOneNodeDisconnectsGraph(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        int landCount =0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND){\\n                    landCount++;\\n                    grid[i][j] = WATER;\\n                    boolean[][] visited = new boolean[M][N];\\n                    int adjacentLandCount=1;\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            adjacentLandCount++;\\n                            if(adjacentLandCount>1){\\n                                DFS(grid, nextRow, nextCol, visited);\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            if(!visited[nextRow][nextCol])\\n                                return true;\\n                        }\\n                    }\\n                    grid[i][j] = LAND;\\n                }\\n            }\\n        }\\n        return landCount==1;\\n    }\\n\\n    boolean isSafe(int row, int col , int M, int N){\\n        return row>=0 && row<M && col>=0 && col<N;\\n    }\\n\\n    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void DFS(int[][] grid, int row, int col, boolean[][] visited){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        if(!isSafe(row, col, M, N) || visited[row][col] || grid[row][col]==0)\\n            return;\\n        visited[row][col]= true;\\n        int visitedCount = 1;\\n        for(int[] dir: dirs){\\n            int newRow = row+dir[0];\\n            int newCol = col+dir[1];\\n            if(isSafe(newRow,newCol, M, N) && !visited[newRow][newCol] && grid[newRow][newCol]==1)\\n                DFS(grid, newRow, newCol, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717286,
                "title": "bfs-dfs-for-articulation-point-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arr1[4]={1,-1,0,0};\\n    int arr2[4]={0,0,1,-1};\\n    void bfs(int x,int y,vector<vector<int>> &vis,vector<vector<int>> grid){\\n        queue<pair<int,int>> pq;\\n        vis[x][y]=1;\\n        pq.push({x,y});\\n        while(!pq.empty()){\\n            pair<int,int> p=pq.front();\\n            int cx=p.first;\\n            int cy=p.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx=cx+arr1[i];\\n                int ny=cy+arr2[i];\\n                if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size()){\\n                    if(vis[nx][ny]==0 and grid[nx][ny]==1){\\n                        pq.push({nx,ny});\\n                        vis[nx][ny]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n    }\\n    int f=0;\\n    void dfs(int sx,int sy,int timer,vector<vector<int>> &lo,vector<vector<int>> &time,int parentx,int parenty,vector<vector<int>> grid,vector<vector<int>> &vis){\\n        timer++;\\n        time[sx][sy]=timer;\\n        lo[sx][sy]=timer;\\n        vis[sx][sy]=1;\\n        int child=0;\\n        // cout<<sx<<\\' \\'<<sy<<endl;\\n        for(int i=0;i<4;i++){\\n            int nx=arr1[i]+sx;\\n            int ny=arr2[i]+sy;\\n            if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size() and grid[nx][ny]==1){\\n                if(parentx==nx and parenty==ny){\\n                    //extra case\\n                    continue;\\n                }\\n                else if(vis[nx][ny]==0){\\n                    //case0\\n                    dfs(nx,ny,timer,lo,time,sx,sy,grid,vis);\\n                    // cout<<nx<<\\' \\'<<ny<<endl;\\n                    // case2\\n                    lo[sx][sy]=min(lo[sx][sy],lo[nx][ny]);\\n                    //case3\\n                    if(nx==1 and ny==2){\\n                        // cout<<\"toi\";\\n                        // cout<<lo[nx][ny]<<\" \"<<time[sx][sy]<<endl;\\n                    }\\n                    if(lo[nx][ny]>=time[sx][sy] and parentx!=-1 and parenty!=-1){\\n                        f=1;\\n                    }\\n                    child++;\\n                }\\n                else{\\n                    // case 1\\n                    lo[sx][sy]=min(lo[sx][sy],time[nx][ny]);\\n                }\\n            }\\n        }  \\n        if(parentx==-1 and parenty==-1){\\n            if(child>1){\\n                // cout<<child<<endl;\\n                f=1;\\n            }\\n        }  \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int sourcex,sourcey;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    sourcex=i;\\n                    sourcey=j;\\n                    c++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vis1(n,vector<int>(m,0));\\n        vector<vector<int>> lo(n,vector<int>(m,0));\\n        vector<vector<int>> time(n,vector<int>(m,0));\\n        if(c>1){\\n            return 0;\\n        }\\n        else{\\n            dfs(sourcex,sourcey,0,lo,time,-1,-1,grid,vis1);\\n            if(f==1){\\n                return 1;\\n            }\\n        }\\n        return min(cnt,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arr1[4]={1,-1,0,0};\\n    int arr2[4]={0,0,1,-1};\\n    void bfs(int x,int y,vector<vector<int>> &vis,vector<vector<int>> grid){\\n        queue<pair<int,int>> pq;\\n        vis[x][y]=1;\\n        pq.push({x,y});\\n        while(!pq.empty()){\\n            pair<int,int> p=pq.front();\\n            int cx=p.first;\\n            int cy=p.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx=cx+arr1[i];\\n                int ny=cy+arr2[i];\\n                if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size()){\\n                    if(vis[nx][ny]==0 and grid[nx][ny]==1){\\n                        pq.push({nx,ny});\\n                        vis[nx][ny]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n    }\\n    int f=0;\\n    void dfs(int sx,int sy,int timer,vector<vector<int>> &lo,vector<vector<int>> &time,int parentx,int parenty,vector<vector<int>> grid,vector<vector<int>> &vis){\\n        timer++;\\n        time[sx][sy]=timer;\\n        lo[sx][sy]=timer;\\n        vis[sx][sy]=1;\\n        int child=0;\\n        // cout<<sx<<\\' \\'<<sy<<endl;\\n        for(int i=0;i<4;i++){\\n            int nx=arr1[i]+sx;\\n            int ny=arr2[i]+sy;\\n            if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size() and grid[nx][ny]==1){\\n                if(parentx==nx and parenty==ny){\\n                    //extra case\\n                    continue;\\n                }\\n                else if(vis[nx][ny]==0){\\n                    //case0\\n                    dfs(nx,ny,timer,lo,time,sx,sy,grid,vis);\\n                    // cout<<nx<<\\' \\'<<ny<<endl;\\n                    // case2\\n                    lo[sx][sy]=min(lo[sx][sy],lo[nx][ny]);\\n                    //case3\\n                    if(nx==1 and ny==2){\\n                        // cout<<\"toi\";\\n                        // cout<<lo[nx][ny]<<\" \"<<time[sx][sy]<<endl;\\n                    }\\n                    if(lo[nx][ny]>=time[sx][sy] and parentx!=-1 and parenty!=-1){\\n                        f=1;\\n                    }\\n                    child++;\\n                }\\n                else{\\n                    // case 1\\n                    lo[sx][sy]=min(lo[sx][sy],time[nx][ny]);\\n                }\\n            }\\n        }  \\n        if(parentx==-1 and parenty==-1){\\n            if(child>1){\\n                // cout<<child<<endl;\\n                f=1;\\n            }\\n        }  \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int sourcex,sourcey;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    sourcex=i;\\n                    sourcey=j;\\n                    c++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vis1(n,vector<int>(m,0));\\n        vector<vector<int>> lo(n,vector<int>(m,0));\\n        vector<vector<int>> time(n,vector<int>(m,0));\\n        if(c>1){\\n            return 0;\\n        }\\n        else{\\n            dfs(sourcex,sourcey,0,lo,time,-1,-1,grid,vis1);\\n            if(f==1){\\n                return 1;\\n            }\\n        }\\n        return min(cnt,2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3630139,
                "title": "articulation-point-algorithm-2d-matrix-as-a-graph",
                "content": "# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_days(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut point: Vec<usize> = Vec::with_capacity(2);\\n        let (m, n) = (grid.len(), grid[0].len()); \\n        let mut no_of_island = 0;\\n        let mut art = false;\\n        \\n        let mut timer = 0;\\n                    \\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    println!(\"{} {}\", i, j);\\n                    no_of_island += 1;\\n                    let mut low_tin = vec![vec![0; n]; m];\\n                    let mut tin = vec![vec![0; n]; m];\\n                    timer = 0;\\n                    Solution::dfs(\\n                        -1, -1,  &mut grid, i, j, &mut low_tin, &mut tin, &mut art,\\n                        &mut timer \\n                    ); \\n                }\\n            }\\n        }\\n        if no_of_island == 0 {return 0;}\\n        if no_of_island > 1 {return 0;}\\n        if timer == 1 {return 1;}\\n        if art {return 1;}\\n        return 2;\\n    }\\n\\n    pub fn dfs(parentx:i32, parenty:i32, grid: &mut Vec<Vec<i32>>, i:usize, j:usize, \\n    low_tin: &mut Vec<Vec<i32>>, tin: &mut Vec<Vec<i32>>, art: &mut bool, timer:&mut i32 ){\\n        \\n        grid[i][j] = -1;\\n        tin[i][j] = *timer;\\n        low_tin[i][j] = *timer;\\n        let mut rootcall = 0;\\n        *timer = *timer+1;\\n\\n        let dirs: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n        for it in dirs {\\n            let newx = i as i32+it[0];\\n            let newy = j as i32+it[1];\\n            if parentx == newx && parenty == newy {continue;}\\n            if newx >= 0 &&  newy >= 0 && newx < grid.len() as i32 && newy < grid[0].len() as i32 {\\n                if grid[newx as usize][newy  as usize] == 1{\\n                    Solution::dfs(\\n                        i as i32, j as i32, grid, newx as usize, newy as usize, low_tin, tin, art, timer\\n                    );   \\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], low_tin[newx as usize][newy as usize]);\\n                    if tin[i][j] <= low_tin[newx as usize][newy as usize] && parentx != -1 && parenty != -1 {\\n                        *art = true;\\n                    }\\n                    rootcall += 1;\\n                \\n                } else if grid[newx as usize][newy as usize] == -1 {\\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], tin[newx as usize][newy as usize]); \\n                }\\n            } else {continue;}        \\n        }\\n        if parentx == -1 && parenty == -1  && rootcall > 1 {\\n            *art = true;\\n        }       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut point: Vec<usize> = Vec::with_capacity(2);\\n        let (m, n) = (grid.len(), grid[0].len()); \\n        let mut no_of_island = 0;\\n        let mut art = false;\\n        \\n        let mut timer = 0;\\n                    \\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    println!(\"{} {}\", i, j);\\n                    no_of_island += 1;\\n                    let mut low_tin = vec![vec![0; n]; m];\\n                    let mut tin = vec![vec![0; n]; m];\\n                    timer = 0;\\n                    Solution::dfs(\\n                        -1, -1,  &mut grid, i, j, &mut low_tin, &mut tin, &mut art,\\n                        &mut timer \\n                    ); \\n                }\\n            }\\n        }\\n        if no_of_island == 0 {return 0;}\\n        if no_of_island > 1 {return 0;}\\n        if timer == 1 {return 1;}\\n        if art {return 1;}\\n        return 2;\\n    }\\n\\n    pub fn dfs(parentx:i32, parenty:i32, grid: &mut Vec<Vec<i32>>, i:usize, j:usize, \\n    low_tin: &mut Vec<Vec<i32>>, tin: &mut Vec<Vec<i32>>, art: &mut bool, timer:&mut i32 ){\\n        \\n        grid[i][j] = -1;\\n        tin[i][j] = *timer;\\n        low_tin[i][j] = *timer;\\n        let mut rootcall = 0;\\n        *timer = *timer+1;\\n\\n        let dirs: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n        for it in dirs {\\n            let newx = i as i32+it[0];\\n            let newy = j as i32+it[1];\\n            if parentx == newx && parenty == newy {continue;}\\n            if newx >= 0 &&  newy >= 0 && newx < grid.len() as i32 && newy < grid[0].len() as i32 {\\n                if grid[newx as usize][newy  as usize] == 1{\\n                    Solution::dfs(\\n                        i as i32, j as i32, grid, newx as usize, newy as usize, low_tin, tin, art, timer\\n                    );   \\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], low_tin[newx as usize][newy as usize]);\\n                    if tin[i][j] <= low_tin[newx as usize][newy as usize] && parentx != -1 && parenty != -1 {\\n                        *art = true;\\n                    }\\n                    rootcall += 1;\\n                \\n                } else if grid[newx as usize][newy as usize] == -1 {\\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], tin[newx as usize][newy as usize]); \\n                }\\n            } else {continue;}        \\n        }\\n        if parentx == -1 && parenty == -1  && rootcall > 1 {\\n            *art = true;\\n        }       \\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593181,
                "title": "python-tarjan-s-algorithm-articulation-point-detection-at-most-2-days-of-flipping-1s-to-0s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a haaaard problem if you don\\'t know that we can take at most 2 days to separate a given island. We solve this using SCCs concept + articulation point detection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use Tarjan\\'s algorithm with articulation point detection. This enables us to calculate the number of islands (strongly connected components) in our grid. Moreover, we detect if we have an articulation point -> a node/point, if remove, will disconnect our SCC breaking it to separate SCCs\\n2. Handle edge cases. If we have more than 1 SCCs, return 0. If we have an articulation point, return 1. Otherwise, check if we actually have islands in the grid. If no islands, return 0. If we have a single 1, return 1.\\n3. Finally, if any of the above did not happen, return 2. Imagine a board full of 1. At the minimum, how many 1 should we erase to have two separate islands?\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n\\n        disc_time = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        low_value = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        parents = [[(-1, -1) for _ in range(cols)] for _ in range(rows)]\\n        is_ap = [[False for _ in range(cols)] for _ in range(rows)]\\n        dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\n        time = 0\\n        has_ap = False\\n        def dfs(i, j):\\n            if grid[i][j] == 0:\\n                return\\n            nonlocal time\\n            nonlocal has_ap\\n            disc_time[i][j] = time\\n            low_value[i][j] = time\\n            time += 1\\n\\n            child = 0\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if not (0 <= ni < rows) or not (0 <= nj < cols):\\n                    continue\\n                if grid[ni][nj] != 1:\\n                    continue\\n\\n                if disc_time[ni][nj] == -1: # not visited\\n                    child += 1\\n                    parents[ni][nj] = (i, j)\\n                    dfs(ni, nj)\\n                    low_value[i][j] = min(low_value[i][j], low_value[ni][nj])\\n\\n                    if parents[i][j] == (-1, -1) and child > 1:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n\\n                    if parents[i][j] != (-1, -1) and low_value[ni][nj] >= disc_time[i][j]:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n                elif (ni, nj) != parents[i][j]:\\n                    low_value[i][j] = min(low_value[i][j], disc_time[ni][nj])\\n\\n        sccs = 0\\n        num_ones = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    num_ones += 1\\n                if disc_time[i][j] == -1 and grid[i][j] == 1:\\n                    dfs(i, j)\\n                    sccs += 1\\n\\n\\n        if sccs > 1:\\n            return 0\\n        elif has_ap:\\n            return 1\\n        else:\\n            if num_ones == 1:\\n                return 1\\n            elif num_ones == 0:\\n                return 0\\n        return 2\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n\\n        disc_time = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        low_value = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        parents = [[(-1, -1) for _ in range(cols)] for _ in range(rows)]\\n        is_ap = [[False for _ in range(cols)] for _ in range(rows)]\\n        dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\n        time = 0\\n        has_ap = False\\n        def dfs(i, j):\\n            if grid[i][j] == 0:\\n                return\\n            nonlocal time\\n            nonlocal has_ap\\n            disc_time[i][j] = time\\n            low_value[i][j] = time\\n            time += 1\\n\\n            child = 0\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if not (0 <= ni < rows) or not (0 <= nj < cols):\\n                    continue\\n                if grid[ni][nj] != 1:\\n                    continue\\n\\n                if disc_time[ni][nj] == -1: # not visited\\n                    child += 1\\n                    parents[ni][nj] = (i, j)\\n                    dfs(ni, nj)\\n                    low_value[i][j] = min(low_value[i][j], low_value[ni][nj])\\n\\n                    if parents[i][j] == (-1, -1) and child > 1:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n\\n                    if parents[i][j] != (-1, -1) and low_value[ni][nj] >= disc_time[i][j]:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n                elif (ni, nj) != parents[i][j]:\\n                    low_value[i][j] = min(low_value[i][j], disc_time[ni][nj])\\n\\n        sccs = 0\\n        num_ones = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    num_ones += 1\\n                if disc_time[i][j] == -1 and grid[i][j] == 1:\\n                    dfs(i, j)\\n                    sccs += 1\\n\\n\\n        if sccs > 1:\\n            return 0\\n        elif has_ap:\\n            return 1\\n        else:\\n            if num_ones == 1:\\n                return 1\\n            elif num_ones == 0:\\n                return 0\\n        return 2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591730,
                "title": "simple-dfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m,islands,ones,vis[35][35];\\n    void dfs(int r,int c,vector<vector<int>>& grid){\\n        if(r<0 or c<0 or r>=grid.size() or c>=grid[0].size() or grid[r][c]==0 or vis[r][c]==1 ) return;\\n        vis[r][c]=1;\\n\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        n=grid.size(),m=grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    dfs(i,j,grid),islands++;\\n                }\\n                if(grid[i][j]==1) ones++;\\n            }\\n        }\\n\\n        if(islands!=1) return 0;\\n\\n        if(m==1 or n==1 or ones<=2) return ones==2 ? 2 : 1;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]==1){\\n                   int x=i,y=j;\\n                   grid[i][j]=0;\\n                   islands=0;\\n                   memset(vis,0,sizeof(vis));\\n                   for(int a=0;a<n;a++){\\n                       for(int b=0;b<m;b++){\\n                           if(vis[a][b]==0 and grid[a][b]==1){\\n                               dfs(a,b,grid),islands++;\\n                           }\\n                       }\\n                   }\\n\\n                   if(islands>1) return 1;\\n\\n                   grid[x][y]=1;\\n               }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,islands,ones,vis[35][35];\\n    void dfs(int r,int c,vector<vector<int>>& grid){\\n        if(r<0 or c<0 or r>=grid.size() or c>=grid[0].size() or grid[r][c]==0 or vis[r][c]==1 ) return;\\n        vis[r][c]=1;\\n\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        n=grid.size(),m=grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    dfs(i,j,grid),islands++;\\n                }\\n                if(grid[i][j]==1) ones++;\\n            }\\n        }\\n\\n        if(islands!=1) return 0;\\n\\n        if(m==1 or n==1 or ones<=2) return ones==2 ? 2 : 1;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]==1){\\n                   int x=i,y=j;\\n                   grid[i][j]=0;\\n                   islands=0;\\n                   memset(vis,0,sizeof(vis));\\n                   for(int a=0;a<n;a++){\\n                       for(int b=0;b<m;b++){\\n                           if(vis[a][b]==0 and grid[a][b]==1){\\n                               dfs(a,b,grid),islands++;\\n                           }\\n                       }\\n                   }\\n\\n                   if(islands>1) return 1;\\n\\n                   grid[x][y]=1;\\n               }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578886,
                "title": "c-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n        if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)  //already their are more than one island seperated or it is empty\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n        if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)  //already their are more than one island seperated or it is empty\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533445,
                "title": "edge-case-sucks-targens-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIf already more than 1 connected comp return 0;\\n\\nif(just 1 conn comp and that too of size 1) return 1;\\nif(no connected comp) return 0;\\n\\nif(any articulation point is found) return 1;\\n\\nelse return 2;\\n\\nWHy? let\\'see\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nin the remaining cases the answer is 2 , because you cannot traverse diagonally and by eliminating at max 2 land(1\\'s) you can make a land not reachable.\\n\\n1 1\\n1 1\\n\\nmake it \\n\\n0 1\\n1 0\\n\\n1 1 1   --->  1 0 1\\n1 1 1         1 1 0\\n1 1 1         1 1 1\\n\\nyou can always make it break into two with at most 2 moves.\\n\\n\\nnow the remaining lands are not reachable\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> low , disc ;\\n    vector<vector<bool>> arti;\\n    vector<vector<pair<int , int>>> par;\\n\\n    int n , m;\\n    int time;\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        n = grid.size() ;\\n        m = grid[0].size();\\n\\n        low.resize(n , vector<int> (m , -1));\\n        disc.resize(n , vector<int> (m , -1));\\n        par.resize(n , vector<pair<int , int>> (m , {-1 , -1}));\\n        arti.resize(n , vector<bool>(m , false));\\n      \\n        int flg_arti = 0;\\n\\n        int conn = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < m ; j++) {\\n                if(grid[i][j] == 1 && disc[i][j] == -1) {\\n                    if(conn == 1) return 0;\\n                    conn++;\\n                    time = 0;\\n                    cnt += solve(i , j , grid);\\n                }\\n                if(arti[i][j]) {\\n                    flg_arti = 1;\\n                }\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        if(cnt == 1 || flg_arti) return 1;\\n        return 2;\\n\\n\\n    }\\n\\n    int dx[4] = {1 , -1 , 0 , 0};\\n    int dy[4] = {0 , 0 , -1 , 1};\\n\\n\\n    int solve(int rw , int col , vector<vector<int>> &grid) {\\n\\n        disc[rw][col] = low[rw][col] = time++;\\n        int child = 0;\\n        int cnt = 1;\\n       \\n        for(int i = 0 ; i < 4 ; i++) {\\n            int x = rw + dx[i];\\n            int y = col + dy[i];\\n\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {\\n                \\n                if(disc[x][y] == -1) {\\n                    par[x][y] = {rw , col};\\n                    child += 1;\\n\\n                    cnt += solve(x , y , grid);\\n\\n                    low[rw][col] = min(low[rw][col] , low[x][y]);\\n\\n                    if(par[rw][col].first == -1 && par[rw][col].second == -1 && child >= 2) {\\n                        arti[rw][col] = true;\\n                    }\\n                    if(par[rw][col].first != -1 && par[rw][col].second != -1 && low[x][y] >= disc[rw][col]) {\\n                        arti[rw][col] = true;\\n                    } \\n                }\\n                else if(make_pair(x , y) != par[rw][col]) {\\n                    low[rw][col] = min(low[rw][col] , disc[x][y]);\\n                }\\n\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> low , disc ;\\n    vector<vector<bool>> arti;\\n    vector<vector<pair<int , int>>> par;\\n\\n    int n , m;\\n    int time;\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        n = grid.size() ;\\n        m = grid[0].size();\\n\\n        low.resize(n , vector<int> (m , -1));\\n        disc.resize(n , vector<int> (m , -1));\\n        par.resize(n , vector<pair<int , int>> (m , {-1 , -1}));\\n        arti.resize(n , vector<bool>(m , false));\\n      \\n        int flg_arti = 0;\\n\\n        int conn = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < m ; j++) {\\n                if(grid[i][j] == 1 && disc[i][j] == -1) {\\n                    if(conn == 1) return 0;\\n                    conn++;\\n                    time = 0;\\n                    cnt += solve(i , j , grid);\\n                }\\n                if(arti[i][j]) {\\n                    flg_arti = 1;\\n                }\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        if(cnt == 1 || flg_arti) return 1;\\n        return 2;\\n\\n\\n    }\\n\\n    int dx[4] = {1 , -1 , 0 , 0};\\n    int dy[4] = {0 , 0 , -1 , 1};\\n\\n\\n    int solve(int rw , int col , vector<vector<int>> &grid) {\\n\\n        disc[rw][col] = low[rw][col] = time++;\\n        int child = 0;\\n        int cnt = 1;\\n       \\n        for(int i = 0 ; i < 4 ; i++) {\\n            int x = rw + dx[i];\\n            int y = col + dy[i];\\n\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {\\n                \\n                if(disc[x][y] == -1) {\\n                    par[x][y] = {rw , col};\\n                    child += 1;\\n\\n                    cnt += solve(x , y , grid);\\n\\n                    low[rw][col] = min(low[rw][col] , low[x][y]);\\n\\n                    if(par[rw][col].first == -1 && par[rw][col].second == -1 && child >= 2) {\\n                        arti[rw][col] = true;\\n                    }\\n                    if(par[rw][col].first != -1 && par[rw][col].second != -1 && low[x][y] >= disc[rw][col]) {\\n                        arti[rw][col] = true;\\n                    } \\n                }\\n                else if(make_pair(x , y) != par[rw][col]) {\\n                    low[rw][col] = min(low[rw][col] , disc[x][y]);\\n                }\\n\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465948,
                "title": "minimum-number-of-days-to-disconnect-island",
                "content": "Time Complexity : O((N * M)2) Where\\n\\n Space Complexity: O(N * M)\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfs(int[][] grid, boolean[][] visited, int row, int col) {\\n        if(visited[row][col]) return;\\n\\n        visited[row][col] = true;\\n        for(int[] dir: dirs) {\\n            int rowNew = row + dir[0];\\n            int colNew = col + dir[1];\\n            if(rowNew >= 0 && rowNew < grid.length && colNew >= 0 && colNew < grid[0].length && grid[rowNew][colNew] == 1) {\\n                dfs(grid, visited, rowNew, colNew);\\n            }\\n        }\\n    }\\n    private int islandCount(int[][] grid) {\\n        int count = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1 && !visited[i][j]) {\\n                    dfs(grid, visited, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n \\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        if(islandCount(grid) != 1) return 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    if(islandCount(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfs(int[][] grid, boolean[][] visited, int row, int col) {\\n        if(visited[row][col]) return;\\n\\n        visited[row][col] = true;\\n        for(int[] dir: dirs) {\\n            int rowNew = row + dir[0];\\n            int colNew = col + dir[1];\\n            if(rowNew >= 0 && rowNew < grid.length && colNew >= 0 && colNew < grid[0].length && grid[rowNew][colNew] == 1) {\\n                dfs(grid, visited, rowNew, colNew);\\n            }\\n        }\\n    }\\n    private int islandCount(int[][] grid) {\\n        int count = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1 && !visited[i][j]) {\\n                    dfs(grid, visited, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n \\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        if(islandCount(grid) != 1) return 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    if(islandCount(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465553,
                "title": "not-an-optimized-approach-but-good-to-know-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n\\n        def numIslands(grid):\\n            ans=0\\n            n=len(grid)\\n            m=len(grid[0])\\n            def dfs(i,j,visited):\\n                if (i,j) in visited:\\n                    return\\n                if grid[i][j]==0:\\n                    visited.add((i,j))\\n                    return\\n                visited.add((i,j))\\n                A=[(-1,0),(1,0),(0,-1),(0,1)]\\n                for dx,dy in A:\\n                    if 0<=i+dx<=n-1 and 0<=j+dy<=m-1 and grid[i+dx][j+dy]==1:\\n                        dfs(i+dx,j+dy,visited)\\n            visited=set()\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j]==1 and (i,j) not in visited:\\n                        dfs(i,j,visited)\\n                        ans+=1\\n            return ans\\n        \\n        if numIslands(grid)!=1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    grid[i][j]=0\\n                    \\n                    if numIslands(grid)!=1:\\n                        return 1\\n                    else:\\n                        grid[i][j]=1\\n        return 2\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n\\n        def numIslands(grid):\\n            ans=0\\n            n=len(grid)\\n            m=len(grid[0])\\n            def dfs(i,j,visited):\\n                if (i,j) in visited:\\n                    return\\n                if grid[i][j]==0:\\n                    visited.add((i,j))\\n                    return\\n                visited.add((i,j))\\n                A=[(-1,0),(1,0),(0,-1),(0,1)]\\n                for dx,dy in A:\\n                    if 0<=i+dx<=n-1 and 0<=j+dy<=m-1 and grid[i+dx][j+dy]==1:\\n                        dfs(i+dx,j+dy,visited)\\n            visited=set()\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j]==1 and (i,j) not in visited:\\n                        dfs(i,j,visited)\\n                        ans+=1\\n            return ans\\n        \\n        if numIslands(grid)!=1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    grid[i][j]=0\\n                    \\n                    if numIslands(grid)!=1:\\n                        return 1\\n                    else:\\n                        grid[i][j]=1\\n        return 2\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445107,
                "title": "java-solution-articulation-point-dfs",
                "content": "```\\nclass Solution {\\n    int [][] disc;\\n    int [][] sat;\\n    int [][] parent;\\n    boolean [][] vis;\\n    int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n    int time=0;\\n    public int DFSSIZE(int [][] grid,int i ,int j ,boolean [][] vis){\\n        vis[i][j]=true;\\n        int count=0;\\n        for(int [] arr:dir){\\n            int r=arr[0]+i;\\n            int c=arr[1]+j;\\n            \\n            if(r>=0 && c>=0 && r<grid.length && c<grid[0].length && grid[r][c]==1 && !vis[r][c]){\\n                count+=DFSSIZE(grid,r,c,vis);\\n            }\\n        }\\n        return count+1;\\n    }\\n    \\n    public boolean AP(int [][] grid,int srcr,int srcc,int [][] parent){\\n        disc[srcr][srcc]=sat[srcr][srcc]=++time;\\n        int child=0;\\n        boolean res=false;\\n        for(int [] arr:dir){\\n            int nbrx=arr[0]+srcr;\\n            int nbry=arr[1]+srcc;\\n            int m=grid[0].length;\\n        \\n            if(nbrx>=0 && nbry>=0 && nbrx<grid.length && nbry<grid[0].length && grid[nbrx][nbry]==1){\\n                // System.out.println(nbrx+\" \"+nbry);\\n                if(vis[nbrx][nbry] && parent[srcr][srcc]==(nbrx*m)+nbry){\\n                   \\n                    continue;\\n                }\\n                else if(vis[nbrx][nbry]){\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],disc[nbrx][nbry]);\\n                }\\n                else{\\n                    vis[nbrx][nbry]=true;\\n                    parent[nbrx][nbry]=(srcr*m)+srcc;\\n                    child++;\\n                    res=res || AP(grid,nbrx,nbry,parent);\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],sat[nbrx][nbry]);\\n                    \\n                    if(parent[srcr][srcc]==-1){\\n                        if(child>=2){\\n                            return true;\\n                        }\\n                    }\\n                    else{\\n                        if(disc[srcr][srcc]<=sat[nbrx][nbry]){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res; \\n    }\\n    public int minDays(int[][] grid) {\\n        int size=0;\\n        int noofComponents=0;\\n        int n =grid.length;\\n        int m =grid[0].length;\\n        parent=new int[n][m];\\n        sat=new int[n][m];\\n        disc=new int[n][m];\\n        vis=new boolean[n][m];\\n        int rootx=0;\\n        int rooty=0;\\n        boolean res=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    rootx=i;\\n                    rooty=j;\\n                    size+=DFSSIZE(grid,i,j,vis);\\n                   noofComponents++; \\n                }\\n            }\\n        }\\n        vis=new boolean [n][m];\\n        if(noofComponents==0 || noofComponents>1){\\n            return 0;\\n        }\\n        else {\\n            if(size==1 || size==2){\\n                return size;\\n            }\\n            else{\\n                parent[rootx][rooty]=-1;\\n               vis[rootx][rooty]=true;\\n               res=AP(grid,rootx,rooty,parent); \\n             \\n                if(res){\\n                    return 1;\\n                }\\n                else{\\n                    return 2;\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int [][] disc;\\n    int [][] sat;\\n    int [][] parent;\\n    boolean [][] vis;\\n    int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n    int time=0;\\n    public int DFSSIZE(int [][] grid,int i ,int j ,boolean [][] vis){\\n        vis[i][j]=true;\\n        int count=0;\\n        for(int [] arr:dir){\\n            int r=arr[0]+i;\\n            int c=arr[1]+j;\\n            \\n            if(r>=0 && c>=0 && r<grid.length && c<grid[0].length && grid[r][c]==1 && !vis[r][c]){\\n                count+=DFSSIZE(grid,r,c,vis);\\n            }\\n        }\\n        return count+1;\\n    }\\n    \\n    public boolean AP(int [][] grid,int srcr,int srcc,int [][] parent){\\n        disc[srcr][srcc]=sat[srcr][srcc]=++time;\\n        int child=0;\\n        boolean res=false;\\n        for(int [] arr:dir){\\n            int nbrx=arr[0]+srcr;\\n            int nbry=arr[1]+srcc;\\n            int m=grid[0].length;\\n        \\n            if(nbrx>=0 && nbry>=0 && nbrx<grid.length && nbry<grid[0].length && grid[nbrx][nbry]==1){\\n                // System.out.println(nbrx+\" \"+nbry);\\n                if(vis[nbrx][nbry] && parent[srcr][srcc]==(nbrx*m)+nbry){\\n                   \\n                    continue;\\n                }\\n                else if(vis[nbrx][nbry]){\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],disc[nbrx][nbry]);\\n                }\\n                else{\\n                    vis[nbrx][nbry]=true;\\n                    parent[nbrx][nbry]=(srcr*m)+srcc;\\n                    child++;\\n                    res=res || AP(grid,nbrx,nbry,parent);\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],sat[nbrx][nbry]);\\n                    \\n                    if(parent[srcr][srcc]==-1){\\n                        if(child>=2){\\n                            return true;\\n                        }\\n                    }\\n                    else{\\n                        if(disc[srcr][srcc]<=sat[nbrx][nbry]){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res; \\n    }\\n    public int minDays(int[][] grid) {\\n        int size=0;\\n        int noofComponents=0;\\n        int n =grid.length;\\n        int m =grid[0].length;\\n        parent=new int[n][m];\\n        sat=new int[n][m];\\n        disc=new int[n][m];\\n        vis=new boolean[n][m];\\n        int rootx=0;\\n        int rooty=0;\\n        boolean res=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    rootx=i;\\n                    rooty=j;\\n                    size+=DFSSIZE(grid,i,j,vis);\\n                   noofComponents++; \\n                }\\n            }\\n        }\\n        vis=new boolean [n][m];\\n        if(noofComponents==0 || noofComponents>1){\\n            return 0;\\n        }\\n        else {\\n            if(size==1 || size==2){\\n                return size;\\n            }\\n            else{\\n                parent[rootx][rooty]=-1;\\n               vis[rootx][rooty]=true;\\n               res=AP(grid,rootx,rooty,parent); \\n             \\n                if(res){\\n                    return 1;\\n                }\\n                else{\\n                    return 2;\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363658,
                "title": "max-2-days-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        num_1s = abs(sum(sum(row) for row in grid))\\n\\n        @cache\\n        def get_rc():\\n            for r in range(m):\\n                for c in range(n):\\n                    if grid[r][c]:\\n                        yield r, c\\n\\n        # mul = 1\\n        # def set_dist(r, c, dist):\\n        #     if r < 0 or r>= m or c < 0 or c >= n:\\n        #         return\\n        #     if grid[r][c] != 1 and grid[r][c] <= dist:\\n        #         return\\n        #     grid[r][c] = dist\\n            \\n        #     set_dist(r-1, c, dist + 1)\\n        #     set_dist(r+1, c, dist + 1)\\n        #     set_dist(r, c-1, dist + 1)\\n        #     set_dist(r, c+1, dist + 1)\\n        \\n        island = 1\\n        def is_connected():\\n            nonlocal island\\n            def count(r, c):\\n                if r < 0 or r>= m or c < 0 or c >= n: return 0\\n                if grid[r][c] != island: return 0\\n                grid[r][c] = -island\\n                total = 1\\n                total += count(r-1, c)\\n                total += count(r+1, c)\\n                total += count(r, c-1)\\n                total += count(r, c+1)\\n                return total\\n            r, c = first_rc\\n            if not grid[r][c]:\\n                r, c = second_rc\\n            conn = count(r, c)\\n            island = -island\\n            return conn == num_1s\\n\\n        if num_1s == 0:\\n            return 0\\n        elif num_1s == 1:\\n            return 1\\n        \\n        \\n        g = get_rc()\\n        first_rc = next(g)\\n        second_rc = next(g)\\n\\n        if not is_connected():\\n            return 0\\n        elif num_1s == 2:\\n            return 2\\n        \\n\\n        # skip = True\\n        num_1s -= 1\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    continue\\n                # if skip:\\n                #     skip = False\\n                #     continue\\n                grid[r][c] = 0\\n                if not is_connected():\\n                    # print(f\"Choke at {r}, {c}\")\\n                    return 1\\n                grid[r][c] = island\\n                \\n                \\n        return 2\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        num_1s = abs(sum(sum(row) for row in grid))\\n\\n        @cache\\n        def get_rc():\\n            for r in range(m):\\n                for c in range(n):\\n                    if grid[r][c]:\\n                        yield r, c\\n\\n        # mul = 1\\n        # def set_dist(r, c, dist):\\n        #     if r < 0 or r>= m or c < 0 or c >= n:\\n        #         return\\n        #     if grid[r][c] != 1 and grid[r][c] <= dist:\\n        #         return\\n        #     grid[r][c] = dist\\n            \\n        #     set_dist(r-1, c, dist + 1)\\n        #     set_dist(r+1, c, dist + 1)\\n        #     set_dist(r, c-1, dist + 1)\\n        #     set_dist(r, c+1, dist + 1)\\n        \\n        island = 1\\n        def is_connected():\\n            nonlocal island\\n            def count(r, c):\\n                if r < 0 or r>= m or c < 0 or c >= n: return 0\\n                if grid[r][c] != island: return 0\\n                grid[r][c] = -island\\n                total = 1\\n                total += count(r-1, c)\\n                total += count(r+1, c)\\n                total += count(r, c-1)\\n                total += count(r, c+1)\\n                return total\\n            r, c = first_rc\\n            if not grid[r][c]:\\n                r, c = second_rc\\n            conn = count(r, c)\\n            island = -island\\n            return conn == num_1s\\n\\n        if num_1s == 0:\\n            return 0\\n        elif num_1s == 1:\\n            return 1\\n        \\n        \\n        g = get_rc()\\n        first_rc = next(g)\\n        second_rc = next(g)\\n\\n        if not is_connected():\\n            return 0\\n        elif num_1s == 2:\\n            return 2\\n        \\n\\n        # skip = True\\n        num_1s -= 1\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    continue\\n                # if skip:\\n                #     skip = False\\n                #     continue\\n                grid[r][c] = 0\\n                if not is_connected():\\n                    # print(f\"Choke at {r}, {c}\")\\n                    return 1\\n                grid[r][c] = island\\n                \\n                \\n        return 2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337239,
                "title": "articulation-point-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[] vis;\\n    int[] dis;\\n    int[] low;\\n    public int minDays(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int zerosum=0;\\n        int onesum=0;\\n        //find all no land ans water\\n        for(int[] g : grid){\\n            for(int val : g){\\n                if(val==1)\\n                onesum++;\\n                else\\n                zerosum++;\\n            }\\n        }\\n       //if no land\\n        if(zerosum==(n*m))\\n        return 0;\\n        //if 1 island\\n        if(onesum==1)\\n        return 1;\\n        //if only land then any corner can be made 2nd component my removing 2 land adj to corner\\n        if(onesum==(n*m))\\n        return 2;\\n\\n        vis=new boolean[n*m];\\n        low=new int[n*m];\\n        dis=new int[n*m];\\n        int len=0;\\n        int root=-1;\\n        //first land mass\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(grid[i][j]==1){\\n                root=i*m+j;\\n                break;\\n            }\\n        }\\n        if(root!=-1)\\n        break;\\n        }\\n       //articulation point \\n        boolean ans=arti(root,-1,grid,len,n,m);\\n\\n        // vis will not be true on all1s if their are already multiple components\\n        for(int i=0;i<(n*m);i++)\\n        if(grid[i/m][i%m]==1 && vis[i]==false){\\n          return 0;\\n        }\\n        // if true their is point and we need to remove only that\\n        //or else remove 2 lands masses to make component\\n        return ans?1:2;\\n    }\\n    boolean arti(int root,int par,int[][] grid,int len,int n,int m){\\n        // root col and row\\n        int sr=root/m;\\n        int sc=root%m;\\n\\n        vis[root]=true;\\n        dis[root]=low[root]=len++;\\n        boolean res=false;\\n        //no of components/islands\\n        int com=0;\\n        // array for traversing in 4 directions\\n        int[][] dir={{ 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 }};\\n        for(int[] d: dir){\\n            int r=sr+d[0];\\n            int c=sc+d[1];\\n            int child=r*m+c;\\n            //if thier is land in child coordinates\\n            if(r>=0 && r<n && c>=0 && c<m && grid[r][c]==1){\\n                //logic of articulation point refer youtube video\\n                // consider love babber code help placement series lecture 99\\n                if(!vis[child]){\\n                    com++;\\n                    res=arti(child,root,grid,len,n,m)||res;\\n                    low[root]=Math.min(low[root],low[child]);\\n                    \\n                    if(low[child]>=dis[root] && par!=-1){\\n                       \\n                     res=true;\\n                    }\\n                    \\n                }\\n                if(child!=par){\\n                    low[root]=Math.min(low[root],low[child]);\\n                }\\n                \\n               \\n            }\\n        }\\n        if(par==-1 && com>1)\\n        return true;\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] vis;\\n    int[] dis;\\n    int[] low;\\n    public int minDays(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int zerosum=0;\\n        int onesum=0;\\n        //find all no land ans water\\n        for(int[] g : grid){\\n            for(int val : g){\\n                if(val==1)\\n                onesum++;\\n                else\\n                zerosum++;\\n            }\\n        }\\n       //if no land\\n        if(zerosum==(n*m))\\n        return 0;\\n        //if 1 island\\n        if(onesum==1)\\n        return 1;\\n        //if only land then any corner can be made 2nd component my removing 2 land adj to corner\\n        if(onesum==(n*m))\\n        return 2;\\n\\n        vis=new boolean[n*m];\\n        low=new int[n*m];\\n        dis=new int[n*m];\\n        int len=0;\\n        int root=-1;\\n        //first land mass\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(grid[i][j]==1){\\n                root=i*m+j;\\n                break;\\n            }\\n        }\\n        if(root!=-1)\\n        break;\\n        }\\n       //articulation point \\n        boolean ans=arti(root,-1,grid,len,n,m);\\n\\n        // vis will not be true on all1s if their are already multiple components\\n        for(int i=0;i<(n*m);i++)\\n        if(grid[i/m][i%m]==1 && vis[i]==false){\\n          return 0;\\n        }\\n        // if true their is point and we need to remove only that\\n        //or else remove 2 lands masses to make component\\n        return ans?1:2;\\n    }\\n    boolean arti(int root,int par,int[][] grid,int len,int n,int m){\\n        // root col and row\\n        int sr=root/m;\\n        int sc=root%m;\\n\\n        vis[root]=true;\\n        dis[root]=low[root]=len++;\\n        boolean res=false;\\n        //no of components/islands\\n        int com=0;\\n        // array for traversing in 4 directions\\n        int[][] dir={{ 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 }};\\n        for(int[] d: dir){\\n            int r=sr+d[0];\\n            int c=sc+d[1];\\n            int child=r*m+c;\\n            //if thier is land in child coordinates\\n            if(r>=0 && r<n && c>=0 && c<m && grid[r][c]==1){\\n                //logic of articulation point refer youtube video\\n                // consider love babber code help placement series lecture 99\\n                if(!vis[child]){\\n                    com++;\\n                    res=arti(child,root,grid,len,n,m)||res;\\n                    low[root]=Math.min(low[root],low[child]);\\n                    \\n                    if(low[child]>=dis[root] && par!=-1){\\n                       \\n                     res=true;\\n                    }\\n                    \\n                }\\n                if(child!=par){\\n                    low[root]=Math.min(low[root],low[child]);\\n                }\\n                \\n               \\n            }\\n        }\\n        if(par==-1 && com>1)\\n        return true;\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328078,
                "title": "try-deleting-any-land-tile",
                "content": "# Complexity\\n- Time complexity:\\n$$O(m^2 n^2)$$\\n\\n- Space complexity:\\n$$O(m n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        bool isLand(int x, int y)\\n        {\\n            if(x < 0 || x >= m || y < 0 || y >= n || (grid[x][y] != 1))\\n                return false;\\n            return true;\\n        }\\n        bool isConnected()\\n        {\\n            bool[,] visited = new bool[m, n];\\n            bool visit(int x, int y)\\n            {\\n                if((!isLand(x, y)) || visited[x, y])\\n                    return false;\\n                visited[x, y] = true;\\n                visit(x - 1, y);\\n                visit(x + 1, y);\\n                visit(x, y - 1);\\n                visit(x, y + 1);\\n                return true;\\n            }\\n            int visitedCnt = 0;\\n            for(int i = 0; i < m; i++)\\n                for(int j = 0; j < n; j++)\\n                    visitedCnt += visit(i, j)?1:0;            \\n            return visitedCnt == 1;\\n        }\\n\\n        //already disconnected\\n        if(!isConnected())\\n            return 0;\\n        \\n        //one single operation required: try deleting any land tile\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(isLand(i, j))\\n                {\\n                    grid[i][j] = 0;\\n                    if(!isConnected())\\n                        return 1;\\n                    grid[i][j] = 1;\\n                }\\n\\n        //all other cases:\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        bool isLand(int x, int y)\\n        {\\n            if(x < 0 || x >= m || y < 0 || y >= n || (grid[x][y] != 1))\\n                return false;\\n            return true;\\n        }\\n        bool isConnected()\\n        {\\n            bool[,] visited = new bool[m, n];\\n            bool visit(int x, int y)\\n            {\\n                if((!isLand(x, y)) || visited[x, y])\\n                    return false;\\n                visited[x, y] = true;\\n                visit(x - 1, y);\\n                visit(x + 1, y);\\n                visit(x, y - 1);\\n                visit(x, y + 1);\\n                return true;\\n            }\\n            int visitedCnt = 0;\\n            for(int i = 0; i < m; i++)\\n                for(int j = 0; j < n; j++)\\n                    visitedCnt += visit(i, j)?1:0;            \\n            return visitedCnt == 1;\\n        }\\n\\n        //already disconnected\\n        if(!isConnected())\\n            return 0;\\n        \\n        //one single operation required: try deleting any land tile\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(isLand(i, j))\\n                {\\n                    grid[i][j] = 0;\\n                    if(!isConnected())\\n                        return 1;\\n                    grid[i][j] = 1;\\n                }\\n\\n        //all other cases:\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325845,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int i,int j,int n,int m,vector<vector<int>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==0 || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        helper(i+1,j,n,m,arr,visited);\\n        helper(i,j-1,n,m,arr,visited);\\n        helper(i-1,j,n,m,arr,visited);\\n        helper(i,j+1,n,m,arr,visited);\\n        \\n    }\\n    int numislands(int n,int m,vector<vector<int>>&arr){\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(arr[i][j]==1 && visited[i][j]!=true){\\n                    helper(i,j,n,m,arr,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=numislands(n,m,grid);\\n        if(ans>1 || ans==0){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    int num=numislands(n,m,grid);\\n                    if(num>1 || num==0){\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void helper(int i,int j,int n,int m,vector<vector<int>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==0 || visited[i][j]==true){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3171061,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut grid = grid;\\n        let mut islands = Self::count_islands(&grid);\\n        let (n, m) = (grid.len(), grid[0].len());\\n        if islands > 1 || islands == 0 {\\n            return 0;\\n        } else {\\n            for i in 0..n {\\n                for j in 0..m {\\n                    if grid[i][j] == 1 {\\n                        grid[i][j] = 0;\\n                        islands = Self::count_islands(&grid);\\n                        grid[i][j] = 1;\\n                        if islands > 1 || islands == 0 {\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        2\\n    }\\n\\n    fn dfs(x: usize, y: usize, grid: &Vec<Vec<i32>>, vis: &mut Vec<Vec<i32>>) {\\n        let dx = vec![1, -1, 0, 0];\\n        let dy = vec![0, 0, 1, -1];\\n        let (n, m) = (grid.len(), grid[0].len());\\n        vis[x][y] = 1;\\n        for a in 0..4 {\\n            let nx = x as i32 + dx[a];\\n            let ny = y as i32 + dy[a];\\n            if nx >= 0\\n                && ny >= 0\\n                && nx < n as i32\\n                && ny < m as i32\\n                && vis[nx as usize][ny as usize] == 0\\n                && grid[nx as usize][ny as usize] == 1\\n            {\\n                Self::dfs(nx as usize, ny as usize, grid, vis);\\n            }\\n        }\\n    }\\n\\n    fn count_islands(grid: &Vec<Vec<i32>>) -> i32 {\\n        let mut islands = 0;\\n        let (n, m) = (grid.len(), grid[0].len());\\n        let mut vis = vec![vec![0; m]; n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if vis[i][j] == 0 && grid[i][j] == 1 {\\n                    Self::dfs(i, j, grid, &mut vis);\\n                    islands += 1;\\n                }\\n            }\\n        }\\n        islands\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut grid = grid;\\n        let mut islands = Self::count_islands(&grid);\\n        let (n, m) = (grid.len(), grid[0].len());\\n        if islands > 1 || islands == 0 {\\n            return 0;\\n        } else {\\n            for i in 0..n {\\n                for j in 0..m {\\n                    if grid[i][j] == 1 {\\n                        grid[i][j] = 0;\\n                        islands = Self::count_islands(&grid);\\n                        grid[i][j] = 1;\\n                        if islands > 1 || islands == 0 {\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        2\\n    }\\n\\n    fn dfs(x: usize, y: usize, grid: &Vec<Vec<i32>>, vis: &mut Vec<Vec<i32>>) {\\n        let dx = vec![1, -1, 0, 0];\\n        let dy = vec![0, 0, 1, -1];\\n        let (n, m) = (grid.len(), grid[0].len());\\n        vis[x][y] = 1;\\n        for a in 0..4 {\\n            let nx = x as i32 + dx[a];\\n            let ny = y as i32 + dy[a];\\n            if nx >= 0\\n                && ny >= 0\\n                && nx < n as i32\\n                && ny < m as i32\\n                && vis[nx as usize][ny as usize] == 0\\n                && grid[nx as usize][ny as usize] == 1\\n            {\\n                Self::dfs(nx as usize, ny as usize, grid, vis);\\n            }\\n        }\\n    }\\n\\n    fn count_islands(grid: &Vec<Vec<i32>>) -> i32 {\\n        let mut islands = 0;\\n        let (n, m) = (grid.len(), grid[0].len());\\n        let mut vis = vec![vec![0; m]; n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if vis[i][j] == 0 && grid[i][j] == 1 {\\n                    Self::dfs(i, j, grid, &mut vis);\\n                    islands += 1;\\n                }\\n            }\\n        }\\n        islands\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152047,
                "title": "simple-dfs-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will check if we have not 1 island then return 0 , else we will try to make every 1 cell 0 then check if we have more than 1 islands if we have then we return 1 else in end we return 2 .\\n# Complexity\\n- Time complexity: O(N^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<bool>>& vis, int i, int j, vector<vector<int>>& g){\\n        if(i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || !g[i][j] || vis[i][j]) return 0;\\n        vis[i][j] = 1;\\n        return 1 + dfs(vis,i+1,j, g) + dfs(vis,i,j+1, g) + dfs(vis,i-1,j, g) + dfs(vis,i,j-1, g);\\n    }\\n\\n    int icnt(vector<vector<int>>& g){\\n        int ino = 0;\\n        vector<vector<bool>> vis(g.size(),vector<bool>(g[0].size(),0));\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[0].size();j++){\\n                if(g[i][j] && !vis[i][j]){\\n                    dfs(vis,i,j,g);\\n                    ino++;\\n                }\\n            }\\n        }\\n        return ino;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int noi = 0, size = 0;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        int x = 0, y = 0;\\n        // first we count number of islands\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    size = dfs(vis,i,j,grid);\\n                    x = i, y = j;\\n                    noi++;\\n                }\\n                if(noi > 1) return 0;\\n            }\\n        }\\n        if(noi == 0) return 0;\\n        // now we will try to flip every one and check if doing this will make 2 island\\n        if(size < 3) return size;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    // Now do icnt\\n                    if(icnt(grid) >= 2) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<bool>>& vis, int i, int j, vector<vector<int>>& g){\\n        if(i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || !g[i][j] || vis[i][j]) return 0;\\n        vis[i][j] = 1;\\n        return 1 + dfs(vis,i+1,j, g) + dfs(vis,i,j+1, g) + dfs(vis,i-1,j, g) + dfs(vis,i,j-1, g);\\n    }\\n\\n    int icnt(vector<vector<int>>& g){\\n        int ino = 0;\\n        vector<vector<bool>> vis(g.size(),vector<bool>(g[0].size(),0));\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[0].size();j++){\\n                if(g[i][j] && !vis[i][j]){\\n                    dfs(vis,i,j,g);\\n                    ino++;\\n                }\\n            }\\n        }\\n        return ino;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int noi = 0, size = 0;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        int x = 0, y = 0;\\n        // first we count number of islands\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    size = dfs(vis,i,j,grid);\\n                    x = i, y = j;\\n                    noi++;\\n                }\\n                if(noi > 1) return 0;\\n            }\\n        }\\n        if(noi == 0) return 0;\\n        // now we will try to flip every one and check if doing this will make 2 island\\n        if(size < 3) return size;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    // Now do icnt\\n                    if(icnt(grid) >= 2) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094296,
                "title": "boring-brute-force-approach-dfs",
                "content": "```\\nimport random\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(i, j, visited):\\n            visited.add((i,j))\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 1:\\n                    dfs(x, y, visited)\\n        \\n        islands = []\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in seen and grid[i][j] == 1:\\n                    visited = set()\\n                    dfs(i, j, visited)\\n                    islands.append(visited)\\n                    seen.update(visited)\\n\\n        if len(islands) > 1 or len(islands) == 0:\\n            return 0\\n        \\n        island_indices = islands[0]\\n        if len(island_indices) == 1:\\n            return 1\\n\\n        island_copy = copy.copy(island_indices)\\n        for index in island_indices:\\n            i, j = index\\n            island_copy.remove(index)\\n            grid[i][j] = 0\\n            visited = set()\\n            x, y = random.choice(list(island_copy))\\n            dfs(x, y, visited)\\n            if len(visited) != len(island_copy):\\n                return 1\\n\\n            island_copy.add(index)\\n            grid[i][j] = 1\\n\\n        return 2\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(i, j, visited):\\n            visited.add((i,j))\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 1:\\n                    dfs(x, y, visited)\\n        \\n        islands = []\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in seen and grid[i][j] == 1:\\n                    visited = set()\\n                    dfs(i, j, visited)\\n                    islands.append(visited)\\n                    seen.update(visited)\\n\\n        if len(islands) > 1 or len(islands) == 0:\\n            return 0\\n        \\n        island_indices = islands[0]\\n        if len(island_indices) == 1:\\n            return 1\\n\\n        island_copy = copy.copy(island_indices)\\n        for index in island_indices:\\n            i, j = index\\n            island_copy.remove(index)\\n            grid[i][j] = 0\\n            visited = set()\\n            x, y = random.choice(list(island_copy))\\n            dfs(x, y, visited)\\n            if len(visited) != len(island_copy):\\n                return 1\\n\\n            island_copy.add(index)\\n            grid[i][j] = 1\\n\\n        return 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045234,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    int m, n;\\n    int ts;\\n    vector<vector<int>> dfn, low;\\n    bool cut;\\n    int rx, ry;\\n\\n    void dfs(int x, int y, const vector<vector<int>> &grid) {\\n        const int dx[4] = {0, 1, 0, -1};\\n        const int dy[4] = {1, 0, -1 ,0};\\n\\n        dfn[x][y] = low[x][y] = ++ts;\\n        int branch = 0;\\n        for (int i = 0; i < 4; i++) {\\n            int tx = x + dx[i], ty = y + dy[i];\\n            if (tx < 0 || tx >= m || ty < 0 || ty >= n || grid[tx][ty] == 0)\\n                continue;\\n\\n            if (dfn[tx][ty] != 0) {\\n                low[x][y] = min(low[x][y], dfn[tx][ty]);\\n                continue;\\n            }\\n\\n            dfs(tx, ty, grid);\\n\\n            branch++;\\n            low[x][y] = min(low[x][y], low[tx][ty]);\\n\\n            if (low[tx][ty] >= dfn[x][y]) {\\n                if (branch >= 2 || !(x == rx && y == ry))\\n                    cut = true;\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dfn.resize(m, vector<int>(n, 0));\\n        low.resize(m, vector<int>(n, 0));\\n        ts = 0;\\n        cut = false;\\n\\n        bool first = false;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == 1 && dfn[i][j] == 0) {\\n                    if (first) return 0;\\n                    first = true;\\n                    rx = i; ry = j;\\n                    dfs(i, j, grid);\\n                }\\n\\n        if (!first) return 0;\\n        if (ts == 1 || cut) return 1;\\n        return 2;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```\\n\\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n    private final int[][] dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m * n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if (!articulationPoints.isEmpty()) {\\n                        hasArticulationPoint = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (numOfIslands >= 2) {\\n            return 0;\\n        }\\n        if (numOfIslands == 0) {\\n            return 0;\\n        }\\n        if (numOfIslands == 1 && minIslandSize == 1) {\\n            return 1;\\n        }\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n\\n    private void tarjan(\\n            int x,\\n            int y,\\n            int prex,\\n            int prey,\\n            int time,\\n            int[][] times,\\n            int[][] lows,\\n            int[][] grid,\\n            List<Integer> articulationPoints,\\n            int color,\\n            int[] islandSize) {\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n                continue;\\n            }\\n            if (grid[nx][ny] == 1) {\\n                children++;\\n                tarjan(\\n                        nx,\\n                        ny,\\n                        x,\\n                        y,\\n                        time + 1,\\n                        times,\\n                        lows,\\n                        grid,\\n                        articulationPoints,\\n                        color,\\n                        islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                if (prex != -1 && lows[nx][ny] >= time) {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        if (prex == -1 && children > 1) {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int m, n;\\n    int ts;\\n    vector<vector<int>> dfn, low;\\n    bool cut;\\n    int rx, ry;\\n\\n    void dfs(int x, int y, const vector<vector<int>> &grid) {\\n        const int dx[4] = {0, 1, 0, -1};\\n        const int dy[4] = {1, 0, -1 ,0};\\n\\n        dfn[x][y] = low[x][y] = ++ts;\\n        int branch = 0;\\n        for (int i = 0; i < 4; i++) {\\n            int tx = x + dx[i], ty = y + dy[i];\\n            if (tx < 0 || tx >= m || ty < 0 || ty >= n || grid[tx][ty] == 0)\\n                continue;\\n\\n            if (dfn[tx][ty] != 0) {\\n                low[x][y] = min(low[x][y], dfn[tx][ty]);\\n                continue;\\n            }\\n\\n            dfs(tx, ty, grid);\\n\\n            branch++;\\n            low[x][y] = min(low[x][y], low[tx][ty]);\\n\\n            if (low[tx][ty] >= dfn[x][y]) {\\n                if (branch >= 2 || !(x == rx && y == ry))\\n                    cut = true;\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dfn.resize(m, vector<int>(n, 0));\\n        low.resize(m, vector<int>(n, 0));\\n        ts = 0;\\n        cut = false;\\n\\n        bool first = false;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == 1 && dfn[i][j] == 0) {\\n                    if (first) return 0;\\n                    first = true;\\n                    rx = i; ry = j;\\n                    dfs(i, j, grid);\\n                }\\n\\n        if (!first) return 0;\\n        if (ts == 1 || cut) return 1;\\n        return 2;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n    private final int[][] dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m * n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if (!articulationPoints.isEmpty()) {\\n                        hasArticulationPoint = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (numOfIslands >= 2) {\\n            return 0;\\n        }\\n        if (numOfIslands == 0) {\\n            return 0;\\n        }\\n        if (numOfIslands == 1 && minIslandSize == 1) {\\n            return 1;\\n        }\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n\\n    private void tarjan(\\n            int x,\\n            int y,\\n            int prex,\\n            int prey,\\n            int time,\\n            int[][] times,\\n            int[][] lows,\\n            int[][] grid,\\n            List<Integer> articulationPoints,\\n            int color,\\n            int[] islandSize) {\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n                continue;\\n            }\\n            if (grid[nx][ny] == 1) {\\n                children++;\\n                tarjan(\\n                        nx,\\n                        ny,\\n                        x,\\n                        y,\\n                        time + 1,\\n                        times,\\n                        lows,\\n                        grid,\\n                        articulationPoints,\\n                        color,\\n                        islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                if (prex != -1 && lows[nx][ny] >= time) {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        if (prex == -1 && children > 1) {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005357,
                "title": "ruby-brute-force-2092-ms",
                "content": "# Intuition\\nAnswer is always in [0..2]. If we can\\'t disconnect the grid by removing only 1 island, then the answer will be 2.\\nSo we should remove every single island and see whether the grid is stayed connected.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    $$O(n^2)$$ (array `visited`)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```ruby\\nDIRECTIONS  = [[1, 0], [-1, 0], [0, 1], [0, -1]].each\\ndef min_days(grid)\\n    m, n = grid.size, grid[0].size\\n    maxi = m - 1\\n    maxj = n - 1\\n    islands = 0\\n    start = start2 = nil \\n    m.times do |i| # Let\\'s count the number of islands.\\n        n.times do |j|\\n            val = grid[i][j]\\n            if val == 1\\n                start2 ||= [i, j] if start\\n                start ||= [i, j]\\n                islands += 1\\n            end\\n        end\\n    end\\n    \\n    return islands if islands.between?(0,1)\\n\\n    connected = -> exclude do # It is true or false.\\n        queue = [exclude == start ? start2 : start]\\n        visited = Array.new(m) { Array.new(n) }\\n        if exclude\\n            exi, exj = exclude\\n            visited[exi][exj] = true\\n            counter = islands - 1\\n        else counter = islands\\n        end\\n\\n        until queue.empty?\\n            i, j = queue.shift\\n            next if visited[i][j]\\n            counter -= 1\\n            return true if counter.zero?\\n            visited[i][j] = true\\n            DIRECTIONS.each do |a, b|\\n                ii = i + a\\n                jj = j + b\\n                if ii.between?(0, maxi) && jj.between?(0, maxj) && grid[ii][jj] == 1 && !visited[ii][jj]\\n                    queue << [ii, jj]\\n                end\\n            end\\n        end\\n        false\\n    end\\n\\n    return 0 unless connected.(nil)\\n    return 2 if islands == 2\\n    return 1 if islands == 3\\n\\n    m.times do |i|\\n        n.times do |j|\\n            return 1 if grid[i][j] == 1 && !connected.([i, j])\\n        end\\n    end\\n    2\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_days < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_days([[1,1,1,1],[1,1,1,0],[1,1,0,1],[1,1,1,1],[1,1,0,0],[1,1,1,1]])\\n        assert_equal 1, min_days([[1,1,0,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,0,1,1]])\\n        assert_equal 2, min_days([[0,1,1,0],[0,1,1,0],[0,0,0,0]])\\n        assert_equal 2, min_days([[1,1]])\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nDIRECTIONS  = [[1, 0], [-1, 0], [0, 1], [0, -1]].each\\ndef min_days(grid)\\n    m, n = grid.size, grid[0].size\\n    maxi = m - 1\\n    maxj = n - 1\\n    islands = 0\\n    start = start2 = nil \\n    m.times do |i| # Let\\'s count the number of islands.\\n        n.times do |j|\\n            val = grid[i][j]\\n            if val == 1\\n                start2 ||= [i, j] if start\\n                start ||= [i, j]\\n                islands += 1\\n            end\\n        end\\n    end\\n    \\n    return islands if islands.between?(0,1)\\n\\n    connected = -> exclude do # It is true or false.\\n        queue = [exclude == start ? start2 : start]\\n        visited = Array.new(m) { Array.new(n) }\\n        if exclude\\n            exi, exj = exclude\\n            visited[exi][exj] = true\\n            counter = islands - 1\\n        else counter = islands\\n        end\\n\\n        until queue.empty?\\n            i, j = queue.shift\\n            next if visited[i][j]\\n            counter -= 1\\n            return true if counter.zero?\\n            visited[i][j] = true\\n            DIRECTIONS.each do |a, b|\\n                ii = i + a\\n                jj = j + b\\n                if ii.between?(0, maxi) && jj.between?(0, maxj) && grid[ii][jj] == 1 && !visited[ii][jj]\\n                    queue << [ii, jj]\\n                end\\n            end\\n        end\\n        false\\n    end\\n\\n    return 0 unless connected.(nil)\\n    return 2 if islands == 2\\n    return 1 if islands == 3\\n\\n    m.times do |i|\\n        n.times do |j|\\n            return 1 if grid[i][j] == 1 && !connected.([i, j])\\n        end\\n    end\\n    2\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_days < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_days([[1,1,1,1],[1,1,1,0],[1,1,0,1],[1,1,1,1],[1,1,0,0],[1,1,1,1]])\\n        assert_equal 1, min_days([[1,1,0,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,0,1,1]])\\n        assert_equal 2, min_days([[0,1,1,0],[0,1,1,0],[0,0,0,0]])\\n        assert_equal 2, min_days([[1,1]])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969006,
                "title": "c-articulation-points-50-lines-7ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[5] = {0,1,0,-1,0};\\n    int m, n;\\n    int t = 0;\\n    bool has_ap = false;\\n    int dis[900], low[900];\\n    int minDays(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      memset(dis, 0, sizeof(dis));\\n      memset(low, 0, sizeof(low));\\n      int c = 0, area = 0;\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          int u = i*n+j;\\n          if (grid[i][j]) {\\n            ++area;\\n            if (!dis[u]) {\\n              dfs(grid, u, -1);\\n              ++c;\\n            }\\n          }\\n        }\\n      }\\n      if (c > 1) { return 0; }\\n      else if (has_ap) { return 1; }\\n      else { return min(area, 2); }\\n    }\\n    void dfs(vector<vector<int>>& grid, int u, int p) {\\n      low[u] = dis[u] = ++t;\\n      int r = u/n, c = u%n;\\n      bool is_ap = false;\\n      int children = 0;\\n      for (int di = 0; di < 4; ++di) {\\n        int nr = r+dir[di], nc = c+dir[di+1];\\n        if (nr < 0 || nr >= m || nc < 0 || nc >= n || !grid[nr][nc]) {\\n          continue;\\n        }\\n        int v = nr*n+nc;\\n        if (v == p) { continue; }\\n        if (dis[v]) {\\n          low[u] = min(low[u], dis[v]);\\n        } else {\\n          dfs(grid, v, u);\\n          ++children;\\n          low[u] = min(low[u], low[v]);\\n          if (low[v] >= dis[u] && p != -1) {\\n            is_ap = true;\\n          }\\n        }\\n      }\\n      is_ap |= (p==-1)&&(children>1);\\n      has_ap |= is_ap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[5] = {0,1,0,-1,0};\\n    int m, n;\\n    int t = 0;\\n    bool has_ap = false;\\n    int dis[900], low[900];\\n    int minDays(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      memset(dis, 0, sizeof(dis));\\n      memset(low, 0, sizeof(low));\\n      int c = 0, area = 0;\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          int u = i*n+j;\\n          if (grid[i][j]) {\\n            ++area;\\n            if (!dis[u]) {\\n              dfs(grid, u, -1);\\n              ++c;\\n            }\\n          }\\n        }\\n      }\\n      if (c > 1) { return 0; }\\n      else if (has_ap) { return 1; }\\n      else { return min(area, 2); }\\n    }\\n    void dfs(vector<vector<int>>& grid, int u, int p) {\\n      low[u] = dis[u] = ++t;\\n      int r = u/n, c = u%n;\\n      bool is_ap = false;\\n      int children = 0;\\n      for (int di = 0; di < 4; ++di) {\\n        int nr = r+dir[di], nc = c+dir[di+1];\\n        if (nr < 0 || nr >= m || nc < 0 || nc >= n || !grid[nr][nc]) {\\n          continue;\\n        }\\n        int v = nr*n+nc;\\n        if (v == p) { continue; }\\n        if (dis[v]) {\\n          low[u] = min(low[u], dis[v]);\\n        } else {\\n          dfs(grid, v, u);\\n          ++children;\\n          low[u] = min(low[u], low[v]);\\n          if (low[v] >= dis[u] && p != -1) {\\n            is_ap = true;\\n          }\\n        }\\n      }\\n      is_ap |= (p==-1)&&(children>1);\\n      has_ap |= is_ap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952200,
                "title": "tarjan-s-algorithm-o-m-n-with-approach-and-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe DFS function uses Tarjan\\'s algorithm to identify the articulation points in the grid. It keeps track of the insertion time and lowest time of each cell, which are used to determine whether a cell is an articulation point. The insertion time of a cell is the time at which it is visited during the DFS, and the lowest time of a cell is the minimum of its insertion time and the insertion times of its neighbours that can be reached without going through the parent of the current cell.\\n\\nIf the lowest time of a neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent), it means that the neighbour can only be reached through the current cell, so if the current cell is removed, the neighbour becomes disconnected from the rest of the grid. Therefore, the current cell is an articulation point.\\n\\nIf the current cell has more than 1 child component and is the root (has no parent), it means that it has more than 1 neighbour that can be reached without going through the parent, so if the current cell is removed, more than 1 component becomes disconnected from the rest of the grid. Therefore, the current cell is also an articulation point.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform a depth-first search (DFS) on the grid to identify the articulation points. An articulation point is a cell that, when removed, disconnects the grid.\\n\\n\\n3. If the number of connected components in the grid is not 1, the grid is already disconnected, so return 0 days. Otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day. Otherwise, return 2 days.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // helper function to check if the given row and column indices are within the bounds of the grid\\n    bool isInBounds(int row, int col, int totalRows, int totalCols) {\\n        return row >= 0 && row < totalRows && col >= 0 && col < totalCols;\\n    }\\n\\n    // Depth-First Search function to identify the articulation points in the grid\\n    // An articulation point is a cell that, when removed, disconnects the grid\\n    void dfsArticulationPoint(int row, int col, int parentRow, int parentCol, vector<vector<int>>& insertionTime, vector<vector<int>>& lowestTime, bool& containsArticulationPoint, int& timer,\\n                                vector<vector<bool>>& visited, vector<vector<int>>& grid, vector<int>& dRow, vector<int>& dCol) {\\n        // mark the current cell as visited\\n        visited[row][col] = true;\\n\\n        // set the insertion time and lowest time of the current cell as the current timer value\\n        insertionTime[row][col] = lowestTime[row][col] = timer++;\\n        \\n        // variable to store the number of child components (connected 1s) of the current cell\\n        int childComponents = 0;\\n\\n        // iterate through the 4 directions (left, right, up, down) to visit the neighbours\\n        for(int direction = 0; direction < 4; direction++) {\\n            int neighbourRow = row + dRow[direction];\\n            int neighbourCol = col + dCol[direction];\\n\\n            // skip the parent cell, as it is not a neighbour\\n            if(neighbourRow == parentRow && neighbourCol == parentCol) continue;\\n\\n            // if the neighbour cell is within the bounds of the grid and is a land cell (has a value of 1)\\n            if(isInBounds(neighbourRow, neighbourCol, grid.size(), grid[0].size()) && grid[neighbourRow][neighbourCol] == 1) {\\n                \\n                // if the neighbour has not been visited yet\\n                if(!visited[neighbourRow][neighbourCol]) {\\n                    \\n                    // recursively call the DFS function on the neighbour\\n                    dfsArticulationPoint(neighbourRow, neighbourCol, row, col, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n\\n                    // update the lowest time of the current cell with the minimum of its current lowest time and the lowest time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], lowestTime[neighbourRow][neighbourCol]);\\n\\n                    // if the lowest time of the neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent)\\n                    if(lowestTime[neighbourRow][neighbourCol] >= insertionTime[row][col] && parentRow != -1 && parentCol != -1) {\\n                        \\n                        // mark that the grid contains an articulation point\\n                        containsArticulationPoint = true;\\n                    }\\n                    \\n                    // increment the number of child components of the current cell\\n                    childComponents++;\\n                } else {\\n                    // if the neighbour has already been visited, update the lowest time of the current cell \\n                    // with the minimum of its current lowest time and the insertion time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], insertionTime[neighbourRow][neighbourCol]);\\n                }\\n            }\\n        }\\n\\n        // if the current cell has more than 1 child component and is the root (has no parent), mark that the grid contains an articulation point\\n        if(childComponents > 1 && parentRow == -1 && parentCol == -1) {\\n            containsArticulationPoint = true;\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        // get the number of rows and columns in the grid\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // 2D vector to store the visited status of each cell\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // 2D vectors to store the insertion time and lowest time of each cell\\n        vector<vector<int>> insertionTime(rows, vector<int>(cols));\\n        vector<vector<int>> lowestTime(rows, vector<int>(cols));\\n        // variable to store whether the grid contains an articulation point\\n        bool containsArticulationPoint = false;\\n        // variable to store the timer value (incremented each time a cell is visited)\\n        int timer = 0;\\n\\n        // vectors to store the row and column offsets to visit the neighbours in the 4 directions (left, right, up, down)\\n        vector<int> dRow = {-1, 0, 1, 0};\\n        vector<int> dCol = {0, 1, 0, -1};\\n\\n        // variable to store the number of land cells (cells with a value of 1) in the grid\\n        int numberOfLandCells = 0;\\n        // variable to store the number of connected components (groups of connected 1s) in the grid\\n        int numberOfComponents = 0;\\n\\n        // iterate through the grid to identify the articulation points and count the number of land cells and connected components\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                // if the current cell is a land cell\\n                if(grid[row][col] == 1) {\\n                    // increment the number of land cells\\n                    numberOfLandCells++;\\n\\n                    // if the current cell has not been visited yet\\n                    if(!visited[row][col]) {\\n                        // perform DFS starting from the current cell to identify the articulation points and count the connected components\\n                        dfsArticulationPoint(row, col, -1, -1, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n                        \\n                        // increment the number of connected components\\n                        numberOfComponents++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // if the number of connected components is not 1, the grid is already disconnected, so return 0 days\\n        // otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day\\n        // otherwise, return 2 days\\n        return numberOfComponents != 1 ? 0 : containsArticulationPoint || numberOfLandCells == 1 ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // helper function to check if the given row and column indices are within the bounds of the grid\\n    bool isInBounds(int row, int col, int totalRows, int totalCols) {\\n        return row >= 0 && row < totalRows && col >= 0 && col < totalCols;\\n    }\\n\\n    // Depth-First Search function to identify the articulation points in the grid\\n    // An articulation point is a cell that, when removed, disconnects the grid\\n    void dfsArticulationPoint(int row, int col, int parentRow, int parentCol, vector<vector<int>>& insertionTime, vector<vector<int>>& lowestTime, bool& containsArticulationPoint, int& timer,\\n                                vector<vector<bool>>& visited, vector<vector<int>>& grid, vector<int>& dRow, vector<int>& dCol) {\\n        // mark the current cell as visited\\n        visited[row][col] = true;\\n\\n        // set the insertion time and lowest time of the current cell as the current timer value\\n        insertionTime[row][col] = lowestTime[row][col] = timer++;\\n        \\n        // variable to store the number of child components (connected 1s) of the current cell\\n        int childComponents = 0;\\n\\n        // iterate through the 4 directions (left, right, up, down) to visit the neighbours\\n        for(int direction = 0; direction < 4; direction++) {\\n            int neighbourRow = row + dRow[direction];\\n            int neighbourCol = col + dCol[direction];\\n\\n            // skip the parent cell, as it is not a neighbour\\n            if(neighbourRow == parentRow && neighbourCol == parentCol) continue;\\n\\n            // if the neighbour cell is within the bounds of the grid and is a land cell (has a value of 1)\\n            if(isInBounds(neighbourRow, neighbourCol, grid.size(), grid[0].size()) && grid[neighbourRow][neighbourCol] == 1) {\\n                \\n                // if the neighbour has not been visited yet\\n                if(!visited[neighbourRow][neighbourCol]) {\\n                    \\n                    // recursively call the DFS function on the neighbour\\n                    dfsArticulationPoint(neighbourRow, neighbourCol, row, col, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n\\n                    // update the lowest time of the current cell with the minimum of its current lowest time and the lowest time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], lowestTime[neighbourRow][neighbourCol]);\\n\\n                    // if the lowest time of the neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent)\\n                    if(lowestTime[neighbourRow][neighbourCol] >= insertionTime[row][col] && parentRow != -1 && parentCol != -1) {\\n                        \\n                        // mark that the grid contains an articulation point\\n                        containsArticulationPoint = true;\\n                    }\\n                    \\n                    // increment the number of child components of the current cell\\n                    childComponents++;\\n                } else {\\n                    // if the neighbour has already been visited, update the lowest time of the current cell \\n                    // with the minimum of its current lowest time and the insertion time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], insertionTime[neighbourRow][neighbourCol]);\\n                }\\n            }\\n        }\\n\\n        // if the current cell has more than 1 child component and is the root (has no parent), mark that the grid contains an articulation point\\n        if(childComponents > 1 && parentRow == -1 && parentCol == -1) {\\n            containsArticulationPoint = true;\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        // get the number of rows and columns in the grid\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // 2D vector to store the visited status of each cell\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // 2D vectors to store the insertion time and lowest time of each cell\\n        vector<vector<int>> insertionTime(rows, vector<int>(cols));\\n        vector<vector<int>> lowestTime(rows, vector<int>(cols));\\n        // variable to store whether the grid contains an articulation point\\n        bool containsArticulationPoint = false;\\n        // variable to store the timer value (incremented each time a cell is visited)\\n        int timer = 0;\\n\\n        // vectors to store the row and column offsets to visit the neighbours in the 4 directions (left, right, up, down)\\n        vector<int> dRow = {-1, 0, 1, 0};\\n        vector<int> dCol = {0, 1, 0, -1};\\n\\n        // variable to store the number of land cells (cells with a value of 1) in the grid\\n        int numberOfLandCells = 0;\\n        // variable to store the number of connected components (groups of connected 1s) in the grid\\n        int numberOfComponents = 0;\\n\\n        // iterate through the grid to identify the articulation points and count the number of land cells and connected components\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                // if the current cell is a land cell\\n                if(grid[row][col] == 1) {\\n                    // increment the number of land cells\\n                    numberOfLandCells++;\\n\\n                    // if the current cell has not been visited yet\\n                    if(!visited[row][col]) {\\n                        // perform DFS starting from the current cell to identify the articulation points and count the connected components\\n                        dfsArticulationPoint(row, col, -1, -1, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n                        \\n                        // increment the number of connected components\\n                        numberOfComponents++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // if the number of connected components is not 1, the grid is already disconnected, so return 0 days\\n        // otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day\\n        // otherwise, return 2 days\\n        return numberOfComponents != 1 ? 0 : containsArticulationPoint || numberOfLandCells == 1 ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945533,
                "title": "dfs-c-clean-simple-fast-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>dx={1,-1,0,0};\\n    vector<ll>dy={0,0,1,-1};\\n\\n    bool issafe(ll x,ll y,ll n,ll m){\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n\\n    void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,ll i,ll j,ll n,ll m,ll f1,ll f2){\\n        visited[i][j]=true;\\n        for(ll k=0;k<4;k++){\\n            ll x=i+dx[k],y=j+dy[k];\\n            if(issafe(x,y,n,m) && grid[x][y]==1 && visited[x][y]==false && !(x==f1 && y==f2)){\\n                dfs(grid,visited,x,y,n,m,f1,f2);\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool check(vector<vector<int>>&grid,ll n,ll m,ll f1,ll f2){\\n        ll count=0;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1 && visited[i][j]==false && !(i==f1 && j==f2)){\\n                    dfs(grid,visited,i,j,n,m,f1,f2);\\n                    count++;\\n                    if(count>1){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),count=0;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    count++;\\n                }\\n            }\\n        }\\n        if(count<=1){\\n            return count;\\n        }\\n        if(check(grid,n,m,-1,-1)){\\n            return 0;\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(check(grid,n,m,i,j)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>dx={1,-1,0,0};\\n    vector<ll>dy={0,0,1,-1};\\n\\n    bool issafe(ll x,ll y,ll n,ll m){\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n\\n    void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,ll i,ll j,ll n,ll m,ll f1,ll f2){\\n        visited[i][j]=true;\\n        for(ll k=0;k<4;k++){\\n            ll x=i+dx[k],y=j+dy[k];\\n            if(issafe(x,y,n,m) && grid[x][y]==1 && visited[x][y]==false && !(x==f1 && y==f2)){\\n                dfs(grid,visited,x,y,n,m,f1,f2);\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool check(vector<vector<int>>&grid,ll n,ll m,ll f1,ll f2){\\n        ll count=0;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1 && visited[i][j]==false && !(i==f1 && j==f2)){\\n                    dfs(grid,visited,i,j,n,m,f1,f2);\\n                    count++;\\n                    if(count>1){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),count=0;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    count++;\\n                }\\n            }\\n        }\\n        if(count<=1){\\n            return count;\\n        }\\n        if(check(grid,n,m,-1,-1)){\\n            return 0;\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(check(grid,n,m,i,j)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832669,
                "title": "c-dfs-strongly-connected-component-code-explained-with-comments",
                "content": "**calculate no of islands using simple dfs**\\n* if no of islands is 0. return 0.\\n*  if no of islands is greater then 1. then grid already is disconnected. return 0.\\n*  **no of islands is 1 then,**   \\n\\t*  1.  we will check if flipping a single 1 can make it disconnected, if yes return 1.\\n\\t*  2. if not then we are sure by flipping any 2 (diagonally oriented )  \\'1\\' we can disconnect the grid. return 2.\\n\\nthats it. Thanks.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs( vector<vector<int>> &grid, int i, int j ){\\n        \\n        if( min(i,j) < 0 || i == grid.size() || j == grid[0].size() || grid[i][j] != 1) return;\\n        \\n        grid[i][j] = 2;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n        dfs(grid, i, j+1);\\n    }\\n    \\n\\t\\t// calculate strongly connected components or no of islands\\n\\t\\t// note that i didnt pass grid by reference, I dont want the original grid to get modified.\\n    int calcSC( vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sc = 0;\\n        for( int i = 0; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    sc++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return sc;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if( calcSC(grid) != 1) return 0;\\n        \\n\\t\\t// check if by making 1 land cell into water, we get disconnected grid\\n        for( int i = 0 ; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if( calcSC(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```\\n\\nPlease upvote if you found this helpful.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs( vector<vector<int>> &grid, int i, int j ){\\n        \\n        if( min(i,j) < 0 || i == grid.size() || j == grid[0].size() || grid[i][j] != 1) return;\\n        \\n        grid[i][j] = 2;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n        dfs(grid, i, j+1);\\n    }\\n    \\n\\t\\t// calculate strongly connected components or no of islands\\n\\t\\t// note that i didnt pass grid by reference, I dont want the original grid to get modified.\\n    int calcSC( vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sc = 0;\\n        for( int i = 0; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    sc++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return sc;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if( calcSC(grid) != 1) return 0;\\n        \\n\\t\\t// check if by making 1 land cell into water, we get disconnected grid\\n        for( int i = 0 ; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if( calcSC(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795846,
                "title": "python-2-solution-articulation-points-check-and-pointwise-dfs",
                "content": "If the islands are already disconnect, we return 0. Otherwise, all we need is to check whether there is a point, delete it will form two components. Such points are called articulation points, can be solved in linear time O(V + E). As the size of the problem is small, we can also use DFS to check articulation points. Please refer to [https://cp-algorithms.com/graph/cutpoints.html]().\\n\\n1. Search articulation points, O(MN)\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        lands = dict()\\n        for x, y in product(range(len(grid)), range(len(grid[0]))):\\n            if grid[x][y]: lands[(x, y)] = len(lands)\\n        if len(lands) <= 1: return len(lands)\\n        n = len(lands)\\n        graph = [set() for _ in range(n)]\\n        for (x, y), i in lands.items():\\n            for nx, ny in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if (nx, ny) in lands:\\n                    graph[i].add(lands[(nx, ny)])\\n                    graph[lands[(nx, ny)]].add(i)\\n        timer = 0\\n        visited, tin, low = set(), [-1] * n, [-1] * n\\n        def check_cutpoint(v, p = -1):\\n            nonlocal timer\\n            visited.add(v)\\n            tin[v] = low[v] = timer\\n            timer += 1\\n            ret, children = False, 0\\n            for to in graph[v]:\\n                if to == p: continue\\n                if to in visited: low[v] = min(low[v], tin[to])\\n                else:\\n                    if check_cutpoint(to, v): ret = True\\n                    low[v] = min(low[v], low[to])\\n                    if low[to] >= tin[v] and p != -1: ret = True\\n                    children += 1\\n            return ret or p == -1 and children > 1\\n        cp = check_cutpoint(0)\\n        if len(visited) != n: return 0\\n        return 1 if cp else 2\\n```\\n2. Pointwise DFS check, O((NM) ^ 2)\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def connect(grid):\\n            visited, area = set(), 0\\n            def dfs(x, y):\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        dfs(nx, ny)\\n            for x, y in product(range(m), range(n)):\\n                if grid[x][y] and (x, y) not in visited:\\n                    if area: return False\\n                    area += 1\\n                    visited.add((x, y))\\n                    dfs(x, y)\\n            return area == 1\\n        if not connect(grid): return 0\\n        for x, y in product(range(m), range(n)):\\n                if grid[x][y]:\\n                    grid[x][y] = 0\\n                    if not connect(grid): return 1\\n                    grid[x][y] = 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        lands = dict()\\n        for x, y in product(range(len(grid)), range(len(grid[0]))):\\n            if grid[x][y]: lands[(x, y)] = len(lands)\\n        if len(lands) <= 1: return len(lands)\\n        n = len(lands)\\n        graph = [set() for _ in range(n)]\\n        for (x, y), i in lands.items():\\n            for nx, ny in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if (nx, ny) in lands:\\n                    graph[i].add(lands[(nx, ny)])\\n                    graph[lands[(nx, ny)]].add(i)\\n        timer = 0\\n        visited, tin, low = set(), [-1] * n, [-1] * n\\n        def check_cutpoint(v, p = -1):\\n            nonlocal timer\\n            visited.add(v)\\n            tin[v] = low[v] = timer\\n            timer += 1\\n            ret, children = False, 0\\n            for to in graph[v]:\\n                if to == p: continue\\n                if to in visited: low[v] = min(low[v], tin[to])\\n                else:\\n                    if check_cutpoint(to, v): ret = True\\n                    low[v] = min(low[v], low[to])\\n                    if low[to] >= tin[v] and p != -1: ret = True\\n                    children += 1\\n            return ret or p == -1 and children > 1\\n        cp = check_cutpoint(0)\\n        if len(visited) != n: return 0\\n        return 1 if cp else 2\\n```\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def connect(grid):\\n            visited, area = set(), 0\\n            def dfs(x, y):\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        dfs(nx, ny)\\n            for x, y in product(range(m), range(n)):\\n                if grid[x][y] and (x, y) not in visited:\\n                    if area: return False\\n                    area += 1\\n                    visited.add((x, y))\\n                    dfs(x, y)\\n            return area == 1\\n        if not connect(grid): return 0\\n        for x, y in product(range(m), range(n)):\\n                if grid[x][y]:\\n                    grid[x][y] = 0\\n                    if not connect(grid): return 1\\n                    grid[x][y] = 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760752,
                "title": "python-simple-dfs",
                "content": "\\n    def minDays(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        def function(grid):\\n            m, n = len(grid), len(grid[0])\\n            \\n            total, visited = 0, set()\\n            \\n            def dfs(i,j,visited):\\n                if 0 <= i < m and 0 <= j < n and grid[i][j] == 1 and (i,j) not in visited:\\n                    visited.add((i,j))\\n                    dfs(i-1,j,visited)\\n                    dfs(i+1,j,visited)\\n                    dfs(i,j-1,visited)\\n                    dfs(i,j+1,visited)\\n                    \\n                    \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1 and (i,j) not in visited:\\n                        total += 1\\n                        dfs(i,j,visited)\\n            \\n            return total\\n        \\n        if function(grid) != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    \\n                    if function(grid) != 1:\\n                        return 1\\n                    \\n                    grid[i][j] = 1\\n        \\n        return 2\\n            \\n",
                "solutionTags": [],
                "code": "\\n    def minDays(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        def function(grid):\\n            m, n = len(grid), len(grid[0])\\n            \\n            total, visited = 0, set()\\n            \\n            def dfs(i,j,visited):\\n                if 0 <= i < m and 0 <= j < n and grid[i][j] == 1 and (i,j) not in visited:\\n                    visited.add((i,j))\\n                    dfs(i-1,j,visited)\\n                    dfs(i+1,j,visited)\\n                    dfs(i,j-1,visited)\\n                    dfs(i,j+1,visited)\\n                    \\n                    \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1 and (i,j) not in visited:\\n                        total += 1\\n                        dfs(i,j,visited)\\n            \\n            return total\\n        \\n        if function(grid) != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    \\n                    if function(grid) != 1:\\n                        return 1\\n                    \\n                    grid[i][j] = 1\\n        \\n        return 2\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2701196,
                "title": "python-bfs-connected-components",
                "content": "```\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        dirr=[1,0,-1,0]\\n        dirc=[0,1,0,-1]\\n        visreq=set()\\n        cntone=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cntone+=1\\n                    \\n                    visreq.add((i,j))\\n                    \\n        if cntone==1:\\n            return 1\\n                \\n        def isvalid(i,j,m,n,visreq,gridma):\\n            if i<0 or i>m-1 or j<0 or j>n-1 or gridma[i][j]==0 :\\n                return False\\n            return True\\n        \\n        # vis=set()\\n        def bfs(source,vis,gridpa,visreqpa):\\n            q=deque()\\n            q.append(source)\\n            \\n            vis.add(source)\\n            \\n            while(q):\\n                # print(q,vis)\\n                x,y=q.popleft()\\n                \\n                # vis.add((x,y))\\n            \\n                for i in range(4):\\n                    adjx=dirr[i]+x\\n                    adjy=dirc[i]+y\\n                    \\n                    if (adjx,adjy) not in vis and isvalid(adjx,adjy,m,n,visreqpa,gridpa):\\n                        vis.add((adjx,adjy))\\n                        q.append((adjx,adjy))\\n                        \\n            return vis\\n        glovis=set()         \\n        cnt=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1 and (i,j) not in glovis:\\n                    glovis=glovis.union(bfs((i,j),set(),grid,visreq))\\n                    cnt+=1\\n                    # print(glovis,\\'ji\\')\\n                    if glovis==visreq:\\n                        break\\n                        \\n        # print(cnt)\\n                        \\n        if cnt!=1:\\n            return 0\\n        # glovis=set()\\n        # print(\\'pudhusu pa\\')\\n        for i in range(m):\\n            for j in range(n):\\n                # print(\"is it to\")\\n                if grid[i][j]==1:\\n\\n                    \\n                    \\n                    gridcopy=copy.deepcopy(grid)\\n                    gridcopy[i][j]=0\\n                    glovis=set()    \\n                    visreqpa=set()\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1:\\n                                \\n                                visreqpa.add((f,e))\\n                    \\n                    \\n                    cnt=0\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1 and (f,e) not in glovis:\\n                                glovis=glovis.union(bfs((f,e),set(),gridcopy,visreqpa))\\n                                \\n                                cnt+=1\\n                                # print(glovis,\\'ji\\')\\n                                if glovis==visreqpa and cnt!=1:\\n                                    return 1\\n                                \\n                                # if cnt>1:\\n                                #     break\\n                                    \\n        return 2\\n                    \\n#         bb,aa=None,None\\n#         for i,j in visreq:\\n#             if not bb:\\n#                 bb=i\\n#             elif bb!=i:\\n#                 return 2\\n#             if not aa:\\n#                 aa=j\\n#             elif aa!=j:\\n#                 return 2\\n            \\n#         return 1\\n                \\n                \\n            \\n            \\n                        \\n\\n                    \\n                    \\n                        \\n                        \\n\\n            \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        dirr=[1,0,-1,0]\\n        dirc=[0,1,0,-1]\\n        visreq=set()\\n        cntone=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cntone+=1\\n                    \\n                    visreq.add((i,j))\\n                    \\n        if cntone==1:\\n            return 1\\n                \\n        def isvalid(i,j,m,n,visreq,gridma):\\n            if i<0 or i>m-1 or j<0 or j>n-1 or gridma[i][j]==0 :\\n                return False\\n            return True\\n        \\n        # vis=set()\\n        def bfs(source,vis,gridpa,visreqpa):\\n            q=deque()\\n            q.append(source)\\n            \\n            vis.add(source)\\n            \\n            while(q):\\n                # print(q,vis)\\n                x,y=q.popleft()\\n                \\n                # vis.add((x,y))\\n            \\n                for i in range(4):\\n                    adjx=dirr[i]+x\\n                    adjy=dirc[i]+y\\n                    \\n                    if (adjx,adjy) not in vis and isvalid(adjx,adjy,m,n,visreqpa,gridpa):\\n                        vis.add((adjx,adjy))\\n                        q.append((adjx,adjy))\\n                        \\n            return vis\\n        glovis=set()         \\n        cnt=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1 and (i,j) not in glovis:\\n                    glovis=glovis.union(bfs((i,j),set(),grid,visreq))\\n                    cnt+=1\\n                    # print(glovis,\\'ji\\')\\n                    if glovis==visreq:\\n                        break\\n                        \\n        # print(cnt)\\n                        \\n        if cnt!=1:\\n            return 0\\n        # glovis=set()\\n        # print(\\'pudhusu pa\\')\\n        for i in range(m):\\n            for j in range(n):\\n                # print(\"is it to\")\\n                if grid[i][j]==1:\\n\\n                    \\n                    \\n                    gridcopy=copy.deepcopy(grid)\\n                    gridcopy[i][j]=0\\n                    glovis=set()    \\n                    visreqpa=set()\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1:\\n                                \\n                                visreqpa.add((f,e))\\n                    \\n                    \\n                    cnt=0\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1 and (f,e) not in glovis:\\n                                glovis=glovis.union(bfs((f,e),set(),gridcopy,visreqpa))\\n                                \\n                                cnt+=1\\n                                # print(glovis,\\'ji\\')\\n                                if glovis==visreqpa and cnt!=1:\\n                                    return 1\\n                                \\n                                # if cnt>1:\\n                                #     break\\n                                    \\n        return 2\\n                    \\n#         bb,aa=None,None\\n#         for i,j in visreq:\\n#             if not bb:\\n#                 bb=i\\n#             elif bb!=i:\\n#                 return 2\\n#             if not aa:\\n#                 aa=j\\n#             elif aa!=j:\\n#                 return 2\\n            \\n#         return 1\\n                \\n                \\n            \\n            \\n                        \\n\\n                    \\n                    \\n                        \\n                        \\n\\n            \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663376,
                "title": "python-articulation-point-dfs-73ms-faster-than-100-o-m-n",
                "content": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609590,
                "title": "c-o-mn-articulation-point",
                "content": "Beautiful Question , tried AP in 2d matrix .  Need to handle extra case when there is single 1. \\n\\nImplementation took quite efforts , if it helps do upvote ;)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    int count1 = 0;\\n    void dfs(int i,int j,pair<int,int>parent,int timer,vector<vector<int>>& grid,\\n             vector<vector<int>>&visited,vector<vector<int>>&tin,vector<vector<int>>&low)\\n    {\\n        int n = grid.size(),m=grid[0].size();\\n        visited[i][j] = 1;\\n        tin[i][j] = low[i][j] = timer++;\\n        count1++;\\n        //cout<<i<<\" \"<<j<<endl;\\n        vector<int>dx = {0,1,0,-1};\\n        vector<int>dy = {1,0,-1,0};\\n        int child = 0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            if(x<0 || y<0 || x>=n || y>=m || grid[x][y] == 0)\\n                    continue;\\n            \\n            else if((x == parent.first && y==parent.second))\\n                continue;\\n            \\n            else if(!visited[x][y])\\n            {\\n                dfs(x,y,{i,j},timer,grid,visited,tin,low);\\n                low[i][j] = min(low[x][y] , low[i][j]);\\n                if(low[x][y] >= tin[i][j] && (parent.first != -1 && parent.second != -1))\\n                {\\n                    v.push_back({i,j});\\n                    //cout<<i<<\" \"<<j;\\n                }\\n                child++;    \\n                \\n            }\\n            else if(visited[x][y])\\n                low[i][j] = min(tin[x][y] , low[i][j]);\\n            \\n            \\n        }\\n        if(parent.first == -1 && parent.second == -1 && child >= 2)\\n        {\\n             v.push_back({i,j});\\n             //cout<<i<<\" \"<<j;\\n        }\\n           \\n        \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        vector<vector<int>>tin(n,vector<int>(m,0));\\n        vector<vector<int>>low(n,vector<int>(m,0));\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j] == 1 && !visited[i][j])\\n                {\\n                    dfs(i,j,{-1,-1},1,grid,visited,tin,low);\\n                    count++;\\n                    if(count >= 2)\\n                        return 0;\\n                }\\n            }\\n        }\\n        if(count == 0) \\n            return 0;\\n        \\n        if(count1 == 1 || (count == 1 && v.size() > 0 ) )\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    int count1 = 0;\\n    void dfs(int i,int j,pair<int,int>parent,int timer,vector<vector<int>>& grid,\\n             vector<vector<int>>&visited,vector<vector<int>>&tin,vector<vector<int>>&low)\\n    {\\n        int n = grid.size(),m=grid[0].size();\\n        visited[i][j] = 1;\\n        tin[i][j] = low[i][j] = timer++;\\n        count1++;\\n        //cout<<i<<\" \"<<j<<endl;\\n        vector<int>dx = {0,1,0,-1};\\n        vector<int>dy = {1,0,-1,0};\\n        int child = 0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            if(x<0 || y<0 || x>=n || y>=m || grid[x][y] == 0)\\n                    continue;\\n            \\n            else if((x == parent.first && y==parent.second))\\n                continue;\\n            \\n            else if(!visited[x][y])\\n            {\\n                dfs(x,y,{i,j},timer,grid,visited,tin,low);\\n                low[i][j] = min(low[x][y] , low[i][j]);\\n                if(low[x][y] >= tin[i][j] && (parent.first != -1 && parent.second != -1))\\n                {\\n                    v.push_back({i,j});\\n                    //cout<<i<<\" \"<<j;\\n                }\\n                child++;    \\n                \\n            }\\n            else if(visited[x][y])\\n                low[i][j] = min(tin[x][y] , low[i][j]);\\n            \\n            \\n        }\\n        if(parent.first == -1 && parent.second == -1 && child >= 2)\\n        {\\n             v.push_back({i,j});\\n             //cout<<i<<\" \"<<j;\\n        }\\n           \\n        \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        vector<vector<int>>tin(n,vector<int>(m,0));\\n        vector<vector<int>>low(n,vector<int>(m,0));\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j] == 1 && !visited[i][j])\\n                {\\n                    dfs(i,j,{-1,-1},1,grid,visited,tin,low);\\n                    count++;\\n                    if(count >= 2)\\n                        return 0;\\n                }\\n            }\\n        }\\n        if(count == 0) \\n            return 0;\\n        \\n        if(count1 == 1 || (count == 1 && v.size() > 0 ) )\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2522493,
                "title": "c-bfs-code-with-explanation",
                "content": "Initially, the idea is to check the number of disconnected islands. If the count of such islands is NOT 1, then there would be no need to convert a land cell into a water cell to further disconnect the islands. In such cases, we return 0.\\n\\nNow, if there happens to be exactly 1 island in the grid, we convert each land cell into a water cell and check if the main island can be disintegrated into two or more smaller islands. If it is possible, by breaking any such land cell, we return 1.\\n\\nIn all the other cases, it would require (at max) 2 land cells (to be converted to water cells) to break up the main island. In this case, we return 2 :)\\n\\nProof of the last statement: A single disconnected land cell is also an island. Keeping this in mind, in order to break up an island into two (or more islands), we can make a corner land cell disconnected by converting two adjoining land cells into water cells.\\n\\n\\n**C++ Code:**\\n\\n\\n```\\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n    \\n    bool check(vector < vector <int> > &grid, int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1);\\n    }\\n    \\n    int solve(vector < vector <int> > &grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector < vector <bool> > vis(m, vector <bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] && !vis[i][j]) {\\n                    ans++;\\n                    queue < pair <int, int> > q;\\n                    q.push({i, j});\\n                    vis[i][j] = true;\\n                    \\n                    while(!q.empty()) {\\n                        auto [ux, uy] = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            if(check(grid, ux + dx[k], uy + dy[k], m, n) && !vis[ux + dx[k]][uy + dy[k]]) {\\n                                q.push({ux + dx[k], uy + dy[k]});\\n                                vis[ux + dx[k]][uy + dy[k]] = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int ans = solve(grid), m = grid.size(), n = grid[0].size();\\n        if(ans != 1)\\n            return 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    int val = solve(grid);\\n                    grid[i][j] = 1;\\n                    \\n                    if(val != 1)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;     \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n    \\n    bool check(vector < vector <int> > &grid, int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1);\\n    }\\n    \\n    int solve(vector < vector <int> > &grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector < vector <bool> > vis(m, vector <bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] && !vis[i][j]) {\\n                    ans++;\\n                    queue < pair <int, int> > q;\\n                    q.push({i, j});\\n                    vis[i][j] = true;\\n                    \\n                    while(!q.empty()) {\\n                        auto [ux, uy] = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            if(check(grid, ux + dx[k], uy + dy[k], m, n) && !vis[ux + dx[k]][uy + dy[k]]) {\\n                                q.push({ux + dx[k], uy + dy[k]});\\n                                vis[ux + dx[k]][uy + dy[k]] = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int ans = solve(grid), m = grid.size(), n = grid[0].size();\\n        if(ans != 1)\\n            return 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    int val = solve(grid);\\n                    grid[i][j] = 1;\\n                    \\n                    if(val != 1)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518126,
                "title": "python-solution-using-tarjan-s-algorithm-with-explanation",
                "content": "the problem asks how many days to split one island into two, one day can turn one land into water, if there have two or more islands on the grid, return ```0``` day\\nthere are have two cornor cases, disconnected means there are two island on the grid at least or are not any island on the grid, so the solution of  ```[[1,1]]``` and ```[[1]]``` is to turn all the land into water.\\n\\nthe basic idea is to calculate how many islands on the grid first, then build undirected graph, and use Tarjan\\'s algo to detect whether the graph has critical edge or not, if have, return ```1```, if not return ```2``` to split the corner of the island\\n\\ntc of tarjan is ```O(V+E)```, ```E = 4V```, is ```O(5V)```, the upper bound of ```V``` is ```O(len(grid) * len(grid[0]))```, so tc actually is ```O(len(grid) * len(grid[0]))```, its sc is the same as tc\\n\\nbased on [200. Number of Islands solution](https://leetcode.com/problems/number-of-islands/discuss/2504106/python-dfsbfs-and-dsu-solution-with-explanation)\\ntc of finding number of island is ```O(len(grid) * len(grid[0]))```, its sc is the same as tc.\\nso total tc is ```O(len(grid) * len(grid[0]))```, total sc is the same as tc\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        numRow, numCol = len(grid), len(grid[0])\\n\\n        def numberOfIsland():\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            visited, ans, count = [[False]*numCol for _ in range(numRow)], 0, 0\\n            def dfs(i, j):\\n                nonlocal count\\n                visited[i][j] = True\\n                count += 1\\n                for dx, dy in directions:\\n                    nx, ny = i+dx, j+dy\\n                    if nx<0 or ny<0 or nx>=numRow or ny>=numCol or visited[nx][ny] or grid[nx][ny]==0: continue\\n                    dfs(nx, ny)\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1 and visited[i][j] == False:\\n                        dfs(i, j)\\n                        ans += 1\\n            return ans, count\\n\\n        num, countOf1 = numberOfIsland()\\n        if num != 1: return 0\\n        elif countOf1 == 1: return 1 #  num == 1\\n        elif countOf1 == 2: return 2 #  num == 1\\n\\n        # build undirected graph\\n        def buildGraph():\\n            graph = {}\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1:\\n                        cur = i*numCol+j\\n                        graph[cur] = []\\n                        for dx, dy in directions:\\n                            nx, ny = i+dx, j+dy\\n                            if nx<0 or ny<0 or nx>=numRow or ny>=numCol or grid[nx][ny]==0: continue\\n                            neighbor = nx*numCol+ny\\n                            graph[cur].append(neighbor)\\n            return graph\\n\\n        graph = buildGraph()\\n        def Tarjan(graph, root):\\n            # the graph has not isolated nodes or node groups\\n            hasCriticalEdge = False\\n            def dfs(previous, current, time, timeMap, visited):\\n                nonlocal hasCriticalEdge\\n                visited.add(current)\\n                timeMap[current] = time\\n                for nei in graph[current]:\\n                    if nei == previous: continue\\n                    if nei not in visited: dfs(current, nei, time+1, timeMap, visited)\\n                    if time < timeMap[nei]: hasCriticalEdge = True\\n                    timeMap[current] = min(timeMap[nei], timeMap[current])\\n            \\n            dfs(-1, root, 1, {}, set())\\n            return hasCriticalEdge\\n        hasCriticalEdge = Tarjan(graph, list(graph.keys())[0])\\n\\n        return 1 if hasCriticalEdge else 2\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```0```\n```[[1,1]]```\n```[[1]]```\n```1```\n```2```\n```O(V+E)```\n```E = 4V```\n```O(5V)```\n```V```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        numRow, numCol = len(grid), len(grid[0])\\n\\n        def numberOfIsland():\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            visited, ans, count = [[False]*numCol for _ in range(numRow)], 0, 0\\n            def dfs(i, j):\\n                nonlocal count\\n                visited[i][j] = True\\n                count += 1\\n                for dx, dy in directions:\\n                    nx, ny = i+dx, j+dy\\n                    if nx<0 or ny<0 or nx>=numRow or ny>=numCol or visited[nx][ny] or grid[nx][ny]==0: continue\\n                    dfs(nx, ny)\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1 and visited[i][j] == False:\\n                        dfs(i, j)\\n                        ans += 1\\n            return ans, count\\n\\n        num, countOf1 = numberOfIsland()\\n        if num != 1: return 0\\n        elif countOf1 == 1: return 1 #  num == 1\\n        elif countOf1 == 2: return 2 #  num == 1\\n\\n        # build undirected graph\\n        def buildGraph():\\n            graph = {}\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1:\\n                        cur = i*numCol+j\\n                        graph[cur] = []\\n                        for dx, dy in directions:\\n                            nx, ny = i+dx, j+dy\\n                            if nx<0 or ny<0 or nx>=numRow or ny>=numCol or grid[nx][ny]==0: continue\\n                            neighbor = nx*numCol+ny\\n                            graph[cur].append(neighbor)\\n            return graph\\n\\n        graph = buildGraph()\\n        def Tarjan(graph, root):\\n            # the graph has not isolated nodes or node groups\\n            hasCriticalEdge = False\\n            def dfs(previous, current, time, timeMap, visited):\\n                nonlocal hasCriticalEdge\\n                visited.add(current)\\n                timeMap[current] = time\\n                for nei in graph[current]:\\n                    if nei == previous: continue\\n                    if nei not in visited: dfs(current, nei, time+1, timeMap, visited)\\n                    if time < timeMap[nei]: hasCriticalEdge = True\\n                    timeMap[current] = min(timeMap[nei], timeMap[current])\\n            \\n            dfs(-1, root, 1, {}, set())\\n            return hasCriticalEdge\\n        hasCriticalEdge = Tarjan(graph, list(graph.keys())[0])\\n\\n        return 1 if hasCriticalEdge else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461127,
                "title": "javascript-dfs-count-the-islands",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    let cnt = numIslands(grid);\\n    console.log(cnt);\\n    if(cnt === 0 || cnt > 1) { // all water or multi-islands\\n        return 0;\\n    }\\n    // check if need to return 1\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let islands = 0;\\n    for(let i = 0; i<m; i++)\\n        for(let j = 0; j<n; j++){\\n            if(grid[i][j] === 1) {\\n                grid[i][j] = 0;\\n                count = numIslands(grid);\\n                console.log(\"count =\", count);\\n                if(count > 1 || count ===0) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n    return 2;\\n};\\n\\nfunction numIslands(grid) {\\n    const dir = [[1,0], [0,1],[0,-1], [-1,0]];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Array(m).fill(0).map(el=>new Array(n).fill(false));\\n    let islands = 0;\\n    for(let i = 0; i<m; i++){\\n        for(let j = 0; j<n; j++) {\\n            if(grid[i][j] === 1 && !visited[i][j]){\\n                islands++;\\n                dfs(grid, i, j);\\n            }\\n        }\\n    }\\n    function dfs(arr, x, y) {\\n        visited[x][y] = true;\\n        for(const d of dir) {\\n            const xx = x + d[0];\\n            const yy = y + d[1];\\n            if(xx<0 || xx>=m || yy<0 || yy>=n || grid[xx][yy] !== 1 || visited[xx][yy]) {\\n              continue;\\n            }\\n            dfs(arr, xx ,yy);\\n        }\\n    }\\n    return islands;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    let cnt = numIslands(grid);\\n    console.log(cnt);\\n    if(cnt === 0 || cnt > 1) { // all water or multi-islands\\n        return 0;\\n    }\\n    // check if need to return 1\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let islands = 0;\\n    for(let i = 0; i<m; i++)\\n        for(let j = 0; j<n; j++){\\n            if(grid[i][j] === 1) {\\n                grid[i][j] = 0;\\n                count = numIslands(grid);\\n                console.log(\"count =\", count);\\n                if(count > 1 || count ===0) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n    return 2;\\n};\\n\\nfunction numIslands(grid) {\\n    const dir = [[1,0], [0,1],[0,-1], [-1,0]];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Array(m).fill(0).map(el=>new Array(n).fill(false));\\n    let islands = 0;\\n    for(let i = 0; i<m; i++){\\n        for(let j = 0; j<n; j++) {\\n            if(grid[i][j] === 1 && !visited[i][j]){\\n                islands++;\\n                dfs(grid, i, j);\\n            }\\n        }\\n    }\\n    function dfs(arr, x, y) {\\n        visited[x][y] = true;\\n        for(const d of dir) {\\n            const xx = x + d[0];\\n            const yy = y + d[1];\\n            if(xx<0 || xx>=m || yy<0 || yy>=n || grid[xx][yy] !== 1 || visited[xx][yy]) {\\n              continue;\\n            }\\n            dfs(arr, xx ,yy);\\n        }\\n    }\\n    return islands;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2427209,
                "title": "articulation-point",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>adj[n*m];\\n        int dif[]={0,1,0,-1,0};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int r=i+dif[k],c=j+dif[k+1];\\n                        if(r>=0 && r<n && c>=0 && c<m && grid[r][c]){\\n                            adj[i*m+j].push_back(r*m+c);\\n                            adj[r*m+c].push_back(i*m+j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    vector<int> tin(n*m, -1);\\n\\tvector<int> low(n*m, -1); \\n\\tvector<int> vis(n*m, 0);\\n\\tvector<int> isArticulation(n*m, 0); \\n\\tint timer = 0; \\n        int land=0;\\n        int bodies=0;\\n\\tfor(int i = 0;i<n;i++) {\\n        for(int j=0;j<m;j++){\\n\\t    if(grid[i][j]) {\\n            land++;\\n            if(!vis[i*m+j]){\\n                bodies++;\\n                dfs(i*m+j, -1, vis, tin, low, timer, adj, isArticulation); \\n            }\\n\\t       \\n\\t    }\\n        }\\n\\t}\\n        cout<<land<<endl;\\n\\tif(bodies==0 || bodies>1) return 0;\\n        int art=0;\\n\\tfor(int i = 0;i<n*m;i++) {\\n\\t    if(isArticulation[i] == 1) art++;\\n\\t}\\n    if(art || land==1) return 1;\\n    \\n        return 2;\\n        \\n    }\\n    void dfs(int node, int parent, vector<int> &vis, vector<int> &tin, vector<int> &low, int &timer, vector<int> adj[], vector<int> &isArticulation) {\\n    vis[node] = 1; \\n    tin[node] = low[node] = timer++;\\n    int child = 0; \\n    for(auto it: adj[node]) {\\n        if(it == parent) continue;\\n        \\n        if(!vis[it]) {\\n            dfs(it, node, vis, tin, low, timer, adj, isArticulation); \\n            low[node] = min(low[node], low[it]); \\n\\t    child++; \\n            if(low[it] >= tin[node] && parent != -1) {\\n                isArticulation[node] = 1; \\n            }\\n        } else {\\n            low[node] = min(low[node], tin[it]); \\n        }\\n    }\\n    \\n    if(parent == -1 && child > 1) {\\n        isArticulation[node] = 1; \\n    }\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>adj[n*m];\\n        int dif[]={0,1,0,-1,0};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int r=i+dif[k],c=j+dif[k+1];\\n                        if(r>=0 && r<n && c>=0 && c<m && grid[r][c]){\\n                            adj[i*m+j].push_back(r*m+c);\\n                            adj[r*m+c].push_back(i*m+j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    vector<int> tin(n*m, -1);\\n\\tvector<int> low(n*m, -1); \\n\\tvector<int> vis(n*m, 0);\\n\\tvector<int> isArticulation(n*m, 0); \\n\\tint timer = 0; \\n        int land=0;\\n        int bodies=0;\\n\\tfor(int i = 0;i<n;i++) {\\n        for(int j=0;j<m;j++){\\n\\t    if(grid[i][j]) {\\n            land++;\\n            if(!vis[i*m+j]){\\n                bodies++;\\n                dfs(i*m+j, -1, vis, tin, low, timer, adj, isArticulation); \\n            }\\n\\t       \\n\\t    }\\n        }\\n\\t}\\n        cout<<land<<endl;\\n\\tif(bodies==0 || bodies>1) return 0;\\n        int art=0;\\n\\tfor(int i = 0;i<n*m;i++) {\\n\\t    if(isArticulation[i] == 1) art++;\\n\\t}\\n    if(art || land==1) return 1;\\n    \\n        return 2;\\n        \\n    }\\n    void dfs(int node, int parent, vector<int> &vis, vector<int> &tin, vector<int> &low, int &timer, vector<int> adj[], vector<int> &isArticulation) {\\n    vis[node] = 1; \\n    tin[node] = low[node] = timer++;\\n    int child = 0; \\n    for(auto it: adj[node]) {\\n        if(it == parent) continue;\\n        \\n        if(!vis[it]) {\\n            dfs(it, node, vis, tin, low, timer, adj, isArticulation); \\n            low[node] = min(low[node], low[it]); \\n\\t    child++; \\n            if(low[it] >= tin[node] && parent != -1) {\\n                isArticulation[node] = 1; \\n            }\\n        } else {\\n            low[node] = min(low[node], tin[it]); \\n        }\\n    }\\n    \\n    if(parent == -1 && child > 1) {\\n        isArticulation[node] = 1; \\n    }\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2386377,
                "title": "c-solution-using-brute-force-and-dfs",
                "content": "In this solution, I first created a graph with vertices as those cells having 1 and edges are such that two vertices have an edge between them iff their corresponding cells are neighbours horizontally or vertically.\\n\\nFirst, I performed a DFS to check if graph is already disconnected. If it is, ```return 0;```. If not, I checked whether removing any one vertex disconnects the graph. This is done by actually removing every vertex and checking if graph gets disconnected. If it does, ```return 1;```. If not, ```return 2``` as we can make the graph disconnected by removing at most 2 vertices.\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& visited, int m, int n, vector<int> start){\\n        int i = start[0];\\n        int j = start[1];\\n        visited[i][j] = 1;\\n        if (i != 0){\\n            if (visited[i - 1][j] == 0){\\n                vector<int> next = {i - 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (i != m - 1){\\n            if (visited[i + 1][j] == 0){\\n                vector<int> next = {i + 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != 0){\\n            if (visited[i][j - 1] == 0){\\n                vector<int> next = {i, j - 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != n - 1){\\n            if (visited[i][j + 1] == 0){\\n                vector<int> next = {i, j + 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        vector<vector<int>> visited;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++){\\n            vector<int> row;\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1) row.push_back(0);\\n                else row.push_back(-1);\\n            }\\n            visited.push_back(row);\\n        }\\n        vector<int> start;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    start.push_back(i);\\n                    start.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if (start.size() == 0) return 0;\\n        dfs(visited, m, n, start);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (visited[i][j] == 0) return 0;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (grid[k][l] == 1){\\n                            if (k == i && l == j) visited[k][l] = -1;\\n                            else visited[k][l] = 0;\\n                        }\\n                        else visited[k][l] = -1;\\n                    }\\n                }\\n                vector<int> start1;\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (visited[k][l] == 0){\\n                            start1.push_back(k);\\n                            start1.push_back(l);\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (start1.size() == 0) return 1;\\n                dfs(visited, m, n, start1);\\n                for (int i = 0; i < m; i++){\\n                    for (int j = 0; j < n; j++){\\n                        if (visited[i][j] == 0) return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```return 0;```\n```return 1;```\n```return 2```\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& visited, int m, int n, vector<int> start){\\n        int i = start[0];\\n        int j = start[1];\\n        visited[i][j] = 1;\\n        if (i != 0){\\n            if (visited[i - 1][j] == 0){\\n                vector<int> next = {i - 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (i != m - 1){\\n            if (visited[i + 1][j] == 0){\\n                vector<int> next = {i + 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != 0){\\n            if (visited[i][j - 1] == 0){\\n                vector<int> next = {i, j - 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != n - 1){\\n            if (visited[i][j + 1] == 0){\\n                vector<int> next = {i, j + 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        vector<vector<int>> visited;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++){\\n            vector<int> row;\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1) row.push_back(0);\\n                else row.push_back(-1);\\n            }\\n            visited.push_back(row);\\n        }\\n        vector<int> start;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    start.push_back(i);\\n                    start.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if (start.size() == 0) return 0;\\n        dfs(visited, m, n, start);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (visited[i][j] == 0) return 0;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (grid[k][l] == 1){\\n                            if (k == i && l == j) visited[k][l] = -1;\\n                            else visited[k][l] = 0;\\n                        }\\n                        else visited[k][l] = -1;\\n                    }\\n                }\\n                vector<int> start1;\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (visited[k][l] == 0){\\n                            start1.push_back(k);\\n                            start1.push_back(l);\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (start1.size() == 0) return 1;\\n                dfs(visited, m, n, start1);\\n                for (int i = 0; i < m; i++){\\n                    for (int j = 0; j < n; j++){\\n                        if (visited[i][j] == 0) return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357360,
                "title": "c-articulation-point",
                "content": "public class Solution {\\n    int m,n;\\n    bool[,] visited;\\n    int[,] id;\\n    int[,] low;\\n    int[][] grid;\\n    int numOfOutEdge=0;\\n    bool[,] art;\\n    int numOfComponents=0;\\n    (int di,int dj)[] dir=new (int di,int dj)[4]{(1,0),(-1,0),(0,1),(0,-1)};\\n    int idc=0;\\n    int artcount=0;\\n    public int MinDays(int[][] grid) {\\n        m=grid.Length;\\n        n=grid[0].Length;\\n        visited=new bool[m,n];\\n        low=new int[m,n];\\n        id=new int[m,n];\\n        art=new bool[m,n];\\n        this.grid=grid;\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                numOfOutEdge=0;\\n                if(!visited[i,j] &&  grid[i][j]==1){\\n\\n                    dfs((i,j),(i,j),(-1,-1) );\\n                    if(art[i,j] && numOfOutEdge<=1){\\n                        artcount--;\\n                        art[i,j]=false;\\n                    }\\n                    numOfComponents++;\\n                }\\n                if(numOfComponents>1)\\n                    return 0;\\n                \\n\\n            }\\n            if(artcount>0)\\n                    return 1;\\n                else \\n                    return Math.Min(2,idc);\\n        \\n\\n    }\\n    \\n    public void dfs((int i,int j) root, (int i,int j) at,(int i,int j) parent)\\n    {\\n        \\n        if((root.i==parent.i ) && (root.j==parent.j))\\n            numOfOutEdge++;\\n        idc++;\\n        id[at.i,at.j]=low[at.i,at.j]=idc;\\n        visited[at.i,at.j]=true;\\n        \\n        for(int d=0;d<4;d++)\\n        {\\n            (int i,int j) next=(at.i+dir[d].di,at.j+dir[d].dj);\\n            if(!isValidNode(next) || (next.i==parent.i && next.j==parent.j) || grid[next.i][next.j]!=1)\\n                continue;\\n\\n            if(visited[next.i,next.j]){\\n                low[at.i,at.j]=Math.Min(low[at.i,at.j],id[next.i,next.j]);\\n\\n            }\\n            else\\n            {\\n                dfs(root,next,at);\\n                low[at.i,at.j]=Math.Min(low[at.i,at.j],low[next.i,next.j]);\\n                if(low[next.i,next.j]>=id[at.i,at.j]){\\n                    art[at.i,at.j]=true;\\n                    artcount++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isValidNode((int i,int j) node)\\n    {\\n        if(node.i>=m || node.i<0 || node.j>=n || node.j<0)\\n            return false;\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int m,n;\\n    bool[,] visited;\\n    int[,] id;\\n    int[,] low;\\n    int[][] grid;\\n    int numOfOutEdge=0;\\n    bool[,] art;\\n    int numOfComponents=0;\\n    (int di,int dj)[] dir=new (int di,int dj)[4]{(1,0),(-1,0),(0,1),(0,-1)}",
                "codeTag": "Java"
            },
            {
                "id": 2349070,
                "title": "92-76-fast-easy-to-understand-c-solution-using-articulation-points-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> steps = {{-1,0}, {1,0}, {0,-1}, {0,1}}; \\n    \\n    bool check(int r, int c, int n, int m)\\n    {\\n        return (r>=0 && r<n && c>=0 && c<m);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int r, int c, vector<vector<bool>>& vis, vector<vector<int>>& disc, vector<vector<int>>& low, int &isAp, int &timer, vector<vector<pair<int, int>>>& parent, int parR, int parC, int n, int m)\\n    {\\n        vis[r][c] = true;\\n        disc[r][c] = low[r][c] = ++timer;\\n        parent[r][c] = {parR, parC};\\n        int child = 0;\\n        \\n        for(auto x: steps)\\n        {\\n            int a = r + x.first;\\n            int b = c + x.second;\\n            \\n            if(check(a, b, n, m) && grid[a][b] == 1)\\n            {\\n                if(!vis[a][b])\\n                {\\n                    child++;\\n            \\n                    dfs(grid, a, b, vis, disc, low, isAp, timer, parent, r, c, n, m);\\n                    low[r][c] = min(low[r][c], low[a][b]);\\n                    \\n                    if((parent[r][c].first !=-1 && parent[r][c].second !=-1) && low[a][b] >= disc[r][c])\\n                        isAp = 1;\\n                }\\n                \\n                else if(a != parent[r][c].first || b != parent[r][c].second)\\n                {\\n                    low[r][c] = min(low[r][c], disc[a][b]);\\n                }\\n            }\\n        }\\n        \\n        if(child > 1 && parent[r][c].first == -1 && parent[r][c].second == -1)\\n            isAp = 1;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j])\\n                    sum++;\\n            }\\n        \\n        if(sum == 1)\\n            return 1;\\n        if(sum == 0)\\n            return 0;\\n        if(sum == m*n)\\n            return 2;\\n        \\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        \\n        vector<vector<pair<int, int>>> parent(n, vector<pair<int,int>>(m));\\n        \\n        int timer = 0;\\n        int isAp = 0;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==1 && !vis[i][j])\\n                {\\n                    count++;\\n                    if(count>1)\\n                        return 0;\\n                    \\n                    dfs(grid, i, j, vis, disc, low, isAp, timer, parent, -1, -1, n, m);\\n                }\\n            }\\n        \\n        if(isAp == 1)\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> steps = {{-1,0}, {1,0}, {0,-1}, {0,1}}; \\n    \\n    bool check(int r, int c, int n, int m)\\n    {\\n        return (r>=0 && r<n && c>=0 && c<m);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int r, int c, vector<vector<bool>>& vis, vector<vector<int>>& disc, vector<vector<int>>& low, int &isAp, int &timer, vector<vector<pair<int, int>>>& parent, int parR, int parC, int n, int m)\\n    {\\n        vis[r][c] = true;\\n        disc[r][c] = low[r][c] = ++timer;\\n        parent[r][c] = {parR, parC};\\n        int child = 0;\\n        \\n        for(auto x: steps)\\n        {\\n            int a = r + x.first;\\n            int b = c + x.second;\\n            \\n            if(check(a, b, n, m) && grid[a][b] == 1)\\n            {\\n                if(!vis[a][b])\\n                {\\n                    child++;\\n            \\n                    dfs(grid, a, b, vis, disc, low, isAp, timer, parent, r, c, n, m);\\n                    low[r][c] = min(low[r][c], low[a][b]);\\n                    \\n                    if((parent[r][c].first !=-1 && parent[r][c].second !=-1) && low[a][b] >= disc[r][c])\\n                        isAp = 1;\\n                }\\n                \\n                else if(a != parent[r][c].first || b != parent[r][c].second)\\n                {\\n                    low[r][c] = min(low[r][c], disc[a][b]);\\n                }\\n            }\\n        }\\n        \\n        if(child > 1 && parent[r][c].first == -1 && parent[r][c].second == -1)\\n            isAp = 1;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j])\\n                    sum++;\\n            }\\n        \\n        if(sum == 1)\\n            return 1;\\n        if(sum == 0)\\n            return 0;\\n        if(sum == m*n)\\n            return 2;\\n        \\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        \\n        vector<vector<pair<int, int>>> parent(n, vector<pair<int,int>>(m));\\n        \\n        int timer = 0;\\n        int isAp = 0;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==1 && !vis[i][j])\\n                {\\n                    count++;\\n                    if(count>1)\\n                        return 0;\\n                    \\n                    dfs(grid, i, j, vis, disc, low, isAp, timer, parent, -1, -1, n, m);\\n                }\\n            }\\n        \\n        if(isAp == 1)\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339859,
                "title": "javascript-flood-fill-algorithm",
                "content": "```\\nvar minDays = function(grid) {\\n    let c=copy2Darray(grid);\\n    //console.log(c)\\n    let tmp=bfs(c);\\n    //console.log(\\'xxxx\\', tmp)\\n    if(tmp>1 || tmp==0){//\\u984C\\u610F\\u5DF2\\u7D93\\u662F\\u5206\\u96E2\\u7684\\u5CF6\\u4E86   \\n        return 0;\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j]==1){\\n                grid[i][j]=0;//\\u8A2D\\u70BA0\\n                let clone=copy2Darray(grid);\\n                let res=bfs(clone);\\n                console.log(i,j,\\'-->\\', res)\\n                if(res != 1) //\\u53EF\\u4EE5\\u4F7F\\u5CF6\\u5206\\u62101\\u500B\\u4EE5\\u4E0A\\n                    return 1;\\n                grid[i][j]=1;//\\u5FA9\\u539F\\n            }\\n        }\\n    }\\n    return 2;\\n\\n    function copy2Darray(a){\\n        let b=[];\\n        for(let i=0; i<a.length; i++){\\n            let t=[];\\n            for(let j=0; j<a[0].length; j++){\\n                t.push(a[i][j]);\\n            }\\n            b.push(t);\\n        }\\n        return b;\\n    }\\n    \\n    function bfs(gr){//\\u4F7F\\u7528flood fill, \\u6AA2\\u67E5\\u76E4\\u9762\\u4E0A\\u7684\\u5CF6\\u662F\\u4E00\\u500B\\u6216\\u5927\\u65BC\\u4E00\\u500B\\n        console.log(gr)\\n        let numberOfIslands=0;\\n        let dirs=[[-1,0],[1,0],[0,1],[0,-1]];\\n        for(let m=0; m<gr.length; m++){\\n            for(let n=0; n<gr[0].length; n++){\\n                if(gr[m][n]==1){\\n                    numberOfIslands++; //\\u7279\\u5225\\u7684\\u5730\\u65B9\\n                    if(numberOfIslands>1)\\n                        return numberOfIslands;\\n                    gr[m][n]=0;\\n                    let nc=[[m,n]];\\n                    while(nc.length>0){\\n                        let nb=nc;\\n                        nc=[];\\n                        for(let [x,y] of nb){\\n                            for(let [i,j] of dirs){\\n                                if(x+i<0 || x+i>=gr.length || y+j<0 || y+j>=gr[0].length || gr[x+i][y+j]==0)\\n                                    continue;\\n                                gr[x+i][y+j]=0;\\n                                nc.push([x+i, y+j]);\\n                            }                                \\n                        }\\n                    }\\n                }                                   \\n            }\\n        }\\n        return numberOfIslands;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(grid) {\\n    let c=copy2Darray(grid);\\n    //console.log(c)\\n    let tmp=bfs(c);\\n    //console.log(\\'xxxx\\', tmp)\\n    if(tmp>1 || tmp==0){//\\u984C\\u610F\\u5DF2\\u7D93\\u662F\\u5206\\u96E2\\u7684\\u5CF6\\u4E86   \\n        return 0;\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j]==1){\\n                grid[i][j]=0;//\\u8A2D\\u70BA0\\n                let clone=copy2Darray(grid);\\n                let res=bfs(clone);\\n                console.log(i,j,\\'-->\\', res)\\n                if(res != 1) //\\u53EF\\u4EE5\\u4F7F\\u5CF6\\u5206\\u62101\\u500B\\u4EE5\\u4E0A\\n                    return 1;\\n                grid[i][j]=1;//\\u5FA9\\u539F\\n            }\\n        }\\n    }\\n    return 2;\\n\\n    function copy2Darray(a){\\n        let b=[];\\n        for(let i=0; i<a.length; i++){\\n            let t=[];\\n            for(let j=0; j<a[0].length; j++){\\n                t.push(a[i][j]);\\n            }\\n            b.push(t);\\n        }\\n        return b;\\n    }\\n    \\n    function bfs(gr){//\\u4F7F\\u7528flood fill, \\u6AA2\\u67E5\\u76E4\\u9762\\u4E0A\\u7684\\u5CF6\\u662F\\u4E00\\u500B\\u6216\\u5927\\u65BC\\u4E00\\u500B\\n        console.log(gr)\\n        let numberOfIslands=0;\\n        let dirs=[[-1,0],[1,0],[0,1],[0,-1]];\\n        for(let m=0; m<gr.length; m++){\\n            for(let n=0; n<gr[0].length; n++){\\n                if(gr[m][n]==1){\\n                    numberOfIslands++; //\\u7279\\u5225\\u7684\\u5730\\u65B9\\n                    if(numberOfIslands>1)\\n                        return numberOfIslands;\\n                    gr[m][n]=0;\\n                    let nc=[[m,n]];\\n                    while(nc.length>0){\\n                        let nb=nc;\\n                        nc=[];\\n                        for(let [x,y] of nb){\\n                            for(let [i,j] of dirs){\\n                                if(x+i<0 || x+i>=gr.length || y+j<0 || y+j>=gr[0].length || gr[x+i][y+j]==0)\\n                                    continue;\\n                                gr[x+i][y+j]=0;\\n                                nc.push([x+i, y+j]);\\n                            }                                \\n                        }\\n                    }\\n                }                                   \\n            }\\n        }\\n        return numberOfIslands;\\n    }   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332541,
                "title": "easy-c-solution-articulation-points-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int row[4] = {-1,1,0,0};\\n    int col[4] = {0,0,-1,1};\\n    int in[31][31] , lw[31][31] , vis[31][31];\\n    bool artpt = false;\\n    int time = 0;\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        int bodies = 0 , land = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                  if(grid[i][j]==1) {\\n                       land++;\\n                       if(!vis[i][j]) {\\n                           bodies++;\\n                           dfs(i,j,-1,-1,grid,n,m);\\n                       }\\n                  }\\n            }\\n        }\\n        if(bodies == 0 || bodies>1) return 0;  // no body or more than one body , already disconnected (more than one island)\\n        else if(artpt || land==1) return 1;  // articulation pt or a single patch of land found , just remove that node!\\n        else return 2;  // otherwise its a ssc (strongly connected component) remove two nodes , one node each day , hence 2 days !\\n    }\\n\\t// learn about how to find articulation points!\\n\\t// https://youtu.be/y8hoABkFbT8\\n    void dfs(int r,int c,int pr,int pc,vector<vector<int>>&grid,int n,int m) {\\n          vis[r][c] = true;\\n          in[r][c] = lw[r][c] = ++time;\\n          int children = 0;\\n          for(int d=0; d<4; d++) {\\n               int R = r + row[d] , C = c + col[d];\\n               if(R>=0 && R<n && C>=0 && C<m && grid[R][C]) {\\n                      if(!vis[R][C]) {\\n                          children++;\\n                          dfs(R,C,r,c,grid,n,m);\\n                          lw[r][c] = min(lw[r][c],lw[R][C]);\\n                          if(in[r][c]<=lw[R][C] && pr!=-1) artpt = true;\\n                      }else {\\n                          lw[r][c] = min(lw[r][c],in[R][C]);\\n                      }\\n               }\\n          }\\n        if(pr == -1 && children>1) artpt = true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row[4] = {-1,1,0,0};\\n    int col[4] = {0,0,-1,1};\\n    int in[31][31] , lw[31][31] , vis[31][31];\\n    bool artpt = false;\\n    int time = 0;\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        int bodies = 0 , land = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                  if(grid[i][j]==1) {\\n                       land++;\\n                       if(!vis[i][j]) {\\n                           bodies++;\\n                           dfs(i,j,-1,-1,grid,n,m);\\n                       }\\n                  }\\n            }\\n        }\\n        if(bodies == 0 || bodies>1) return 0;  // no body or more than one body , already disconnected (more than one island)\\n        else if(artpt || land==1) return 1;  // articulation pt or a single patch of land found , just remove that node!\\n        else return 2;  // otherwise its a ssc (strongly connected component) remove two nodes , one node each day , hence 2 days !\\n    }\\n\\t// learn about how to find articulation points!\\n\\t// https://youtu.be/y8hoABkFbT8\\n    void dfs(int r,int c,int pr,int pc,vector<vector<int>>&grid,int n,int m) {\\n          vis[r][c] = true;\\n          in[r][c] = lw[r][c] = ++time;\\n          int children = 0;\\n          for(int d=0; d<4; d++) {\\n               int R = r + row[d] , C = c + col[d];\\n               if(R>=0 && R<n && C>=0 && C<m && grid[R][C]) {\\n                      if(!vis[R][C]) {\\n                          children++;\\n                          dfs(R,C,r,c,grid,n,m);\\n                          lw[r][c] = min(lw[r][c],lw[R][C]);\\n                          if(in[r][c]<=lw[R][C] && pr!=-1) artpt = true;\\n                      }else {\\n                          lw[r][c] = min(lw[r][c],in[R][C]);\\n                      }\\n               }\\n          }\\n        if(pr == -1 && children>1) artpt = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317942,
                "title": "c-simple-solution-with-hint-explanation",
                "content": "Hint:- \\nonly these cases are possible suppose you are on the position (x, y) than\\n1- already two island so, return 0 in this case\\n2- one island but have <= 2 blocks return cnt of blocks\\n3- make island (x, y) unconnected i.e. go all 4 direction and if there is a 1 then add it to your temp-ans (final ans will be min of temp-ans)\\n4- remove this island (x, y) and check if it is now unconnected or not. If it is then return 1\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int xx[4] = {0, 0, 1, -1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    int n, m;\\n    vector<vector<int>> g, vis;\\n    \\n    bool cango(int x, int y){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(g[x][y] == 0) return false;\\n        return true;\\n    }\\n    \\n    int ans = INT_MAX;\\n    int cnt = 0;\\n    \\n    int tdfs(int x, int y, vector<vector<int>>&tgrid, vector<vector<int>>&tvis){\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            \\n            if(cango(nx, ny) && tgrid[nx][ny] == 1 && tvis[nx][ny] == 0){\\n                tvis[nx][ny] = 1;\\n                ct += tdfs(nx, ny, tgrid, tvis);\\n            }\\n        }\\n        \\n        return ct + 1;\\n    }\\n    \\n    bool tryremove(int x, int y){\\n        vector<vector<int>> tgrid = g;\\n        vector<vector<int>> tvis(n, vector<int>(m, 0));\\n        int tcnt = cnt - 1;\\n        \\n        tgrid[x][y] = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(tgrid[i][j] == 1){\\n                    tvis[i][j] = 1;\\n                    int tcntx = tdfs(i, j, tgrid, tvis);\\n                    // cout<<tcntx<<\" - \"<<tcnt<<endl;\\n                    if(tcntx == tcnt) return false;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int dfs(int x, int y){\\n        \\n        int temp = 0;\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            if(cango(nx, ny)){ \\n                temp++;\\n                if(vis[nx][ny] == 0){\\n                    vis[nx][ny] = 1;\\n                    ct += dfs(nx, ny);\\n                }\\n            }\\n        }\\n        \\n        if(temp == 2){\\n            if(tryremove(x, y)){\\n                // cout<<x<<\" \"<<y<<endl;\\n                ans = min(ans, 1);\\n            }\\n        }\\n        \\n        ans = min(ans, temp);\\n        return ct + 1;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        cnt = 0;\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1) cnt++;\\n            }\\n        }\\n        \\n        vis = vector<vector<int>>(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1){\\n                    vis[i][j] = 1;\\n                    int tempcnt = dfs(i, j);\\n                    if(tempcnt != cnt) return 0;\\n                    if(tempcnt <= 2) return tempcnt;\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int xx[4] = {0, 0, 1, -1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    int n, m;\\n    vector<vector<int>> g, vis;\\n    \\n    bool cango(int x, int y){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(g[x][y] == 0) return false;\\n        return true;\\n    }\\n    \\n    int ans = INT_MAX;\\n    int cnt = 0;\\n    \\n    int tdfs(int x, int y, vector<vector<int>>&tgrid, vector<vector<int>>&tvis){\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            \\n            if(cango(nx, ny) && tgrid[nx][ny] == 1 && tvis[nx][ny] == 0){\\n                tvis[nx][ny] = 1;\\n                ct += tdfs(nx, ny, tgrid, tvis);\\n            }\\n        }\\n        \\n        return ct + 1;\\n    }\\n    \\n    bool tryremove(int x, int y){\\n        vector<vector<int>> tgrid = g;\\n        vector<vector<int>> tvis(n, vector<int>(m, 0));\\n        int tcnt = cnt - 1;\\n        \\n        tgrid[x][y] = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(tgrid[i][j] == 1){\\n                    tvis[i][j] = 1;\\n                    int tcntx = tdfs(i, j, tgrid, tvis);\\n                    // cout<<tcntx<<\" - \"<<tcnt<<endl;\\n                    if(tcntx == tcnt) return false;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int dfs(int x, int y){\\n        \\n        int temp = 0;\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            if(cango(nx, ny)){ \\n                temp++;\\n                if(vis[nx][ny] == 0){\\n                    vis[nx][ny] = 1;\\n                    ct += dfs(nx, ny);\\n                }\\n            }\\n        }\\n        \\n        if(temp == 2){\\n            if(tryremove(x, y)){\\n                // cout<<x<<\" \"<<y<<endl;\\n                ans = min(ans, 1);\\n            }\\n        }\\n        \\n        ans = min(ans, temp);\\n        return ct + 1;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        cnt = 0;\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1) cnt++;\\n            }\\n        }\\n        \\n        vis = vector<vector<int>>(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1){\\n                    vis[i][j] = 1;\\n                    int tempcnt = dfs(i, j);\\n                    if(tempcnt != cnt) return 0;\\n                    if(tempcnt <= 2) return tempcnt;\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2294614,
                "title": "incorrect-first-attempt",
                "content": "```\\nclass Solution {\\n  public int minDays(int[][] grid) {\\n    // return firstIncorrectAttempt(grid);\\n  }\\n  \\n  public int firstIncorrectAttempt(int[][] grid) {\\n    int[] res = smallestIsland(grid);\\n    int count = res[0];\\n    int size = res[1];\\n    if(count != 1) {\\n      return 0;\\n    }\\n    // Does not account for an island like this [[1,1,1,1,1]]\\n    if(size > 3) {\\n      return 2;\\n    } else {\\n      return size;\\n    }\\n  }\\n  \\n  public int[] smallestIsland(int[][] grid) {\\n    // returns {numsIslands, smallestIsland}\\n    int islandCount = 0;\\n    int size = Integer.MAX_VALUE;\\n    int[][] visited = new int[grid.length][grid[0].length];\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[0].length; j++) {\\n        if(grid[i][j] == 1 && visited[i][j] != 1) {\\n          ++islandCount;\\n          size = Math.min(size, exploreIsland(grid, visited, i, j));\\n        }\\n      }\\n    }\\n    return new int[]{islandCount, size};\\n  }\\n  \\n  // returns island size\\n  public int exploreIsland(int[][] grid, int[][] visited, int i, int j) {\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length\\n      || visited[i][j] == 1 || grid[i][j] != 1) {\\n      return -1;\\n    }\\n    \\n    visited[i][j] = 1;\\n    \\n    int up = exploreIsland(grid, visited, i + 1, j);\\n    int down = exploreIsland(grid, visited, i - 1, j);\\n    int left = exploreIsland(grid, visited, i, j - 1);\\n    int right = exploreIsland(grid, visited, i, j + 1);\\n    \\n    return 1 + Math.max(0, up) + Math.max(0, down) + Math.max(0, left) + Math.max(0, right);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int minDays(int[][] grid) {\\n    // return firstIncorrectAttempt(grid);\\n  }\\n  \\n  public int firstIncorrectAttempt(int[][] grid) {\\n    int[] res = smallestIsland(grid);\\n    int count = res[0];\\n    int size = res[1];\\n    if(count != 1) {\\n      return 0;\\n    }\\n    // Does not account for an island like this [[1,1,1,1,1]]\\n    if(size > 3) {\\n      return 2;\\n    } else {\\n      return size;\\n    }\\n  }\\n  \\n  public int[] smallestIsland(int[][] grid) {\\n    // returns {numsIslands, smallestIsland}\\n    int islandCount = 0;\\n    int size = Integer.MAX_VALUE;\\n    int[][] visited = new int[grid.length][grid[0].length];\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[0].length; j++) {\\n        if(grid[i][j] == 1 && visited[i][j] != 1) {\\n          ++islandCount;\\n          size = Math.min(size, exploreIsland(grid, visited, i, j));\\n        }\\n      }\\n    }\\n    return new int[]{islandCount, size};\\n  }\\n  \\n  // returns island size\\n  public int exploreIsland(int[][] grid, int[][] visited, int i, int j) {\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length\\n      || visited[i][j] == 1 || grid[i][j] != 1) {\\n      return -1;\\n    }\\n    \\n    visited[i][j] = 1;\\n    \\n    int up = exploreIsland(grid, visited, i + 1, j);\\n    int down = exploreIsland(grid, visited, i - 1, j);\\n    int left = exploreIsland(grid, visited, i, j - 1);\\n    int right = exploreIsland(grid, visited, i, j + 1);\\n    \\n    return 1 + Math.max(0, up) + Math.max(0, down) + Math.max(0, left) + Math.max(0, right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271671,
                "title": "c-dfs-count-number-of-islands",
                "content": "* **Thought Process ->**\\n* I just drew few example and figured out the logic.\\n\\n* If Number of islands in grid are more than one or there are no islands then there is no need to do anything return 0. `ans == 0`\\n\\n* Otherwise , if there is only one island , then only two possibilities arise --> \\n\\n* Suppose the grid may look something like- > `[1,1,1,1,1,1]` , `[[1,1,1,1],[1,0,1,1]]` , `[[0,1,1,0,1],[0,0,1,1,1]]` , for all these types of cases we can see that only one day is required to make it disconnected.  `ans == 1`\\n\\n* The Other case will be just take out the first two land(s) in diagonal directions.\\n say , grid = `[[1,1],[1,1],[1,1]]` , make `grid[0][1] = 0  and grid[1][1] = 0` and we are done. `ans == 2`\\n\\n```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1};\\n    void dfs(int i , int j , vector<vector<int>> &grid , vector<vector<int>> &visited ){\\n        visited[i][j] = 1;\\n        \\n        for(int itr = 0 ; itr < 4 ; ++itr ){\\n            int ii = i + dx[itr] , jj = j + dy[itr] ;\\n            if(ii >= 0 and jj >= 0 and ii < r and jj < c and grid[ii][jj] and !visited[ii][jj]) dfs(ii,jj,grid,visited);\\n        }\\n    }\\n    \\n    int find_islands(vector<vector<int>> &grid){\\n        vector<vector<int>> visited(r,vector<int>(c)) ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                if(!visited[i][j]) ++ans , dfs(i,j,grid,visited);\\n            }\\n        }\\n        return ans ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        int islands = find_islands(grid) ;\\n        if(!islands || islands > 1) return 0 ; \\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                \\n                grid[i][j] = 0 ;\\n                int groups = find_islands(grid) ;\\n                if(groups > 1 || !groups) return 1 ;\\n                grid[i][j] = 1 ;\\n            }\\n        }\\n        \\n        return 2 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1};\\n    void dfs(int i , int j , vector<vector<int>> &grid , vector<vector<int>> &visited ){\\n        visited[i][j] = 1;\\n        \\n        for(int itr = 0 ; itr < 4 ; ++itr ){\\n            int ii = i + dx[itr] , jj = j + dy[itr] ;\\n            if(ii >= 0 and jj >= 0 and ii < r and jj < c and grid[ii][jj] and !visited[ii][jj]) dfs(ii,jj,grid,visited);\\n        }\\n    }\\n    \\n    int find_islands(vector<vector<int>> &grid){\\n        vector<vector<int>> visited(r,vector<int>(c)) ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                if(!visited[i][j]) ++ans , dfs(i,j,grid,visited);\\n            }\\n        }\\n        return ans ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        int islands = find_islands(grid) ;\\n        if(!islands || islands > 1) return 0 ; \\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                \\n                grid[i][j] = 0 ;\\n                int groups = find_islands(grid) ;\\n                if(groups > 1 || !groups) return 1 ;\\n                grid[i][j] = 1 ;\\n            }\\n        }\\n        \\n        return 2 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260430,
                "title": "dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n      \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int islandCount= findIslandCount(grid);\\n        \\n        if(islandCount==0 || islandCount>1) //means its already disconnected\\n            return 0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //make one cell to 0 and find the island count\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    islandCount= findIslandCount(grid);\\n                    //make it again to 1\\n                    grid[i][j]=1;\\n                    if(islandCount==0 || islandCount>1) //means its already disconnected\\n                        return 1;\\n                }\\n                \\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int findIslandCount(int[][] grid){\\n        \\n         int m=grid.length;\\n         int n=grid[0].length;\\n         boolean visited[][]=new boolean[m][n];\\n         int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visited[i][j] && grid[i][j]==1){\\n                    count++;\\n                    if(count>1) //if count >1 then we dont need to do dfs for more nodes\\n                        return count;\\n                     doDFS(grid,visited,i,j,m,n);  \\n                }\\n            }\\n        }\\n      return count;\\n    }\\n    \\n    private void doDFS(int[][] grid,boolean[][] visited,int i,int j,int m,int n){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j] || grid[i][j]!=1)\\n            return;\\n        \\n        visited[i][j]=true;\\n        \\n        doDFS(grid,visited,i+1,j,m,n);        \\n        doDFS(grid,visited,i-1,j,m,n);\\n        doDFS(grid,visited,i,j+1,m,n);\\n        doDFS(grid,visited,i,j-1,m,n);\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int minDays(int[][] grid) {\\n      \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int islandCount= findIslandCount(grid);\\n        \\n        if(islandCount==0 || islandCount>1) //means its already disconnected\\n            return 0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //make one cell to 0 and find the island count\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    islandCount= findIslandCount(grid);\\n                    //make it again to 1\\n                    grid[i][j]=1;\\n                    if(islandCount==0 || islandCount>1) //means its already disconnected\\n                        return 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2190052,
                "title": "fast-go-beats-100",
                "content": "```\\nvar dx = []int{1, -1, 0, 0}\\nvar dy = []int{0, 0, 1, -1}\\n\\nfunc fill(g [][]int, x, y int) {\\n    g[x][y] = 2\\n    for i := 0; i < 4; i++ {\\n        nx, ny := x + dx[i], y + dy[i]\\n        if nx < 0 || nx >= len(g) || ny < 0 || ny >= len(g[0]) || g[nx][ny] != 1 {\\n            continue\\n        }\\n        fill(g, nx, ny)        \\n    }\\n}\\n\\nfunc cnt(g [][]int) int {\\n    r := 0\\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 1 {\\n                r++\\n                fill(g, i, j)\\n            }  \\n        }\\n    }\\n    \\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 2 {\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return r\\n}\\n\\nfunc minDays(g [][]int) int {\\n    n, m := len(g), len(g[0])\\n    c := cnt(g)\\n    if c != 1 {\\n        return 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if g[i][j] == 1 {\\n                g[i][j] = 0\\n                c = cnt(g)\\n                if c != 1 {\\n                    return 1\\n                }\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2    \\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar dx = []int{1, -1, 0, 0}\\nvar dy = []int{0, 0, 1, -1}\\n\\nfunc fill(g [][]int, x, y int) {\\n    g[x][y] = 2\\n    for i := 0; i < 4; i++ {\\n        nx, ny := x + dx[i], y + dy[i]\\n        if nx < 0 || nx >= len(g) || ny < 0 || ny >= len(g[0]) || g[nx][ny] != 1 {\\n            continue\\n        }\\n        fill(g, nx, ny)        \\n    }\\n}\\n\\nfunc cnt(g [][]int) int {\\n    r := 0\\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 1 {\\n                r++\\n                fill(g, i, j)\\n            }  \\n        }\\n    }\\n    \\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 2 {\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return r\\n}\\n\\nfunc minDays(g [][]int) int {\\n    n, m := len(g), len(g[0])\\n    c := cnt(g)\\n    if c != 1 {\\n        return 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if g[i][j] == 1 {\\n                g[i][j] = 0\\n                c = cnt(g)\\n                if c != 1 {\\n                    return 1\\n                }\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2163686,
                "title": "c-simple-dfs-and-finding-connected-components",
                "content": "```\\nvoid dfs(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited){\\n    if(i>=grid.size() || j>=grid[0].size() || j<0 || i<0) return;\\n    if(!visited[i][j] && grid[i][j]){\\n        visited[i][j]=1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n        dfs(grid, i, j+1, visited);\\n    }\\n    return;\\n}\\n\\nint cc(vector<vector<int>> &grid, vector<vector<int>> &visited){\\n    int count=0;\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0; j<grid[i].size() ;j++){\\n            if(!visited[i][j] && grid[i][j]){\\n                count++;\\n                dfs(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n}\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0; j<grid[i].size();j++) if(grid[i][j]) c++;\\n        if(c==1) return 1;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        int x = cc(grid, visited);\\n        if(x>1 || x==0) return 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n                if(grid[i][j] && !visited[i][j]){\\n                    grid[i][j] = 0;\\n                    x = cc(grid,visited);\\n                    if(x > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nvoid dfs(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited){\\n    if(i>=grid.size() || j>=grid[0].size() || j<0 || i<0) return;\\n    if(!visited[i][j] && grid[i][j]){\\n        visited[i][j]=1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n        dfs(grid, i, j+1, visited);\\n    }\\n    return;\\n}\\n\\nint cc(vector<vector<int>> &grid, vector<vector<int>> &visited){\\n    int count=0;\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0; j<grid[i].size() ;j++){\\n            if(!visited[i][j] && grid[i][j]){\\n                count++;\\n                dfs(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n}\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0; j<grid[i].size();j++) if(grid[i][j]) c++;\\n        if(c==1) return 1;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        int x = cc(grid, visited);\\n        if(x>1 || x==0) return 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n                if(grid[i][j] && !visited[i][j]){\\n                    grid[i][j] = 0;\\n                    x = cc(grid,visited);\\n                    if(x > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158527,
                "title": "c-articulation-point",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> low,dis,vis,path{{1,0},{0,1},{-1,0},{0,-1}};\\n    int ct=0;\\n    void dfs(int i, int j, vector<vector<int>> &visi,vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size(); \\n        visi[i][j] = true;\\n        for(auto it:path)\\n        {\\n            int x = i+it[0], y = j+it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && visi[x][y] == false && grid[x][y]==1)\\n            {\\n                visi[x][y] = true;\\n                dfs(x,y,visi,grid);\\n            }\\n        }\\n    }\\n    void APutil(int i,int j,int &time,vector<vector<int>> &grid,int pi, int pj)\\n    {\\n        int children = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[i][j] = true;\\n        dis[i][j] = low[i][j] = ++time;\\n        for(auto it: path)\\n        {\\n            int x = i + it[0], y = j + it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && grid[x][y] == 1)  \\n            {\\n                if(vis[x][y] == 0)\\n                {\\n                    children++;\\n                    APutil(x,y,time,grid,i,j);\\n                    low[i][j] = min(low[i][j],low[x][y]);\\n                    if(pi != -1 && low[x][y] >= dis[i][j]) ct++;\\n                }\\n                else \\n                    low[i][j] = min(low[i][j],dis[x][y]);\\n            }\\n        }\\n        if(pi==-1 && children>1) ct++;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        low.resize(n,vector<int>(m));\\n        dis.resize(n,vector<int>(m));\\n        vis.resize(n,vector<int>(m));\\n        int time=0;\\n        ct=0;\\n        vector<vector<int>> visi(n,vector<int>(m));\\n        int cnt=0,c=0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1) c++;\\n                if(grid[i][j]==1 && visi[i][j]==0)\\n                {\\n                    APutil(i,j,time,grid,-1,-1);\\n                    cnt++;\\n                    dfs(i,j,visi,grid);\\n                }\\n            }\\n        }\\n        if(cnt!=1) return 0;\\n        if((ct>=1 || c==1)) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> low,dis,vis,path{{1,0},{0,1},{-1,0},{0,-1}};\\n    int ct=0;\\n    void dfs(int i, int j, vector<vector<int>> &visi,vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size(); \\n        visi[i][j] = true;\\n        for(auto it:path)\\n        {\\n            int x = i+it[0], y = j+it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && visi[x][y] == false && grid[x][y]==1)\\n            {\\n                visi[x][y] = true;\\n                dfs(x,y,visi,grid);\\n            }\\n        }\\n    }\\n    void APutil(int i,int j,int &time,vector<vector<int>> &grid,int pi, int pj)\\n    {\\n        int children = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[i][j] = true;\\n        dis[i][j] = low[i][j] = ++time;\\n        for(auto it: path)\\n        {\\n            int x = i + it[0], y = j + it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && grid[x][y] == 1)  \\n            {\\n                if(vis[x][y] == 0)\\n                {\\n                    children++;\\n                    APutil(x,y,time,grid,i,j);\\n                    low[i][j] = min(low[i][j],low[x][y]);\\n                    if(pi != -1 && low[x][y] >= dis[i][j]) ct++;\\n                }\\n                else \\n                    low[i][j] = min(low[i][j],dis[x][y]);\\n            }\\n        }\\n        if(pi==-1 && children>1) ct++;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        low.resize(n,vector<int>(m));\\n        dis.resize(n,vector<int>(m));\\n        vis.resize(n,vector<int>(m));\\n        int time=0;\\n        ct=0;\\n        vector<vector<int>> visi(n,vector<int>(m));\\n        int cnt=0,c=0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1) c++;\\n                if(grid[i][j]==1 && visi[i][j]==0)\\n                {\\n                    APutil(i,j,time,grid,-1,-1);\\n                    cnt++;\\n                    dfs(i,j,visi,grid);\\n                }\\n            }\\n        }\\n        if(cnt!=1) return 0;\\n        if((ct>=1 || c==1)) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100332,
                "title": "c-clean-code-easy-to-understand-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int isLands=0,o=0,r,c;\\n    int vis[31][31];\\n    void dfs(vector<vector<int>>& g,int i,int j){\\n        if(i<0 || i>=r || j<0 || j>=c || vis[i][j] || !g[i][j]) return;\\n        vis[i][j]=1;\\n        dfs(g,i+1,j);\\n        dfs(g,i-1,j);\\n        dfs(g,i,j+1);\\n        dfs(g,i,j-1);        \\n    }\\n    void countALL(vector<vector<int>>& g){\\n        isLands=0,o=0;\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(!vis[i][j]&&g[i][j])dfs(g,i,j),isLands++;\\n                if(g[i][j])o++;\\n            }\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        r=g.size();\\n        c=g[0].size();\\n        countALL(g);\\n        if(isLands!=1) return 0;\\n        if(r==1 || c==1 || o<=2) return o==2?2:1;\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(g[i][j]){\\n                    g[i][j]=0;\\n                    countALL(g);\\n                    if(isLands>1) return 1;\\n                    g[i][j]=1;\\n                }\\n            }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isLands=0,o=0,r,c;\\n    int vis[31][31];\\n    void dfs(vector<vector<int>>& g,int i,int j){\\n        if(i<0 || i>=r || j<0 || j>=c || vis[i][j] || !g[i][j]) return;\\n        vis[i][j]=1;\\n        dfs(g,i+1,j);\\n        dfs(g,i-1,j);\\n        dfs(g,i,j+1);\\n        dfs(g,i,j-1);        \\n    }\\n    void countALL(vector<vector<int>>& g){\\n        isLands=0,o=0;\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(!vis[i][j]&&g[i][j])dfs(g,i,j),isLands++;\\n                if(g[i][j])o++;\\n            }\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        r=g.size();\\n        c=g[0].size();\\n        countALL(g);\\n        if(isLands!=1) return 0;\\n        if(r==1 || c==1 || o<=2) return o==2?2:1;\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(g[i][j]){\\n                    g[i][j]=0;\\n                    countALL(g);\\n                    if(isLands>1) return 1;\\n                    g[i][j]=1;\\n                }\\n            }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054513,
                "title": "c-dfs-scc-clean-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; \\n    \\n    bool valid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &used) {\\n        used[x][y] = true;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int a = x + dir[i][0];\\n            int b = y + dir[i][1];\\n            if(valid(a, b, m, n) && grid[a][b] == 1 && !used[a][b])\\n                dfs(a, b, grid, used);\\n        }\\n        \\n    }\\n    \\n    int total_cmpnt(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> used(m, vector<bool>(n, false));\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1 && !used[i][j]) {\\n                    cnt += 1;\\n                    dfs(i, j, grid, used);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // if initially disconnected\\n        int cnt = total_cmpnt(grid);\\n        \\n        // cout << cnt << endl;\\n        \\n        if(cnt != 1)\\n            return 0;\\n        \\n        // for 1 day\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;   // flip to 0\\n                    cnt = total_cmpnt(grid);\\n                    if(cnt != 1)\\n                        return 1;\\n                    grid[i][j] = 1;   // restore to 1\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; \\n    \\n    bool valid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &used) {\\n        used[x][y] = true;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int a = x + dir[i][0];\\n            int b = y + dir[i][1];\\n            if(valid(a, b, m, n) && grid[a][b] == 1 && !used[a][b])\\n                dfs(a, b, grid, used);\\n        }\\n        \\n    }\\n    \\n    int total_cmpnt(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> used(m, vector<bool>(n, false));\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1 && !used[i][j]) {\\n                    cnt += 1;\\n                    dfs(i, j, grid, used);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // if initially disconnected\\n        int cnt = total_cmpnt(grid);\\n        \\n        // cout << cnt << endl;\\n        \\n        if(cnt != 1)\\n            return 0;\\n        \\n        // for 1 day\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;   // flip to 0\\n                    cnt = total_cmpnt(grid);\\n                    if(cnt != 1)\\n                        return 1;\\n                    grid[i][j] = 1;   // restore to 1\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2045241,
                "title": "c-articulation-points-logical-way-for-optimal-removal-at-any-point",
                "content": "Explanation in a later post.\\n\\n---\\n\\n```cpp\\n#define _CRT_SECURE_NO_WARNINGS\\n#include <algorithm>\\n#include <array>\\n#include <charconv>\\n#include <cstring>\\n#include <functional>\\n#include <iomanip>\\n#include <iostream>\\n#include <list>\\n#include <map>\\n#include <numeric>\\n#include <queue>\\n#include <random>\\n#include <set>\\n#include <stack>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <utility>\\n#include <vector>\\nusing namespace std;\\n\\n#ifdef LC_LOCAL\\nstruct TreeNode {\\n  int val;\\n  TreeNode *left = nullptr;\\n  TreeNode *right = nullptr;\\n};\\nstruct ListNode {\\n  int val;\\n  ListNode *next = nullptr;\\n};\\n#endif\\n\\ntemplate <typename T, typename = void> struct is_container {\\n  static constexpr bool value = false;\\n};\\ntemplate <typename T>\\nstruct is_container<T, void_t<decltype(T{}.begin()), decltype(T{}.end())>> {\\n  static constexpr bool value = true;\\n};\\ntemplate <typename = void> inline constexpr bool always_false = false;\\n\\ntemplate <typename T, bool ReadEnd> T parse(FILE *f, int &c) {\\n  if constexpr (is_same_v<T, int>) {\\n    int ans = 0, neg = 0;\\n    while ((char(c = fgetc(f)) >= \\'0\\' && (char)c <= \\'9\\') || (char)c == \\'-\\') {\\n      if ((char)c == \\'-\\')\\n        neg = 1;\\n      else\\n        ans = ans * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n    }\\n    if constexpr (!ReadEnd)\\n      ungetc(c, f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, string>) {\\n    string ans;\\n    fgetc(f);\\n    while (char(c = fgetc(f)) != \\'\"\\')\\n      ans += (char)c;\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, TreeNode *>) {\\n    int e = 2;\\n    auto dummy = new TreeNode{};\\n    deque<TreeNode *> q;\\n    q.push_back(dummy);\\n    fgetc(f);\\n    while ((char)c != \\']\\') {\\n      int sz = q.size();\\n      while (sz > 0) {\\n        int val = 0, neg = 0;\\n        bool is_null = false;\\n        while (char(c = fgetc(f)) != \\',\\' && (char)c != \\']\\') {\\n          if ((char)c >= \\'0\\' && (char)c <= \\'9\\')\\n            val = val * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n          else if ((char)c == \\'-\\')\\n            neg = 1;\\n          else\\n            is_null = true;\\n        }\\n        if (!is_null) {\\n          auto new_node = new TreeNode{val};\\n          if (e & 1)\\n            q[0]->left = new_node;\\n          else\\n            q[0]->right = new_node;\\n          q.push_back(new_node);\\n        }\\n        if (e++ % 2 == 0) {\\n          q.pop_front();\\n          sz--;\\n        }\\n      }\\n      e = 1;\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->right;\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    auto dummy = new ListNode{};\\n    auto cur = dummy;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\') {\\n        cur->next = new ListNode{parse<int, true>(f, c)};\\n        cur = cur->next;\\n      }\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->next;\\n  } else if constexpr (is_container<T>::value) {\\n    T ans;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\')\\n        ans.emplace_back(parse<typename T::value_type, true>(f, c));\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else\\n    static_assert(always_false<T>, \"parsing for type not supported\");\\n}\\n\\ntemplate <bool WriteEnd, typename T> void write(FILE *f, const T &val) {\\n  static constexpr const char *end = WriteEnd ? \"\\\\n\" : \"\";\\n  if constexpr (is_same_v<T, int>)\\n    fprintf(f, \"%d%s\", val, end);\\n  else if constexpr (is_same_v<T, float>)\\n    fprintf(f, \"%.f%s\", val, end);\\n  else if constexpr (is_same_v<T, bool>)\\n    fprintf(f, \"%s%s\", val ? \"true\" : \"false\", end);\\n  else if constexpr (is_same_v<T, string>)\\n    fprintf(f, \"\\\\\"%s\\\\\"%s\", val.data(), end);\\n  else if constexpr (is_same_v<T, TreeNode *>) {\\n    deque<TreeNode *> q;\\n    fprintf(f, \"[\");\\n    if (val) {\\n      q.push_back(val);\\n      fprintf(f, \"%d\", val->val);\\n    }\\n    while (!q.empty()) {\\n      int sz = q.size();\\n      string ans;\\n      while (sz-- > 0) {\\n        auto cur = q.front();\\n        q.pop_front();\\n        if (cur->left) {\\n          q.push_back(cur->left);\\n          ans += \\',\\';\\n          ans += to_string(cur->left->val);\\n        } else\\n          ans += \",null\";\\n        if (cur->right) {\\n          q.push_back(cur->right);\\n          ans += \\',\\';\\n          ans += to_string(cur->right->val);\\n        } else\\n          ans += \",null\";\\n      }\\n      if (!q.empty())\\n        fprintf(f, ans.data());\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    int c = 0;\\n    auto cur = val;\\n    fprintf(f, \"[\");\\n    while (cur) {\\n      fprintf(f, \"%s%d\", c++ ? \",\" : \"\", cur->val);\\n      cur = cur->next;\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_container<T>::value) {\\n    fprintf(f, \"[\");\\n    int c = 0;\\n    for (int i = 0; i < val.size(); i++) {\\n      fprintf(f, \"%s\", c++ ? \",\" : \"\");\\n      write<false>(f, val[i]);\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else\\n    static_assert(always_false<T>, \"writing for type not supported\");\\n}\\n\\ntemplate <typename Args, size_t... Idx>\\nvoid write_args(FILE *f, const Args &args, index_sequence<Idx...>) {\\n  ((fprintf(f, \"#%lld: \", Idx + 1), write<true>(f, get<Idx + 1>(args))), ...);\\n}\\n\\ntemplate <typename Solution, typename R, typename... Ts>\\nvoid exec(R (Solution::*fn)(Ts...)) {\\n  constexpr bool returns = !is_same_v<R, void>;\\n  auto out = fopen(\"output.txt\", \"w\");\\n  if constexpr (sizeof...(Ts) == 0) {\\n    if constexpr (returns) {\\n      write<true>(out, (Solution{}.*fn)());\\n    } else\\n      (Solution{}.*fn)();\\n  } else {\\n    auto in = fopen(\"input.txt\", \"r\");\\n    int c = fgetc(in);\\n    if (c == EOF) {\\n      fclose(in);\\n      return;\\n    } else\\n      ungetc(c, in);\\n    while (true) {\\n      if (char(c = fgetc(in)) == EOF)\\n        break;\\n      else\\n        ungetc(c, in);\\n      if (char(c = fgetc(in)) == \\'/\\') {\\n        while ((c = fgetc(in)) != \\'\\\\n\\' && c != EOF) {\\n        }\\n      } else {\\n        ungetc(c, in);\\n        tuple args{Solution{}, parse<decay_t<Ts>, true>(in, c)...};\\n        if constexpr (!returns) {\\n          apply(fn, args);\\n          fprintf(out, \"New state of parameters:\\\\n\");\\n          write_args(out, args, index_sequence_for<Ts...>{});\\n        } else\\n          write<true>(out, apply(fn, args));\\n#ifdef LC_LOCAL\\n        cout << endl;\\n#endif\\n      }\\n    }\\n    fclose(in);\\n  }\\n  fclose(out);\\n}\\n\\nvoid _print(const string &x) { cout << \\'\\\\\"\\' << x << \\'\\\\\"\\'; }\\nvoid _print(bool x) { cout << (x ? \"true\" : \"false\"); }\\ntemplate <typename T> enable_if_t<is_arithmetic_v<T>> _print(const T &x) {\\n  cout << x;\\n}\\ntemplate <typename T, size_t... Idx>\\nvoid _print2(const T &x, index_sequence<Idx...>) {\\n  int c = 0;\\n  ((cout << (c++ ? \",\" : \"\"), _print(get<Idx>(x))), ...);\\n}\\ntemplate <typename T> void_t<typename tuple_size<T>::type> _print(const T &x) {\\n  cout << \\'{\\';\\n  _print2(x, make_index_sequence<tuple_size_v<T>>{});\\n  cout << \\'}\\';\\n}\\ntemplate <typename T> enable_if_t<is_container<T>::value> _print(const T &x) {\\n  cout << \\'[\\';\\n  int c = 0;\\n  for (const auto &e : x) {\\n    cout << (c++ ? \",\" : \"\");\\n    _print(e);\\n  }\\n  cout << \\']\\';\\n}\\n\\n#define CONCAT_IMPL(x, y) x##y\\n#define CONCAT(x, y) CONCAT_IMPL(x, y)\\n#define NUM_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\\n#define NUM_ARGS(...) NUM_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\\n#define DBG_VAL(x) cout << \\'[\\' << #x << \" = \", _print(x), cout << \"] \"\\n#define DBG_1(x) DBG_VAL(x)\\n#define DBG_2(x, ...) DBG_VAL(x), DBG_1(__VA_ARGS__)\\n#define DBG_3(x, ...) DBG_VAL(x), DBG_2(__VA_ARGS__)\\n#define DBG_4(x, ...) DBG_VAL(x), DBG_3(__VA_ARGS__)\\n#define DBG_5(x, ...) DBG_VAL(x), DBG_4(__VA_ARGS__)\\n#define DBG_6(x, ...) DBG_VAL(x), DBG_5(__VA_ARGS__)\\n#define DBG_7(x, ...) DBG_VAL(x), DBG_6(__VA_ARGS__)\\n#define DBG_8(x, ...) DBG_VAL(x), DBG_7(__VA_ARGS__)\\n#define DBG_9(x, ...) DBG_VAL(x), DBG_8(__VA_ARGS__)\\n#define DBG_10(x, ...) DBG_VAL(x), DBG_9(__VA_ARGS__)\\n// supports up to 10 arguments debugging at one time\\n\\n#ifdef LC_LOCAL\\n#define dbg(...) CONCAT(DBG_, NUM_ARGS(__VA_ARGS__))(__VA_ARGS__), cout << endl\\n#else\\n#define dbg(...)\\n#endif\\n\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define umap unordered_map\\n#define uset unordered_set\\n#define vec vector\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nnamespace std {\\ntemplate <typename T> class hash<std::pair<T, T>> {\\npublic:\\n  size_t operator()(const pair<T, T> &x) const {\\n    // https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\\n    ll lhs = hash<T>()(x.first), rhs = hash<T>()(x.second);\\n    lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);\\n    return lhs;\\n  }\\n};\\n} // namespace std\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\n// ----- CHANGE FOR PROBLEM -----\\nclass Solution {\\n\\n  void dfs(vec<vec<int>> &grid, vec<vec<vec<pii>>> &adj, vec<vec<bool>> &vis,\\n           vec<vec<int>> &disc, vec<vec<int>> &low, int ip, int jp, int i,\\n           int j, int time, bool &res) {\\n    int children = 0;\\n    disc[i][j] = low[i][j] = time;\\n    vis[i][j] = false;\\n\\n    for (auto [i2, j2] : adj[i][j]) {\\n      if (vis[i2][j2]) {\\n        children++;\\n        dfs(grid, adj, vis, disc, low, i, j, i2, j2, time + 1, res);\\n        amin(low[i][j], low[i2][j2]);\\n        if (ip != -1 && jp != -1 && low[i2][j2] >= disc[i][j])\\n          res = true;\\n      } else if (i2 != ip || j2 != jp)\\n        amin(low[i][j], disc[i2][j2]);\\n    }\\n    if (ip == -1 && jp == -1 && children > 1)\\n      res = true;\\n  }\\n\\npublic:\\n  int minDays(vector<vector<int>> &grid) {\\n    int m = grid.size(), n = grid[0].size();\\n\\n    vec<vec<bool>> vis(m, vec<bool>(n));\\n    vec<vec<vec<pii>>> adj(m, vec<vec<pii>>(n));\\n    deque<pii> s;\\n    int is = INF, js = INF, islands = 0, lands = 0;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          lands++;\\n          if (!vis[i][j]) {\\n            islands++;\\n            if (islands == 2)\\n              return 0;\\n            deque<pii> q;\\n            q.push_back({i, j});\\n            vis[i][j] = true;\\n            is = i;\\n            js = j;\\n            while (!q.empty()) {\\n              auto [i2, j2] = q.front();\\n              q.pop_front();\\n              for (int k = 0; k < 4; k++) {\\n                int i3 = i2 + dx[k];\\n                int j3 = j2 + dy[k];\\n                if (valid(i3, j3, m, n) && grid[i3][j3] == 1 && !vis[i3][j3]) {\\n                  vis[i3][j3] = true;\\n                  q.push_back({i3, j3});\\n                }\\n              }\\n            }\\n          }\\n          for (int k = 0; k < 4; k++) {\\n            int i2 = i + dx[k];\\n            int j2 = j + dy[k];\\n            if (valid(i2, j2, m, n) && grid[i2][j2] == 1)\\n              adj[i][j].push_back({i2, j2});\\n          }\\n        }\\n      }\\n    }\\n    if (lands < 3)\\n      return lands;\\n    dbg(adj, is, js);\\n\\n    vec<vec<int>> disc(m, vec<int>(n));\\n    vec<vec<int>> low(m, vec<int>(n));\\n    bool res = false;\\n    dfs(grid, adj, vis, disc, low, -1, -1, is, js, 1, res);\\n    dbg(res);\\n    if (res)\\n      return 1;\\n\\n    int ans = INF;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] != 1)\\n          continue;\\n        int res = INF, vertical = INF, horizontal = INF, slice = INF;\\n        if (i > 0 && i < m - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = j - 1; k >= 0 && grid[i][k] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = j + 1; k < n && grid[i][k] == 1; k++, r++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            horizontal = l + r + 1;\\n        }\\n        if (j > 0 && j < n - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = i - 1; k >= 0 && grid[k][j] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = i + 1; k < m && grid[k][j] == 1; k++, l++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            vertical = l + r + 1;\\n        }\\n        int l = 0, r = 0;\\n        bool cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2--, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2++, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        l = 0, r = 0;\\n        cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2++, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2--, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        ans = min({ans, horizontal, vertical, slice});\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n// ----- CHANGE FOR PROBLEM -----\\n\\n#ifdef LC_LOCAL\\nint main() {\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  exec(&Solution::minDays); // CHANGE FOR PROBLEM\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n#define _CRT_SECURE_NO_WARNINGS\\n#include <algorithm>\\n#include <array>\\n#include <charconv>\\n#include <cstring>\\n#include <functional>\\n#include <iomanip>\\n#include <iostream>\\n#include <list>\\n#include <map>\\n#include <numeric>\\n#include <queue>\\n#include <random>\\n#include <set>\\n#include <stack>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <utility>\\n#include <vector>\\nusing namespace std;\\n\\n#ifdef LC_LOCAL\\nstruct TreeNode {\\n  int val;\\n  TreeNode *left = nullptr;\\n  TreeNode *right = nullptr;\\n};\\nstruct ListNode {\\n  int val;\\n  ListNode *next = nullptr;\\n};\\n#endif\\n\\ntemplate <typename T, typename = void> struct is_container {\\n  static constexpr bool value = false;\\n};\\ntemplate <typename T>\\nstruct is_container<T, void_t<decltype(T{}.begin()), decltype(T{}.end())>> {\\n  static constexpr bool value = true;\\n};\\ntemplate <typename = void> inline constexpr bool always_false = false;\\n\\ntemplate <typename T, bool ReadEnd> T parse(FILE *f, int &c) {\\n  if constexpr (is_same_v<T, int>) {\\n    int ans = 0, neg = 0;\\n    while ((char(c = fgetc(f)) >= \\'0\\' && (char)c <= \\'9\\') || (char)c == \\'-\\') {\\n      if ((char)c == \\'-\\')\\n        neg = 1;\\n      else\\n        ans = ans * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n    }\\n    if constexpr (!ReadEnd)\\n      ungetc(c, f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, string>) {\\n    string ans;\\n    fgetc(f);\\n    while (char(c = fgetc(f)) != \\'\"\\')\\n      ans += (char)c;\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, TreeNode *>) {\\n    int e = 2;\\n    auto dummy = new TreeNode{};\\n    deque<TreeNode *> q;\\n    q.push_back(dummy);\\n    fgetc(f);\\n    while ((char)c != \\']\\') {\\n      int sz = q.size();\\n      while (sz > 0) {\\n        int val = 0, neg = 0;\\n        bool is_null = false;\\n        while (char(c = fgetc(f)) != \\',\\' && (char)c != \\']\\') {\\n          if ((char)c >= \\'0\\' && (char)c <= \\'9\\')\\n            val = val * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n          else if ((char)c == \\'-\\')\\n            neg = 1;\\n          else\\n            is_null = true;\\n        }\\n        if (!is_null) {\\n          auto new_node = new TreeNode{val};\\n          if (e & 1)\\n            q[0]->left = new_node;\\n          else\\n            q[0]->right = new_node;\\n          q.push_back(new_node);\\n        }\\n        if (e++ % 2 == 0) {\\n          q.pop_front();\\n          sz--;\\n        }\\n      }\\n      e = 1;\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->right;\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    auto dummy = new ListNode{};\\n    auto cur = dummy;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\') {\\n        cur->next = new ListNode{parse<int, true>(f, c)};\\n        cur = cur->next;\\n      }\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->next;\\n  } else if constexpr (is_container<T>::value) {\\n    T ans;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\')\\n        ans.emplace_back(parse<typename T::value_type, true>(f, c));\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else\\n    static_assert(always_false<T>, \"parsing for type not supported\");\\n}\\n\\ntemplate <bool WriteEnd, typename T> void write(FILE *f, const T &val) {\\n  static constexpr const char *end = WriteEnd ? \"\\\\n\" : \"\";\\n  if constexpr (is_same_v<T, int>)\\n    fprintf(f, \"%d%s\", val, end);\\n  else if constexpr (is_same_v<T, float>)\\n    fprintf(f, \"%.f%s\", val, end);\\n  else if constexpr (is_same_v<T, bool>)\\n    fprintf(f, \"%s%s\", val ? \"true\" : \"false\", end);\\n  else if constexpr (is_same_v<T, string>)\\n    fprintf(f, \"\\\\\"%s\\\\\"%s\", val.data(), end);\\n  else if constexpr (is_same_v<T, TreeNode *>) {\\n    deque<TreeNode *> q;\\n    fprintf(f, \"[\");\\n    if (val) {\\n      q.push_back(val);\\n      fprintf(f, \"%d\", val->val);\\n    }\\n    while (!q.empty()) {\\n      int sz = q.size();\\n      string ans;\\n      while (sz-- > 0) {\\n        auto cur = q.front();\\n        q.pop_front();\\n        if (cur->left) {\\n          q.push_back(cur->left);\\n          ans += \\',\\';\\n          ans += to_string(cur->left->val);\\n        } else\\n          ans += \",null\";\\n        if (cur->right) {\\n          q.push_back(cur->right);\\n          ans += \\',\\';\\n          ans += to_string(cur->right->val);\\n        } else\\n          ans += \",null\";\\n      }\\n      if (!q.empty())\\n        fprintf(f, ans.data());\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    int c = 0;\\n    auto cur = val;\\n    fprintf(f, \"[\");\\n    while (cur) {\\n      fprintf(f, \"%s%d\", c++ ? \",\" : \"\", cur->val);\\n      cur = cur->next;\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_container<T>::value) {\\n    fprintf(f, \"[\");\\n    int c = 0;\\n    for (int i = 0; i < val.size(); i++) {\\n      fprintf(f, \"%s\", c++ ? \",\" : \"\");\\n      write<false>(f, val[i]);\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else\\n    static_assert(always_false<T>, \"writing for type not supported\");\\n}\\n\\ntemplate <typename Args, size_t... Idx>\\nvoid write_args(FILE *f, const Args &args, index_sequence<Idx...>) {\\n  ((fprintf(f, \"#%lld: \", Idx + 1), write<true>(f, get<Idx + 1>(args))), ...);\\n}\\n\\ntemplate <typename Solution, typename R, typename... Ts>\\nvoid exec(R (Solution::*fn)(Ts...)) {\\n  constexpr bool returns = !is_same_v<R, void>;\\n  auto out = fopen(\"output.txt\", \"w\");\\n  if constexpr (sizeof...(Ts) == 0) {\\n    if constexpr (returns) {\\n      write<true>(out, (Solution{}.*fn)());\\n    } else\\n      (Solution{}.*fn)();\\n  } else {\\n    auto in = fopen(\"input.txt\", \"r\");\\n    int c = fgetc(in);\\n    if (c == EOF) {\\n      fclose(in);\\n      return;\\n    } else\\n      ungetc(c, in);\\n    while (true) {\\n      if (char(c = fgetc(in)) == EOF)\\n        break;\\n      else\\n        ungetc(c, in);\\n      if (char(c = fgetc(in)) == \\'/\\') {\\n        while ((c = fgetc(in)) != \\'\\\\n\\' && c != EOF) {\\n        }\\n      } else {\\n        ungetc(c, in);\\n        tuple args{Solution{}, parse<decay_t<Ts>, true>(in, c)...};\\n        if constexpr (!returns) {\\n          apply(fn, args);\\n          fprintf(out, \"New state of parameters:\\\\n\");\\n          write_args(out, args, index_sequence_for<Ts...>{});\\n        } else\\n          write<true>(out, apply(fn, args));\\n#ifdef LC_LOCAL\\n        cout << endl;\\n#endif\\n      }\\n    }\\n    fclose(in);\\n  }\\n  fclose(out);\\n}\\n\\nvoid _print(const string &x) { cout << \\'\\\\\"\\' << x << \\'\\\\\"\\'; }\\nvoid _print(bool x) { cout << (x ? \"true\" : \"false\"); }\\ntemplate <typename T> enable_if_t<is_arithmetic_v<T>> _print(const T &x) {\\n  cout << x;\\n}\\ntemplate <typename T, size_t... Idx>\\nvoid _print2(const T &x, index_sequence<Idx...>) {\\n  int c = 0;\\n  ((cout << (c++ ? \",\" : \"\"), _print(get<Idx>(x))), ...);\\n}\\ntemplate <typename T> void_t<typename tuple_size<T>::type> _print(const T &x) {\\n  cout << \\'{\\';\\n  _print2(x, make_index_sequence<tuple_size_v<T>>{});\\n  cout << \\'}\\';\\n}\\ntemplate <typename T> enable_if_t<is_container<T>::value> _print(const T &x) {\\n  cout << \\'[\\';\\n  int c = 0;\\n  for (const auto &e : x) {\\n    cout << (c++ ? \",\" : \"\");\\n    _print(e);\\n  }\\n  cout << \\']\\';\\n}\\n\\n#define CONCAT_IMPL(x, y) x##y\\n#define CONCAT(x, y) CONCAT_IMPL(x, y)\\n#define NUM_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\\n#define NUM_ARGS(...) NUM_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\\n#define DBG_VAL(x) cout << \\'[\\' << #x << \" = \", _print(x), cout << \"] \"\\n#define DBG_1(x) DBG_VAL(x)\\n#define DBG_2(x, ...) DBG_VAL(x), DBG_1(__VA_ARGS__)\\n#define DBG_3(x, ...) DBG_VAL(x), DBG_2(__VA_ARGS__)\\n#define DBG_4(x, ...) DBG_VAL(x), DBG_3(__VA_ARGS__)\\n#define DBG_5(x, ...) DBG_VAL(x), DBG_4(__VA_ARGS__)\\n#define DBG_6(x, ...) DBG_VAL(x), DBG_5(__VA_ARGS__)\\n#define DBG_7(x, ...) DBG_VAL(x), DBG_6(__VA_ARGS__)\\n#define DBG_8(x, ...) DBG_VAL(x), DBG_7(__VA_ARGS__)\\n#define DBG_9(x, ...) DBG_VAL(x), DBG_8(__VA_ARGS__)\\n#define DBG_10(x, ...) DBG_VAL(x), DBG_9(__VA_ARGS__)\\n// supports up to 10 arguments debugging at one time\\n\\n#ifdef LC_LOCAL\\n#define dbg(...) CONCAT(DBG_, NUM_ARGS(__VA_ARGS__))(__VA_ARGS__), cout << endl\\n#else\\n#define dbg(...)\\n#endif\\n\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define umap unordered_map\\n#define uset unordered_set\\n#define vec vector\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nnamespace std {\\ntemplate <typename T> class hash<std::pair<T, T>> {\\npublic:\\n  size_t operator()(const pair<T, T> &x) const {\\n    // https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\\n    ll lhs = hash<T>()(x.first), rhs = hash<T>()(x.second);\\n    lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);\\n    return lhs;\\n  }\\n};\\n} // namespace std\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\n// ----- CHANGE FOR PROBLEM -----\\nclass Solution {\\n\\n  void dfs(vec<vec<int>> &grid, vec<vec<vec<pii>>> &adj, vec<vec<bool>> &vis,\\n           vec<vec<int>> &disc, vec<vec<int>> &low, int ip, int jp, int i,\\n           int j, int time, bool &res) {\\n    int children = 0;\\n    disc[i][j] = low[i][j] = time;\\n    vis[i][j] = false;\\n\\n    for (auto [i2, j2] : adj[i][j]) {\\n      if (vis[i2][j2]) {\\n        children++;\\n        dfs(grid, adj, vis, disc, low, i, j, i2, j2, time + 1, res);\\n        amin(low[i][j], low[i2][j2]);\\n        if (ip != -1 && jp != -1 && low[i2][j2] >= disc[i][j])\\n          res = true;\\n      } else if (i2 != ip || j2 != jp)\\n        amin(low[i][j], disc[i2][j2]);\\n    }\\n    if (ip == -1 && jp == -1 && children > 1)\\n      res = true;\\n  }\\n\\npublic:\\n  int minDays(vector<vector<int>> &grid) {\\n    int m = grid.size(), n = grid[0].size();\\n\\n    vec<vec<bool>> vis(m, vec<bool>(n));\\n    vec<vec<vec<pii>>> adj(m, vec<vec<pii>>(n));\\n    deque<pii> s;\\n    int is = INF, js = INF, islands = 0, lands = 0;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          lands++;\\n          if (!vis[i][j]) {\\n            islands++;\\n            if (islands == 2)\\n              return 0;\\n            deque<pii> q;\\n            q.push_back({i, j});\\n            vis[i][j] = true;\\n            is = i;\\n            js = j;\\n            while (!q.empty()) {\\n              auto [i2, j2] = q.front();\\n              q.pop_front();\\n              for (int k = 0; k < 4; k++) {\\n                int i3 = i2 + dx[k];\\n                int j3 = j2 + dy[k];\\n                if (valid(i3, j3, m, n) && grid[i3][j3] == 1 && !vis[i3][j3]) {\\n                  vis[i3][j3] = true;\\n                  q.push_back({i3, j3});\\n                }\\n              }\\n            }\\n          }\\n          for (int k = 0; k < 4; k++) {\\n            int i2 = i + dx[k];\\n            int j2 = j + dy[k];\\n            if (valid(i2, j2, m, n) && grid[i2][j2] == 1)\\n              adj[i][j].push_back({i2, j2});\\n          }\\n        }\\n      }\\n    }\\n    if (lands < 3)\\n      return lands;\\n    dbg(adj, is, js);\\n\\n    vec<vec<int>> disc(m, vec<int>(n));\\n    vec<vec<int>> low(m, vec<int>(n));\\n    bool res = false;\\n    dfs(grid, adj, vis, disc, low, -1, -1, is, js, 1, res);\\n    dbg(res);\\n    if (res)\\n      return 1;\\n\\n    int ans = INF;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] != 1)\\n          continue;\\n        int res = INF, vertical = INF, horizontal = INF, slice = INF;\\n        if (i > 0 && i < m - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = j - 1; k >= 0 && grid[i][k] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = j + 1; k < n && grid[i][k] == 1; k++, r++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            horizontal = l + r + 1;\\n        }\\n        if (j > 0 && j < n - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = i - 1; k >= 0 && grid[k][j] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = i + 1; k < m && grid[k][j] == 1; k++, l++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            vertical = l + r + 1;\\n        }\\n        int l = 0, r = 0;\\n        bool cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2--, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2++, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        l = 0, r = 0;\\n        cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2++, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2--, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        ans = min({ans, horizontal, vertical, slice});\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n// ----- CHANGE FOR PROBLEM -----\\n\\n#ifdef LC_LOCAL\\nint main() {\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  exec(&Solution::minDays); // CHANGE FOR PROBLEM\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1803634,
                "title": "dfs-solution",
                "content": "Answer can only be 0, 1 or 2\\nCase1: If there are more than 1 islands on initial grid -> 0\\nCase2: If by changing one grid item from 1 to 0, two islands are formed -> 1\\nCase3: Else -> 2\\n\\nSteps -\\n1. Count islands\\n2. If Case1 -> 0\\n3. Else check for Case2. Loop through grid and for each 1, convert to 0. This takes one day. Use countIslands to check if more than 1 island is formed. If true return 1, else convert the position back to 1 and continue the loop\\n4. Else it\\'s Case3 -> 2\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    if(countIslands(grid) !== 1) return 0\\n    \\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            if(grid[r][c]) {\\n                grid[r][c] = 0\\n                if(countIslands(grid) !== 1) return 1\\n                grid[r][c] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2\\n};\\n\\nfunction getKey(i, j) {\\n    return `${i}-${j}`\\n}\\n\\nfunction countIslands(grid) {\\n    const visited = new Set()\\n    let islands  = 0\\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            const key = getKey(r, c)\\n            if(grid[r][c] && !visited.has(key)) {\\n                islands++\\n                dfs(grid, r, c, visited)\\n            }\\n        }\\n    }\\n    \\n    return islands\\n}\\n\\nfunction dfs(grid, r, c, visited) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    if(isValid(grid, r, c, visited)) {\\n        const key = getKey(r, c)\\n        visited.add(key)\\n        for(const [dx, dy] of dir) {\\n            dfs(grid, r + dx, c + dy, visited)\\n        }\\n    }\\n}\\n\\nfunction isValid(grid, r, c, visited) {\\n    const key = getKey(r, c)\\n    if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] && !visited.has(key)) return true\\n       \\n     return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    if(countIslands(grid) !== 1) return 0\\n    \\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            if(grid[r][c]) {\\n                grid[r][c] = 0\\n                if(countIslands(grid) !== 1) return 1\\n                grid[r][c] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2\\n};\\n\\nfunction getKey(i, j) {\\n    return `${i}-${j}`\\n}\\n\\nfunction countIslands(grid) {\\n    const visited = new Set()\\n    let islands  = 0\\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            const key = getKey(r, c)\\n            if(grid[r][c] && !visited.has(key)) {\\n                islands++\\n                dfs(grid, r, c, visited)\\n            }\\n        }\\n    }\\n    \\n    return islands\\n}\\n\\nfunction dfs(grid, r, c, visited) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    if(isValid(grid, r, c, visited)) {\\n        const key = getKey(r, c)\\n        visited.add(key)\\n        for(const [dx, dy] of dir) {\\n            dfs(grid, r + dx, c + dy, visited)\\n        }\\n    }\\n}\\n\\nfunction isValid(grid, r, c, visited) {\\n    const key = getKey(r, c)\\n    if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] && !visited.has(key)) return true\\n       \\n     return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713905,
                "title": "c-tarjan-s-algorithm-81-faster-24-ms",
                "content": "```\\n    int time;\\n    int rootCalls;\\n    \\n    void dfs(vector<vector<int>> &gr, int u , int par, vector<int> &disc,vector<int> &low,vector<bool> &vis, vector<bool> &AP)\\n    {\\n        disc[u] = low[u] = time++;\\n        \\n        vis[u] = true;\\n        \\n        for(int v : gr[u])\\n        {\\n            if(!vis[v])\\n            {\\n                \\n                if(par == -1)\\n                    rootCalls++;\\n                \\n                dfs(gr, v , u, disc, low, vis, AP);\\n                if(disc[u] <= low[v])\\n                {\\n                    AP[u] = true;\\n                }\\n                \\n                low[u] = min(low[u], low[v]);\\n                \\n            }\\n            else if(v != par)\\n            {\\n                low[u] = min(low[u], disc[v]);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> gr(n * m);\\n        vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int OneCnt = 0;\\n        \\n        //Make Graph \\n        //Each grid is numbered as (i * m + j)\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    OneCnt++;\\n                    int num1 = j + i * m;\\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        int x = i + dir[k][0], y = j + dir[k][1];\\n                        if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y] == 1)\\n                        {\\n                            int num2 = y + x * m;\\n                            gr[num1].push_back(num2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> disc(n * m), low(n * m);\\n        vector<bool> vis(n * m, false), AP(n * m, false);\\n        int x = 0;\\n        time = 0;\\n\\n        \\n        \\n        //Run Normal Trajan\\'s Algorithm\\n        for(int i = 0; i < n * m; i++)\\n        {\\n            rootCalls = 0;\\n            int r = i / m;\\n            int c = i % m;\\n            if(!vis[i] && grid[r][c] == 1)\\n            {\\n                dfs(gr, i , -1, disc, low, vis, AP);\\n                x++;\\n            }\\n            if(rootCalls == 1)\\n            {\\n                AP[i] = false;\\n            }\\n            \\n        }\\n        \\n        \\n        // if x > 1 means that components were disconnected from beginning\\n        if(x > 1)\\n        {\\n            return 0;\\n        }\\n        \\n        //check if there is one vertex(grid) such that it is critical/ Articulation point\\n        for(int z : AP)\\n        {\\n            if(z)return 1;\\n        }\\n        \\n        //Handle the corner cases\\n        if(OneCnt == 0)\\n        {\\n            return 0;\\n        }\\n        if(OneCnt == 1)\\n            return 1;\\n\\n        \\n        return 2;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n    int time;\\n    int rootCalls;\\n    \\n    void dfs(vector<vector<int>> &gr, int u , int par, vector<int> &disc,vector<int> &low,vector<bool> &vis, vector<bool> &AP)\\n    {\\n        disc[u] = low[u] = time++;\\n        \\n        vis[u] = true;\\n        \\n        for(int v : gr[u])\\n        {\\n            if(!vis[v])\\n            {\\n                \\n                if(par == -1)\\n                    rootCalls++;\\n                \\n                dfs(gr, v , u, disc, low, vis, AP);\\n                if(disc[u] <= low[v])\\n                {\\n                    AP[u] = true;\\n                }\\n                \\n                low[u] = min(low[u], low[v]);\\n                \\n            }\\n            else if(v != par)\\n            {\\n                low[u] = min(low[u], disc[v]);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> gr(n * m);\\n        vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int OneCnt = 0;\\n        \\n        //Make Graph \\n        //Each grid is numbered as (i * m + j)\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    OneCnt++;\\n                    int num1 = j + i * m;\\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        int x = i + dir[k][0], y = j + dir[k][1];\\n                        if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y] == 1)\\n                        {\\n                            int num2 = y + x * m;\\n                            gr[num1].push_back(num2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> disc(n * m), low(n * m);\\n        vector<bool> vis(n * m, false), AP(n * m, false);\\n        int x = 0;\\n        time = 0;\\n\\n        \\n        \\n        //Run Normal Trajan\\'s Algorithm\\n        for(int i = 0; i < n * m; i++)\\n        {\\n            rootCalls = 0;\\n            int r = i / m;\\n            int c = i % m;\\n            if(!vis[i] && grid[r][c] == 1)\\n            {\\n                dfs(gr, i , -1, disc, low, vis, AP);\\n                x++;\\n            }\\n            if(rootCalls == 1)\\n            {\\n                AP[i] = false;\\n            }\\n            \\n        }\\n        \\n        \\n        // if x > 1 means that components were disconnected from beginning\\n        if(x > 1)\\n        {\\n            return 0;\\n        }\\n        \\n        //check if there is one vertex(grid) such that it is critical/ Articulation point\\n        for(int z : AP)\\n        {\\n            if(z)return 1;\\n        }\\n        \\n        //Handle the corner cases\\n        if(OneCnt == 0)\\n        {\\n            return 0;\\n        }\\n        if(OneCnt == 1)\\n            return 1;\\n\\n        \\n        return 2;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659083,
                "title": "java-solution-with-tarjan-algorithm-to-find-articulation-point",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int minDays(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m*n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if(articulationPoints.size()>0)hasArticulationPoint = true;\\n                }\\n            }\\n        }\\n        \\n        if(numOfIslands>=2)return 0;\\n        if(numOfIslands==0)return 0;\\n        if(numOfIslands==1 && minIslandSize == 1)return 1;\\n        return hasArticulationPoint ? 1  : 2;\\n    }\\n    \\n    public void tarjan(int x, int y, int prex, int prey, int time, int[][] times, int[][] lows, int[][] grid, List<Integer> articulationPoints, int color, int[] islandSize)\\n    {\\n        boolean log = false;\\n        if(x==1&&y==1)log = true;\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for(int[] dir : dirs)\\n        {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if(nx<0||ny<0||nx>=grid.length||ny>=grid[0].length)\\n            {\\n                continue;\\n            }\\n            \\n            if(grid[nx][ny]==1)\\n            {\\n                children++;\\n                tarjan(nx,ny,x,y,time+1,times,lows,grid,articulationPoints,color,islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                // Diff from detecting bridge: \\n                // Detecting bridge: lows[nx][ny]>times[x][y]\\n                // Detecting articulation point: lows[nx][ny]>=times[x][y]\\n                // and articulation point also requires check on if curnode is root node\\n                // if is root node, and there are more than 1 independent children, then it\\'s articulation point.\\n                // if is not root node, then check: lows[nx][ny]>=times[x][y]\\n                if(prex != -1 && lows[nx][ny]>=time)\\n                {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            }\\n            else if((nx!=prex||ny!=prey) && grid[nx][ny]!=0)\\n            {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        \\n        if(prex==-1 && children > 1)\\n        {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int minDays(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m*n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if(articulationPoints.size()>0)hasArticulationPoint = true;\\n                }\\n            }\\n        }\\n        \\n        if(numOfIslands>=2)return 0;\\n        if(numOfIslands==0)return 0;\\n        if(numOfIslands==1 && minIslandSize == 1)return 1;\\n        return hasArticulationPoint ? 1  : 2;\\n    }\\n    \\n    public void tarjan(int x, int y, int prex, int prey, int time, int[][] times, int[][] lows, int[][] grid, List<Integer> articulationPoints, int color, int[] islandSize)\\n    {\\n        boolean log = false;\\n        if(x==1&&y==1)log = true;\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for(int[] dir : dirs)\\n        {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if(nx<0||ny<0||nx>=grid.length||ny>=grid[0].length)\\n            {\\n                continue;\\n            }\\n            \\n            if(grid[nx][ny]==1)\\n            {\\n                children++;\\n                tarjan(nx,ny,x,y,time+1,times,lows,grid,articulationPoints,color,islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                // Diff from detecting bridge: \\n                // Detecting bridge: lows[nx][ny]>times[x][y]\\n                // Detecting articulation point: lows[nx][ny]>=times[x][y]\\n                // and articulation point also requires check on if curnode is root node\\n                // if is root node, and there are more than 1 independent children, then it\\'s articulation point.\\n                // if is not root node, then check: lows[nx][ny]>=times[x][y]\\n                if(prex != -1 && lows[nx][ny]>=time)\\n                {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            }\\n            else if((nx!=prex||ny!=prey) && grid[nx][ny]!=0)\\n            {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        \\n        if(prex==-1 && children > 1)\\n        {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655254,
                "title": "go-modularized-solution-with-dfs",
                "content": "Prior to solving this problem, I recommend checking the following two problems first:\\n\\n*  [Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n*  [Critical Connections in a Network](https://leetcode.com/problems/critical-connections-in-a-network/)\\n\\nBellow are the steps to a full implementation:\\n\\n1. Find the number of islands `numIslands`.\\n2. If `numIslands != 1`, we already have disconnected islands, so return 0.\\n3. Find number of lands `numLands` (grid cells with value 1). Obviously, `numLands > 0`.\\n4. If `numLands == 1` return 1. (Just remove the land).\\n5. If `numLands == 2` return 2. (Remove both lands).\\n6. Now, we just a new graph problem: Consider land cells as nodes and their connection to adjacent lands as edges. The problem is now to find if the graph has a bridge.\\n7. If the graph has a bridge, return 1. (Just remove the bridge and get two connected components).\\n8. Else, return 2. (We can always remove two edges to increase the number of connected components.\\n\\nThe algorithm has `O(mn)` time and space complexity, where `m x n` is the grid size.\\n\\n```\\nfunc minDays(grid [][]int) int {\\n    numIslands := findNumIslands(grid)\\n    if numIslands != 1 {\\n        return 0\\n    }\\n    numLands := findNumLands(grid)\\n    if numLands < 3 {\\n        return numLands\\n    }\\n    if hasBridge(grid) {\\n        return 1\\n    }\\n    return 2\\n}\\n\\nfunc findNumIslands(grid [][]int) int  {\\n    ans := 0\\n    visited := make([][]bool, len(grid))\\n    for i := range grid {\\n        visited[i] = make([]bool, len(grid[i]))\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 && !visited[i][j] {\\n                ans++\\n                dfs(grid, i, j, visited)\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(grid [][]int, i, j int, visited [][]bool) {\\n    visited[i][j] = true\\n    dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n    for _, dir := range dirs {\\n        x, y := i+dir[0], j+dir[1]\\n        if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n            continue\\n        }\\n        if grid[x][y] == 0 || visited[x][y] {\\n            continue\\n        }\\n        dfs(grid, x, y, visited)\\n    }\\n}\\n\\nfunc findNumLands(grid [][]int) int {\\n    ans := 0\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc hasBridge(grid [][]int) bool {\\n    adj := makeAdj(grid)\\n    disc := map[int]int{}\\n    low := map[int]int{}\\n    var first int\\n    for k := range adj {\\n        first = k\\n        break\\n    }\\n    node, parent, time := first, -1, 1\\n    return bridgeDfs(node, parent, time, adj, disc, low)\\n}\\n\\nfunc bridgeDfs(node, parent, time int, adj map[int][]int, disc, low map[int]int) bool {\\n    disc[node] = time\\n    low[node] = time\\n    for _, next := range adj[node] {\\n        if next == parent {\\n            continue\\n        }\\n        if disc[next] == 0 {\\n            if bridgeDfs(next, node, time+1, adj, disc, low) {\\n                return true\\n            }\\n            low[node] = min(low[node], low[next])\\n            if low[next] > disc[node] {\\n                return true\\n            }\\n        } else {\\n            low[node] = min(low[node], disc[next])\\n        }\\n    }\\n    return false\\n}\\n\\nfunc makeAdj(grid [][]int) map[int][]int {\\n    ans := map[int][]int{}\\n    for i := range grid {\\n        n := len(grid[i])\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n                for _, dir := range dirs {\\n                    x, y := i+dir[0], j+dir[1]\\n                    if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n                        continue\\n                    }\\n                    if grid[x][y] == 1 {\\n                        ans[i*n+j] = append(ans[i*n+j], x*n+y)\\n                    }\\n                }                \\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfunc minDays(grid [][]int) int {\\n    numIslands := findNumIslands(grid)\\n    if numIslands != 1 {\\n        return 0\\n    }\\n    numLands := findNumLands(grid)\\n    if numLands < 3 {\\n        return numLands\\n    }\\n    if hasBridge(grid) {\\n        return 1\\n    }\\n    return 2\\n}\\n\\nfunc findNumIslands(grid [][]int) int  {\\n    ans := 0\\n    visited := make([][]bool, len(grid))\\n    for i := range grid {\\n        visited[i] = make([]bool, len(grid[i]))\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 && !visited[i][j] {\\n                ans++\\n                dfs(grid, i, j, visited)\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(grid [][]int, i, j int, visited [][]bool) {\\n    visited[i][j] = true\\n    dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n    for _, dir := range dirs {\\n        x, y := i+dir[0], j+dir[1]\\n        if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n            continue\\n        }\\n        if grid[x][y] == 0 || visited[x][y] {\\n            continue\\n        }\\n        dfs(grid, x, y, visited)\\n    }\\n}\\n\\nfunc findNumLands(grid [][]int) int {\\n    ans := 0\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc hasBridge(grid [][]int) bool {\\n    adj := makeAdj(grid)\\n    disc := map[int]int{}\\n    low := map[int]int{}\\n    var first int\\n    for k := range adj {\\n        first = k\\n        break\\n    }\\n    node, parent, time := first, -1, 1\\n    return bridgeDfs(node, parent, time, adj, disc, low)\\n}\\n\\nfunc bridgeDfs(node, parent, time int, adj map[int][]int, disc, low map[int]int) bool {\\n    disc[node] = time\\n    low[node] = time\\n    for _, next := range adj[node] {\\n        if next == parent {\\n            continue\\n        }\\n        if disc[next] == 0 {\\n            if bridgeDfs(next, node, time+1, adj, disc, low) {\\n                return true\\n            }\\n            low[node] = min(low[node], low[next])\\n            if low[next] > disc[node] {\\n                return true\\n            }\\n        } else {\\n            low[node] = min(low[node], disc[next])\\n        }\\n    }\\n    return false\\n}\\n\\nfunc makeAdj(grid [][]int) map[int][]int {\\n    ans := map[int][]int{}\\n    for i := range grid {\\n        n := len(grid[i])\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n                for _, dir := range dirs {\\n                    x, y := i+dir[0], j+dir[1]\\n                    if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n                        continue\\n                    }\\n                    if grid[x][y] == 1 {\\n                        ans[i*n+j] = append(ans[i*n+j], x*n+y)\\n                    }\\n                }                \\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653252,
                "title": "java-tarjan-s-algo-to-detect-bridge-o-mn-easy-to-understand",
                "content": "Observations for the problems\\n- when number of island are more than 1, it is already disconnected. Answer is 0.\\n- When number of islands is 0, then already no land. Answer is 0.\\n- When number of islands is 1, then we have check if any bridge exists i.e. if a edge is removed from the graph, then graph becomes disconnected, such edge is called bridge.\\n\\nWe can find the bridge edge by using Tarjan\\'s algorithm to detect Articulation point or bridge. Only problem here is to construct a graph to implement tarjan\\'s alrogithm on it.\\nSo, we first build the graph, and then apply standard Tarjan\\'s algorithm to detect the bridge edge. If we find the bridge edge, then answer is 1, else 2.\\n\\n```\\nclass Solution {\\n    \\n    int nodes;\\n    int N;\\n    int M;\\n    \\n    Map<Integer, List<Integer>> adjList;\\n    boolean bridgeFound = false;\\n    \\n    int root = -1;\\n    \\n    public int minDays(int[][] grid) {\\n        \\n        N = grid.length;\\n        M = grid[0].length;\\n        \\n        adjList = new HashMap<>();\\n        \\n        boolean[][] visited = new boolean[N][M];\\n        int islands = numOfIsland(grid, visited);\\n        \\n        if(islands != 1) return 0;\\n        if(nodes == 1) return 1;\\n        if(nodes==2) return 2;\\n        \\n        buildGraph(grid);\\n        \\n        Map<Integer, Integer> low = new HashMap<>();\\n        Set<Integer> visited2 = new HashSet<>();\\n        tarjan(low, visited2, -1, root, 0);\\n\\t\\t\\n        if(bridgeFound) return 1;\\n        return 2;\\n        \\n    }\\n    \\n    void tarjan(Map<Integer, Integer> low, Set<Integer> visited, int parent, int vertex, int time) {\\n        visited.add(vertex);\\n        low.put(vertex, time);\\n        \\n        for(int t: adjList.get(vertex)){\\n            if(t==parent) continue;\\n            if(!visited.contains(t)) {\\n                tarjan(low, visited, vertex, t, time+1);\\n            }\\n            low.put(vertex, Math.min(low.get(vertex), low.get(t)));\\n            if(time < low.get(t)) {\\n                bridgeFound = true;\\n            }\\n        }\\n        \\n    }\\n    \\n    void buildGraph(int[][] grid) {\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    if(i-1>=0) addEdge(i, j, i-1, j, grid);\\n                    if(i+1<grid.length) addEdge(i, j, i+1, j, grid);\\n                    if(j-1>=0) addEdge(i, j, i, j-1, grid);\\n                    if(j+1<grid[0].length) addEdge(i, j, i, j+1, grid);\\n                    \\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(int prevX, int prevY, int x, int y, int[][] grid){\\n        if(grid[x][y] == 0) return;\\n        int u = prevX * M + prevY;\\n        int v = x*M + y;\\n        \\n        if(!adjList.containsKey(u)) adjList.put(u, new ArrayList<>());\\n        if(!adjList.containsKey(v)) adjList.put(v, new ArrayList<>());\\n        \\n        adjList.get(u).add(v);\\n        adjList.get(v).add(u);\\n    }\\n    \\n    int numOfIsland(int[][] grid, boolean[][] visited) {\\n        int islandCount = 0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++) {\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    if(root == -1) root = i*M + j;\\n                    \\n                    islandCount++;\\n                    dfs(grid, i, j, visited);\\n                    \\n                }\\n            }\\n        }\\n        return islandCount;\\n        \\n    }\\n    \\n    void dfs(int[][] grid, int i, int j, boolean[][] visited){\\n        if(visited[i][j]) return;\\n        if(grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        nodes++;    \\n        \\n        if(i-1>=0) dfs(grid, i-1, j, visited);\\n        if(i+1<grid.length) dfs(grid, i+1, j, visited);\\n        if(j-1>=0) dfs(grid, i, j-1, visited);\\n        if(j+1<grid[0].length) dfs(grid, i, j+1, visited);\\n    }\\n}\\n```\\n\\nTime Complexity: O(N*M)\\nThis can optimised more in term of space complexity, but didn\\'t for sake of easy understanding.",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int nodes;\\n    int N;\\n    int M;\\n    \\n    Map<Integer, List<Integer>> adjList;\\n    boolean bridgeFound = false;\\n    \\n    int root = -1;\\n    \\n    public int minDays(int[][] grid) {\\n        \\n        N = grid.length;\\n        M = grid[0].length;\\n        \\n        adjList = new HashMap<>();\\n        \\n        boolean[][] visited = new boolean[N][M];\\n        int islands = numOfIsland(grid, visited);\\n        \\n        if(islands != 1) return 0;\\n        if(nodes == 1) return 1;\\n        if(nodes==2) return 2;\\n        \\n        buildGraph(grid);\\n        \\n        Map<Integer, Integer> low = new HashMap<>();\\n        Set<Integer> visited2 = new HashSet<>();\\n        tarjan(low, visited2, -1, root, 0);\\n\\t\\t\\n        if(bridgeFound) return 1;\\n        return 2;\\n        \\n    }\\n    \\n    void tarjan(Map<Integer, Integer> low, Set<Integer> visited, int parent, int vertex, int time) {\\n        visited.add(vertex);\\n        low.put(vertex, time);\\n        \\n        for(int t: adjList.get(vertex)){\\n            if(t==parent) continue;\\n            if(!visited.contains(t)) {\\n                tarjan(low, visited, vertex, t, time+1);\\n            }\\n            low.put(vertex, Math.min(low.get(vertex), low.get(t)));\\n            if(time < low.get(t)) {\\n                bridgeFound = true;\\n            }\\n        }\\n        \\n    }\\n    \\n    void buildGraph(int[][] grid) {\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    if(i-1>=0) addEdge(i, j, i-1, j, grid);\\n                    if(i+1<grid.length) addEdge(i, j, i+1, j, grid);\\n                    if(j-1>=0) addEdge(i, j, i, j-1, grid);\\n                    if(j+1<grid[0].length) addEdge(i, j, i, j+1, grid);\\n                    \\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(int prevX, int prevY, int x, int y, int[][] grid){\\n        if(grid[x][y] == 0) return;\\n        int u = prevX * M + prevY;\\n        int v = x*M + y;\\n        \\n        if(!adjList.containsKey(u)) adjList.put(u, new ArrayList<>());\\n        if(!adjList.containsKey(v)) adjList.put(v, new ArrayList<>());\\n        \\n        adjList.get(u).add(v);\\n        adjList.get(v).add(u);\\n    }\\n    \\n    int numOfIsland(int[][] grid, boolean[][] visited) {\\n        int islandCount = 0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++) {\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    if(root == -1) root = i*M + j;\\n                    \\n                    islandCount++;\\n                    dfs(grid, i, j, visited);\\n                    \\n                }\\n            }\\n        }\\n        return islandCount;\\n        \\n    }\\n    \\n    void dfs(int[][] grid, int i, int j, boolean[][] visited){\\n        if(visited[i][j]) return;\\n        if(grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        nodes++;    \\n        \\n        if(i-1>=0) dfs(grid, i-1, j, visited);\\n        if(i+1<grid.length) dfs(grid, i+1, j, visited);\\n        if(j-1>=0) dfs(grid, i, j-1, visited);\\n        if(j+1<grid[0].length) dfs(grid, i, j+1, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631266,
                "title": "c-articulation-points",
                "content": "\\tthe number of days would be either 0, 1, or 2\\n\\n\\tif there are more than 1 componenents (or more than 1 island in the matrix), then it is already disconnected and hence 0 days are required\\n\\tif these is only one component, then\\n\\tconsitruct the graph - a cell (i, j) is represented as cols*i + j in the graph.\\n\\tCount the number of articulation points in the graph. If there exists an articulation point, then one such node exist, if when removed would disconnect the graph into more than one component\\n\\tif there are no articulation points, we would be forced to remove two nodes to make it disconnected\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<bool>> visMat;\\n\\n\\tint dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\tbool isValid(int i, int j, vector<vector<int>> &grid) {\\n\\n\\t\\treturn (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n\\t}\\n\\n\\tvector<int> parent;\\n\\tvector<int> low;\\n\\tvector<int> disc;\\n\\tvector<bool> vis;\\n\\tvector<bool> ap;\\n\\n\\n\\tvoid dfs(vector<vector<int>> &grid, int i, int j) {\\n\\n\\t\\tvisMat[i][j] = true;\\n\\t\\tfor (auto d : dirs) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\tif (isValid(ni, nj, grid) && !visMat[ni][nj] && grid[ni][nj] == 1) {dfs(grid, ni, nj);}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint time = 0;\\n\\tvoid dfsArticulation(vector<set<int>> &graph, int u) {\\n\\n\\t\\t// cout << \"At \" << u << \" \";\\n\\n\\t\\tlow[u] = disc[u] = ++time;\\n\\t\\tvis[u] = true;\\n\\t\\tint dfsCount = 0;\\n\\n\\t\\tfor (int v : graph[u]) {\\n\\n\\t\\t\\tif (v == parent[u]) continue;\\n\\n\\t\\t\\telse if (vis[v]) low[u] = min(low[u], disc[v]);\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdfsCount++;\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tdfsArticulation(graph, v);\\n\\t\\t\\t\\tlow[u] = min(low[u], low[v]);\\n\\n\\t\\t\\t\\tif (parent[u] == -1) {\\n\\n\\t\\t\\t\\t\\tif (dfsCount > 1) {\\n\\t\\t\\t\\t\\t\\tif (low[v] >= disc[u]) {\\n\\t\\t\\t\\t\\t\\t\\tap[u] = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse  {\\n\\t\\t\\t\\t\\tif (low[v] >= disc[u]) ap[u] = true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t}\\n\\n\\n\\tint minDays(vector<vector<int>>& grid) {\\n\\t\\tint rows = grid.size();\\n\\t\\tint cols = grid[0].size();\\n\\t\\tint comps = 0;\\n\\t\\tint onesCount = 0;\\n\\n\\t\\tvisMat.resize(rows, vector<bool> (cols, false));\\n\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tonesCount += grid[i][j];\\n\\t\\t\\t\\tif (grid[i][j] == 1 && !visMat[i][j]) {\\n\\t\\t\\t\\t\\tdfs(grid, i, j);\\n\\t\\t\\t\\t\\tcomps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (onesCount == 1) return 1;\\n\\t\\t// cout << \"Comps : \" << comps << \\'\\\\n\\';\\n\\t\\tif (comps > 1) return 0;\\n\\n\\n\\t\\tvector<set<int>> graph(rows * cols + 1);\\n\\t\\tparent.resize(rows * cols + 1);\\n\\t\\tlow.resize(rows * cols + 1);\\n\\t\\tdisc.resize(rows * cols + 1);\\n\\t\\tvis.resize(rows * cols + 1, false);\\n\\t\\tap.resize(rows * cols + 1, false);\\n\\n\\t\\tint src = -1;\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\n\\t\\t\\t\\tif (src == -1) src = cols * i + j;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (isValid(ni, nj, grid) && grid[ni][nj] == 1) {\\n\\n\\t\\t\\t\\t\\t\\tgraph[cols * i + j].insert(cols * ni + nj);\\n\\t\\t\\t\\t\\t\\tgraph[cols * ni + nj].insert(cols * i + j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tparent[src] = -1;\\n\\t\\tint artiPoints = 0;\\n\\t\\tdfsArticulation(graph, src);\\n\\n\\n\\t\\tfor (int i = 0; i < ap.size(); i++) {\\n\\t\\t\\tif (ap[i]) return 1;\\n\\n\\t\\t}\\n\\n\\t\\treturn 2;\\n\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<bool>> visMat;\\n\\n\\tint dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\tbool isValid(int i, int j, vector<vector<int>> &grid) {\\n\\n\\t\\treturn (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n\\t}\\n\\n\\tvector<int> parent;\\n\\tvector<int> low;\\n\\tvector<int> disc;\\n\\tvector<bool> vis;\\n\\tvector<bool> ap;\\n\\n\\n\\tvoid dfs(vector<vector<int>> &grid, int i, int j) {\\n\\n\\t\\tvisMat[i][j] = true;\\n\\t\\tfor (auto d : dirs) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\tif (isValid(ni, nj, grid) && !visMat[ni][nj] && grid[ni][nj] == 1) {dfs(grid, ni, nj);}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint time = 0;\\n\\tvoid dfsArticulation(vector<set<int>> &graph, int u) {\\n\\n\\t\\t// cout << \"At \" << u << \" \";\\n\\n\\t\\tlow[u] = disc[u] = ++time;\\n\\t\\tvis[u] = true;\\n\\t\\tint dfsCount = 0;\\n\\n\\t\\tfor (int v : graph[u]) {\\n\\n\\t\\t\\tif (v == parent[u]) continue;\\n\\n\\t\\t\\telse if (vis[v]) low[u] = min(low[u], disc[v]);\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdfsCount++;\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tdfsArticulation(graph, v);\\n\\t\\t\\t\\tlow[u] = min(low[u], low[v]);\\n\\n\\t\\t\\t\\tif (parent[u] == -1) {\\n\\n\\t\\t\\t\\t\\tif (dfsCount > 1) {\\n\\t\\t\\t\\t\\t\\tif (low[v] >= disc[u]) {\\n\\t\\t\\t\\t\\t\\t\\tap[u] = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse  {\\n\\t\\t\\t\\t\\tif (low[v] >= disc[u]) ap[u] = true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t}\\n\\n\\n\\tint minDays(vector<vector<int>>& grid) {\\n\\t\\tint rows = grid.size();\\n\\t\\tint cols = grid[0].size();\\n\\t\\tint comps = 0;\\n\\t\\tint onesCount = 0;\\n\\n\\t\\tvisMat.resize(rows, vector<bool> (cols, false));\\n\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tonesCount += grid[i][j];\\n\\t\\t\\t\\tif (grid[i][j] == 1 && !visMat[i][j]) {\\n\\t\\t\\t\\t\\tdfs(grid, i, j);\\n\\t\\t\\t\\t\\tcomps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (onesCount == 1) return 1;\\n\\t\\t// cout << \"Comps : \" << comps << \\'\\\\n\\';\\n\\t\\tif (comps > 1) return 0;\\n\\n\\n\\t\\tvector<set<int>> graph(rows * cols + 1);\\n\\t\\tparent.resize(rows * cols + 1);\\n\\t\\tlow.resize(rows * cols + 1);\\n\\t\\tdisc.resize(rows * cols + 1);\\n\\t\\tvis.resize(rows * cols + 1, false);\\n\\t\\tap.resize(rows * cols + 1, false);\\n\\n\\t\\tint src = -1;\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\n\\t\\t\\t\\tif (src == -1) src = cols * i + j;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (isValid(ni, nj, grid) && grid[ni][nj] == 1) {\\n\\n\\t\\t\\t\\t\\t\\tgraph[cols * i + j].insert(cols * ni + nj);\\n\\t\\t\\t\\t\\t\\tgraph[cols * ni + nj].insert(cols * i + j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tparent[src] = -1;\\n\\t\\tint artiPoints = 0;\\n\\t\\tdfsArticulation(graph, src);\\n\\n\\n\\t\\tfor (int i = 0; i < ap.size(); i++) {\\n\\t\\t\\tif (ap[i]) return 1;\\n\\n\\t\\t}\\n\\n\\t\\treturn 2;\\n\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1630519,
                "title": "simple-solution-either-0-1-or-2-c-with-time-o-m-n-2-space-o-1",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid,int color){\\n        if(i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or grid[i][j] == color){\\n            return;\\n        }\\n        grid[i][j] = color;\\n        dfs(i+1,j,m,n,grid,color);\\n        dfs(i,j-1,m,n,grid,color);\\n        dfs(i-1,j,m,n,grid,color);\\n        dfs(i,j+1,m,n,grid,color);\\n    }\\n    \\n    int countOnes(int m,int n,vector<vector<int>> &grid){\\n        int ones = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        return ones;\\n    }\\n    \\n    int countIslands(int m,int n,vector<vector<int>> &grid){\\n        int island = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i,j,m,n,grid,2);\\n                    island++;\\n                }\\n            }\\n        }        \\n        return island;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ones = countOnes(m,n,grid);\\n        \\n        int island = countIslands(m,n,grid);\\n\\n        \\n        if(island != 1) return 0; //1st case \\n               \\n        if(m == 1 or n == 1 or ones <= 2){\\n            return ones == 2 ? 2:1; //2nd case\\n        }\\n        \\n        //Last option\\n        int islandColor = 2;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == islandColor){\\n                    grid[i][j] = 0;\\n                    island = 0;\\n                    for(int k=0;k<m;k++){\\n                        for(int l=0;l<n;l++){\\n                            if(grid[k][l] == islandColor){\\n                                dfs(k,l,m,n,grid,islandColor+1);\\n                                island++;\\n                            }\\n                        }\\n                    }\\n                    if(island > 1) return 1; // 3rd case\\n                    grid[i][j] = ++islandColor;\\n                }\\n            }\\n        }\\n        return 2; //4th case\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid,int color){\\n        if(i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or grid[i][j] == color){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1581268,
                "title": "c-bfs",
                "content": "There is code repeition, so to make it more pleasing, you may write a seperate function for BFS\\n```\\n\\tint minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int dy[4] = {0, -1, 0, 1};\\n        int dx[4] = {-1, 0, 1, 0};\\n        \\n        vector<vector<bool>> used;\\n        for (int i = 0; i < n; i++) {\\n            vector<bool> temp;\\n            for (int j = 0; j < m; j++) {\\n                temp.push_back(false);\\n            }\\n            used.push_back(temp);\\n        }\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!used[i][j] && grid[i][j] == 1) {\\n                    \\n                    queue<pair<int, int>> q;\\n                    q.push(make_pair(i, j));\\n                    used[i][j] = true;\\n                    \\n                    cnt++;\\n                    \\n                    while (!q.empty()) {\\n                        pair<int, int> front = q.front();\\n                        int y = front.first;\\n                        int x = front.second;\\n                        for (int k = 0; k < 4; k++) {\\n                            int tempY = y + dy[k];\\n                            int tempX = x + dx[k];\\n                            if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                    q.push(make_pair(tempY, tempX));\\n                                    used[tempY][tempX] = true;\\n                                }\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt > 1) {\\n            return 0;\\n        }\\n        \\n        for (int _i = 0; _i < n; _i++) {\\n            for (int _j = 0; _j < m; _j++) {\\n                if (grid[_i][_j] == 1) {\\n                    grid[_i][_j] = 0;\\n                    \\n                    bool isBfs = false;\\n                    \\n                    used.clear();\\n                    for (int i = 0; i < n; i++) {\\n                        vector<bool> temp;\\n                        for (int j = 0; j < m; j++) {\\n                            temp.push_back(false);\\n                        }\\n                        used.push_back(temp);\\n                    }\\n                    \\n                    cnt = 0;\\n                    for (int i = 0; i < n; i++) {\\n                        for (int j = 0; j < m; j++) {\\n                            if (!used[i][j] && grid[i][j] == 1) {\\n\\n                                isBfs = true;\\n                                queue<pair<int, int>> q;\\n                                q.push(make_pair(i, j));\\n                                used[i][j] = true;\\n\\n                                cnt++;\\n\\n                                while (!q.empty()) {\\n                                    pair<int, int> front = q.front();\\n                                    int y = front.first;\\n                                    int x = front.second;\\n                                    for (int k = 0; k < 4; k++) {\\n                                        int tempY = y + dy[k];\\n                                        int tempX = x + dx[k];\\n                                        if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                            if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                                q.push(make_pair(tempY, tempX));\\n                                                used[tempY][tempX] = true;\\n                                            }\\n                                        }\\n                                    }\\n                                    q.pop();\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if (cnt > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    if (!isBfs) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[_i][_j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int dy[4] = {0, -1, 0, 1};\\n        int dx[4] = {-1, 0, 1, 0};\\n        \\n        vector<vector<bool>> used;\\n        for (int i = 0; i < n; i++) {\\n            vector<bool> temp;\\n            for (int j = 0; j < m; j++) {\\n                temp.push_back(false);\\n            }\\n            used.push_back(temp);\\n        }\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!used[i][j] && grid[i][j] == 1) {\\n                    \\n                    queue<pair<int, int>> q;\\n                    q.push(make_pair(i, j));\\n                    used[i][j] = true;\\n                    \\n                    cnt++;\\n                    \\n                    while (!q.empty()) {\\n                        pair<int, int> front = q.front();\\n                        int y = front.first;\\n                        int x = front.second;\\n                        for (int k = 0; k < 4; k++) {\\n                            int tempY = y + dy[k];\\n                            int tempX = x + dx[k];\\n                            if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                    q.push(make_pair(tempY, tempX));\\n                                    used[tempY][tempX] = true;\\n                                }\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt > 1) {\\n            return 0;\\n        }\\n        \\n        for (int _i = 0; _i < n; _i++) {\\n            for (int _j = 0; _j < m; _j++) {\\n                if (grid[_i][_j] == 1) {\\n                    grid[_i][_j] = 0;\\n                    \\n                    bool isBfs = false;\\n                    \\n                    used.clear();\\n                    for (int i = 0; i < n; i++) {\\n                        vector<bool> temp;\\n                        for (int j = 0; j < m; j++) {\\n                            temp.push_back(false);\\n                        }\\n                        used.push_back(temp);\\n                    }\\n                    \\n                    cnt = 0;\\n                    for (int i = 0; i < n; i++) {\\n                        for (int j = 0; j < m; j++) {\\n                            if (!used[i][j] && grid[i][j] == 1) {\\n\\n                                isBfs = true;\\n                                queue<pair<int, int>> q;\\n                                q.push(make_pair(i, j));\\n                                used[i][j] = true;\\n\\n                                cnt++;\\n\\n                                while (!q.empty()) {\\n                                    pair<int, int> front = q.front();\\n                                    int y = front.first;\\n                                    int x = front.second;\\n                                    for (int k = 0; k < 4; k++) {\\n                                        int tempY = y + dy[k];\\n                                        int tempX = x + dx[k];\\n                                        if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                            if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                                q.push(make_pair(tempY, tempX));\\n                                                used[tempY][tempX] = true;\\n                                            }\\n                                        }\\n                                    }\\n                                    q.pop();\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if (cnt > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    if (!isBfs) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[_i][_j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331264,
                "title": "easy-java-dfs",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int countOne = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    countOne++;\\n                }\\n            }\\n        }\\n        if(countOne == 1) return 1;\\n       int k = countIsland(grid);\\n        if(k > 1) return 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    int g = countIsland(grid);\\n                    if(g>1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    int countIsland(int grid[][]){\\n        int c=0;\\n         boolean v[][] = new boolean[grid.length][grid[0].length];  \\n          for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1 && v[i][j] == false){\\n                    ++c;\\n                   count(grid,i,j,v);\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void count(int g[][],int i,int j,boolean v[][]){\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j] == 0 || v[i][j]){\\n            return;\\n        }\\n        v[i][j] = true;\\n        count(g,i+1,j,v);\\n        count(g,i,j+1,v);\\n        count(g,i-1,j,v);\\n        count(g,i,j-1,v);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int countOne = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    countOne++;\\n                }\\n            }\\n        }\\n        if(countOne == 1) return 1;\\n       int k = countIsland(grid);\\n        if(k > 1) return 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    int g = countIsland(grid);\\n                    if(g>1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    int countIsland(int grid[][]){\\n        int c=0;\\n         boolean v[][] = new boolean[grid.length][grid[0].length];  \\n          for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1 && v[i][j] == false){\\n                    ++c;\\n                   count(grid,i,j,v);\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void count(int g[][],int i,int j,boolean v[][]){\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j] == 0 || v[i][j]){\\n            return;\\n        }\\n        v[i][j] = true;\\n        count(g,i+1,j,v);\\n        count(g,i,j+1,v);\\n        count(g,i-1,j,v);\\n        count(g,i,j-1,v);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297390,
                "title": "java-solution-easy-to-understand-dfs",
                "content": "```\\nclass Solution {\\n    \\n    int[] dir = {1,0,-1,0,1}; // dir to move in grid\\n    \\n    public void dfs(int[][] grid , int r , int c , boolean[][] visited){\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[0].length || grid[r][c]== 0 || visited[r][c]) // condition to not move to grid\\n            return ;\\n        visited[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            dfs(grid , r+dir[i] , c+dir[i+1] ,visited);\\n        }\\n    }\\n    \\n    public int countIsland(int[][] grid){\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int IslandNum =0;\\n        boolean[][] visited = new boolean[row][col];\\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(grid[i][j] == 1 && !visited[i][j]){\\n                    dfs(grid , i , j , visited);\\n                    IslandNum++; // counting the number of Island in grid \\n                }\\n            }\\n        }\\n        return IslandNum;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        int cntIsland = countIsland(grid);\\n        if(cntIsland ==0 || cntIsland>1)return 0; // no connected or many connected || not singly connected\\n        \\n        \\n        for(int i =0;i<grid.length ;i++){\\n            for(int j=0;j<grid[0].length ;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    cntIsland = countIsland(grid);\\n                    if(cntIsland ==0 || cntIsland>1)return 1; // after making one Land to water , then number of connected component\\n                    grid[i][j] =1;\\n                }\\n            }\\n        }\\n        return 2; // remove the two land  from any corner to make corner element disconnected\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] dir = {1,0,-1,0,1}; // dir to move in grid\\n    \\n    public void dfs(int[][] grid , int r , int c , boolean[][] visited){\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[0].length || grid[r][c]== 0 || visited[r][c]) // condition to not move to grid\\n            return ;\\n        visited[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            dfs(grid , r+dir[i] , c+dir[i+1] ,visited);\\n        }\\n    }\\n    \\n    public int countIsland(int[][] grid){\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int IslandNum =0;\\n        boolean[][] visited = new boolean[row][col];\\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(grid[i][j] == 1 && !visited[i][j]){\\n                    dfs(grid , i , j , visited);\\n                    IslandNum++; // counting the number of Island in grid \\n                }\\n            }\\n        }\\n        return IslandNum;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        int cntIsland = countIsland(grid);\\n        if(cntIsland ==0 || cntIsland>1)return 0; // no connected or many connected || not singly connected\\n        \\n        \\n        for(int i =0;i<grid.length ;i++){\\n            for(int j=0;j<grid[0].length ;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    cntIsland = countIsland(grid);\\n                    if(cntIsland ==0 || cntIsland>1)return 1; // after making one Land to water , then number of connected component\\n                    grid[i][j] =1;\\n                }\\n            }\\n        }\\n        return 2; // remove the two land  from any corner to make corner element disconnected\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273896,
                "title": "c-solution-with-explaination-in-comments",
                "content": "class Solution {\\npublic:\\n    int X[4]={0,1,0,-1};\\n    int Y[4]={1,0,-1,0};\\n    bool disconnected(vector<vector<int>>& grid,int count)\\n    {\\n        stack<pair<int,int>> st;\\n        set<pair<int,int>> visited;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] ==1)\\n                {\\n                    st.push({i,j});\\n                    count--;\\n                    j=INT_MAX-1;\\n                    i= INT_MAX-1;\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            pair<int,int> coordinate = st.top();\\n            st.pop();\\n            visited.insert(coordinate);\\n            \\n            int x_cor = coordinate.first,y_cor=coordinate.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                if(x_cor + X[i]<grid.size() && x_cor+X[i]>=0 && y_cor + Y[i]<grid[0].size() && y_cor+Y[i] >=0)\\n                {\\n                    if(visited.find({x_cor + X[i],y_cor+Y[i]})==visited.end() && grid[x_cor + X[i]][y_cor+Y[i]]==1)\\n                    {\\n                        count--;\\n                        visited.insert({x_cor + X[i],y_cor+Y[i]});\\n                        st.push({x_cor + X[i],y_cor+Y[i]});\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        if(count == 0)\\n            return false;\\n        return true;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        set<pair<int,int>> s;\\n        int minlen=INT_MAX;\\n        \\n        // Now one observation we can make is that the ans can be at max 2 because for a 1 on corner ans will be 2\\n        // so our ans is 0,1  or 2\\n        // so check in base condition if its disconnected i.e 0\\n        // if not flip every one bit to 0 and check for each combination if disconnected else return 2;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] ==1)\\n                    count++;\\n            }\\n        }        \\n        \\n\\n        if(count==0 || disconnected(grid,count))\\n            return 0;\\n        \\n        if(count == 1)\\n            return 1;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    grid[i][j] = 0;\\n                        if(disconnected(grid,count-1))\\n                        {   \\n                            return 1;\\n                        }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int X[4]={0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1207076,
                "title": "python-tarjan-s-algorithm-to-find-whether-there-are-critical-connections",
                "content": "```\\nfrom collections import defaultdict as ddict\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def neighbor(i, j):\\n            lst = [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]\\n            return [(x, y) for x, y in lst if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1]\\n        \\n        # Tarjan\\'s algorithm to find whether there are critical connections\\n        def dfs(i, j, time):\\n            node[(i, j)] = time\\n            low[(i, j)] = time\\n            visited.add((i, j))\\n            is_crit = False\\n            size = 1\\n            for x, y in neighbor(i, j):\\n                if (x, y) not in visited:\\n                    nei_size, has_crit = dfs(x, y, time + 1)\\n                    size += nei_size\\n                    is_crit = is_crit or has_crit\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n                    if low[(x, y)] == time + 1:\\n                        # critical connection found\\n                        is_crit = True\\n                elif node[(x, y)] != time - 1:\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n            return size, is_crit\\n        \\n        # handle edge case when there is only one node\\n        grid_sum = sum([grid[i][j] for i in range(len(grid)) for j in range(len(grid[0]))])\\n        if grid_sum <= 1:\\n            return grid_sum\\n        critical = False\\n        visited = set()\\n        node = ddict(int)\\n        low = ddict(int)\\n        comp = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in visited:\\n                    comp += 1\\n                    size, has_crit = dfs(i, j, 1)\\n                    # when there are two nodes connected together, we need to remove two even if there is a critical connection\\n                    if size > 2 and has_crit:\\n                        critical = True\\n        # more than one component, return 0\\n        if comp > 1:\\n            return 0\\n        return 1 if critical else 2\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict as ddict\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def neighbor(i, j):\\n            lst = [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]\\n            return [(x, y) for x, y in lst if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1]\\n        \\n        # Tarjan\\'s algorithm to find whether there are critical connections\\n        def dfs(i, j, time):\\n            node[(i, j)] = time\\n            low[(i, j)] = time\\n            visited.add((i, j))\\n            is_crit = False\\n            size = 1\\n            for x, y in neighbor(i, j):\\n                if (x, y) not in visited:\\n                    nei_size, has_crit = dfs(x, y, time + 1)\\n                    size += nei_size\\n                    is_crit = is_crit or has_crit\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n                    if low[(x, y)] == time + 1:\\n                        # critical connection found\\n                        is_crit = True\\n                elif node[(x, y)] != time - 1:\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n            return size, is_crit\\n        \\n        # handle edge case when there is only one node\\n        grid_sum = sum([grid[i][j] for i in range(len(grid)) for j in range(len(grid[0]))])\\n        if grid_sum <= 1:\\n            return grid_sum\\n        critical = False\\n        visited = set()\\n        node = ddict(int)\\n        low = ddict(int)\\n        comp = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in visited:\\n                    comp += 1\\n                    size, has_crit = dfs(i, j, 1)\\n                    # when there are two nodes connected together, we need to remove two even if there is a critical connection\\n                    if size > 2 and has_crit:\\n                        critical = True\\n        # more than one component, return 0\\n        if comp > 1:\\n            return 0\\n        return 1 if critical else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018960,
                "title": "python3-short-dfs-solution",
                "content": "number of island + brute force\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def count(g):\\n            def dfs(i, j):\\n                if 0 <= i < m and 0 <= j < n and g[i][j]:\\n                    g[i][j] = 0 \\n                    list(map(dfs, (i+1, i-1, i, i), (j, j, j+1, j-1)))\\n            return sum(g[i][j] and not dfs(i, j) for i, j in product(range(m), range(n)))\\n        \\n        m, n = len(grid), len(grid[0])\\n        if count(deepcopy(grid)) != 1: return 0\\n        \\n        for i, j in product(range(m), range(n)):\\n            g = deepcopy(grid)\\n            g[i][j] = 0\\n            if count(g) != 1: return 1\\n        return 2",
                "solutionTags": [],
                "code": "number of island + brute force\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def count(g):\\n            def dfs(i, j):\\n                if 0 <= i < m and 0 <= j < n and g[i][j]:\\n                    g[i][j] = 0 \\n                    list(map(dfs, (i+1, i-1, i, i), (j, j, j+1, j-1)))\\n            return sum(g[i][j] and not dfs(i, j) for i, j in product(range(m), range(n)))\\n        \\n        m, n = len(grid), len(grid[0])\\n        if count(deepcopy(grid)) != 1: return 0\\n        \\n        for i, j in product(range(m), range(n)):\\n            g = deepcopy(grid)\\n            g[i][j] = 0\\n            if count(g) != 1: return 1\\n        return 2",
                "codeTag": "Java"
            },
            {
                "id": 1002076,
                "title": "proof-that-we-never-need-more-than-2-deletions",
                "content": "If we have <=3 vertices, the fact that only 2 deletions is needed is trivial. So now we are left with 4 or more vertices.\\n\\nLook at the elements that are in the lowest row #. From those, consider the element with the lowest column #. Now this has to have at most 2 neighbouring vertices. Why?\\n\\nIf we could go up, the row number would be lower. If we could go left, the column number would be lower. So we have at most two edges from this vertex. Delete the two vertices at the end of the edges to disconnect the rest of the graph from this vertex. (Note: # vertices>=4 so we have at least two vertices left)\\n\\nSo this proves that we never need more than 2. It is obvious that we need two in some cases.",
                "solutionTags": [],
                "code": "If we have <=3 vertices, the fact that only 2 deletions is needed is trivial. So now we are left with 4 or more vertices.\\n\\nLook at the elements that are in the lowest row #. From those, consider the element with the lowest column #. Now this has to have at most 2 neighbouring vertices. Why?\\n\\nIf we could go up, the row number would be lower. If we could go left, the column number would be lower. So we have at most two edges from this vertex. Delete the two vertices at the end of the edges to disconnect the rest of the graph from this vertex. (Note: # vertices>=4 so we have at least two vertices left)\\n\\nSo this proves that we never need more than 2. It is obvious that we need two in some cases.",
                "codeTag": "Unknown"
            },
            {
                "id": 925185,
                "title": "c-8ms-99-o-mn-tarjan",
                "content": "The answer<=2, because corners of the island require 2 cuts at most.\\nUse Tarjan algorithm to find any bridge. If found, return 1, otherwise 2.\\nReturn 2 for cases like [[1, 1]] (i.e. single island with 2 cells) specially.\\n\\n```\\nclass Solution {\\npublic:\\n    const int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    int dfs(int x, int y, int px, int py) {\\n        int res = INT_MAX;\\n        for (int i = 0; i < 4; ++i) {\\n            int xx = x + dirs[i][0];\\n            int yy = y + dirs[i][1];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] != 1)\\n                continue;\\n            if (xx == px && yy == py)\\n                continue;\\n            if (depth[xx][yy] != -1) {\\n                res = min(res, depth[xx][yy]);\\n            } else {\\n                depth[xx][yy] = depth[x][y] + 1;\\n                int ret = dfs(xx, yy, x, y);\\n                if (ret == -1)\\n                    return -1;\\n                res = min(res, ret);\\n            }\\n        }\\n        return (res > depth[x][y]) ? -1 : min(depth[x][y], res);\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 0;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        int ax, ay;\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (vis[i][j])\\n                    continue;\\n                if (grid[i][j] == 1) {\\n                    if (cnt)\\n                        return 0;\\n                    ax = i, ay = j;\\n                    vector<pair<int, int>> bfs = {{i, j}};\\n                    vis[i][j] = true;\\n                    ++cnt;\\n                    while (!bfs.empty()) {\\n                        int x = bfs.back().first;\\n                        int y = bfs.back().second;\\n                        bfs.pop_back();\\n                        for (int k = 0; k < 4; ++k) {\\n                            int xx = x + dirs[k][0];\\n                            int yy = y + dirs[k][1];\\n                            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy] || grid[xx][yy] != 1)\\n                                continue;\\n                            vis[xx][yy] = true;\\n                            ++cnt;\\n                            bfs.push_back({xx, yy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == 0)\\n            return 0;\\n        if (cnt == 2)\\n            return 2;\\n        g = grid;\\n        depth = vector<vector<int>>(n, vector<int>(m, -1));\\n        depth[ax][ay] = 0;\\n        if (dfs(ax, ay, -1, -1) == -1)\\n            return 1;\\n        return 2;\\n    }\\n    \\n    int n, m;\\n    vector<vector<int>> g;\\n    vector<vector<int>> depth;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    int dfs(int x, int y, int px, int py) {\\n        int res = INT_MAX;\\n        for (int i = 0; i < 4; ++i) {\\n            int xx = x + dirs[i][0];\\n            int yy = y + dirs[i][1];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] != 1)\\n                continue;\\n            if (xx == px && yy == py)\\n                continue;\\n            if (depth[xx][yy] != -1) {\\n                res = min(res, depth[xx][yy]);\\n            } else {\\n                depth[xx][yy] = depth[x][y] + 1;\\n                int ret = dfs(xx, yy, x, y);\\n                if (ret == -1)\\n                    return -1;\\n                res = min(res, ret);\\n            }\\n        }\\n        return (res > depth[x][y]) ? -1 : min(depth[x][y], res);\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 0;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        int ax, ay;\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (vis[i][j])\\n                    continue;\\n                if (grid[i][j] == 1) {\\n                    if (cnt)\\n                        return 0;\\n                    ax = i, ay = j;\\n                    vector<pair<int, int>> bfs = {{i, j}};\\n                    vis[i][j] = true;\\n                    ++cnt;\\n                    while (!bfs.empty()) {\\n                        int x = bfs.back().first;\\n                        int y = bfs.back().second;\\n                        bfs.pop_back();\\n                        for (int k = 0; k < 4; ++k) {\\n                            int xx = x + dirs[k][0];\\n                            int yy = y + dirs[k][1];\\n                            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy] || grid[xx][yy] != 1)\\n                                continue;\\n                            vis[xx][yy] = true;\\n                            ++cnt;\\n                            bfs.push_back({xx, yy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == 0)\\n            return 0;\\n        if (cnt == 2)\\n            return 2;\\n        g = grid;\\n        depth = vector<vector<int>>(n, vector<int>(m, -1));\\n        depth[ax][ay] = 0;\\n        if (dfs(ax, ay, -1, -1) == -1)\\n            return 1;\\n        return 2;\\n    }\\n    \\n    int n, m;\\n    vector<vector<int>> g;\\n    vector<vector<int>> depth;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866762,
                "title": "simple-python",
                "content": "```\\ndef minDays(self, g: List[List[int]]) -> int:\\n    def dfs(i, j, vis):\\n        vis.add((i, j))\\n        for i1, j1 in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n            if (0 <= i1 < m and 0 <= j1 < n) and (i1, j1) not in vis and g[i1][j1]: dfs(i1, j1, vis)                       \\n    if not g: return 0\\n    m, n = len(g), len(g[0])        \\n    cand = [(i,j) for i in range(m) for j in range(n) if g[i][j]]        \\n    if not cand: return 0\\n    vis = set(); dfs(cand[0][0], cand[0][1], vis) \\n    if len(vis) < len(cand): return 0\\n    if len(cand) <= 2: return len(cand)\\n\\n    for k, ij in enumerate(cand):            \\n        i, j = ij\\n        g[i][j] = 0\\n        vis = set()\\n        k = -1 if k == 0 else 0\\n        dfs(cand[k][0], cand[k][1], vis)\\n        if len(vis) < len(cand) - 1: return 1\\n        g[i][j] = 1\\n    return 2",
                "solutionTags": [],
                "code": "```\\ndef minDays(self, g: List[List[int]]) -> int:\\n    def dfs(i, j, vis):\\n        vis.add((i, j))\\n        for i1, j1 in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n            if (0 <= i1 < m and 0 <= j1 < n) and (i1, j1) not in vis and g[i1][j1]: dfs(i1, j1, vis)                       \\n    if not g: return 0\\n    m, n = len(g), len(g[0])        \\n    cand = [(i,j) for i in range(m) for j in range(n) if g[i][j]]        \\n    if not cand: return 0\\n    vis = set(); dfs(cand[0][0], cand[0][1], vis) \\n    if len(vis) < len(cand): return 0\\n    if len(cand) <= 2: return len(cand)\\n\\n    for k, ij in enumerate(cand):            \\n        i, j = ij\\n        g[i][j] = 0\\n        vis = set()\\n        k = -1 if k == 0 else 0\\n        dfs(cand[k][0], cand[k][1], vis)\\n        if len(vis) < len(cand) - 1: return 1\\n        g[i][j] = 1\\n    return 2",
                "codeTag": "Python3"
            },
            {
                "id": 859877,
                "title": "how-to-proof-at-most-2-days",
                "content": "One way to proof maybe like this, assuming every node has three or more degree of connection, then such island has infinite area, which is impossible in this problem. But, is this thoughts right, and how to formally proof this?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 848220,
                "title": "java-2-approaches-with-comments-dfs-tarjan",
                "content": "```\\n/*\\n * the matrix can be infinitely big with only ones and still be done in 2 days\\n *  day 0\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 1\\n\\t[1,0,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 2\\n\\t[1,0,1]\\n\\t[0,1,1]\\n\\t[1,1,1]\\n */\\n\\n/**\\n * Approach 1: DFS\\n * \\tIf you look carefully, the result is 0, 1, or 2;\\n\\t1, if num of islands not 1, return 0;\\n\\t2, special cases, only one 1 or two 1s;\\n\\t3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n\\t4, otherwise return 2;\\n\\n\\n * \\tComplexity of finding noOfIsland is O(mn)\\n\\tSince in worst case we might end up calling noOfIsland function mXn times\\n\\tOverall Complexity is O((mn)^2)\\n */\\npublic int minDays(int[][] grid) {\\n\\n\\tif (numIslands(grid) != 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (numIslands(grid) != 1) { // check if this pt is a cutting bridge\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 2; // \\n}\\n\\npublic int numIslands(int[][] grid) {\\n\\tint count = 0;\\n\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (!visited[i][j] && grid[i][j] == 1) {\\n\\t\\t\\t\\tdfsUtil(visited, grid, i, j);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate void dfsUtil(boolean[][] visited, int[][] grid, int i, int j) {\\n\\tif (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\tvisited[i][j] = true;\\n\\t\\tlands++;\\n\\t\\tdfsUtil(visited, grid, i + 1, j);\\n\\t\\tdfsUtil(visited, grid, i - 1, j);\\n\\t\\tdfsUtil(visited, grid, i, j + 1);\\n\\t\\tdfsUtil(visited, grid, i, j - 1);\\n\\t}\\n}\\n\\n/**\\n * Approach 2: Tarjan\\'s Algo\\n * \\tIf there is no island or more than 1 island, return 0;\\n\\tIf there is only one land, return 1;\\n\\tIf any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n\\tOtherwise, return 2 ( I haven\\'t found a formal proof yet).\\n */\\n\\npublic int lands = 0; // if we have only 1 land ie 1 cell with value one then ans is 1\\n\\npublic int minDaysApproach2(int[][] grid) {\\n\\tif (numIslands(grid) != 1)\\n\\t\\treturn 0;\\n\\t// we are here means we have only 1 island\\n\\n\\tif (lands <= 2)\\n\\t\\t// special case when we have 010 land or 0110 like this land in this case island is 1, there is no ap\\n\\t\\treturn lands;\\n\\n\\t// we are here means we have only 1 island, and land is greater then 2 which means ap/bridge is possible\\n\\tHashMap<Integer, List<Integer>> graph = buildGraphFromGrid(grid);\\n\\n\\t//return Bridge.getBridges(graph).size() > 0 ? 1 : 2;\\n\\treturn ArticulationPoints.getAP(graph).size() > 0 ? 1 : 2;\\n}\\n\\npublic HashMap<Integer, List<Integer>> buildGraphFromGrid(int[][] grid) {\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList = new HashMap<Integer, List<Integer>>();\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tfor (int j = 0; j < grid[0].length; j++)\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs)\\n\\t\\t\\t\\t\\t\\tmark(grid, i, j, i + dir[0], j + dir[1], adjacencyList);\\n\\n\\t\\treturn adjacencyList;\\n\\t}\\n\\n\\tpublic static void mark(int grid[][], int prevX, int prevY, int x, int y,\\n\\t\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\t\\tif (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0)\\n\\t\\t\\treturn;\\n\\t\\tint n1 = prevX * grid[0].length + prevY;\\n\\t\\tint n2 = x * grid[0].length + y;\\n\\t\\tadjacencyList.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n\\t\\tadjacencyList.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n\\t}\\n\\n\\n\\n\\n/*************************Utilities*******************************/\\npublic class ArticulationPoints {\\n\\nprivate static int time;\\n\\n// The function to do DFS traversal. It uses recursive function APUtil() \\npublic static List<Integer> getAP(HashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Initialize parent and visited, and ap(articulation point) arrays\\n\\tList<Integer> ap = new ArrayList();\\n\\tHashMap<Integer, Integer> disc = new HashMap<Integer, Integer>(); // vertex, discovery value\\n\\tHashMap<Integer, Integer> low = new HashMap<Integer, Integer>(); // vertex, low value\\n\\tHashMap<Integer, Integer> parent = new HashMap<Integer, Integer>(); // // child vertex, parent vertex\\n\\n\\tSet<Integer> visited = new HashSet<Integer>();\\n\\n\\t// Call the recursive helper function to find articulation \\n\\t// points in DFS tree\\n\\n\\tfor (Map.Entry<Integer, List<Integer>> entry : adjacencyList.entrySet()) {\\n\\t\\tint v = entry.getKey();\\n\\t\\tif (!disc.containsKey(v))\\n\\t\\t\\tAPUtil(v, visited, disc, low, parent, ap, adjacencyList);\\n\\t}\\n\\treturn ap;\\n}\\n\\n// A recursive function that find articulation points using DFS \\n// u --> The vertex to be visited next \\n// visited[] --> keeps tract of visited vertices \\n// disc[] --> Stores discovery times of visited vertices \\n// parent[] --> Stores parent vertices in DFS tree \\n// ap[] --> Store articulation points \\npublic static void APUtil(int currVertex, Set<Integer> visited, HashMap<Integer, Integer> disc,\\n\\t\\tHashMap<Integer, Integer> low, HashMap<Integer, Integer> parent, List<Integer> ap,\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Count of children in DFS Tree \\n\\tint children = 0;\\n\\n\\t// Mark the current node as visited \\n\\tvisited.add(currVertex);\\n\\n\\t// Initialize discovery time and low value\\n\\n\\tdisc.put(currVertex, time);\\n\\tlow.put(currVertex, time);\\n\\t++time;\\n\\n\\tint neighbor;\\n\\n\\tif (adjacencyList.containsKey(currVertex)) {\\n\\t\\t// Go through all vertices adjacent to this  \\n\\t\\tIterator<Integer> itr = adjacencyList.get(currVertex).iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\n\\t\\t\\tneighbor = itr.next();\\n//\\t\\t\\t\\t//if neighbor is same as parent then just ignore this vertex.\\n//\\t            if(parent.containsKey(currVertex) && neighbor == parent.get(currVertex)) {\\n//\\t                continue;\\n//\\t            }\\n\\n\\t\\t\\t// If neighbor is not visited yet, then make it a child of currVertex \\n\\t\\t\\t// in DFS tree and recur for it \\n\\t\\t\\tif (!visited.contains(neighbor)) {\\n\\t\\t\\t\\tchildren++;\\n\\t\\t\\t\\tparent.put(neighbor, currVertex);\\n\\t\\t\\t\\tAPUtil(neighbor, visited, disc, low, parent, ap, adjacencyList);\\n\\n\\t\\t\\t\\t// Check if the subtree rooted with neighbor has a connection to \\n\\t\\t\\t\\t// one of the ancestors of currVertex \\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), low.get(neighbor)));\\n\\n\\t\\t\\t\\t// currVertex is an articulation point in following cases \\n\\n\\t\\t\\t\\t// (1) currVertex is root of DFS tree and has two or more chilren. \\n\\t\\t\\t\\t// (2) If currVertex is not root and low value of one of its child is more than discovery value of currVertex.\\n\\t\\t\\t\\tif (parent.get(currVertex) == null && children > 1 || parent.get(currVertex) != null && low.get(neighbor) >= disc.get(currVertex))\\n\\t\\t\\t\\t\\tap.add(currVertex);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update low value of u for parent function calls. \\n\\t\\t\\telse if (parent.containsKey(currVertex) && neighbor != parent.get(currVertex))\\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), disc.get(neighbor)));\\n\\t\\t}\\n\\t}\\n}\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n * the matrix can be infinitely big with only ones and still be done in 2 days\\n *  day 0\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 1\\n\\t[1,0,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 2\\n\\t[1,0,1]\\n\\t[0,1,1]\\n\\t[1,1,1]\\n */\\n\\n/**\\n * Approach 1: DFS\\n * \\tIf you look carefully, the result is 0, 1, or 2;\\n\\t1, if num of islands not 1, return 0;\\n\\t2, special cases, only one 1 or two 1s;\\n\\t3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n\\t4, otherwise return 2;\\n\\n\\n * \\tComplexity of finding noOfIsland is O(mn)\\n\\tSince in worst case we might end up calling noOfIsland function mXn times\\n\\tOverall Complexity is O((mn)^2)\\n */\\npublic int minDays(int[][] grid) {\\n\\n\\tif (numIslands(grid) != 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (numIslands(grid) != 1) { // check if this pt is a cutting bridge\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 2; // \\n}\\n\\npublic int numIslands(int[][] grid) {\\n\\tint count = 0;\\n\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (!visited[i][j] && grid[i][j] == 1) {\\n\\t\\t\\t\\tdfsUtil(visited, grid, i, j);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate void dfsUtil(boolean[][] visited, int[][] grid, int i, int j) {\\n\\tif (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\tvisited[i][j] = true;\\n\\t\\tlands++;\\n\\t\\tdfsUtil(visited, grid, i + 1, j);\\n\\t\\tdfsUtil(visited, grid, i - 1, j);\\n\\t\\tdfsUtil(visited, grid, i, j + 1);\\n\\t\\tdfsUtil(visited, grid, i, j - 1);\\n\\t}\\n}\\n\\n/**\\n * Approach 2: Tarjan\\'s Algo\\n * \\tIf there is no island or more than 1 island, return 0;\\n\\tIf there is only one land, return 1;\\n\\tIf any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n\\tOtherwise, return 2 ( I haven\\'t found a formal proof yet).\\n */\\n\\npublic int lands = 0; // if we have only 1 land ie 1 cell with value one then ans is 1\\n\\npublic int minDaysApproach2(int[][] grid) {\\n\\tif (numIslands(grid) != 1)\\n\\t\\treturn 0;\\n\\t// we are here means we have only 1 island\\n\\n\\tif (lands <= 2)\\n\\t\\t// special case when we have 010 land or 0110 like this land in this case island is 1, there is no ap\\n\\t\\treturn lands;\\n\\n\\t// we are here means we have only 1 island, and land is greater then 2 which means ap/bridge is possible\\n\\tHashMap<Integer, List<Integer>> graph = buildGraphFromGrid(grid);\\n\\n\\t//return Bridge.getBridges(graph).size() > 0 ? 1 : 2;\\n\\treturn ArticulationPoints.getAP(graph).size() > 0 ? 1 : 2;\\n}\\n\\npublic HashMap<Integer, List<Integer>> buildGraphFromGrid(int[][] grid) {\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList = new HashMap<Integer, List<Integer>>();\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tfor (int j = 0; j < grid[0].length; j++)\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs)\\n\\t\\t\\t\\t\\t\\tmark(grid, i, j, i + dir[0], j + dir[1], adjacencyList);\\n\\n\\t\\treturn adjacencyList;\\n\\t}\\n\\n\\tpublic static void mark(int grid[][], int prevX, int prevY, int x, int y,\\n\\t\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\t\\tif (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0)\\n\\t\\t\\treturn;\\n\\t\\tint n1 = prevX * grid[0].length + prevY;\\n\\t\\tint n2 = x * grid[0].length + y;\\n\\t\\tadjacencyList.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n\\t\\tadjacencyList.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n\\t}\\n\\n\\n\\n\\n/*************************Utilities*******************************/\\npublic class ArticulationPoints {\\n\\nprivate static int time;\\n\\n// The function to do DFS traversal. It uses recursive function APUtil() \\npublic static List<Integer> getAP(HashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Initialize parent and visited, and ap(articulation point) arrays\\n\\tList<Integer> ap = new ArrayList();\\n\\tHashMap<Integer, Integer> disc = new HashMap<Integer, Integer>(); // vertex, discovery value\\n\\tHashMap<Integer, Integer> low = new HashMap<Integer, Integer>(); // vertex, low value\\n\\tHashMap<Integer, Integer> parent = new HashMap<Integer, Integer>(); // // child vertex, parent vertex\\n\\n\\tSet<Integer> visited = new HashSet<Integer>();\\n\\n\\t// Call the recursive helper function to find articulation \\n\\t// points in DFS tree\\n\\n\\tfor (Map.Entry<Integer, List<Integer>> entry : adjacencyList.entrySet()) {\\n\\t\\tint v = entry.getKey();\\n\\t\\tif (!disc.containsKey(v))\\n\\t\\t\\tAPUtil(v, visited, disc, low, parent, ap, adjacencyList);\\n\\t}\\n\\treturn ap;\\n}\\n\\n// A recursive function that find articulation points using DFS \\n// u --> The vertex to be visited next \\n// visited[] --> keeps tract of visited vertices \\n// disc[] --> Stores discovery times of visited vertices \\n// parent[] --> Stores parent vertices in DFS tree \\n// ap[] --> Store articulation points \\npublic static void APUtil(int currVertex, Set<Integer> visited, HashMap<Integer, Integer> disc,\\n\\t\\tHashMap<Integer, Integer> low, HashMap<Integer, Integer> parent, List<Integer> ap,\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Count of children in DFS Tree \\n\\tint children = 0;\\n\\n\\t// Mark the current node as visited \\n\\tvisited.add(currVertex);\\n\\n\\t// Initialize discovery time and low value\\n\\n\\tdisc.put(currVertex, time);\\n\\tlow.put(currVertex, time);\\n\\t++time;\\n\\n\\tint neighbor;\\n\\n\\tif (adjacencyList.containsKey(currVertex)) {\\n\\t\\t// Go through all vertices adjacent to this  \\n\\t\\tIterator<Integer> itr = adjacencyList.get(currVertex).iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\n\\t\\t\\tneighbor = itr.next();\\n//\\t\\t\\t\\t//if neighbor is same as parent then just ignore this vertex.\\n//\\t            if(parent.containsKey(currVertex) && neighbor == parent.get(currVertex)) {\\n//\\t                continue;\\n//\\t            }\\n\\n\\t\\t\\t// If neighbor is not visited yet, then make it a child of currVertex \\n\\t\\t\\t// in DFS tree and recur for it \\n\\t\\t\\tif (!visited.contains(neighbor)) {\\n\\t\\t\\t\\tchildren++;\\n\\t\\t\\t\\tparent.put(neighbor, currVertex);\\n\\t\\t\\t\\tAPUtil(neighbor, visited, disc, low, parent, ap, adjacencyList);\\n\\n\\t\\t\\t\\t// Check if the subtree rooted with neighbor has a connection to \\n\\t\\t\\t\\t// one of the ancestors of currVertex \\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), low.get(neighbor)));\\n\\n\\t\\t\\t\\t// currVertex is an articulation point in following cases \\n\\n\\t\\t\\t\\t// (1) currVertex is root of DFS tree and has two or more chilren. \\n\\t\\t\\t\\t// (2) If currVertex is not root and low value of one of its child is more than discovery value of currVertex.\\n\\t\\t\\t\\tif (parent.get(currVertex) == null && children > 1 || parent.get(currVertex) != null && low.get(neighbor) >= disc.get(currVertex))\\n\\t\\t\\t\\t\\tap.add(currVertex);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update low value of u for parent function calls. \\n\\t\\t\\telse if (parent.containsKey(currVertex) && neighbor != parent.get(currVertex))\\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), disc.get(neighbor)));\\n\\t\\t}\\n\\t}\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 833776,
                "title": "c-reset-bit-solution-for-1568",
                "content": "The solution first tests how many islands are there.\\n\\n-> If there is a single island, it resets every set bit and tests if resetting the bit disconnects the island. If it disconnects the single island into 2 or more islands OR removes a single bit island so that there are no islands left, we return \"one day\" as answer. \\n\\n-> If none of the bits tested could disconnect the single island, then we deduce that at least 2 bits are needed to do the job. It is provable that 2 bits can disconnect any island in any configuration. So, we return \"2 days\" as answer.\\n\\n-> If in the first test, we find no islands or there are already disconnected islands, we simply return \"0 days\" as answer.\\n\\n```\\n/*tktripathy*/\\nclass Solution {\\npublic:\\n    int dir[4][2] = { {-1, 0}, { 1, 0}, { 0, -1}, { 0, 1} };\\n    /* Accumulate adjacent ones to form an island */\\n    void dfs(vector<vector<int>>& g, int r, int c, vector<vector<bool>>& v, int rsz, int csz) \\n    {\\n        v[r][c] = true;                \\n        for (auto d : dir) {\\n            int x = r + d[0], y = c + d[1];\\n            if ((x >= 0 && x < rsz) && (y >= 0 && y < csz) && (g[x][y] && !v[x][y]) )         \\n                dfs(g, x, y, v, rsz, csz);\\n        }\\n    }\\n    /* Count islands */\\n    int ci(vector<vector<int>>& g, int rsz, int csz) {\\n        int ic = 0; vector<vector<bool>> v(rsz, vector<bool>(csz, 0)); \\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j] && !v[i][j]) { dfs(g, i, j, v, rsz, csz); ++ic; }\\n            }\\n        }\\n        return ic;\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        int single = 0, rsz = g.size(), csz = g[0].size();\\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j]) {\\n                    if (!single && ci(g, rsz, csz) == 1) single++; /* found a single island */\\n                    if (single) {       /* if so, reset every set bit and test if resetting */\\n                        g[i][j] = 0;    /* ... a bit might disconnect the island */\\n                        int r = ci(g, rsz, csz); if (r >= 2 /* disconnected */ || !r /* no island left */) return 1 /* one day */;\\n                        g[i][j] = 1;\\n                    } else return 0; /* no islands or already disconnected - zero days */\\n                }\\n            }\\n        }\\n        return 2; /* two days */\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*tktripathy*/\\nclass Solution {\\npublic:\\n    int dir[4][2] = { {-1, 0}, { 1, 0}, { 0, -1}, { 0, 1} };\\n    /* Accumulate adjacent ones to form an island */\\n    void dfs(vector<vector<int>>& g, int r, int c, vector<vector<bool>>& v, int rsz, int csz) \\n    {\\n        v[r][c] = true;                \\n        for (auto d : dir) {\\n            int x = r + d[0], y = c + d[1];\\n            if ((x >= 0 && x < rsz) && (y >= 0 && y < csz) && (g[x][y] && !v[x][y]) )         \\n                dfs(g, x, y, v, rsz, csz);\\n        }\\n    }\\n    /* Count islands */\\n    int ci(vector<vector<int>>& g, int rsz, int csz) {\\n        int ic = 0; vector<vector<bool>> v(rsz, vector<bool>(csz, 0)); \\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j] && !v[i][j]) { dfs(g, i, j, v, rsz, csz); ++ic; }\\n            }\\n        }\\n        return ic;\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        int single = 0, rsz = g.size(), csz = g[0].size();\\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j]) {\\n                    if (!single && ci(g, rsz, csz) == 1) single++; /* found a single island */\\n                    if (single) {       /* if so, reset every set bit and test if resetting */\\n                        g[i][j] = 0;    /* ... a bit might disconnect the island */\\n                        int r = ci(g, rsz, csz); if (r >= 2 /* disconnected */ || !r /* no island left */) return 1 /* one day */;\\n                        g[i][j] = 1;\\n                    } else return 0; /* no islands or already disconnected - zero days */\\n                }\\n            }\\n        }\\n        return 2; /* two days */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833465,
                "title": "c-count-the-number-of-islands-time-complexity-o-mn-2-space-complexity-o-mn",
                "content": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int size = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    size++;\\n                }\\n                \\n                if (size > 1)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (size > 1) \\n            {\\n                break;\\n            }\\n        }\\n        \\n        int islandCount = GetNumberOfIslands(grid);\\n        if (islandCount == 0 || islandCount > 1) \\n        {\\n            return 0;\\n        }\\n        \\n        if (size == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    if (GetNumberOfIslands(grid) > 1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited= new bool[m,n];\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] { 0, 1},\\n            new int[2] { 0, -1},\\n            new int[2] { 1, 0}, \\n            new int[2] { -1, 0}\\n        };\\n        \\n        int count = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1 && !visited[i,j])\\n                {\\n                    dfs(grid, i, j, visited, dirs);\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs)\\n    {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs)\\n        {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n            if (IsInBoundary(grid, nexti, nextj) && grid[nexti][nextj] == 1 && !visited[nexti, nextj])\\n            {\\n                dfs(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBoundary(int[][] grid, int i, int j)\\n    {\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int size = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    size++;\\n                }\\n                \\n                if (size > 1)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (size > 1) \\n            {\\n                break;\\n            }\\n        }\\n        \\n        int islandCount = GetNumberOfIslands(grid);\\n        if (islandCount == 0 || islandCount > 1) \\n        {\\n            return 0;\\n        }\\n        \\n        if (size == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    if (GetNumberOfIslands(grid) > 1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited= new bool[m,n];\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] { 0, 1},\\n            new int[2] { 0, -1},\\n            new int[2] { 1, 0}, \\n            new int[2] { -1, 0}\\n        };\\n        \\n        int count = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1 && !visited[i,j])\\n                {\\n                    dfs(grid, i, j, visited, dirs);\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs)\\n    {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs)\\n        {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n            if (IsInBoundary(grid, nexti, nextj) && grid[nexti][nextj] == 1 && !visited[nexti, nextj])\\n            {\\n                dfs(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBoundary(int[][] grid, int i, int j)\\n    {\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826428,
                "title": "rust-translated-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_days(g: Vec<Vec<i32>>) -> i32 {\\n        const DIR: [i32; 5] = [0, 1, 0, -1, 0];\\n\\n        fn dfs(\\n            grid: &Vec<Vec<i32>>,\\n            i: i32,\\n            j: i32,\\n            depth: &mut Vec<Vec<i32>>,\\n            low: &mut Vec<Vec<i32>>,\\n            parent: &mut Vec<Vec<i32>>,\\n            time: &mut i32,\\n            is_articulation_point: &mut bool,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            depth[i as usize][j as usize] = *time;\\n            *time += 1;\\n            low[i as usize][j as usize] = depth[i as usize][j as usize];\\n            let mut children = 0;\\n            for k in 0..4 {\\n                let ni = i + DIR[k as usize];\\n                let nj = j + DIR[k as usize + 1];\\n                if ni >= 0\\n                    && ni < m as i32\\n                    && nj >= 0\\n                    && nj < n as i32\\n                    && grid[ni as usize][nj as usize] == 1\\n                {\\n                    //valid connection\\n                    if depth[ni as usize][nj as usize] == -1 {\\n                        children += 1;\\n                        parent[ni as usize][nj as usize] = i * n as i32 + j;\\n                        dfs(\\n                            grid,\\n                            ni,\\n                            nj,\\n                            depth,\\n                            low,\\n                            parent,\\n                            time,\\n                            is_articulation_point,\\n                        );\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            low[ni as usize][nj as usize],\\n                        );\\n                        if low[ni as usize][nj as usize] >= depth[i as usize][j as usize]\\n                            && parent[i as usize][j as usize] > -1\\n                        {\\n                            *is_articulation_point = true;\\n                        }\\n                    } else if ni * n as i32 + nj != parent[i as usize][j as usize] {\\n                        //ignore the incoming path\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            depth[ni as usize][nj as usize],\\n                        );\\n                    }\\n                }\\n            }\\n            if parent[i as usize][j as usize] == -1 && children > 1 {\\n                *is_articulation_point = true;\\n            }\\n        }\\n\\n        let m = g.len();\\n        let n = g[0].len();\\n        let mut is_articulation_point = false;\\n        let mut time = 0;\\n\\n        let mut lands = 0;\\n        let mut islands = 0;\\n\\n        let mut depth = vec![vec![-1; n]; m];\\n        let mut low = vec![vec![-1; n]; m];\\n        let mut parent = vec![vec![-1; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                if g[i][j] == 1 {\\n                    lands += 1;\\n                    if depth[i][j] == -1 {\\n                        dfs(\\n                            &g,\\n                            i as i32,\\n                            j as i32,\\n                            &mut depth,\\n                            &mut low,\\n                            &mut parent,\\n                            &mut time,\\n                            &mut is_articulation_point,\\n                        );\\n                        islands += 1;\\n                    }\\n                }\\n            }\\n        }\\n        if islands == 0 || islands >= 2 {\\n            return 0;\\n        }\\n        if lands == 1 {\\n            return 1;\\n        }\\n        if is_articulation_point {\\n            return 1;\\n        }\\n        return 2;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_days() {\\n        assert_eq!(\\n            Solution::min_days(vec![vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 0, 0, 0]]),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_02() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 1]]), 2)\\n    }\\n\\n    #[test]\\n    fn test_min_days_03() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 0, 1, 0]]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_days_04() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 0, 1, 1]\\n            ]),\\n            1\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_05() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1]\\n            ]),\\n            2\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_days(g: Vec<Vec<i32>>) -> i32 {\\n        const DIR: [i32; 5] = [0, 1, 0, -1, 0];\\n\\n        fn dfs(\\n            grid: &Vec<Vec<i32>>,\\n            i: i32,\\n            j: i32,\\n            depth: &mut Vec<Vec<i32>>,\\n            low: &mut Vec<Vec<i32>>,\\n            parent: &mut Vec<Vec<i32>>,\\n            time: &mut i32,\\n            is_articulation_point: &mut bool,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            depth[i as usize][j as usize] = *time;\\n            *time += 1;\\n            low[i as usize][j as usize] = depth[i as usize][j as usize];\\n            let mut children = 0;\\n            for k in 0..4 {\\n                let ni = i + DIR[k as usize];\\n                let nj = j + DIR[k as usize + 1];\\n                if ni >= 0\\n                    && ni < m as i32\\n                    && nj >= 0\\n                    && nj < n as i32\\n                    && grid[ni as usize][nj as usize] == 1\\n                {\\n                    //valid connection\\n                    if depth[ni as usize][nj as usize] == -1 {\\n                        children += 1;\\n                        parent[ni as usize][nj as usize] = i * n as i32 + j;\\n                        dfs(\\n                            grid,\\n                            ni,\\n                            nj,\\n                            depth,\\n                            low,\\n                            parent,\\n                            time,\\n                            is_articulation_point,\\n                        );\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            low[ni as usize][nj as usize],\\n                        );\\n                        if low[ni as usize][nj as usize] >= depth[i as usize][j as usize]\\n                            && parent[i as usize][j as usize] > -1\\n                        {\\n                            *is_articulation_point = true;\\n                        }\\n                    } else if ni * n as i32 + nj != parent[i as usize][j as usize] {\\n                        //ignore the incoming path\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            depth[ni as usize][nj as usize],\\n                        );\\n                    }\\n                }\\n            }\\n            if parent[i as usize][j as usize] == -1 && children > 1 {\\n                *is_articulation_point = true;\\n            }\\n        }\\n\\n        let m = g.len();\\n        let n = g[0].len();\\n        let mut is_articulation_point = false;\\n        let mut time = 0;\\n\\n        let mut lands = 0;\\n        let mut islands = 0;\\n\\n        let mut depth = vec![vec![-1; n]; m];\\n        let mut low = vec![vec![-1; n]; m];\\n        let mut parent = vec![vec![-1; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                if g[i][j] == 1 {\\n                    lands += 1;\\n                    if depth[i][j] == -1 {\\n                        dfs(\\n                            &g,\\n                            i as i32,\\n                            j as i32,\\n                            &mut depth,\\n                            &mut low,\\n                            &mut parent,\\n                            &mut time,\\n                            &mut is_articulation_point,\\n                        );\\n                        islands += 1;\\n                    }\\n                }\\n            }\\n        }\\n        if islands == 0 || islands >= 2 {\\n            return 0;\\n        }\\n        if lands == 1 {\\n            return 1;\\n        }\\n        if is_articulation_point {\\n            return 1;\\n        }\\n        return 2;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_days() {\\n        assert_eq!(\\n            Solution::min_days(vec![vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 0, 0, 0]]),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_02() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 1]]), 2)\\n    }\\n\\n    #[test]\\n    fn test_min_days_03() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 0, 1, 0]]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_days_04() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 0, 1, 1]\\n            ]),\\n            1\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_05() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1]\\n            ]),\\n            2\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826021,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "Answer can never be greater than 2 because it takes only two diagonal blocks to detach corner block from rest of the island. Just make each block with value one to zero and search in rest of the matrix, when for a particular block you can get island disconnected it is 1 else 2.\\nAlso for peaople using C++, here time constraints are tight, so instead of visited set use a 2D vector, send calls only when size and value checks are satisified, else it will give TLE.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int rows, int cols, int i, int j, vector<vector<int>>& visited){\\n        visited[i][j] = 1;\\n        if(i<rows-1 && visited[i+1][j]==0 && grid[i+1][j]==1 )dfs(grid, rows, cols, i+1, j, visited);\\n        if(i>0 && visited[i-1][j]==0 && grid[i-1][j]==1 )dfs(grid, rows, cols, i-1, j, visited);\\n        if(j<cols-1 && visited[i][j+1]==0 && grid[i][j+1]==1 )dfs(grid, rows, cols, i, j+1, visited);\\n        if(j>0 && visited[i][j-1]==0 && grid[i][j-1]==1 )dfs(grid, rows, cols, i, j-1, visited);\\n        return;\\n    }\\n    \\n    int countIslands(vector<vector<int>>& grid, int rows, int cols){\\n        vector<vector<int>> visited(rows, vector<int>(cols,0));\\n        int count = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j]==1 && visited[i][j]==0){\\n                    dfs(grid, rows, cols, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if(countIslands(grid,rows,cols)!=1){\\n            return 0;\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(countIslands(grid,rows,cols)!=1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int rows, int cols, int i, int j, vector<vector<int>>& visited){\\n        visited[i][j] = 1;\\n        if(i<rows-1 && visited[i+1][j]==0 && grid[i+1][j]==1 )dfs(grid, rows, cols, i+1, j, visited);\\n        if(i>0 && visited[i-1][j]==0 && grid[i-1][j]==1 )dfs(grid, rows, cols, i-1, j, visited);\\n        if(j<cols-1 && visited[i][j+1]==0 && grid[i][j+1]==1 )dfs(grid, rows, cols, i, j+1, visited);\\n        if(j>0 && visited[i][j-1]==0 && grid[i][j-1]==1 )dfs(grid, rows, cols, i, j-1, visited);\\n        return;\\n    }\\n    \\n    int countIslands(vector<vector<int>>& grid, int rows, int cols){\\n        vector<vector<int>> visited(rows, vector<int>(cols,0));\\n        int count = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j]==1 && visited[i][j]==0){\\n                    dfs(grid, rows, cols, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if(countIslands(grid,rows,cols)!=1){\\n            return 0;\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(countIslands(grid,rows,cols)!=1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825911,
                "title": "c-time-n-3-space-n",
                "content": "1. C# deep copy for 2D array.\\n2. DFS along with dp.\\n\\'\\'\\'\\'\\npublic class Solution {\\n    int[] ax = new int[4]{1,-1,0,0};\\n    int[] ay = new int[4]{0,0,-1,1};\\n    public int MinDays(int[][] grid) {\\n        int days = 0;\\n        if(CountIslands(grid.Select(a => a.ToArray()).ToArray()) != 1)\\n            return days;\\n      \\n        days = 1;        \\n        for(int i =0; i<grid.Count(); i++)\\n        {\\n            for(int j = 0; j<grid[0].Count(); j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j] = 0;                                 \\n                    if(CountIslands(grid.Select(e=>e.ToArray()).ToArray()) != 1) \\n                        return days;\\n                    grid[i][j] = 1;\\n                }\\n               \\n            }\\n        }        \\n        \\n        return 2;\\n    }\\n    \\n    public int CountIslands(int[][] grid)\\n    {\\n        int ret = 0;\\n        for(int i = 0; i<grid.Count(); i++)\\n        {\\n            for( int j = 0; j<grid[0].Count(); j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    Dfs(grid, i, j);                    \\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public void Dfs(int[][] grid, int i, int j)\\n    {\\n        if(grid[i][j]==0) return;\\n        grid[i][j] = 0;\\n        for(int a = 0; a<4; a++)\\n        {\\n            int nx = i + ax[a];\\n            int ny = j + ay[a];\\n            if(nx>=0 && ny>=0 && nx<grid.Count() && ny<grid[0].Count())\\n                Dfs(grid, nx, ny);\\n        }\\n        return;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] ax = new int[4]{1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 824919,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minDays(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tpath = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tidx = []\\n\\t\\t\\tseen = set()\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tidx.append((i, j))\\n\\t\\t\\tif not idx:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(idx) == 1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tdef check(stack, seen):\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\ta, b = stack.pop()\\n\\t\\t\\t\\t\\tif (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\t\\t\\t\\tfor i in path:\\n\\t\\t\\t\\t\\t\\t\\tx = a + i[0]\\n\\t\\t\\t\\t\\t\\t\\ty = b + i[1]\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < r and 0 <= y < c and grid[x][y] == 1 and (x, y) not in seen:\\n\\t\\t\\t\\t\\t\\t\\t\\tstack.append((x, y))            \\n\\t\\t\\t\\treturn len(seen)\\n\\t\\t\\tif check([idx[0]], seen) < len(idx):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tfor i in range(len(idx)):\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 0\\n\\t\\t\\t\\ttmp = idx[:i] + idx[i + 1:]\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tif (check([tmp[0]], seen)) < len(tmp):\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 1\\n\\t\\t\\treturn 2",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minDays(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tpath = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tidx = []\\n\\t\\t\\tseen = set()\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tidx.append((i, j))\\n\\t\\t\\tif not idx:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(idx) == 1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tdef check(stack, seen):\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\ta, b = stack.pop()\\n\\t\\t\\t\\t\\tif (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\t\\t\\t\\tfor i in path:\\n\\t\\t\\t\\t\\t\\t\\tx = a + i[0]\\n\\t\\t\\t\\t\\t\\t\\ty = b + i[1]\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < r and 0 <= y < c and grid[x][y] == 1 and (x, y) not in seen:\\n\\t\\t\\t\\t\\t\\t\\t\\tstack.append((x, y))            \\n\\t\\t\\t\\treturn len(seen)\\n\\t\\t\\tif check([idx[0]], seen) < len(idx):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tfor i in range(len(idx)):\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 0\\n\\t\\t\\t\\ttmp = idx[:i] + idx[i + 1:]\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tif (check([tmp[0]], seen)) < len(tmp):\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 1\\n\\t\\t\\treturn 2",
                "codeTag": "Java"
            },
            {
                "id": 824206,
                "title": "java-dfs-25ms-faster-than-90-72",
                "content": "```\\npublic int minDays(int[][] grid) {\\n\\tint r = grid.length;\\n\\tint c = grid[0].length;\\n\\tboolean[][] used = new boolean[r][c];\\n\\tint count = 0, size = 0;\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tsize++; //size the vaule 1\\n\\t\\t\\t//get the max island \\n\\t\\t\\tcount = Math.max(count, dfs(grid, used, i, j));\\n\\t\\t}\\n\\t}\\n\\t// if size of vaule 1 is not equal count  , so it is disconntected reutrn 0.\\n\\tif (size != count) return 0;\\n\\t//if just one vaule 1, return 1\\n\\tif (size == 1) return 1;\\n\\t\\n\\t// check if remove one value 1,  if can made it is disconntected return 1;  otherwise return 2.\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tboolean[][] t = new boolean[r][c];\\n\\t\\t\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i - 1, j);\\n\\t\\t\\t} else if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i + 1, j);\\n\\t\\t\\t} else if (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j - 1);\\n\\t\\t\\t} else if (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (res + 1 != size) return 1;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t}\\n\\t}\\n\\treturn 2;\\n}\\n\\nint dfs(int[][] grid, boolean[][] used, int i, int j) {\\n\\tif (used[i][j]) return 0;\\n\\tint res = grid[i][j];\\n\\tused[i][j] = true;\\n\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i - 1, j);\\n\\t}\\n\\tif (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i + 1, j);\\n\\t}\\n\\tif (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j - 1);\\n\\t}\\n\\tif (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int minDays(int[][] grid) {\\n\\tint r = grid.length;\\n\\tint c = grid[0].length;\\n\\tboolean[][] used = new boolean[r][c];\\n\\tint count = 0, size = 0;\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tsize++; //size the vaule 1\\n\\t\\t\\t//get the max island \\n\\t\\t\\tcount = Math.max(count, dfs(grid, used, i, j));\\n\\t\\t}\\n\\t}\\n\\t// if size of vaule 1 is not equal count  , so it is disconntected reutrn 0.\\n\\tif (size != count) return 0;\\n\\t//if just one vaule 1, return 1\\n\\tif (size == 1) return 1;\\n\\t\\n\\t// check if remove one value 1,  if can made it is disconntected return 1;  otherwise return 2.\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tboolean[][] t = new boolean[r][c];\\n\\t\\t\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i - 1, j);\\n\\t\\t\\t} else if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i + 1, j);\\n\\t\\t\\t} else if (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j - 1);\\n\\t\\t\\t} else if (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (res + 1 != size) return 1;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t}\\n\\t}\\n\\treturn 2;\\n}\\n\\nint dfs(int[][] grid, boolean[][] used, int i, int j) {\\n\\tif (used[i][j]) return 0;\\n\\tint res = grid[i][j];\\n\\tused[i][j] = true;\\n\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i - 1, j);\\n\\t}\\n\\tif (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i + 1, j);\\n\\t}\\n\\tif (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j - 1);\\n\\t}\\n\\tif (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824175,
                "title": "c-dfs-with-explanation",
                "content": "Basically, the answer <= 2;\\nIf there are more than 1 islands or there are no islands.  \\n&nbsp;&nbsp;&nbsp;&nbsp;return 0,\\nelse, \\n&nbsp;&nbsp;&nbsp;&nbsp;try to erase some points then count how many islands are there now.\\n&nbsp;&nbsp;&nbsp;&nbsp;there are only few points we should test,\\n1. a point connecting to two points, and they are on the same line.\\n111 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 1\\n111 (1) 1 1 \\n111 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 1\\n\\n2. a point connecting with several points, and one of them connecting only 1 other point.\\n1 1 &nbsp;1\\n1 1 (1) 1\\n1 1 &nbsp;1\\n\\n3. a point connecting with no other points(an island it self)\\n0 &nbsp;0&nbsp; 0\\n0 (1) 0\\n0&nbsp; 0&nbsp; 0\\n\\n(The 1 surrended in brackets should be test). \\n\\nIf there are 0 or more than 1 islands,\\n&nbsp;&nbsp;&nbsp;&nbsp;return 1\\nelse \\n&nbsp;&nbsp;&nbsp;&nbsp;return 2\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> directions = {{-1,0}, {1, 0}, {0, -1}, {0,1}};\\nvoid dfs(vector<vector<int>>& grid, int row, int col, vector<vector<int>>* points = NULL)\\n{\\n\\tint count = 0;\\n\\tvector<int> dir(4);\\n\\tfor (int i = 0; i < directions.size(); i++)\\n\\t{\\n\\t\\tint r = row + directions[i][0];\\n\\t\\tint c = col + directions[i][1];\\n\\n\\t\\tif (r >= 0 && r < grid.size() && c >= 0 && c < grid[r].size() && grid[r][c])\\n\\t\\t{\\n\\t\\t\\tdir[i] = 1;\\n\\t\\t\\t++count;\\n\\t\\t\\tif (grid[r][c] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[r][c] = 2;\\t\\t\\t\\t\\n\\t\\t\\t\\tdfs(grid, r, c, points);\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tif(points)\\n\\t{\\n\\t\\tif (count == 0 || (count == 2 && ((dir[0] & dir[1]) ^ (dir[2] & dir[3]))))\\n\\t\\t\\tpoints->push_back({row, col});\\n\\t\\telse if(count == 1) \\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < dir.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dir[i]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpoints->push_back({row + directions[i][0], col + directions[i][1]});\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n}\\n\\nint islandCount(vector<vector<int>> grid, vector<vector<int>>* points = NULL)\\n{\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < grid[i].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tdfs(grid, i, j, points);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tvector<vector<int>> points;\\n\\n\\tint cnt = islandCount(grid, &points);\\n\\tif(cnt > 1 || cnt == 0)\\n\\t\\treturn 0;\\n\\n\\tfor(int i = 0; i < points.size(); i++)\\n\\t{\\n\\t\\tgrid[points[i][0]][points[i][1]] = 0;\\n        int cnt = islandCount(grid);\\n\\t\\tif(cnt > 1 || cnt == 0)\\n\\t\\t\\treturn 1;\\n\\t\\tgrid[points[i][0]][points[i][1]] = 1;\\n\\t}\\n\\treturn 2;\\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> directions = {{-1,0}, {1, 0}, {0, -1}, {0,1}};\\nvoid dfs(vector<vector<int>>& grid, int row, int col, vector<vector<int>>* points = NULL)\\n{\\n\\tint count = 0;\\n\\tvector<int> dir(4);\\n\\tfor (int i = 0; i < directions.size(); i++)\\n\\t{\\n\\t\\tint r = row + directions[i][0];\\n\\t\\tint c = col + directions[i][1];\\n\\n\\t\\tif (r >= 0 && r < grid.size() && c >= 0 && c < grid[r].size() && grid[r][c])\\n\\t\\t{\\n\\t\\t\\tdir[i] = 1;\\n\\t\\t\\t++count;\\n\\t\\t\\tif (grid[r][c] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[r][c] = 2;\\t\\t\\t\\t\\n\\t\\t\\t\\tdfs(grid, r, c, points);\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tif(points)\\n\\t{\\n\\t\\tif (count == 0 || (count == 2 && ((dir[0] & dir[1]) ^ (dir[2] & dir[3]))))\\n\\t\\t\\tpoints->push_back({row, col});\\n\\t\\telse if(count == 1) \\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < dir.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dir[i]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpoints->push_back({row + directions[i][0], col + directions[i][1]});\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n}\\n\\nint islandCount(vector<vector<int>> grid, vector<vector<int>>* points = NULL)\\n{\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < grid[i].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tdfs(grid, i, j, points);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tvector<vector<int>> points;\\n\\n\\tint cnt = islandCount(grid, &points);\\n\\tif(cnt > 1 || cnt == 0)\\n\\t\\treturn 0;\\n\\n\\tfor(int i = 0; i < points.size(); i++)\\n\\t{\\n\\t\\tgrid[points[i][0]][points[i][1]] = 0;\\n        int cnt = islandCount(grid);\\n\\t\\tif(cnt > 1 || cnt == 0)\\n\\t\\t\\treturn 1;\\n\\t\\tgrid[points[i][0]][points[i][1]] = 1;\\n\\t}\\n\\treturn 2;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822473,
                "title": "c-dfs-1-4-positive",
                "content": "The answer is:\\n1. Zero if there is no islands or more than one island.\\n2. One when there is a single piece of land that connects two or more semi-islands. \\n3. Two otherwise.\\n\\nHow to tell if a land connects semi-islands? If it does not, doing DFS in one direction will explore the entire island. If it does, we need to do DFS in more directions.\\n\\nIn other words, if a land does not connect semi-islands, the result of DFS will be positive for only one direction.\\n\\n```cpp\\nint fill(vector<vector<int>>& g, int i, int j, int col, bool top = false) {\\n    if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != col)\\n        return 0;\\n    g[i][j] = col + 1;\\n    int r = fill(g, i + 1, j, col), l = fill(g, i - 1, j, col);\\n    int d = fill(g, i, j + 1, col), u = fill(g, i, j - 1, col);\\n    if (top)\\n        return max({r, l, d, u}) == r + l + d + u ? 2 : 1;\\n    else \\n        return 1 + r + l + d + u;\\n}\\nint minDays(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (auto i = 0; i < g.size(); ++i)\\n        for (auto j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j]) {\\n                if (g[i][j] == 1 && res != 0)\\n                    return 0;\\n                res = res == 1 ? 1 : fill(g, i, j, g[i][j], true);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint fill(vector<vector<int>>& g, int i, int j, int col, bool top = false) {\\n    if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != col)\\n        return 0;\\n    g[i][j] = col + 1;\\n    int r = fill(g, i + 1, j, col), l = fill(g, i - 1, j, col);\\n    int d = fill(g, i, j + 1, col), u = fill(g, i, j - 1, col);\\n    if (top)\\n        return max({r, l, d, u}) == r + l + d + u ? 2 : 1;\\n    else \\n        return 1 + r + l + d + u;\\n}\\nint minDays(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (auto i = 0; i < g.size(); ++i)\\n        for (auto j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j]) {\\n                if (g[i][j] == 1 && res != 0)\\n                    return 0;\\n                res = res == 1 ? 1 : fill(g, i, j, g[i][j], true);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822411,
                "title": "python",
                "content": "```\\nimport copy\\n\\n# function that returns how many island in the given grid\\ndef num_island(grid):\\n    neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n    def adjacent(x, y):\\n        return [[x+nx, y+ny] for nx, ny in neighbors if 0 <= x+nx < len(grid) and 0 <= y+ny < len(grid[0])]\\n        \\n    def recur(grid, r, c):\\n        if grid[r][c] == 0:\\n            pass\\n            \\n        grid[r][c] = 0\\n        \\n        neighbor = adjacent(r, c)\\n        \\n        for x, y in neighbor:\\n            if grid[x][y] == 1:\\n                recur(grid, x, y)\\n        return grid\\n        \\n    ret = 0\\n    for i, r in enumerate(grid):\\n        for j, c in enumerate(r):\\n            if c == 1:\\n                ret += 1\\n                grid = recur(grid, i, j)\\n    return ret\\n\\nclass Solution(object):\\n    def minDays(self, grid):\\n        grid_cpy = copy.deepcopy(grid)\\n        target = num_island(grid_cpy)\\n\\n        # island is already diconnected\\n        if target >= 2 or target == 0:\\n            return 0\\n\\n        # one island case\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    grid_cpy = copy.deepcopy(grid)\\n                    grid_cpy[i][j] = 0\\n                    if num_island(grid_cpy) == 2:\\n                        return 1\\n        return 2\\n```\\nsource: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819303/Python-you-need-at-most-2-days",
                "solutionTags": [],
                "code": "```\\nimport copy\\n\\n# function that returns how many island in the given grid\\ndef num_island(grid):\\n    neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n    def adjacent(x, y):\\n        return [[x+nx, y+ny] for nx, ny in neighbors if 0 <= x+nx < len(grid) and 0 <= y+ny < len(grid[0])]\\n        \\n    def recur(grid, r, c):\\n        if grid[r][c] == 0:\\n            pass\\n            \\n        grid[r][c] = 0\\n        \\n        neighbor = adjacent(r, c)\\n        \\n        for x, y in neighbor:\\n            if grid[x][y] == 1:\\n                recur(grid, x, y)\\n        return grid\\n        \\n    ret = 0\\n    for i, r in enumerate(grid):\\n        for j, c in enumerate(r):\\n            if c == 1:\\n                ret += 1\\n                grid = recur(grid, i, j)\\n    return ret\\n\\nclass Solution(object):\\n    def minDays(self, grid):\\n        grid_cpy = copy.deepcopy(grid)\\n        target = num_island(grid_cpy)\\n\\n        # island is already diconnected\\n        if target >= 2 or target == 0:\\n            return 0\\n\\n        # one island case\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    grid_cpy = copy.deepcopy(grid)\\n                    grid_cpy[i][j] = 0\\n                    if num_island(grid_cpy) == 2:\\n                        return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821826,
                "title": "javascript-tarjan-s-algorithm",
                "content": "General\\n```\\nvar minDays = function(grid) {\\n  \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                if(getNumIsland(grid,i,j) != 1) return 1;\\n            }\\n        }\\n    }\\n    \\n    return 2;\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```\\n\\nTarjan\\n```\\nvar minDays = function(grid) {\\n    let cellsCount = 0;\\n    let bridge = new Array();\\n    \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    if(cellsCount == 2) return 2;\\n        \\n    let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                tarjan(grid,i,j,dp,1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n\\n    if(0 < bridge.length) return 1;\\n    \\n    return 2;\\n    \\n    function tarjan(grid,row,col,dp,count,dir=-1){\\n        \\n        if(0 < dp[row][col]) return dp[row][col];\\n        \\n        dp[row][col] = count;\\n        \\n        let min = Number.MAX_VALUE;\\n        \\n        if(col + 1 < grid[0].length && grid[row][col+1] == 1 && dir != 1) {\\n            min = Math.min(min, tarjan(grid, row,col + 1,dp,count+1,3));\\n        }\\n        if(row + 1 < grid.length && grid[row+1][col] == 1 && dir != 0) {\\n            min = Math.min(min, tarjan(grid, row+1,col,dp,count+1,2));\\n        }\\n        if(0 <= col - 1 && grid[row][col-1] == 1 && dir != 3) {\\n            min = Math.min(min, tarjan(grid, row,col - 1,dp,count+1,1));\\n        }\\n        if(0 <= row - 1 && grid[row-1][col] == 1 && dir != 2) {\\n            min = Math.min(min, tarjan(grid, row-1,col,dp,count+1,0));\\n        }\\n        if(count < min) bridge.push([row,col]);\\n        else dp[row][col] = min;\\n        \\n        return Math.min(count, min);\\n    }\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1) cellsCount++;\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(grid) {\\n  \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                if(getNumIsland(grid,i,j) != 1) return 1;\\n            }\\n        }\\n    }\\n    \\n    return 2;\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```\n```\\nvar minDays = function(grid) {\\n    let cellsCount = 0;\\n    let bridge = new Array();\\n    \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    if(cellsCount == 2) return 2;\\n        \\n    let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                tarjan(grid,i,j,dp,1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n\\n    if(0 < bridge.length) return 1;\\n    \\n    return 2;\\n    \\n    function tarjan(grid,row,col,dp,count,dir=-1){\\n        \\n        if(0 < dp[row][col]) return dp[row][col];\\n        \\n        dp[row][col] = count;\\n        \\n        let min = Number.MAX_VALUE;\\n        \\n        if(col + 1 < grid[0].length && grid[row][col+1] == 1 && dir != 1) {\\n            min = Math.min(min, tarjan(grid, row,col + 1,dp,count+1,3));\\n        }\\n        if(row + 1 < grid.length && grid[row+1][col] == 1 && dir != 0) {\\n            min = Math.min(min, tarjan(grid, row+1,col,dp,count+1,2));\\n        }\\n        if(0 <= col - 1 && grid[row][col-1] == 1 && dir != 3) {\\n            min = Math.min(min, tarjan(grid, row,col - 1,dp,count+1,1));\\n        }\\n        if(0 <= row - 1 && grid[row-1][col] == 1 && dir != 2) {\\n            min = Math.min(min, tarjan(grid, row-1,col,dp,count+1,0));\\n        }\\n        if(count < min) bridge.push([row,col]);\\n        else dp[row][col] = min;\\n        \\n        return Math.min(count, min);\\n    }\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1) cellsCount++;\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821665,
                "title": "c-tarjan",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> idx(m, vector<int>(n, -1));\\n        vector<vector<int>> low(m, vector<int>(n, INT_MAX));\\n        vector<vector<int>> dr({{0,1},{1,0},{0,-1},{-1,0}});\\n        int index = 0;\\n        bool foundCut = false;\\n        function<void(int,int,int,int)> dfs = [&](int i, int j, int fi, int fj) {\\n            idx[i][j] = index++;\\n            low[i][j] = idx[i][j];\\n            int count = 0;\\n            for (const auto &d : dr) {\\n                int ni = i + d[0], nj = j + d[1];\\n                if (ni == fi && nj == fj) continue;\\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {\\n                    if (idx[ni][nj] == -1) {\\n                        dfs(ni, nj, i, j);\\n                        if (low[ni][nj] < low[i][j])\\n                            low[i][j] = low[ni][nj];\\n                        if (fi != -1 && low[ni][nj] >= idx[i][j]) foundCut = true;\\n                        count++;\\n                    } else if (idx[ni][nj] < low[i][j]) \\n                        low[i][j] = idx[ni][nj];\\n                }\\n            }\\n            if (fi == -1 && count >= 2) foundCut = true;\\n        };\\n        bool first = true;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && idx[i][j] == -1) {\\n                    if (!first) return 0;\\n                    dfs(i, j, -1, -1);\\n                    first = false;\\n                }\\n            }\\n        }\\n        return foundCut ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> idx(m, vector<int>(n, -1));\\n        vector<vector<int>> low(m, vector<int>(n, INT_MAX));\\n        vector<vector<int>> dr({{0,1},{1,0},{0,-1},{-1,0}});\\n        int index = 0;\\n        bool foundCut = false;\\n        function<void(int,int,int,int)> dfs = [&](int i, int j, int fi, int fj) {\\n            idx[i][j] = index++;\\n            low[i][j] = idx[i][j];\\n            int count = 0;\\n            for (const auto &d : dr) {\\n                int ni = i + d[0], nj = j + d[1];\\n                if (ni == fi && nj == fj) continue;\\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {\\n                    if (idx[ni][nj] == -1) {\\n                        dfs(ni, nj, i, j);\\n                        if (low[ni][nj] < low[i][j])\\n                            low[i][j] = low[ni][nj];\\n                        if (fi != -1 && low[ni][nj] >= idx[i][j]) foundCut = true;\\n                        count++;\\n                    } else if (idx[ni][nj] < low[i][j]) \\n                        low[i][j] = idx[ni][nj];\\n                }\\n            }\\n            if (fi == -1 && count >= 2) foundCut = true;\\n        };\\n        bool first = true;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && idx[i][j] == -1) {\\n                    if (!first) return 0;\\n                    dfs(i, j, -1, -1);\\n                    first = false;\\n                }\\n            }\\n        }\\n        return foundCut ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821152,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n    int find(vector<int> &dp, int tar) {\\n        if (dp[tar] == tar) return tar;\\n        else {\\n            dp[tar] = find(dp, dp[tar]);\\n            return dp[tar];\\n        }\\n    }\\n\\n    void merge(vector<int> &dp, int p, int q) {\\n        auto a = find(dp, p);\\n        auto b = find(dp, q);\\n        dp[b] = dp[a];\\n    }\\n\\n\\n    bool solve(const vector<vector<int>> &grid, int n, int m) {\\n        vector<int> dp(n * m, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) dp[i * m + j] = i * m + j;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == 1) merge(dp, i * m + j, i * m - m + j);\\n                    if (i + 1 < n && grid[i + 1][j] == 1) merge(dp, i * m + j, i * m + m + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == 1) merge(dp, i * m + j, i * m + j - 1);\\n                    if (j + 1 < m && grid[i][j + 1] == 1) merge(dp, i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        int num = 0;\\n        for (int i = 0; i < n * m; ++i)\\n            if (dp[i] == i) num++;\\n        return num != 1;\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        bool ans = solve(grid, n, m);\\n        if (ans) return 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    ans = solve(grid, n, m);\\n                    if (ans) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(vector<int> &dp, int tar) {\\n        if (dp[tar] == tar) return tar;\\n        else {\\n            dp[tar] = find(dp, dp[tar]);\\n            return dp[tar];\\n        }\\n    }\\n\\n    void merge(vector<int> &dp, int p, int q) {\\n        auto a = find(dp, p);\\n        auto b = find(dp, q);\\n        dp[b] = dp[a];\\n    }\\n\\n\\n    bool solve(const vector<vector<int>> &grid, int n, int m) {\\n        vector<int> dp(n * m, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) dp[i * m + j] = i * m + j;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == 1) merge(dp, i * m + j, i * m - m + j);\\n                    if (i + 1 < n && grid[i + 1][j] == 1) merge(dp, i * m + j, i * m + m + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == 1) merge(dp, i * m + j, i * m + j - 1);\\n                    if (j + 1 < m && grid[i][j + 1] == 1) merge(dp, i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        int num = 0;\\n        for (int i = 0; i < n * m; ++i)\\n            if (dp[i] == i) num++;\\n        return num != 1;\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        bool ans = solve(grid, n, m);\\n        if (ans) return 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    ans = solve(grid, n, m);\\n                    if (ans) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821094,
                "title": "java-solution-25ms-simple",
                "content": "```\\nclass Solution {\\n    // deep copy the grid\\n    int[][] copy(int[][] grid){\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            copy[i] = new int[grid[0].length];\\n            System.arraycopy(grid[i], 0, copy[i], 0, grid[0].length);\\n        }\\n        return copy;\\n    }\\n    // make the whole island to 0\\n    void f(int[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0) return;\\n        grid[i][j]=0; \\n        f(grid, i+1, j);\\n        f(grid, i-1, j);\\n        f(grid, i, j+1);\\n        f(grid, i, j-1);\\n    }\\n    // Check if the grid still connect. Make one island to 0 and check if still has 1.\\n    boolean connect(int[][] grid){\\n        boolean flag = false;\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    if(flag) return false;\\n                    f(grid, i, j);\\n                    flag=true;\\n                }\\n        return true;\\n    }\\n\\t\\n    public int minDays(int[][] grid) {\\n        int[][] copy = copy(grid);\\n        if(!connect(copy)) return 0; // case 1, already disconnect\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    copy = copy(grid);\\n                    copy[i][j]=0;\\n                    if(!connect(copy)) return 1; // case 2, set one cell to 0 then disconnct\\n                }\\n        return 2; // case 3, set 2 cells 0 then disconnect. You can ensure to make an edge cell disconnect by at most 2 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // deep copy the grid\\n    int[][] copy(int[][] grid){\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            copy[i] = new int[grid[0].length];\\n            System.arraycopy(grid[i], 0, copy[i], 0, grid[0].length);\\n        }\\n        return copy;\\n    }\\n    // make the whole island to 0\\n    void f(int[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0) return;\\n        grid[i][j]=0; \\n        f(grid, i+1, j);\\n        f(grid, i-1, j);\\n        f(grid, i, j+1);\\n        f(grid, i, j-1);\\n    }\\n    // Check if the grid still connect. Make one island to 0 and check if still has 1.\\n    boolean connect(int[][] grid){\\n        boolean flag = false;\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    if(flag) return false;\\n                    f(grid, i, j);\\n                    flag=true;\\n                }\\n        return true;\\n    }\\n\\t\\n    public int minDays(int[][] grid) {\\n        int[][] copy = copy(grid);\\n        if(!connect(copy)) return 0; // case 1, already disconnect\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    copy = copy(grid);\\n                    copy[i][j]=0;\\n                    if(!connect(copy)) return 1; // case 2, set one cell to 0 then disconnct\\n                }\\n        return 2; // case 3, set 2 cells 0 then disconnect. You can ensure to make an edge cell disconnect by at most 2 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820534,
                "title": "python-remove-one-1-bfs-count-islands-o-n-2",
                "content": "if bfs find 2 or 0 island, return 0\\nremove one 1, if bfs find 2 or 0 island, return 1\\nelse: return 2\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        # if bfs find 2 or 0 island, return 0\\n        # remove one 1, if bfs find 2 or 0 island, return 1\\n        # else: return 2\\n        g = grid\\n        R, C = len(g), len(g[0])\\n        if self.cnt(g) != 1:\\n            return 0\\n        self.reset(g)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] == 0:\\n                    continue\\n                g[r][c] = 0\\n                if self.cnt(g) != 1:\\n                    return 1\\n                g[r][c] = 1\\n                self.reset(g)\\n        return 2 \\n    \\n    def cnt(self, g):\\n        R, C = len(g), len(g[0])\\n        ans = 0\\n        dirs = (0,1),(1,0),(0,-1),(-1,0)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] != 1:\\n                    continue\\n                ans += 1\\n                g[r][c] = 2\\n                q, q2 = [(r,c)], []\\n                while q:\\n                    for r1, c1 in q:\\n                        for dr, dc in dirs:\\n                            r2, c2 = r1 + dr, c1 + dc\\n                            if not (0 <= r2 < R and 0 <= c2 < C):\\n                                continue\\n                            if g[r2][c2] != 1:\\n                                continue\\n                            q2.append((r2,c2))\\n                            g[r2][c2] = 2\\n                    q, q2 = q2, []\\n        return ans\\n    \\n    def reset(self, g):\\n        R, C = len(g), len(g[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] > 0:\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        # if bfs find 2 or 0 island, return 0\\n        # remove one 1, if bfs find 2 or 0 island, return 1\\n        # else: return 2\\n        g = grid\\n        R, C = len(g), len(g[0])\\n        if self.cnt(g) != 1:\\n            return 0\\n        self.reset(g)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] == 0:\\n                    continue\\n                g[r][c] = 0\\n                if self.cnt(g) != 1:\\n                    return 1\\n                g[r][c] = 1\\n                self.reset(g)\\n        return 2 \\n    \\n    def cnt(self, g):\\n        R, C = len(g), len(g[0])\\n        ans = 0\\n        dirs = (0,1),(1,0),(0,-1),(-1,0)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] != 1:\\n                    continue\\n                ans += 1\\n                g[r][c] = 2\\n                q, q2 = [(r,c)], []\\n                while q:\\n                    for r1, c1 in q:\\n                        for dr, dc in dirs:\\n                            r2, c2 = r1 + dr, c1 + dc\\n                            if not (0 <= r2 < R and 0 <= c2 < C):\\n                                continue\\n                            if g[r2][c2] != 1:\\n                                continue\\n                            q2.append((r2,c2))\\n                            g[r2][c2] = 2\\n                    q, q2 = q2, []\\n        return ans\\n    \\n    def reset(self, g):\\n        R, C = len(g), len(g[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] > 0:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820385,
                "title": "c-brute-force-dfs-solution",
                "content": "```\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tif(getIslandCount(grid) != 1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[row][col] = 0;\\n\\n\\t\\t\\t\\tif(getIslandCount(grid) != 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgrid[row][col] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn 2;\\n}\\n\\nint getIslandCount(const vector<vector<int>>& grid)\\n{\\n\\tvector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n\\tint count = 0;\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(!visited[row][col] && grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(grid, visited, row, col);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int row, int col)\\n{\\n\\tif(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != 1 || visited[row][col])\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[row][col] = true;\\n\\n\\tdfs(grid, visited, row + 1, col);\\n\\tdfs(grid, visited, row - 1, col);\\n\\tdfs(grid, visited, row, col + 1);\\n\\tdfs(grid, visited, row, col - 1);\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tif(getIslandCount(grid) != 1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[row][col] = 0;\\n\\n\\t\\t\\t\\tif(getIslandCount(grid) != 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgrid[row][col] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn 2;\\n}\\n\\nint getIslandCount(const vector<vector<int>>& grid)\\n{\\n\\tvector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n\\tint count = 0;\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(!visited[row][col] && grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(grid, visited, row, col);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int row, int col)\\n{\\n\\tif(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != 1 || visited[row][col])\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[row][col] = true;\\n\\n\\tdfs(grid, visited, row + 1, col);\\n\\tdfs(grid, visited, row - 1, col);\\n\\tdfs(grid, visited, row, col + 1);\\n\\tdfs(grid, visited, row, col - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820141,
                "title": "python-easy-to-understand-simple-code",
                "content": "**Answer can only be 0,1,2 **\\n\\n0 -> Initially when there are multiple islands and when there is no islands\\n1 and 2 -> when there is only 1 island \\nWe check only for the case when in only one disconnectivety can make it into more than 1 island oterwise it is 2\\nCode is just simple traversal of the grid and lastly count the number of islands present in it, most important is to get the intution behind that that.\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        \\n        def count(grid):\\n            vis=[[False]*m for i in range(n)]\\n            \\n            def isValid(i,j):\\n                if i<0 or i>=n or j<0 or j>=m or vis[i][j] or not grid[i][j]:\\n                    return False\\n                return True\\n            \\n            def dfs(i,j):\\n                if isValid(i,j):\\n                    vis[i][j]=True\\n                    dfs(i+1,j)\\n                    dfs(i-1,j)\\n                    dfs(i,j+1)\\n                    dfs(i,j-1)\\n\\n            cnt=0\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] and not vis[i][j]:\\n                        cnt+=1\\n                        dfs(i,j)\\n\\n            return cnt\\n        \\n        islands=count(grid)\\n        if islands!=1:\\n            return 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    grid[i][j]=0\\n                    islands=count(grid)\\n                    if islands!=1:\\n                        return 1\\n                    grid[i][j]=1\\n        return 2\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        \\n        def count(grid):\\n            vis=[[False]*m for i in range(n)]\\n            \\n            def isValid(i,j):\\n                if i<0 or i>=n or j<0 or j>=m or vis[i][j] or not grid[i][j]:\\n                    return False\\n                return True\\n            \\n            def dfs(i,j):\\n                if isValid(i,j):\\n                    vis[i][j]=True\\n                    dfs(i+1,j)\\n                    dfs(i-1,j)\\n                    dfs(i,j+1)\\n                    dfs(i,j-1)\\n\\n            cnt=0\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] and not vis[i][j]:\\n                        cnt+=1\\n                        dfs(i,j)\\n\\n            return cnt\\n        \\n        islands=count(grid)\\n        if islands!=1:\\n            return 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    grid[i][j]=0\\n                    islands=count(grid)\\n                    if islands!=1:\\n                        return 1\\n                    grid[i][j]=1\\n        return 2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 820094,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<int> x = {1, 0, -1, 0};\\n    vector<int> y = {0, -1, 0, 1};\\n    \\n    void dfs(int r, int c, vector<vector<int>>& grid){\\n        vis[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            if(r+x[i]<0 || r+x[i]>=grid.size() || c+y[i]<0 || c+y[i]>=grid[0].size()) continue;\\n            if(vis[r+x[i]][c+y[i]] || !grid[r+x[i]][c+y[i]]) continue;\\n            dfs(r+x[i], c+y[i], grid);\\n        }\\n        return;\\n    }\\n    \\n    int helper(vector<vector<int>>& grid){\\n        int count = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis.clear();\\n        vis.resize(n, vector<bool>(m, 0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j] || !grid[i][j]) continue;\\n                count++;\\n                dfs(i, j, grid);\\n            }\\n        } \\n        \\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        if(helper(grid)!=1) return 0;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]) continue;\\n                grid[i][j] = 0;\\n                int k = helper(grid);\\n                if(k>1) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<int> x = {1, 0, -1, 0};\\n    vector<int> y = {0, -1, 0, 1};\\n    \\n    void dfs(int r, int c, vector<vector<int>>& grid){\\n        vis[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            if(r+x[i]<0 || r+x[i]>=grid.size() || c+y[i]<0 || c+y[i]>=grid[0].size()) continue;\\n            if(vis[r+x[i]][c+y[i]] || !grid[r+x[i]][c+y[i]]) continue;\\n            dfs(r+x[i], c+y[i], grid);\\n        }\\n        return;\\n    }\\n    \\n    int helper(vector<vector<int>>& grid){\\n        int count = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis.clear();\\n        vis.resize(n, vector<bool>(m, 0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j] || !grid[i][j]) continue;\\n                count++;\\n                dfs(i, j, grid);\\n            }\\n        } \\n        \\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        if(helper(grid)!=1) return 0;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]) continue;\\n                grid[i][j] = 0;\\n                int k = helper(grid);\\n                if(k>1) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819825,
                "title": "java-with-explanation-minimum-number-of-days-to-disconnect-island",
                "content": "**intuition:**\\nThere can be maximum 2 days to disconnect the island\\nex:\\n```\\n1 1 1      1 1 1\\n1 1 1  ->  1 1 *\\n1 1 1      1 * 1\\n ```\\n\\n1. so, number of days will always be <= 2\\n2. now, we want to check can we disconnect island in 0 or 1 day\\n   * Island can be disconnected in 0 days\\n\\t\\t* if there is no island or there are more than 1 island. i.e. there is nothing to disconnect if there is no island. \\n\\t\\t* if there are two islands that means they are already disconnected.\\n \\n 3. if there is only one island, as we have seen above, in max two days, we can disconnect it. Now we need to check if we can disconnect the island in just 1 day.\\n 4. To check, if we can disconnect the island in one day, we iterate over the grid and set grid[r][c] = 0, and count the islands,\\n\\t * if island count is > 1, that means we can disconnect island in just one day.\\n\\t * else ans is 2.\\n\\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (noOfIsland(grid) != 1) { // we already have two or zero islands, i.e. already disconnected\\n            return 0;\\n        }\\n\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1) {\\n                    grid[r][c] = 0;\\n                    if (noOfIsland(grid) > 1) { // we can disconnect island in one day.\\n                        return 1;\\n                    }\\n                    grid[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2; // two days are required to disconnect the island\\n    }\\n    \\n    private static int noOfIsland(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        boolean[][] seen = new boolean[nr][nc];\\n        int islands = 0;\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1 && !seen[r][c]) {\\n                    islands++;\\n                    dfs(grid, seen, r, c);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    private static void dfs(int[][] grid, boolean[][] seen, int r, int c) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (r < 0 || r >= nr || c < 0 || c >= nc || grid[r][c] == 0 || seen[r][c])\\n            return;\\n\\n        seen[r][c] = true;\\n        dfs(grid, seen, r + 1, c);\\n        dfs(grid, seen, r - 1, c);\\n        dfs(grid, seen, r, c + 1);\\n        dfs(grid, seen, r, c - 1);\\n    }\\n}\\n```\\n\\n**Time Complexity:** \\nr = no. of rows, c = no. of cols\\nO((rc)^2)\\n\\n**Space Complexity**\\nO(rc)",
                "solutionTags": [],
                "code": "```\\n1 1 1      1 1 1\\n1 1 1  ->  1 1 *\\n1 1 1      1 * 1\\n ```\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (noOfIsland(grid) != 1) { // we already have two or zero islands, i.e. already disconnected\\n            return 0;\\n        }\\n\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1) {\\n                    grid[r][c] = 0;\\n                    if (noOfIsland(grid) > 1) { // we can disconnect island in one day.\\n                        return 1;\\n                    }\\n                    grid[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2; // two days are required to disconnect the island\\n    }\\n    \\n    private static int noOfIsland(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        boolean[][] seen = new boolean[nr][nc];\\n        int islands = 0;\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1 && !seen[r][c]) {\\n                    islands++;\\n                    dfs(grid, seen, r, c);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    private static void dfs(int[][] grid, boolean[][] seen, int r, int c) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (r < 0 || r >= nr || c < 0 || c >= nc || grid[r][c] == 0 || seen[r][c])\\n            return;\\n\\n        seen[r][c] = true;\\n        dfs(grid, seen, r + 1, c);\\n        dfs(grid, seen, r - 1, c);\\n        dfs(grid, seen, r, c + 1);\\n        dfs(grid, seen, r, c - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819814,
                "title": "java-0-or-1-or-2",
                "content": "```\\nclass Solution {\\n    int m,n;\\n    public int minDays(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int conn = count(grid);\\n        if(conn > 1 || conn == 0) return 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(count(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    public int count(int[][] grid){\\n        boolean[][] vis = new boolean[m][n];\\n        int conn = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs(i,j,vis,grid);\\n                    conn++;\\n                }\\n            }\\n        }\\n        return conn;\\n    }\\n    \\n    public void dfs(int r,int c,boolean[][] vis,int[][] grid){\\n        if(r >= m || r < 0 || c >= n || c < 0 || vis[r][c] || grid[r][c] == 0) return;\\n        vis[r][c] = true;\\n        dfs(r + 1,c,vis,grid);\\n        dfs(r - 1,c,vis,grid);\\n        dfs(r,c + 1,vis,grid);\\n        dfs(r,c - 1,vis,grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m,n;\\n    public int minDays(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int conn = count(grid);\\n        if(conn > 1 || conn == 0) return 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(count(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    public int count(int[][] grid){\\n        boolean[][] vis = new boolean[m][n];\\n        int conn = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs(i,j,vis,grid);\\n                    conn++;\\n                }\\n            }\\n        }\\n        return conn;\\n    }\\n    \\n    public void dfs(int r,int c,boolean[][] vis,int[][] grid){\\n        if(r >= m || r < 0 || c >= n || c < 0 || vis[r][c] || grid[r][c] == 0) return;\\n        vis[r][c] = true;\\n        dfs(r + 1,c,vis,grid);\\n        dfs(r - 1,c,vis,grid);\\n        dfs(r,c + 1,vis,grid);\\n        dfs(r,c - 1,vis,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819777,
                "title": "java-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n                \\n        int cnt = count(grid, m, n);\\n        if (cnt != 1) {\\n            \\n            return cnt == -1 ? 2 : 0;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    \\n                    grid[i][j] = 0;\\n                    \\n                    if (count(grid, m, n) > 1) {\\n                        \\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int countIsland(int[][] grid, int i, int j, int m, int n, \\n                            boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i >= m || j >= n || visited[i][j] \\n            || grid[i][j] == 0) return 0;\\n        \\n        visited[i][j] = true;\\n        \\n        return countIsland(grid, i, j + 1, m, n, visited) +\\n            countIsland(grid, i + 1, j, m, n, visited) +\\n            countIsland(grid, i - 1, j, m, n, visited) +\\n            countIsland(grid, i, j - 1, m, n, visited);\\n    }\\n    \\n    private int count(int[][] grid, int m, int n) {\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int count = 0, g = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    ++g;\\n                    if (!visited[i][j]) {\\n                        countIsland(grid, i, j, m, n, visited);\\n                        ++count;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        if (g == (m * n)) {\\n            \\n            count = -1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n                \\n        int cnt = count(grid, m, n);\\n        if (cnt != 1) {\\n            \\n            return cnt == -1 ? 2 : 0;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    \\n                    grid[i][j] = 0;\\n                    \\n                    if (count(grid, m, n) > 1) {\\n                        \\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int countIsland(int[][] grid, int i, int j, int m, int n, \\n                            boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i >= m || j >= n || visited[i][j] \\n            || grid[i][j] == 0) return 0;\\n        \\n        visited[i][j] = true;\\n        \\n        return countIsland(grid, i, j + 1, m, n, visited) +\\n            countIsland(grid, i + 1, j, m, n, visited) +\\n            countIsland(grid, i - 1, j, m, n, visited) +\\n            countIsland(grid, i, j - 1, m, n, visited);\\n    }\\n    \\n    private int count(int[][] grid, int m, int n) {\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int count = 0, g = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    ++g;\\n                    if (!visited[i][j]) {\\n                        countIsland(grid, i, j, m, n, visited);\\n                        ++count;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        if (g == (m * n)) {\\n            \\n            count = -1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819654,
                "title": "c-3-steps-solution",
                "content": "1. Check if there is only 1 island (if not, then return 0)\\n2. Check if remove 1 land can leads to disconnected (if yes, return 1)\\n3. return 2\\n```\\nclass Solution \\n{\\n    public:\\n    int lands=0;\\n    int m,n;\\n    void count_islands(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        grid[i][j]=0;\\n        lands++;\\n        count_islands(grid,i+1,j);\\n        count_islands(grid,i-1,j);\\n        count_islands(grid,i,j+1);\\n        count_islands(grid,i,j-1);\\n    }\\n    int number_of_islands(vector<vector<int>> grid)\\n    {\\n        int result=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count_islands(grid,i,j);\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int islands=number_of_islands(grid);\\n        if(islands!=1)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    if(number_of_islands(grid)>1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int lands=0;\\n    int m,n;\\n    void count_islands(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        grid[i][j]=0;\\n        lands++;\\n        count_islands(grid,i+1,j);\\n        count_islands(grid,i-1,j);\\n        count_islands(grid,i,j+1);\\n        count_islands(grid,i,j-1);\\n    }\\n    int number_of_islands(vector<vector<int>> grid)\\n    {\\n        int result=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count_islands(grid,i,j);\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int islands=number_of_islands(grid);\\n        if(islands!=1)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    if(number_of_islands(grid)>1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819622,
                "title": "python-1492ms-beat-100",
                "content": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def bfs():\\n            count = 1\\n            mask = 1 << nodes[0]\\n            pool = [nodes[0]]\\n            while pool:\\n                n = pool.pop()\\n                for nei in adj[n]:\\n                    if mask & (1 << nei) == 0:\\n                        pool.append(nei)\\n                        mask |= 1 << nei\\n                        count += 1\\n            if count < len(nodes):\\n                return True\\n            return False\\n\\n        adj = defaultdict(set)\\n        height = len(grid)\\n        width = len(grid[0])\\n        move = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\n        nodes = []\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j]:\\n                    isolate = True\\n                    node = i * width + j\\n                    nodes.append(node)\\n                    for i1, j1 in move:\\n                        i1 += i\\n                        j1 += j\\n                        if 0 <= i1 < height and 0 <= j1 < width and grid[i1][j1]:\\n                            adj[node].add(i1 * width + j1)\\n                            isolate = False\\n                    if isolate:\\n                        return 0\\n        if len(nodes) <= 2:\\n            return len(nodes)\\n        if bfs():\\n            return 0\\n        for k in list(nodes):\\n            v = adj[k]\\n            for node in v:\\n                adj[node].remove(k)\\n            nodes.remove(k)\\n            if bfs():\\n                return 1\\n            nodes.append(k)\\n            for node in v:\\n                adj[node].add(k)\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def bfs():\\n            count = 1\\n            mask = 1 << nodes[0]\\n            pool = [nodes[0]]\\n            while pool:\\n                n = pool.pop()\\n                for nei in adj[n]:\\n                    if mask & (1 << nei) == 0:\\n                        pool.append(nei)\\n                        mask |= 1 << nei\\n                        count += 1\\n            if count < len(nodes):\\n                return True\\n            return False\\n\\n        adj = defaultdict(set)\\n        height = len(grid)\\n        width = len(grid[0])\\n        move = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\n        nodes = []\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j]:\\n                    isolate = True\\n                    node = i * width + j\\n                    nodes.append(node)\\n                    for i1, j1 in move:\\n                        i1 += i\\n                        j1 += j\\n                        if 0 <= i1 < height and 0 <= j1 < width and grid[i1][j1]:\\n                            adj[node].add(i1 * width + j1)\\n                            isolate = False\\n                    if isolate:\\n                        return 0\\n        if len(nodes) <= 2:\\n            return len(nodes)\\n        if bfs():\\n            return 0\\n        for k in list(nodes):\\n            v = adj[k]\\n            for node in v:\\n                adj[node].remove(k)\\n            nodes.remove(k)\\n            if bfs():\\n                return 1\\n            nodes.append(k)\\n            for node in v:\\n                adj[node].add(k)\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819607,
                "title": "simple-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    int n,m;\\n    void dfs(int x,int y,vector<vector<int>>&adj){\\n        if(x<0 || x>=n || y<0 || y>=m || vis[x][y] || adj[x][y]==0)return ;\\n        vis[x][y]=true;\\n        dfs(x+1,y,adj);\\n        dfs(x-1,y,adj);\\n        dfs(x,y+1,adj);\\n        dfs(x,y-1,adj);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    island++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        if(island>1 || island==0)return 0;\\n        //either 1 or 2;\\n        //..checking for 1..\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    grid[i][j]=0;\\n                    vis.clear();\\n                    island=0;\\n                    vis.resize(n,vector<bool>(m,false));\\n                    int island=0;\\n                    for(int i=0;i<n;i++){\\n                        for(int j=0;j<m;j++){\\n                            if(!vis[i][j] && grid[i][j]){\\n                                island++;\\n                                dfs(i,j,grid);\\n                            }\\n                        }\\n                    }\\n                    if(island>1)return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        //one not possible answer is 2\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    int n,m;\\n    void dfs(int x,int y,vector<vector<int>>&adj){\\n        if(x<0 || x>=n || y<0 || y>=m || vis[x][y] || adj[x][y]==0)return ;\\n        vis[x][y]=true;\\n        dfs(x+1,y,adj);\\n        dfs(x-1,y,adj);\\n        dfs(x,y+1,adj);\\n        dfs(x,y-1,adj);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    island++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        if(island>1 || island==0)return 0;\\n        //either 1 or 2;\\n        //..checking for 1..\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    grid[i][j]=0;\\n                    vis.clear();\\n                    island=0;\\n                    vis.resize(n,vector<bool>(m,false));\\n                    int island=0;\\n                    for(int i=0;i<n;i++){\\n                        for(int j=0;j<m;j++){\\n                            if(!vis[i][j] && grid[i][j]){\\n                                island++;\\n                                dfs(i,j,grid);\\n                            }\\n                        }\\n                    }\\n                    if(island>1)return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        //one not possible answer is 2\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819597,
                "title": "java-code-union-find",
                "content": "```\\nclass UF {\\n    int[] parent;\\n    int[][] grid;\\n    UF(int n, int[][] g) {\\n        parent = new int[n];\\n        grid = g;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int v) {\\n        while (v != parent[v]) {\\n            parent[v] = parent[parent[v]];\\n            v = parent[v];\\n        }\\n        return v;\\n    }\\n    public void union(int k, int v) {\\n        parent[find(v)] = find(k);\\n    }\\n    public boolean multiIsland() {\\n        int t = -1;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (t == -1) {\\n                    t = find(i*n+j);\\n                } else {\\n                    if (t!=find(i*n+j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public boolean isOneIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UF uf = new UF(m*n,grid);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int cur = n*i+j;\\n                if (i-1>=0 && grid[i-1][j]==1) {\\n                    uf.union(cur, cur-n);\\n                }\\n                if (j-1>=0 && grid[i][j-1]==1) {\\n                    uf.union(cur, cur-1);\\n                }\\n            }\\n        }\\n        return !uf.multiIsland();\\n    }\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (!isOneIsland(grid)) {\\n            return 0;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if (!isOneIsland(grid)) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF {\\n    int[] parent;\\n    int[][] grid;\\n    UF(int n, int[][] g) {\\n        parent = new int[n];\\n        grid = g;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int v) {\\n        while (v != parent[v]) {\\n            parent[v] = parent[parent[v]];\\n            v = parent[v];\\n        }\\n        return v;\\n    }\\n    public void union(int k, int v) {\\n        parent[find(v)] = find(k);\\n    }\\n    public boolean multiIsland() {\\n        int t = -1;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (t == -1) {\\n                    t = find(i*n+j);\\n                } else {\\n                    if (t!=find(i*n+j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public boolean isOneIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UF uf = new UF(m*n,grid);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int cur = n*i+j;\\n                if (i-1>=0 && grid[i-1][j]==1) {\\n                    uf.union(cur, cur-n);\\n                }\\n                if (j-1>=0 && grid[i][j-1]==1) {\\n                    uf.union(cur, cur-1);\\n                }\\n            }\\n        }\\n        return !uf.multiIsland();\\n    }\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (!isOneIsland(grid)) {\\n            return 0;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if (!isOneIsland(grid)) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819533,
                "title": "python-3-o-m-n-80ms",
                "content": "The approach is different and more optimal compared to most of the other suggested solutions here. Specifically, the part that is different is: how we check if a land cell is critical meaning that we can split the island by removing just this one cell. \\nOther solutions do it by removing the cell and recounting islands on the map, whereas my approach is to look at each cell\\'s neighbors and count how many of them are water cells that are connected to the edge of the greed (referred to as \"open waters\" in the code). \\nThe idea is that if there are >=2 non-adjacent open water openings around the land cell, then we can say that there also are >=2 non-adjacent land neighbors, and since waters are \"open\", the are connected to the edge of the grid, so we can draw a line that goes from edge of the grid through the land cell and back to edge of the grid splitting the island.\\n\\n\\n```\\nclass Solution:\\n    def markLand(self, grid: List[List[int]], row, col, color) -> int:\\n        if grid[row][col] != 1:\\n            return\\n        grid[row][col] = color\\n        for d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markLand(grid, row+d[0], col + d[1], color)        \\n                \\n    def markWater(self, grid: List[List[int]], row, col, color, open_waters) -> int:\\n        if grid[row][col] != 0:\\n            return\\n        grid[row][col] = color\\n        # water can be connected diagonally\\n        for d in [[0,1],[1,0],[0,-1],[-1,0], [-1,-1], [-1,1], [1,-1], [1,1]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markWater(grid, row+d[0], col + d[1], color, open_waters)\\n            else:\\n                open_waters.add(color)\\n            \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        land_color = 2\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 1:\\n                    self.markLand(grid, row, col, land_color)\\n                    land_color += 1\\n        if land_color == 2 or land_color > 3:\\n            # return if there are 0 or 2+ islands\\n            return 0\\n        \\n        water_color = -1\\n        # set of colors of waters that are connected to edge of the grid\\n        open_waters = set()\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    self.markWater(grid, row, col, water_color, open_waters)\\n                    water_color -= 1\\n        \\n        \\n        def is_open_water(r, c):\\n            # cells out of the grid are considered open_water too            \\n            return not(0 <= r < rows and 0 <= c < cols) or grid[r][c] in open_waters\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 2: # land color\\n                    water_seq_count = 0\\n                    water_count = 0\\n                    is_water = False\\n                    # go clockwise and count how many sequences of water we there are\\n                    circle = [[-1, 0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]\\n                    for t in circle:\\n                        r = row + t[0] \\n                        c = col + t[1]\\n                        if is_open_water(r, c):\\n                            water_count += 1\\n                            if not is_water:\\n                                is_water = True\\n                                water_seq_count += 1\\n                        else:\\n                            is_water = False\\n                                \\n                    \\n                    \\n                    # subtract 1 if first and last cells on the circle are both open waters\\n                    if is_water and is_open_water(row-1, col):\\n                        water_seq_count -= 1\\n                    \\n                    # if the land cell is in between of 2 waters, which are connected to edge of the grid, then\\n                    # removing this cell should split the island\\n                    if water_seq_count >= 2:\\n                        return 1\\n                    # if the island consists of a single cell, return 1\\n                    if water_count == 8:\\n                        return 1\\n                    \\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def markLand(self, grid: List[List[int]], row, col, color) -> int:\\n        if grid[row][col] != 1:\\n            return\\n        grid[row][col] = color\\n        for d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markLand(grid, row+d[0], col + d[1], color)        \\n                \\n    def markWater(self, grid: List[List[int]], row, col, color, open_waters) -> int:\\n        if grid[row][col] != 0:\\n            return\\n        grid[row][col] = color\\n        # water can be connected diagonally\\n        for d in [[0,1],[1,0],[0,-1],[-1,0], [-1,-1], [-1,1], [1,-1], [1,1]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markWater(grid, row+d[0], col + d[1], color, open_waters)\\n            else:\\n                open_waters.add(color)\\n            \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        land_color = 2\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 1:\\n                    self.markLand(grid, row, col, land_color)\\n                    land_color += 1\\n        if land_color == 2 or land_color > 3:\\n            # return if there are 0 or 2+ islands\\n            return 0\\n        \\n        water_color = -1\\n        # set of colors of waters that are connected to edge of the grid\\n        open_waters = set()\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    self.markWater(grid, row, col, water_color, open_waters)\\n                    water_color -= 1\\n        \\n        \\n        def is_open_water(r, c):\\n            # cells out of the grid are considered open_water too            \\n            return not(0 <= r < rows and 0 <= c < cols) or grid[r][c] in open_waters\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 2: # land color\\n                    water_seq_count = 0\\n                    water_count = 0\\n                    is_water = False\\n                    # go clockwise and count how many sequences of water we there are\\n                    circle = [[-1, 0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]\\n                    for t in circle:\\n                        r = row + t[0] \\n                        c = col + t[1]\\n                        if is_open_water(r, c):\\n                            water_count += 1\\n                            if not is_water:\\n                                is_water = True\\n                                water_seq_count += 1\\n                        else:\\n                            is_water = False\\n                                \\n                    \\n                    \\n                    # subtract 1 if first and last cells on the circle are both open waters\\n                    if is_water and is_open_water(row-1, col):\\n                        water_seq_count -= 1\\n                    \\n                    # if the land cell is in between of 2 waters, which are connected to edge of the grid, then\\n                    # removing this cell should split the island\\n                    if water_seq_count >= 2:\\n                        return 1\\n                    # if the island consists of a single cell, return 1\\n                    if water_count == 8:\\n                        return 1\\n                    \\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819528,
                "title": "java-bfs-number-of-islands-days-at-most-2",
                "content": "Credits to [@GSAN](https://leetcode.com/gsan/). Smart and tricky thought ! \\n\\nWe can disconnect island at most 2 days.\\n\\nImagine a grid full of 1, we can use at most 2 days to disconnect it like the following graph.\\n\\n```\\n1 1 1 1 1         1 . 1 1 1 \\n1 1 1 1 1  -----> . 1 1 1 1\\n1 1 1 1 1         1 1 1 1 1\\n```\\n\\nSo what we need to do is just trying only 1 step to change 1 to 0, and check whether current num of islands is bigger than 1. \\nIf in the first step we don\\'t achieve more than 1 island we just return 2.\\nIf in the first step we achieve more than 1 island we can return 1.\\n\\n```java\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0)return 0;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(numIslands(grid) != 1)return 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(numIslands(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n    public int numIslands(int[][] grid) {\\n        if(grid == null || grid.length == 0)return 0;\\n        boolean[][] seen = new boolean[m][n];\\n        int count = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1 && !seen[i][j]){\\n                    queue.add(new int[]{i,j});\\n                    seen[i][j] = true;\\n                    while(!queue.isEmpty()){\\n                        int[] temp = queue.poll();\\n                        for(int[] dir : dirs){\\n                            int x = temp[0] + dir[0];\\n                            int y = temp[1] + dir[1];\\n                            if(x>=0 && x<m && y>=0 && y<n && grid[x][y] == 1 && !seen[x][y]){\\n                                seen[x][y] = true;\\n                                queue.add(new int[]{x,y});\\n                            }\\n                        }\\n                    }\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }             \\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 1 1 1 1         1 . 1 1 1 \\n1 1 1 1 1  -----> . 1 1 1 1\\n1 1 1 1 1         1 1 1 1 1\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570146,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1566978,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1574301,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 2072412,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1928951,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            }
        ]
    }
]