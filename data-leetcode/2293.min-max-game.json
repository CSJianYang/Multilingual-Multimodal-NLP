[
    {
        "title": "Min Max Game",
        "question_content": "You are given a 0-indexed integer array nums whose length is a power of 2.\nApply the following algorithm on nums:\n\n\tLet n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2.\n\tFor every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]).\n\tFor every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]).\n\tReplace the array nums with newNums.\n\tRepeat the entire process starting from step 1.\n\nReturn the last number that remains in nums after applying the algorithm.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,5,2,4,8,2,2]\nOutput: 1\nExplanation: The following arrays are the results of applying the algorithm repeatedly.\nFirst: nums = [1,5,4,2]\nSecond: nums = [1,4]\nThird: nums = [1]\n1 is the last remaining number, so we return 1.\n\nExample 2:\n\nInput: nums = [3]\nOutput: 3\nExplanation: 3 is already the last remaining number, so we return 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1024\n\t1 <= nums[i] <= 109\n\tnums.length is a power of 2.",
        "solutions": [
            {
                "id": 2112080,
                "title": "o-1-space-3-lines",
                "content": "# C++\\n    int minMaxGame(vector<int>& a) {\\n        for(int n= size(a); n>1 ; n-=(n/2)){\\n            for(int i=0;i<n/2;i++) \\n\\t\\t\\t    a[i]= (i%2)==1? max(a[2 * i], a[2 * i + 1]) : min(a[2 * i], a[2 * i + 1]);   \\n        }\\n        return a[0];\\n    }\\n# Java\\n    public int minMaxGame(int[] a) {\\n        for(int n= a.length; n>1 ; n-=(n/2)){\\n            for(int i=0;i<n/2;i++) \\n\\t\\t\\t    a[i]= (i%2)==1? Math.max(a[2 * i], a[2 * i + 1]) : Math.min(a[2 * i], a[2 * i + 1]);   \\n        }\\n        return a[0];\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# C++\\n    int minMaxGame(vector<int>& a) {\\n        for(int n= size(a); n>1 ; n-=(n/2)){\\n            for(int i=0;i<n/2;i++) \\n\\t\\t\\t    a[i]= (i%2)==1? max(a[2 * i], a[2 * i + 1]) : min(a[2 * i], a[2 * i + 1]);   \\n        }\\n        return a[0];\\n    }\\n# Java\\n    public int minMaxGame(int[] a) {\\n        for(int n= a.length; n>1 ; n-=(n/2)){\\n            for(int i=0;i<n/2;i++) \\n\\t\\t\\t    a[i]= (i%2)==1? Math.max(a[2 * i], a[2 * i + 1]) : Math.min(a[2 * i], a[2 * i + 1]);   \\n        }\\n        return a[0];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2128017,
                "title": "python-single-loop-extend-the-list",
                "content": "A few variations of the same idea: Append the computed min/max values to the given list. That way I just need *one* \"loop\", because at the end of the originally given data, I then encounter and continue with the min/max values I computed. At the end, I just return the last value.\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        for f, *x in zip(cycle((min, max)), it, it):\\n            nums.append(f(*x))\\n        return nums[-1]\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def minmax(*x, f=cycle((min, max))):\\n            return next(f)(*x)\\n        it = iter(nums)\\n        nums += map(minmax, it, it)\\n        return nums[-1]\\n    \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += map(lambda f, *x: f(*x), cycle((min, max)), it, it)\\n        return nums[-1]\\n    \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += (f(*x) for f, *x in zip(cycle((min, max)), it, it))\\n        return nums[-1]\\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        for i, x in enumerate(it):\\n            try:\\n                nums.append((min, max)[i%2](x, next(it)))\\n            except:\\n                return x\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += chain.from_iterable(\\n            zip(map(min, it, it),\\n                map(max, it, it)))\\n        return min(nums[-2:])\\n\\n",
                "solutionTags": [],
                "code": "A few variations of the same idea: Append the computed min/max values to the given list. That way I just need *one* \"loop\", because at the end of the originally given data, I then encounter and continue with the min/max values I computed. At the end, I just return the last value.\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        for f, *x in zip(cycle((min, max)), it, it):\\n            nums.append(f(*x))\\n        return nums[-1]\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def minmax(*x, f=cycle((min, max))):\\n            return next(f)(*x)\\n        it = iter(nums)\\n        nums += map(minmax, it, it)\\n        return nums[-1]\\n    \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += map(lambda f, *x: f(*x), cycle((min, max)), it, it)\\n        return nums[-1]\\n    \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += (f(*x) for f, *x in zip(cycle((min, max)), it, it))\\n        return nums[-1]\\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        for i, x in enumerate(it):\\n            try:\\n                nums.append((min, max)[i%2](x, next(it)))\\n            except:\\n                return x\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        it = iter(nums)\\n        nums += chain.from_iterable(\\n            zip(map(min, it, it),\\n                map(max, it, it)))\\n        return min(nums[-2:])\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2111996,
                "title": "c-recursive-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1) return nums[0];  // Base case\\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++) { \\n            if(i%2==0) newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum); // Recursive call\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1) return nums[0];  // Base case\\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++) { \\n            if(i%2==0) newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum); // Recursive call\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115014,
                "title": "explanation-o-n-python",
                "content": "No need to create new array.\\nIt can be seen that changes can be mae within same array.\\nThe changed elements are never called again so their positions are useless and we use those vacant indexes.\\n\\n```\\nclass Solution:\\n    def minMaxGame(self, a: List[int]) -> int:\\n        \\n        def solve(n):\\n            if n==1:\\n                return\\n            for i in range(n//2):\\n                if i%2:\\n                    a[i] = max (a[2*i], a[2*i+1])\\n                else:\\n                    a[i] = min (a[2*i], a[2*i+1])\\n            solve(n//2)\\n            return\\n        solve(len(a))\\n        return a[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2cdfd693-ef54-4ccd-bad2-a6068e297956_1654445135.817252.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, a: List[int]) -> int:\\n        \\n        def solve(n):\\n            if n==1:\\n                return\\n            for i in range(n//2):\\n                if i%2:\\n                    a[i] = max (a[2*i], a[2*i+1])\\n                else:\\n                    a[i] = min (a[2*i], a[2*i+1])\\n            solve(n//2)\\n            return\\n        solve(len(a))\\n        return a[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112053,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        \\n        while(nums.length>1){\\n            int n = nums.length;\\n            int[] newNums = new int[n/2];\\n            for(int i =0;i<newNums.length;i++){\\n            newNums[i]= (i%2==0)?Math.min(nums[2*i],nums[2*i+1]):Math.max(nums[2*i],nums[2*i+1]);\\n            }\\n            nums = newNums;\\n        }\\n        \\n        return nums[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        \\n        while(nums.length>1){\\n            int n = nums.length;\\n            int[] newNums = new int[n/2];\\n            for(int i =0;i<newNums.length;i++){\\n            newNums[i]= (i%2==0)?Math.min(nums[2*i],nums[2*i+1]):Math.max(nums[2*i],nums[2*i+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2112349,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:                \\n        l=nums\\n        while len(l)>1:\\n            is_min=True     \\n            tmp=[]\\n            for i in range(0, len(l), 2):\\n                if is_min:\\n                    tmp.append(min(l[i:i+2]))\\n                else:\\n                    tmp.append(max(l[i:i+2]))\\n                is_min=not is_min            \\n            l=tmp            \\n        return l[0]                        \\n```\\n\\n**Time - O(nlogn)** - The input space is reduced by half after each iteration. \\n**Space - O(n)**\\n\\n**Note**: The space can be reduced to `O(1)` if you use input array as the space to store the next list of elements. But I don\\'t like the idea of modifying the input array.\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:                \\n        l=nums\\n        while len(l)>1:\\n            is_min=True     \\n            tmp=[]\\n            for i in range(0, len(l), 2):\\n                if is_min:\\n                    tmp.append(min(l[i:i+2]))\\n                else:\\n                    tmp.append(max(l[i:i+2]))\\n                is_min=not is_min            \\n            l=tmp            \\n        return l[0]                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112893,
                "title": "functional-recursion",
                "content": "It\\'s easier to solve this problem by simulation. Using a recursion is funnier, IMHO.\\n\\nDeclaring `mn` and `mx` is needed due to C++ legacy issues (waiting for `min` and `max` to be rewritten in STL with variadic templates).\\n\\n**C++**\\n```cpp\\nint minMaxGame(vector<int>& nums) {\\n    auto mn = [](int a, int b){ return min(a, b); };\\n    auto mx = [](int a, int b){ return max(a, b); };\\n    function<int(int, int, function<int(int, int)>)> op = [&](int i, int j, function<int(int, int)> f) {\\n        return j - i == 1 ? f(nums[i], nums[j]) : f(op(i, i + (j - i) / 2, mn), op(i + (j - i) / 2 + 1, j, mx));\\n    };\\n    return nums.size() == 1 ? nums.back() : op(0, nums.size() - 1, mn);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minMaxGame(vector<int>& nums) {\\n    auto mn = [](int a, int b){ return min(a, b); };\\n    auto mx = [](int a, int b){ return max(a, b); };\\n    function<int(int, int, function<int(int, int)>)> op = [&](int i, int j, function<int(int, int)> f) {\\n        return j - i == 1 ? f(nums[i], nums[j]) : f(op(i, i + (j - i) / 2, mn), op(i + (j - i) / 2 + 1, j, mx));\\n    };\\n    return nums.size() == 1 ? nums.back() : op(0, nums.size() - 1, mn);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111978,
                "title": "simulate-the-process-python-beginner-friendly-my-notes",
                "content": "```\\n#base case\\nif len(nums)==1:\\n            return nums[0]\\n\\n#as long as my length doesn\\'t become 1, I repeat the process\\nwhile len(nums)!=1:\\n\\t#we take a newnums everytime of size n//2\\n\\tnewnums = [-1]*(len(nums)//2)\\n\\tfor i in range(0,len(nums)//2):\\n\\t\\tif i%2==0:\\n\\t\\t\\tnewnums[i] = min(nums[2 * i], nums[2 * i + 1])\\n\\t\\telse:\\n\\t\\t\\tnewnums[i] = max(nums[2 * i], nums[2 * i + 1])\\n\\t#add the newarray to the older one.\\n\\tnums = newnums\\n\\nreturn nums[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n#base case\\nif len(nums)==1:\\n            return nums[0]\\n\\n#as long as my length doesn\\'t become 1, I repeat the process\\nwhile len(nums)!=1:\\n\\t#we take a newnums everytime of size n//2\\n\\tnewnums = [-1]*(len(nums)//2)\\n\\tfor i in range(0,len(nums)//2):\\n\\t\\tif i%2==0:\\n\\t\\t\\tnewnums[i] = min(nums[2 * i], nums[2 * i + 1])\\n\\t\\telse:\\n\\t\\t\\tnewnums[i] = max(nums[2 * i], nums[2 * i + 1])\\n\\t#add the newarray to the older one.\\n\\tnums = newnums\\n\\nreturn nums[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112485,
                "title": "python-1-line-recursive-solution",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return nums[0] if 1==len(nums) else self.minMaxGame([(max if i%2 else min)(nums[2*i],nums[2*i+1]) for i in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return nums[0] if 1==len(nums) else self.minMaxGame([(max if i%2 else min)(nums[2*i],nums[2*i+1]) for i in range(len(nums)//2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112375,
                "title": "c-o-1-space-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            int k=0;\\n            for(int i=0;i<n/2;i++){\\n                if(k%2==0) nums[k]=min(nums[2*i],nums[2*i+1]);\\n                else nums[k]=max(nums[2*i],nums[2*i+1]);\\n                k++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            int k=0;\\n            for(int i=0;i<n/2;i++){\\n                if(k%2==0) nums[k]=min(nums[2*i],nums[2*i+1]);\\n                else nums[k]=max(nums[2*i],nums[2*i+1]);\\n                k++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126950,
                "title": "simple-javascript-typescript-solution",
                "content": "My simple and intuitive solution:\\n```\\nfunction minMaxGame(nums: number[]): number {\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.min(nums[0], nums[1]);\\n    \\n    const newNums = [];\\n    for (let i = 0; i < nums.length; i+=4) {\\n        newNums.push(Math.min(nums[i], nums[i+1]));\\n        newNums.push(Math.max(nums[i+2], nums[i+3]));\\n    }\\n    \\n    return minMaxGame(newNums);\\n};\\n```\\n\\nRuntime:\\xA0100 ms, faster than\\xA058.33%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Min Max Game.\\nMemory Usage:\\xA044.9 MB, less than\\xA058.33%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Min Max Game.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minMaxGame(nums: number[]): number {\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.min(nums[0], nums[1]);\\n    \\n    const newNums = [];\\n    for (let i = 0; i < nums.length; i+=4) {\\n        newNums.push(Math.min(nums[i], nums[i+1]));\\n        newNums.push(Math.max(nums[i+2], nums[i+3]));\\n    }\\n    \\n    return minMaxGame(newNums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112635,
                "title": "using-recursion-java-divide-and-conquer-o-log-n-time",
                "content": "- We know that the array length is power of 2. We can repeatedly divide the array into half.\\n- But for each divided subarray, we have to find its min or max element.\\n\\nHow do we know if we have to find min or max value?\\nFor that we will track a variable `min`.\\n-- If value of `min` is `1`, we have to find the minimum value of current subarray.\\n-- If value of `min` is `2`, we have to find the maximum value of current subarray.\\n\\nThe trick is that,\\nWe have to recursively find the middle of the array.\\nFrom the left subarray, we have to find the min, this can be indicated by passing `1` in recursion for variable `min`\\nFrom the right subarray, we have to find the max, this can be indicated by passing `2` in recursion for variable `min`\\nAt the last, \\nwe will find the min of left and right subarray values based on value of variable `min`.\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        return recurMinMax(nums, left, right,1);\\n        \\n        \\n        \\n    }\\n    public int recurMinMax(int[] nums, int left, int right,int min){\\n        if(right - left == 0)\\n            return nums[right];\\n        int mid = (left+ right)/2;\\n        int minE = recurMinMax(nums,left,mid,1);\\n        int maxE = recurMinMax(nums,mid+1,right,2);\\n        \\n        if(min == 1){\\n            return Math.min(minE, maxE);\\n\\n        }\\n        else return Math.max(minE,maxE);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        return recurMinMax(nums, left, right,1);\\n        \\n        \\n        \\n    }\\n    public int recurMinMax(int[] nums, int left, int right,int min){\\n        if(right - left == 0)\\n            return nums[right];\\n        int mid = (left+ right)/2;\\n        int minE = recurMinMax(nums,left,mid,1);\\n        int maxE = recurMinMax(nums,mid+1,right,2);\\n        \\n        if(min == 1){\\n            return Math.min(minE, maxE);\\n\\n        }\\n        else return Math.max(minE,maxE);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111938,
                "title": "c-easy-to-understand-2-approaches",
                "content": "**Method 1:-Brute Force**\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        int i=0;\\n        bool f=false;\\n        vector<int> v;\\n        while(i<n){\\n            if(!f){\\n              v.push_back(min(nums[i],nums[i+1]));\\n            }\\n            else{\\n                v.push_back(max(nums[i],nums[i+1]));\\n            }\\n            f=!f;\\n            i+=2;\\n        if(i == n){\\n             nums = v;\\n             v.clear();\\n             n = n/2;\\n             i = 0;\\n             if(n == 1) return nums[0];\\n          } \\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Method 2:- Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> newnums(n/2);\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                newnums[i]=min(nums[2*i],nums[2*i+1]);\\n            }\\n            else{\\n                newnums[i]=max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        int res=minMaxGame(newnums);\\n        return res;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        int i=0;\\n        bool f=false;\\n        vector<int> v;\\n        while(i<n){\\n            if(!f){\\n              v.push_back(min(nums[i],nums[i+1]));\\n            }\\n            else{\\n                v.push_back(max(nums[i],nums[i+1]));\\n            }\\n            f=!f;\\n            i+=2;\\n        if(i == n){\\n             nums = v;\\n             v.clear();\\n             n = n/2;\\n             i = 0;\\n             if(n == 1) return nums[0];\\n          } \\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> newnums(n/2);\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                newnums[i]=min(nums[2*i],nums[2*i+1]);\\n            }\\n            else{\\n                newnums[i]=max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        int res=minMaxGame(newnums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748771,
                "title": "java-0ms-100-faster-using-recursion",
                "content": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        return recursion(nums);\\n    }\\n    \\n    public int recursion(int[] nums){\\n        \\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        int[] temp = new int[nums.length/2];\\n        int count=0;\\n        int index=0;\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(count%2==0){\\n                temp[index] = Math.min(nums[i],nums[i+1]);\\n            }else{\\n                temp[index] = Math.max(nums[i],nums[i+1]);\\n            }\\n            count++;\\n            index++;\\n        }\\n        //System.out.println(Arrays.toString(temp));\\n        return recursion(temp);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        return recursion(nums);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2117265,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_max_game(mut nums: Vec<i32>) -> i32 {\\n        while nums.len() > 1 {\\n            nums = nums\\n                .chunks(2)\\n                .enumerate()\\n                .map(|(i, pair)| match i % 2 {\\n                    0 => *pair.iter().min().unwrap(),\\n                    _ => *pair.iter().max().unwrap(),\\n                })\\n                .collect();\\n        }\\n        nums[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_max_game(mut nums: Vec<i32>) -> i32 {\\n        while nums.len() > 1 {\\n            nums = nums\\n                .chunks(2)\\n                .enumerate()\\n                .map(|(i, pair)| match i % 2 {\\n                    0 => *pair.iter().min().unwrap(),\\n                    _ => *pair.iter().max().unwrap(),\\n                })\\n                .collect();\\n        }\\n        nums[0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112071,
                "title": "brute-force-c-easy-to-understand-readable-code",
                "content": "did just as mentioned in the problem\\n```\\nint minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return nums[0];\\n        }\\n        int x = nums.size();\\n        while(x!=1){\\n            x = x/2;\\n            for(int i=0;i<x;i++){\\n                if(i%2==0){\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }   \\n        }\\n        return nums[0];   \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "did just as mentioned in the problem\\n```\\nint minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return nums[0];\\n        }\\n        int x = nums.size();\\n        while(x!=1){\\n            x = x/2;\\n            for(int i=0;i<x;i++){\\n                if(i%2==0){\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }   \\n        }\\n        return nums[0];   \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2758867,
                "title": "100-faster-java-code-using-recursion",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n       if(nums.length==1)\\n           return nums[0];\\n        int index=0;\\n        int count=0;\\n        int[] out=new int[nums.length/2];\\n        for(int i=0;i<nums.length-1;i=i+2){\\n            if(count%2==0)\\n                out[index]=Math.min(nums[i],nums[i+1]);\\n            else\\n                out[index]=Math.max(nums[i],nums[i+1]);\\n            count++;\\n            index++;\\n        }\\n        return minMaxGame(out);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n       if(nums.length==1)\\n           return nums[0];\\n        int index=0;\\n        int count=0;\\n        int[] out=new int[nums.length/2];\\n        for(int i=0;i<nums.length-1;i=i+2){\\n            if(count%2==0)\\n                out[index]=Math.min(nums[i],nums[i+1]);\\n            else\\n                out[index]=Math.max(nums[i],nums[i+1]);\\n            count++;\\n            index++;\\n        }\\n        return minMaxGame(out);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418570,
                "title": "c-simple-solution",
                "content": "```\\nint minMaxGame(vector<int>& nums) \\n{\\n\\tint n = nums.size();\\n\\twhile(n > 1)\\n\\t{\\n\\t\\tfor(int i=0; i<n/2; i++)\\n\\t\\t{\\n\\t\\t\\tif(i % 2 == 0)  \\n\\t\\t\\t\\tnums[i] = min(nums[2*i], nums[2*i+1]);\\n\\t\\t\\telse    \\n\\t\\t\\t\\tnums[i] = max(nums[2*i], nums[2*i+1]);\\n\\t\\t}\\n\\t\\tn /= 2;\\n\\t}\\n\\treturn nums[0];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minMaxGame(vector<int>& nums) \\n{\\n\\tint n = nums.size();\\n\\twhile(n > 1)\\n\\t{\\n\\t\\tfor(int i=0; i<n/2; i++)\\n\\t\\t{\\n\\t\\t\\tif(i % 2 == 0)  \\n\\t\\t\\t\\tnums[i] = min(nums[2*i], nums[2*i+1]);\\n\\t\\t\\telse    \\n\\t\\t\\t\\tnums[i] = max(nums[2*i], nums[2*i+1]);\\n\\t\\t}\\n\\t\\tn /= 2;\\n\\t}\\n\\treturn nums[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243572,
                "title": "simple-recursion-java-solution-in-place-algorithm",
                "content": "```\\n\\tpublic int minMaxGame(int[] nums) {\\n        \\n        if(nums.length == 1) return nums[0];\\n        \\n        for(int i = 0; i < nums.length/2; i++){\\n\\n            if(i%2 == 0) nums[i] = Math.min(nums[2*i], nums[(2*i) + 1]);\\n            else nums[i] = Math.max(nums[2*i], nums[(2*i) + 1]);\\n        }\\n        \\n        return minMaxGame(Arrays.copyOf(nums, nums.length/2));\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int minMaxGame(int[] nums) {\\n        \\n        if(nums.length == 1) return nums[0];\\n        \\n        for(int i = 0; i < nums.length/2; i++){\\n\\n            if(i%2 == 0) nums[i] = Math.min(nums[2*i], nums[(2*i) + 1]);\\n            else nums[i] = Math.max(nums[2*i], nums[(2*i) + 1]);\\n        }\\n        \\n        return minMaxGame(Arrays.copyOf(nums, nums.length/2));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191947,
                "title": "simple-java-iterative-solution-o-1-space",
                "content": "Since we don\\'t need the previous value after finding (max/min) result, we can store the result in the same place and manage our indexes through simple calculations as showing below.\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        var isMin = true;\\n        var n=1;\\n        \\n        while(n<nums.length) {\\n            \\n            for(int i=0; i<nums.length; i+= n*2) {\\n                nums[i] = isMin ?\\n                    Math.min(nums[i], nums[i+n]) : \\n                    Math.max(nums[i], nums[i+n]);\\n                isMin = !isMin;\\n            }\\n            \\n            n *= 2;\\n        }\\n        \\n        return nums[0];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        var isMin = true;\\n        var n=1;\\n        \\n        while(n<nums.length) {\\n            \\n            for(int i=0; i<nums.length; i+= n*2) {\\n                nums[i] = isMin ?\\n                    Math.min(nums[i], nums[i+n]) : \\n                    Math.max(nums[i], nums[i+n]);\\n                isMin = !isMin;\\n            }\\n            \\n            n *= 2;\\n        }\\n        \\n        return nums[0];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116555,
                "title": "in-place-javascript",
                "content": "```\\nvar minMaxGame = function(nums) {\\n    while (nums.length > 1) {\\n        let half = nums.length / 2;\\n        for (let i = 0; i < half; i++)\\n            nums[i] = i % 2 === 0 ? Math.min(nums[2 * i], nums[2 * i + 1]) : Math.max(nums[2 * i], nums[2 * i + 1]);\\n        \\n        nums.length = half;\\n    }\\n    \\n    return nums[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMaxGame = function(nums) {\\n    while (nums.length > 1) {\\n        let half = nums.length / 2;\\n        for (let i = 0; i < half; i++)\\n            nums[i] = i % 2 === 0 ? Math.min(nums[2 * i], nums[2 * i + 1]) : Math.max(nums[2 * i], nums[2 * i + 1]);\\n        \\n        nums.length = half;\\n    }\\n    \\n    return nums[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114643,
                "title": "java-recursive-solution-runtime-0ms",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int len=nums.length;\\n        if(len==1)\\n            return nums[0];\\n        int[] newNums=new int[len/2];\\n        int index=0;\\n        for(int i=0;i<len;i+=2)\\n        {\\n            if(index%2==0)\\n            {\\n                newNums[index++]=Math.min(nums[i],nums[i+1]);\\n            }\\n            else\\n            {\\n                newNums[index++]=Math.max(nums[i],nums[i+1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int len=nums.length;\\n        if(len==1)\\n            return nums[0];\\n        int[] newNums=new int[len/2];\\n        int index=0;\\n        for(int i=0;i<len;i+=2)\\n        {\\n            if(index%2==0)\\n            {\\n                newNums[index++]=Math.min(nums[i],nums[i+1]);\\n            }\\n            else\\n            {\\n                newNums[index++]=Math.max(nums[i],nums[i+1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112540,
                "title": "4-liner-constant-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minMaxGame(vector<int>& nums) {\\n\\t\\t\\tfor(int n = nums.size();n > 1; n /= 2)\\n\\t\\t\\t\\tfor (int i = 0; i < n / 2; i++) \\n\\t\\t\\t\\t\\tnums[i] = (i%2 == 0) ? min(nums[2*i], nums[2*i + 1]) : max(nums[2*i], nums[2*i + 1]);\\n\\n\\t\\t\\treturn nums[0];\\n\\t\\t}\\n\\t};\\n\\t\\n**Time Complexity :** *O(n)*\\n**Space Complexity :** *O(1)*",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minMaxGame(vector<int>& nums) {\\n\\t\\t\\tfor(int n = nums.size();n > 1; n /= 2)\\n\\t\\t\\t\\tfor (int i = 0; i < n / 2; i++) \\n\\t\\t\\t\\t\\tnums[i] = (i%2 == 0) ? min(nums[2*i], nums[2*i + 1]) : max(nums[2*i], nums[2*i + 1]);\\n\\n\\t\\t\\treturn nums[0];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2112435,
                "title": "c-use-recursion-explanation-through-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //Use recursion\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        //base condition \\n        if(nums.size()==1)\\n            return nums[0];\\n        \\n        //define new vector newnums which stores min and max values and then again pass to the function\\n        vector<int> newnums;\\n        int n = nums.size(), ans;\\n        \\n        //iterate till n/2 times\\n        for(int i=0; i<n/2; i++)\\n        {\\n            //if index is even \\n            if(i%2==0)\\n                newnums.push_back(min(nums[2*i], nums[2*i+1]));\\n            \\n            //if index is odd\\n            else\\n                newnums.push_back(max(nums[2*i], nums[2*i+1]));\\n        \\n        }\\n        \\n        //pass newnums to the minMaxGame function for next level recursion\\n        ans = minMaxGame(newnums);\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use recursion\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        //base condition \\n        if(nums.size()==1)\\n            return nums[0];\\n        \\n        //define new vector newnums which stores min and max values and then again pass to the function\\n        vector<int> newnums;\\n        int n = nums.size(), ans;\\n        \\n        //iterate till n/2 times\\n        for(int i=0; i<n/2; i++)\\n        {\\n            //if index is even \\n            if(i%2==0)\\n                newnums.push_back(min(nums[2*i], nums[2*i+1]));\\n            \\n            //if index is odd\\n            else\\n                newnums.push_back(max(nums[2*i], nums[2*i+1]));\\n        \\n        }\\n        \\n        //pass newnums to the minMaxGame function for next level recursion\\n        ans = minMaxGame(newnums);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112216,
                "title": "rust-easy-solution-solved-in-place",
                "content": "```rust\\nuse std::cmp::{min, max};\\n\\nimpl Solution {\\n    pub fn min_max_game(mut nums: Vec<i32>) -> i32 {\\n        let mut n = nums.len()/2;\\n        \\n        while n > 0{\\n            for i in 0..n{\\n                if i % 2 ==0{\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            n /= 2;\\n        }\\n        \\n        nums[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::{min, max};\\n\\nimpl Solution {\\n    pub fn min_max_game(mut nums: Vec<i32>) -> i32 {\\n        let mut n = nums.len()/2;\\n        \\n        while n > 0{\\n            for i in 0..n{\\n                if i % 2 ==0{\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            n /= 2;\\n        }\\n        \\n        nums[0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3779027,
                "title": "python-3-simple-recursion-with-diapason-pass",
                "content": "```python3 []\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def getMinMax(l, r, func):\\n            if r - l == 1: return nums[l]\\n            mid = l + (r-l)//2\\n            return func(getMinMax(l, mid, min), getMinMax(mid, r, max))\\n            \\n        return getMinMax(0, len(nums), min)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def getMinMax(l, r, func):\\n            if r - l == 1: return nums[l]\\n            mid = l + (r-l)//2\\n            return func(getMinMax(l, mid, min), getMinMax(mid, r, max))\\n            \\n        return getMinMax(0, len(nums), min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673984,
                "title": "2-c-solutions-beginner-friendly-approach-with-and-without-recursion",
                "content": "\\n# Code\\n```\\n// Solution 1 (with recursion)\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n       if(n==1) return nums[0];\\n       vector<int> newNum(n/2);\\n       for(int i=0; i<n/2; i++) { \\n            if(i%2==0) \\n                newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else \\n                newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum);\\n        return res;\\n    }\\n};\\n\\n// Solution 2 (without recursion)\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            int k=0;\\n            for(int i=0;i<n/2;i++){\\n                if(k%2==0) \\n                    nums[k]=min(nums[2*i],nums[2*i+1]);\\n                else \\n                    nums[k]=max(nums[2*i],nums[2*i+1]);\\n                k++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Solution 1 (with recursion)\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n       if(n==1) return nums[0];\\n       vector<int> newNum(n/2);\\n       for(int i=0; i<n/2; i++) { \\n            if(i%2==0) \\n                newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else \\n                newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum);\\n        return res;\\n    }\\n};\\n\\n// Solution 2 (without recursion)\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            int k=0;\\n            for(int i=0;i<n/2;i++){\\n                if(k%2==0) \\n                    nums[k]=min(nums[2*i],nums[2*i+1]);\\n                else \\n                    nums[k]=max(nums[2*i],nums[2*i+1]);\\n                k++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363467,
                "title": "min-max-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        vector<int> arr;\\n        int i, new_num, n;\\n        n = nums.size();\\n        while(n>1)\\n        {\\n            n = nums.size();\\n            for(i=0 ; i<n/2 ; i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    new_num = min(nums[2*i], nums[2*i+1]);\\n                    arr.push_back(new_num);\\n                }\\n                else\\n                {\\n                    new_num = max(nums[2*i], nums[2*i+1]);\\n                    arr.push_back(new_num);\\n                }\\n            }\\n            nums.clear();\\n            nums = arr;\\n            arr.clear();\\n        }\\n        return nums[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        vector<int> arr;\\n        int i, new_num, n;\\n        n = nums.size();\\n        while(n>1)\\n        {\\n            n = nums.size();\\n            for(i=0 ; i<n/2 ; i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    new_num = min(nums[2*i], nums[2*i+1]);\\n                    arr.push_back(new_num);\\n                }\\n                else\\n                {\\n                    new_num = max(nums[2*i], nums[2*i+1]);\\n                    arr.push_back(new_num);\\n                }\\n            }\\n            nums.clear();\\n            nums = arr;\\n            arr.clear();\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168113,
                "title": "min-max-game-easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n\\n        int[] newNums = new int[n/2];\\n        for(int i=0; i<newNums.length; i++){\\n            if(i % 2 == 1){\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }else{\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n\\n        int[] newNums = new int[n/2];\\n        for(int i=0; i<newNums.length; i++){\\n            if(i % 2 == 1){\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }else{\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962799,
                "title": "100-javascript-recursion",
                "content": "\\n\\n# Code\\n```\\nvar minMaxGame = function(nums) {\\n  if(nums.length===1) return nums;\\n  let newNums = [];\\n  let flag = true;\\n  for(let i=0;i<nums.length;i=i+2){ // i=4 nums= [1,5]\\n      if(flag){\\n          let val = Math.min(nums[i],nums[i+1]);\\n          newNums.push(val);\\n          flag = false\\n      }else{\\n        let val = Math.max(nums[i],nums[i+1])  \\n          newNums.push(val)\\n          flag = true;\\n      }\\n  }\\n  return minMaxGame(newNums)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMaxGame = function(nums) {\\n  if(nums.length===1) return nums;\\n  let newNums = [];\\n  let flag = true;\\n  for(let i=0;i<nums.length;i=i+2){ // i=4 nums= [1,5]\\n      if(flag){\\n          let val = Math.min(nums[i],nums[i+1]);\\n          newNums.push(val);\\n          flag = false\\n      }else{\\n        let val = Math.max(nums[i],nums[i+1])  \\n          newNums.push(val)\\n          flag = true;\\n      }\\n  }\\n  return minMaxGame(newNums)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2929898,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newNums = []\\n        isMax = False\\n        while len(nums) != 1:\\n            for i in range(0, len(nums) - 1, 2):\\n                if not isMax:\\n                    newNums.append(min(nums[i], nums[i + 1]))\\n                    isMax = True\\n                else:\\n                    newNums.append(max(nums[i], nums[i + 1]))\\n                    isMax = False\\n            nums = newNums\\n            newNums = []\\n        return nums[0]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/bd7ea14e-525c-4c37-9069-0f237d51b3af_1671483731.2972088.png)\\n![image.png](https://assets.leetcode.com/users/images/6a3a43fb-b478-4d05-b7a5-d53444af94e0_1671483750.149535.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newNums = []\\n        isMax = False\\n        while len(nums) != 1:\\n            for i in range(0, len(nums) - 1, 2):\\n                if not isMax:\\n                    newNums.append(min(nums[i], nums[i + 1]))\\n                    isMax = True\\n                else:\\n                    newNums.append(max(nums[i], nums[i + 1]))\\n                    isMax = False\\n            nums = newNums\\n            newNums = []\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876854,
                "title": "1-using-recursion-2-only-single-array",
                "content": "# Intuition\\n\\n- easy\\n- most of the logic was given in description only\\n- same logic which any one will think\\n \\n\\n# Approach\\n\\n# 1. Recursion\\n- storing next min max array\\n- in new array n return until only one element is left\\n```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1)\\n            return nums[0];\\n        \\n        int new_arr[] = new int[n/2];\\n\\n        for(int i=0; i<new_arr.length; i++)\\n            new_arr[i] = i%2==0 ? Math.min(nums[2*i], nums[2*i+1]) : Math.max(nums[2*i], nums[2*i+1]);\\n\\n        return minMaxGame(new_arr);\\n    }\\n}\\n```\\n\\n# 2. Only Single Array\\n- Store in Same Array\\n- Multi loops\\n\\n```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n>1){\\n            for(int i=0; i<n/2; i++)\\n                nums[i] = i%2==0 ? Math.min(nums[2*i], nums[2*i+1]) : Math.max(nums[2*i], nums[2*i+1]);\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\\n.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1)\\n            return nums[0];\\n        \\n        int new_arr[] = new int[n/2];\\n\\n        for(int i=0; i<new_arr.length; i++)\\n            new_arr[i] = i%2==0 ? Math.min(nums[2*i], nums[2*i+1]) : Math.max(nums[2*i], nums[2*i+1]);\\n\\n        return minMaxGame(new_arr);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n>1){\\n            for(int i=0; i<n/2; i++)\\n                nums[i] = i%2==0 ? Math.min(nums[2*i], nums[2*i+1]) : Math.max(nums[2*i], nums[2*i+1]);\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838187,
                "title": "java-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        int[] newNums = new int[nums.length/2];\\n        while (newNums.length > 1) {\\n            for (int i = 0; i < newNums.length; i+=2) {\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            for (int i = 1; i < newNums.length; i+=2) {\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            nums = newNums;\\n            newNums = new int[newNums.length/2];\\n        }\\n        \\n        return Math.min(nums[0], nums[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n        int[] newNums = new int[nums.length/2];\\n        while (newNums.length > 1) {\\n            for (int i = 0; i < newNums.length; i+=2) {\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            for (int i = 1; i < newNums.length; i+=2) {\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            nums = newNums;\\n            newNums = new int[newNums.length/2];\\n        }\\n        \\n        return Math.min(nums[0], nums[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744280,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1) return nums[0]; \\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++) { \\n            if(i%2==0) newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1) return nums[0]; \\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++) { \\n            if(i%2==0) newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            else newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n        } \\n        int res = minMaxGame(newNum);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677728,
                "title": "python-simple-to-understand",
                "content": "```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) != 1:\\n            new_nums = []\\n            j = 0\\n            for i in range(0, len(nums) - 1, 2):\\n                if j % 2 == 0:\\n                    new_nums.append(min([nums[i], nums[i + 1]]))\\n                else:\\n                    new_nums.append(max([nums[i], nums[i + 1]]))\\n                j += 1\\n            nums = new_nums\\n        return nums[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) != 1:\\n            new_nums = []\\n            j = 0\\n            for i in range(0, len(nums) - 1, 2):\\n                if j % 2 == 0:\\n                    new_nums.append(min([nums[i], nums[i + 1]]))\\n                else:\\n                    new_nums.append(max([nums[i], nums[i + 1]]))\\n                j += 1\\n            nums = new_nums\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332540,
                "title": "c-sol-100-optimal-7-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            for(int i=0;i<n/2;i++){\\n                if(i%2==0)nums[i]=min(nums[2 * i], nums[2 * i + 1]);\\n                else nums[i]=max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            n=n/2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        while(n>1){\\n            for(int i=0;i<n/2;i++){\\n                if(i%2==0)nums[i]=min(nums[2 * i], nums[2 * i + 1]);\\n                else nums[i]=max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            n=n/2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160753,
                "title": "python-loop-easy-to-understand-fast-90",
                "content": "**Python 3 Solution**\\n\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        \\n        while len(nums) > 1:\\n            newNums = [0]*(len(nums)//2)\\n            for i in range(0, len(nums)//2):\\n                if i % 2 == 0:\\n                    newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n                else:\\n                    newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n            nums = list(newNums)\\n            \\n        return nums[0]\\n```\\n\\n**Explanation:**\\n\\n  * While the array is greater than size 1, we:\\n  * Create an empty array of half the length.\\n  * Loop through half of the nums, and apply the logic specified.\\n  * Stop when we have a array of size 1.\\n\\n\\n**Complexity:**\\n\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the size of the array.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        \\n        while len(nums) > 1:\\n            newNums = [0]*(len(nums)//2)\\n            for i in range(0, len(nums)//2):\\n                if i % 2 == 0:\\n                    newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n                else:\\n                    newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n            nums = list(newNums)\\n            \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138681,
                "title": "cpp",
                "content": "class Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=log2(nums.size());\\n        vector<int>v=nums;\\n        while(n>0){\\n            int flag=0;\\n            vector<int>x;\\n            for(int i=0;i<v.size();i=i+2){\\n            if(flag==0){\\n                x.push_back(min(v[i],v[i+1]));\\n                flag=1;\\n            }\\n            else if(flag==1){\\n              x.push_back(max(v[i],v[i+1]));\\n                flag=0;\\n            }\\n            }\\n            v=x;\\n            n--;\\n        }\\n        return v[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=log2(nums.size());\\n        vector<int>v=nums;\\n        while(n>0){\\n            int flag=0;\\n            vector<int>x;\\n            for(int i=0;i<v.size();i=i+2){\\n            if(flag==0){\\n                x.push_back(min(v[i],v[i+1]));\\n                flag=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2117972,
                "title": "easy-o-1-c-solution",
                "content": "```\\nint minMaxGame(vector<int>& nums)  {   \\n        while(nums.size()!=1){\\n            int j=0;\\n            for(int i=0; i<nums.size(); i+=2){\\n                (j&1)?nums[j]=max(nums[i], nums[i+1]):nums[j]=min(nums[i], nums[i+1]);\\n                j++;\\n            }\\n            nums.resize(j);\\n        }\\n        return nums[0];     \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMaxGame(vector<int>& nums)  {   \\n        while(nums.size()!=1){\\n            int j=0;\\n            for(int i=0; i<nums.size(); i+=2){\\n                (j&1)?nums[j]=max(nums[i], nums[i+1]):nums[j]=min(nums[i], nums[i+1]);\\n                j++;\\n            }\\n            nums.resize(j);\\n        }\\n        return nums[0];     \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114494,
                "title": "java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if (n==1){\\n            return nums[0];//Break statement of Recursion\\n        }\\n            int[] newNums = new int[n/2];//Making an array of half of the size\\n            for (int i = 0; i <n/2 ; i++) {\\n                if (i%2==0){//For even numbers\\n                    newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n                }else{//For odd numbers\\n                    newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n        if (newNums.length>1){\\n            return minMaxGame(newNums);//Using recursion for the next iteration untill we reach to array of length 1\\n        } return newNums[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if (n==1){\\n            return nums[0];//Break statement of Recursion\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2113874,
                "title": "c-iterative-and-recursive-solution",
                "content": "**Please upvote if found this helpful**\\n\\n```\\nint solve(vector<int> &nums,int n){\\n    if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> temp;\\n        int c = 0;\\n        for(int i = 0;i<nums.size();i+=2){\\n            if(c%2==0)\\n                temp.push_back(min(nums[i],nums[i+1]));\\n            if(c%2)\\n                temp.push_back(max(nums[i],nums[i+1]));\\n            c++;\\n        }\\n        return solve(temp,n/2);\\n    }\\n\\tint minMaxGame(vector<int>& nums) {\\n\\tint ans = solve(nums,nums.size());\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t**Itertive solution**\\n\\t\\n\\t\\n\\t\\n\\t int minMaxGame(vector<int>& nums) {\\n        int ans = 0;\\n        int size = nums.size();\\n        if(size == 1)\\n            return nums[0];\\n        while(size != 1){\\n            vector<int> temp;\\n            int c = 0;\\n            for(int i = 0;i<size;i+=2){\\n                if(c%2==0)\\n                temp.push_back(min(nums[i],nums[i+1]));\\n                if(c%2==1)\\n                    temp.push_back(max(nums[i],nums[i+1]));\\n                c++;\\n            }\\n            if(temp.size() == 1)\\n                return temp[0];\\n            size = size/2;\\n            nums = temp;\\n        }\\n        return 0;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "**Please upvote if found this helpful**\\n\\n```\\nint solve(vector<int> &nums,int n){\\n    if(n == 1)\\n            return nums[0];\\n        \\n        vector<int> temp;\\n        int c = 0;\\n        for(int i = 0;i<nums.size();i+=2){\\n            if(c%2==0)\\n                temp.push_back(min(nums[i],nums[i+1]));\\n            if(c%2)\\n                temp.push_back(max(nums[i],nums[i+1]));\\n            c++;\\n        }\\n        return solve(temp,n/2);\\n    }\\n\\tint minMaxGame(vector<int>& nums) {\\n\\tint ans = solve(nums,nums.size());\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t**Itertive solution**\\n\\t\\n\\t\\n\\t\\n\\t int minMaxGame(vector<int>& nums) {\\n        int ans = 0;\\n        int size = nums.size();\\n        if(size == 1)\\n            return nums[0];\\n        while(size != 1){\\n            vector<int> temp;\\n            int c = 0;\\n            for(int i = 0;i<size;i+=2){\\n                if(c%2==0)\\n                temp.push_back(min(nums[i],nums[i+1]));\\n                if(c%2==1)\\n                    temp.push_back(max(nums[i],nums[i+1]));\\n                c++;\\n            }\\n            if(temp.size() == 1)\\n                return temp[0];\\n            size = size/2;\\n            nums = temp;\\n        }\\n        return 0;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2113265,
                "title": "python-super-easy-understanding-upvote-plz",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def dfs(nums, min_or_max):\\n            if len(nums) <= 2:\\n                return min_or_max(nums)\\n            return min_or_max(dfs(nums[:len(nums)//2], min), dfs(nums[len(nums)//2:], max))\\n        return dfs(nums, min)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def dfs(nums, min_or_max):\\n            if len(nums) <= 2:\\n                return min_or_max(nums)\\n            return min_or_max(dfs(nums[:len(nums)//2], min), dfs(nums[len(nums)//2:], max))\\n        return dfs(nums, min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113004,
                "title": "c-easy-approach-simple-code",
                "content": "**Plase Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        // if nums size is 1 then return value itself as answer\\n        if(nums.size()==1)\\n            return nums[0];\\n        \\n        // define a new vector that will store new min max values\\n        vector<int> comb;\\n        \\n        int n = nums.size();\\n        \\n        // iterate by n/2 according yo condition\\n        for(int i=0;i<n/2;i++)\\n        {\\n            // even index\\n            if(i%2 == 0)\\n                comb.push_back(min(nums[2 * i], nums[2 * i + 1]));\\n            \\n            // odd index\\n            else\\n                comb.push_back(max(nums[2 * i], nums[2 * i + 1]));\\n        }\\n        \\n        // call recusrion with same function till our comb size reached to the 1\\n        int ans = minMaxGame(comb);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        // if nums size is 1 then return value itself as answer\\n        if(nums.size()==1)\\n            return nums[0];\\n        \\n        // define a new vector that will store new min max values\\n        vector<int> comb;\\n        \\n        int n = nums.size();\\n        \\n        // iterate by n/2 according yo condition\\n        for(int i=0;i<n/2;i++)\\n        {\\n            // even index\\n            if(i%2 == 0)\\n                comb.push_back(min(nums[2 * i], nums[2 * i + 1]));\\n            \\n            // odd index\\n            else\\n                comb.push_back(max(nums[2 * i], nums[2 * i + 1]));\\n        }\\n        \\n        // call recusrion with same function till our comb size reached to the 1\\n        int ans = minMaxGame(comb);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112919,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# while length of nums is greater than 1 \\n        while(n > 1):\\n            newNums = [0 for i in range(n//2)]\\n\\t\\t\\t\\n\\t\\t\\t# place at even indexes\\n            for i in range(0,n//2,2):\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            \\n\\t\\t\\t# place at odd indexes\\n            for i in range(1,n//2,2):\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n                \\n            nums= newNums\\n            \\n            n=len(nums)\\n            \\n        return nums[-1]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# while length of nums is greater than 1 \\n        while(n > 1):\\n            newNums = [0 for i in range(n//2)]\\n\\t\\t\\t\\n\\t\\t\\t# place at even indexes\\n            for i in range(0,n//2,2):\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            \\n\\t\\t\\t# place at odd indexes\\n            for i in range(1,n//2,2):\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n                \\n            nums= newNums\\n            \\n            n=len(nums)\\n            \\n        return nums[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112482,
                "title": "python-easy-solution",
                "content": "Here we use the concept of recursion , for which we created a new function called game fo easy implementation of our function.\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return Solution().game(nums)\\n        \\n    def game(self,nums):\\n        if len(nums)==1:\\n            return nums[0]\\n        \\n        l=[]\\n        for i in range(len(nums)//2):\\n            if i%2==0:\\n                l.append(min(nums[2 * i], nums[2 * i + 1]))\\n            \\n            else:\\n                l.append(max(nums[2 * i], nums[2 * i + 1]))\\n        #print(l)       \\n        return Solution().game(l)\\n```\\nIf u understood the code then plz...UPVOTE...Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return Solution().game(nums)\\n        \\n    def game(self,nums):\\n        if len(nums)==1:\\n            return nums[0]\\n        \\n        l=[]\\n        for i in range(len(nums)//2):\\n            if i%2==0:\\n                l.append(min(nums[2 * i], nums[2 * i + 1]))\\n            \\n            else:\\n                l.append(max(nums[2 * i], nums[2 * i + 1]))\\n        #print(l)       \\n        return Solution().game(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112279,
                "title": "too-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.back();\\n        \\n        int n = nums.size();\\n        vector<int> a(n/2);\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(i%2==0)\\n            a[i] = min(nums[2*i],nums[2*i+1]);\\n            else\\n                a[i] = max(nums[2*i],nums[2*i+1]);\\n        }\\n        \\n        return minMaxGame(a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums.back();\\n        \\n        int n = nums.size();\\n        vector<int> a(n/2);\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(i%2==0)\\n            a[i] = min(nums[2*i],nums[2*i+1]);\\n            else\\n                a[i] = max(nums[2*i],nums[2*i+1]);\\n        }\\n        \\n        return minMaxGame(a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112259,
                "title": "java-o-1-extra-space-easy-to-understand",
                "content": "Please upvote if you like the solution\\n\\niterating until n>1\\ntaking min of first to number and taking max of next to number, so on..\\nmaintaining the index variable to indicate the current location where to store the new result i.e(min(a,b), max(a,b)\\n\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int index = 0;\\n        int n = nums.length;\\n        int a=0,i=0;\\n        while(n>1){\\n            if(a%2==0){\\n                nums[index] = Math.min(nums[i],nums[i+1]);\\n                index++;\\n                a++;\\n            }\\n            else{\\n                nums[index] = Math.max(nums[i],nums[i+1]);\\n                index++;\\n                a++;\\n            }\\n            \\n            if(i==n-2){\\n                n=n/2;\\n                index = 0;\\n                a=0;\\n                i=0;\\n            }\\n            else\\n                i=i+2;\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int index = 0;\\n        int n = nums.length;\\n        int a=0,i=0;\\n        while(n>1){\\n            if(a%2==0){\\n                nums[index] = Math.min(nums[i],nums[i+1]);\\n                index++;\\n                a++;\\n            }\\n            else{\\n                nums[index] = Math.max(nums[i],nums[i+1]);\\n                index++;\\n                a++;\\n            }\\n            \\n            if(i==n-2){\\n                n=n/2;\\n                index = 0;\\n                a=0;\\n                i=0;\\n            }\\n            else\\n                i=i+2;\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111930,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\n    vector<int> helper(vector<int>& nums,int n){\\n        vector<int> ans;\\n        for(int i=0;i<n/2;i++){\\n            if(i%2 == 0) ans.emplace_back(min(nums[2*i],nums[2*i+1]));\\n            else ans.emplace_back(max(nums[2 * i], nums[2 * i + 1]));\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n == 1) return nums[0];\\n        while(true){\\n           vector<int> arr = helper(nums,n);\\n            n = arr.size();\\n            nums = arr;\\n            if(n == 1) return  arr[0];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> helper(vector<int>& nums,int n){\\n        vector<int> ans;\\n        for(int i=0;i<n/2;i++){\\n            if(i%2 == 0) ans.emplace_back(min(nums[2*i],nums[2*i+1]));\\n            else ans.emplace_back(max(nums[2 * i], nums[2 * i + 1]));\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n == 1) return nums[0];\\n        while(true){\\n           vector<int> arr = helper(nums,n);\\n            n = arr.size();\\n            nums = arr;\\n            if(n == 1) return  arr[0];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111885,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\t\\t\\twhile len(nums) != 1:\\n\\t\\t\\t\\tnewNums = []\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor i in range(0, len(nums), 2):\\n\\t\\t\\t\\t\\tif cnt % 2 == 0:\\n\\t\\t\\t\\t\\t\\tnewNums.append(min(nums[i], nums[i + 1]))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnewNums.append(max(nums[i], nums[i + 1]))\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tnums = newNums\\n\\t\\t\\treturn nums[0]\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minMaxGame(int[] nums) {\\n\\t\\t\\twhile (nums.length != 1) {\\n\\t\\t\\t\\tint[] newNums = new int[nums.length / 2];\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length; i += 2) {\\n\\t\\t\\t\\t\\tif (cnt % 2 == 0) {\\n\\t\\t\\t\\t\\t\\tnewNums[i / 2] = Math.min(nums[i], nums[i + 1]);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnewNums[i / 2] = Math.max(nums[i], nums[i + 1]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums = newNums;\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[0];\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\t\\t\\twhile len(nums) != 1:\\n\\t\\t\\t\\tnewNums = []\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor i in range(0, len(nums), 2):\\n\\t\\t\\t\\t\\tif cnt % 2 == 0:\\n\\t\\t\\t\\t\\t\\tnewNums.append(min(nums[i], nums[i + 1]))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnewNums.append(max(nums[i], nums[i + 1]))\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tnums = newNums\\n\\t\\t\\treturn nums[0]\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minMaxGame(int[] nums) {\\n\\t\\t\\twhile (nums.length != 1) {\\n\\t\\t\\t\\tint[] newNums = new int[nums.length / 2];\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length; i += 2) {\\n\\t\\t\\t\\t\\tif (cnt % 2 == 0) {\\n\\t\\t\\t\\t\\t\\tnewNums[i / 2] = Math.min(nums[i], nums[i + 1]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4019575,
                "title": "i-will-make-it-easy-for-you-here-it-is",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n\\n      while(nums.size()!=1){\\n         vector<int>currvect;\\n         bool flag = true;\\n         for(int i=0;i<nums.size()-1;i++){\\n           if(flag){\\n              currvect.push_back(min(nums[i],nums[i+1]));\\n               flag = false;\\n           }\\n           else{\\n               currvect.push_back(max(nums[i],nums[i+1]));\\n               flag = true;\\n           }\\n           i++;\\n         }\\n         nums = currvect;\\n      }\\n     return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n\\n      while(nums.size()!=1){\\n         vector<int>currvect;\\n         bool flag = true;\\n         for(int i=0;i<nums.size()-1;i++){\\n           if(flag){\\n              currvect.push_back(min(nums[i],nums[i+1]));\\n               flag = false;\\n           }\\n           else{\\n               currvect.push_back(max(nums[i],nums[i+1]));\\n               flag = true;\\n           }\\n           i++;\\n         }\\n         nums = currvect;\\n      }\\n     return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774178,
                "title": "java-100-faster-recursion-with-explanation",
                "content": "# Approach\\nAn approach to solving the \"Min Max Game\" problem is a recursive one, which is a valid and efficient way to find the last remaining number after applying the algorithm. Let\\'s describe the approach step-by-step:\\n\\n1. **Base Case**: Check if the length of the `nums` array is 1. If it is, then it means we have reached the last remaining number after applying the algorithm. In this case, simply return `nums[0]` as the output.\\n\\n2. **Recursive Case**: If the length of the `nums` array is greater than 1, we proceed with the algorithm.\\n   - Create a new array called `newNums` of length `nums.length / 2`. This array will store the values of `min(nums[2 * i], nums[2 * i + 1])` for even indices and `max(nums[2 * i], nums[2 * i + 1])` for odd indices.\\n   - Traverse through `newNums` and calculate the values for each index based on the algorithm\\'s rules using the `min()` and `max()` functions.\\n   - Now, we have a new array `newNums`, which is half the size of the original `nums` array. We call the `minMaxGame()` function recursively with `newNums` as the input.\\n\\n3. **Termination Condition**: The recursion will continue until the base case is reached (i.e., the `nums` array has only one element). Once the base case is reached, the recursion will start to unwind, and the last remaining number will be returned from each recursive call.\\n\\n4. **Return**: The final result will be the output of the initial recursive call, which is the last remaining number after applying the algorithm to the original `nums` array.\\n\\nThe logic behind this approach is to repeatedly apply the algorithm on the given array until we have only one element left. Each time we apply the algorithm, we reduce the size of the array by half (by creating the `newNums` array). This recursive process allows us to efficiently find the last remaining number.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1) \\n            return nums[0];\\n\\n        int[] newNums = new int[nums.length / 2];\\n\\n        for(int i = 0; i < newNums.length; i++){\\n            if(i % 2 == 0)\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            else\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n        }\\n\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Recursion",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1) \\n            return nums[0];\\n\\n        int[] newNums = new int[nums.length / 2];\\n\\n        for(int i = 0; i < newNums.length; i++){\\n            if(i % 2 == 0)\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            else\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n        }\\n\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693050,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def next(self, nums: List[int]) -> int:\\n        i=0\\n        cnt=0\\n        res=[]\\n        while(i<len(nums)):\\n            if cnt%2==0:\\n                res.append(min(nums[i],nums[i+1]))\\n            else:\\n                res.append(max(nums[i],nums[i+1]))\\n            cnt+=1\\n            i+=2\\n        return res\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while(len(nums)>1):\\n            nums=Solution.next(self,nums)\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def next(self, nums: List[int]) -> int:\\n        i=0\\n        cnt=0\\n        res=[]\\n        while(i<len(nums)):\\n            if cnt%2==0:\\n                res.append(min(nums[i],nums[i+1]))\\n            else:\\n                res.append(max(nums[i],nums[i+1]))\\n            cnt+=1\\n            i+=2\\n        return res\\n\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while(len(nums)>1):\\n            nums=Solution.next(self,nums)\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630598,
                "title": "a-straightforward-solution-by-recursion",
                "content": "# Code\\n```\\nfunc minMaxGame(nums []int) int {\\n\\tn := len(nums)\\n\\tif n == 1 {\\n\\t\\treturn nums[0]\\n\\t}\\n\\n\\tvar mode bool\\n\\tnewNums := make([]int, 0, len(nums)/2)\\n\\tfor i := 0; i < n; i += 2 {\\n\\t\\to := nums[i]\\n\\t\\tt := nums[i+1]\\n\\n\\t\\tif mode {\\n\\t\\t\\tnewNums = append(newNums, max(o, t))\\n\\t\\t} else {\\n\\t\\t\\tnewNums = append(newNums, min(o, t))\\n\\t\\t}\\n\\n\\t\\tmode = !mode\\n\\t}\\n\\n\\treturn minMaxGame(newNums)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn y\\n\\t}\\n\\treturn x\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn y\\n\\t}\\n\\treturn x\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc minMaxGame(nums []int) int {\\n\\tn := len(nums)\\n\\tif n == 1 {\\n\\t\\treturn nums[0]\\n\\t}\\n\\n\\tvar mode bool\\n\\tnewNums := make([]int, 0, len(nums)/2)\\n\\tfor i := 0; i < n; i += 2 {\\n\\t\\to := nums[i]\\n\\t\\tt := nums[i+1]\\n\\n\\t\\tif mode {\\n\\t\\t\\tnewNums = append(newNums, max(o, t))\\n\\t\\t} else {\\n\\t\\t\\tnewNums = append(newNums, min(o, t))\\n\\t\\t}\\n\\n\\t\\tmode = !mode\\n\\t}\\n\\n\\treturn minMaxGame(newNums)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn y\\n\\t}\\n\\treturn x\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn y\\n\\t}\\n\\treturn x\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516803,
                "title": "beginner-friendly-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) > 1:\\n            new_nums = []\\n            for i in range(0,len(nums),2):\\n                a = nums[i]\\n                b = nums[i+1]\\n                if (i/2)%2  == 0:\\n                    if a < b:\\n                        new_nums.append(a)\\n                    else:\\n                        new_nums.append(b)\\n                else:\\n                    if a > b:\\n                        new_nums.append(a)\\n                    else:\\n                        new_nums.append(b)\\n            nums = new_nums\\n        return nums[0]            \\n\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) > 1:\\n            new_nums = []\\n            for i in range(0,len(nums),2):\\n                a = nums[i]\\n                b = nums[i+1]\\n                if (i/2)%2  == 0:\\n                    if a < b:\\n                        new_nums.append(a)\\n                    else:\\n                        new_nums.append(b)\\n                else:\\n                    if a > b:\\n                        new_nums.append(a)\\n                    else:\\n                        new_nums.append(b)\\n            nums = new_nums\\n        return nums[0]            \\n\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287865,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->we have to compare the values until the length of the list is 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate while until the length of the list is single value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        i=0\\n        x=[]\\n        y=True\\n        while i<=len(nums):\\n            if i==len(nums):\\n                nums=x\\n                x=[]\\n                i=0\\n            if y:\\n                x.append(min(nums[i:i+2]))\\n                i=i+2\\n                y=False\\n            else:\\n                x.append(max(nums[i:i+2]))\\n                i=i+2\\n                y=True\\n        return x[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        i=0\\n        x=[]\\n        y=True\\n        while i<=len(nums):\\n            if i==len(nums):\\n                nums=x\\n                x=[]\\n                i=0\\n            if y:\\n                x.append(min(nums[i:i+2]))\\n                i=i+2\\n                y=False\\n            else:\\n                x.append(max(nums[i:i+2]))\\n                i=i+2\\n                y=True\\n        return x[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989638,
                "title": "easiest-solution-with-two-approach",
                "content": "# Complexity\\n- Time complexity: O(n*n/2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n# iterative:\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n*n/2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n# iterative:\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```\\n# Complexity\\n- Time complexity: O(n*n/2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n# iterative:\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        while(n!=1){\\n            int x=0;\\n            for(int i=0;i<n/2;i++){\\n                if(x%2==0){\\n                    nums[x]=min(nums[2*i],nums[2*i+1]);\\n                }\\n                else{ \\n                    nums[x]=max(nums[2*i],nums[2*i+1]);\\n                }\\n                x++;\\n            }\\n            n/=2;\\n        }\\n        return nums[0];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804335,
                "title": "min-max-game-solution-java",
                "content": "class Solution {\\n  public int minMaxGame(int[] nums) {\\n    if (nums.length == 1)\\n      return nums[0];\\n\\n    int[] nextNums = new int[nums.length / 2];\\n    for (int i = 0; i < nextNums.length; ++i)\\n      nextNums[i] = (i & 1) == 1 ? Math.max(nums[2 * i], nums[2 * i + 1])\\n                                 : Math.min(nums[2 * i], nums[2 * i + 1]);\\n    return minMaxGame(nextNums);\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Simulation"
                ],
                "code": "class Solution {\\n  public int minMaxGame(int[] nums) {\\n    if (nums.length == 1)\\n      return nums[0];\\n\\n    int[] nextNums = new int[nums.length / 2];\\n    for (int i = 0; i < nextNums.length; ++i)\\n      nextNums[i] = (i & 1) == 1 ? Math.max(nums[2 * i], nums[2 * i + 1])\\n                                 : Math.min(nums[2 * i], nums[2 * i + 1]);\\n    return minMaxGame(nextNums);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2613751,
                "title": "java-0-ms-100-faster",
                "content": "```\\npublic int minMaxGame(int[] nums) {\\n        if (nums.length == 1)\\n\\t\\treturn nums[0];\\n\\n\\t\\tint ans[] = new int[nums.length / 2];\\n\\t\\tfor (int i = 0, j = 1, k = 0; i < nums.length && j < nums.length;) {\\n\\t\\t\\tif (k % 2 == 0) {\\n\\t\\t\\t\\tans[k] = Math.min(nums[i], nums[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[k] = Math.max(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t\\ti += 2;\\n\\t\\t\\tj += 2;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\treturn minMaxGame(ans);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minMaxGame(int[] nums) {\\n        if (nums.length == 1)\\n\\t\\treturn nums[0];\\n\\n\\t\\tint ans[] = new int[nums.length / 2];\\n\\t\\tfor (int i = 0, j = 1, k = 0; i < nums.length && j < nums.length;) {\\n\\t\\t\\tif (k % 2 == 0) {\\n\\t\\t\\t\\tans[k] = Math.min(nums[i], nums[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[k] = Math.max(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t\\ti += 2;\\n\\t\\t\\tj += 2;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\treturn minMaxGame(ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2550512,
                "title": "100-0-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minMaxGame = function(nums) {\\n    return helper(nums);\\n};\\n\\nvar helper = function(nums) {\\n    \\n    if(nums.length === 1) return nums[0];\\n    \\n    let arr = new Array();\\n    \\n    for (let i = 0; i < nums.length; i = i + 2) {\\n        if ((i / 2) % 2 === 1) {\\n            arr.push(Math.max(nums[i], nums[i+1]))\\n        } else {\\n            arr.push(Math.min(nums[i], nums[i+1]))\\n        }\\n    }\\n    return helper(arr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minMaxGame = function(nums) {\\n    return helper(nums);\\n};\\n\\nvar helper = function(nums) {\\n    \\n    if(nums.length === 1) return nums[0];\\n    \\n    let arr = new Array();\\n    \\n    for (let i = 0; i < nums.length; i = i + 2) {\\n        if ((i / 2) % 2 === 1) {\\n            arr.push(Math.max(nums[i], nums[i+1]))\\n        } else {\\n            arr.push(Math.min(nums[i], nums[i+1]))\\n        }\\n    }\\n    return helper(arr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500016,
                "title": "java-solution-using-recursion-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] arr) {\\n        if (arr.length == 1) {\\n            return arr[0];\\n        }\\n        int[] ans = new int[arr.length / 2];\\n        int ind = 0, cnt = 0;\\n        for (int i = 0; i < arr.length - 1; i += 2, cnt++) {\\n            int val = 0;\\n            if (cnt % 2 == 0) {\\n                val = Integer.min(arr[i], arr[i+1]);\\n            }\\n            else val = Integer.max(arr[i], arr[i+1]);\\n            ans[ind++] = val;\\n        }\\n        return minMaxGame(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] arr) {\\n        if (arr.length == 1) {\\n            return arr[0];\\n        }\\n        int[] ans = new int[arr.length / 2];\\n        int ind = 0, cnt = 0;\\n        for (int i = 0; i < arr.length - 1; i += 2, cnt++) {\\n            int val = 0;\\n            if (cnt % 2 == 0) {\\n                val = Integer.min(arr[i], arr[i+1]);\\n            }\\n            else val = Integer.max(arr[i], arr[i+1]);\\n            ans[ind++] = val;\\n        }\\n        return minMaxGame(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460737,
                "title": "constant-space-c-solution",
                "content": "```\\nint minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        while(n > 1) {            \\n            for(int i = 0; i < n / 2; i++) {\\n                if(i % 2 == 0) {\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }\\n                else {\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            n /= 2;\\n        }\\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        while(n > 1) {            \\n            for(int i = 0; i < n / 2; i++) {\\n                if(i % 2 == 0) {\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }\\n                else {\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            n /= 2;\\n        }\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445061,
                "title": "c-two-solutions-easily-understandable",
                "content": "```\\nTime: O(Log n * n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n==1)\\n                return nums[0];\\n        bool flag=true;\\n        for(int i=0,j=0;i<n;i=i+2,j++){\\n            if(flag){\\n                nums[j]=min(nums[i],nums[i+1]);\\n            }else{\\n                nums[j]=max(nums[i],nums[i+1]);\\n            }\\n            //cout<<n<<\" \"<<flag<<\" \"<<nums[j]<<\"::\";\\n            flag=!flag;\\n            if(i+2==n){\\n                i=-2,j=-1;\\n                n= n>>1;\\n            }\\n            if(n==1)\\n                return nums[0];\\n        }\\n        return nums[0];\\n    }\\n};\\n\\nTime: O(2*n-1)  Space: O(n)  ---> 1+2+4+..+n=2*n-1\\n\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n==1)\\n                return nums[0];\\n       vector<int> num(n/2);\\n        for(int i=0;i<n/2;i++){\\n            if(i&1)\\n                num[i]=max(nums[2*i],nums[2*i+1]);\\n            else\\n                num[i]=min(nums[2*i],nums[2*i+1]);\\n        }\\n        return minMaxGame(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime: O(Log n * n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n==1)\\n                return nums[0];\\n        bool flag=true;\\n        for(int i=0,j=0;i<n;i=i+2,j++){\\n            if(flag){\\n                nums[j]=min(nums[i],nums[i+1]);\\n            }else{\\n                nums[j]=max(nums[i],nums[i+1]);\\n            }\\n            //cout<<n<<\" \"<<flag<<\" \"<<nums[j]<<\"::\";\\n            flag=!flag;\\n            if(i+2==n){\\n                i=-2,j=-1;\\n                n= n>>1;\\n            }\\n            if(n==1)\\n                return nums[0];\\n        }\\n        return nums[0];\\n    }\\n};\\n\\nTime: O(2*n-1)  Space: O(n)  ---> 1+2+4+..+n=2*n-1\\n\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=size(nums);\\n        if(n==1)\\n                return nums[0];\\n       vector<int> num(n/2);\\n        for(int i=0;i<n/2;i++){\\n            if(i&1)\\n                num[i]=max(nums[2*i],nums[2*i+1]);\\n            else\\n                num[i]=min(nums[2*i],nums[2*i+1]);\\n        }\\n        return minMaxGame(num);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2417196,
                "title": "swift-one-liner-also-two-easy-solutions-tail-recursion-no-recursion",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        nums.count == 1 ? nums[0] : minMaxGame((0 ..< nums.count/2).reduce(into: [Int]()) { let (a,b) = (nums[$1*2], nums[$1*2+1]); $0.append($1%2 == 0 ? min(a,b) : max(a,b)) })\\n    }\\n}\\n```\\n**NOTE:** Technically qualifies as one-liner since `return` was omitted.\\n\\n---\\n\\n**One-Liner, pretty-printed and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        nums.count == 1 ? nums[0] : minMaxGame( // tail-recursion with following array:\\n            (0 ..< nums.count/2).reduce(into: [Int]()) { result, iDiv2 in\\n                let (a,b) = (nums[iDiv2*2], nums[iDiv2*2 + 1])\\n                result.append(iDiv2%2 == 0 ? min(a,b) : max(a,b)) // iDiv2%2 will fully cycle every four elements of incoming array\\n            }\\n        )\\n    }\\n}\\n```\\n\\n---\\n\\n**Easy Solution using Tail Recursion (accepted answer)**\\n\\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        guard nums.count > 1 else { return nums[0] }\\n        var i = 0\\n        var isMin = true\\n        var result = [Int]()\\n        while i < nums.count {\\n            result.append(isMin ? min(nums[i], nums[i+1]) : max(nums[i], nums[i+1]))\\n            isMin.toggle()\\n            i += 2\\n        }\\n        return minMaxGame(result)\\n    }\\n}\\n```\\n\\n**Easy-Solution, No Recursion, Re-use `nums` (accepted answer)**\\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var size = nums.count/2\\n        \\n        while size > 0 {\\n            for i in 0 ..< size {\\n                nums[i] = i%2 == 0 ? min(nums[i*2], nums[i*2+1]) : max(nums[i*2], nums[i*2+1])\\n            }\\n            size /= 2\\n        }\\n\\n        return nums[0]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        nums.count == 1 ? nums[0] : minMaxGame((0 ..< nums.count/2).reduce(into: [Int]()) { let (a,b) = (nums[$1*2], nums[$1*2+1]); $0.append($1%2 == 0 ? min(a,b) : max(a,b)) })\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        nums.count == 1 ? nums[0] : minMaxGame( // tail-recursion with following array:\\n            (0 ..< nums.count/2).reduce(into: [Int]()) { result, iDiv2 in\\n                let (a,b) = (nums[iDiv2*2], nums[iDiv2*2 + 1])\\n                result.append(iDiv2%2 == 0 ? min(a,b) : max(a,b)) // iDiv2%2 will fully cycle every four elements of incoming array\\n            }\\n        )\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        guard nums.count > 1 else { return nums[0] }\\n        var i = 0\\n        var isMin = true\\n        var result = [Int]()\\n        while i < nums.count {\\n            result.append(isMin ? min(nums[i], nums[i+1]) : max(nums[i], nums[i+1]))\\n            isMin.toggle()\\n            i += 2\\n        }\\n        return minMaxGame(result)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minMaxGame(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var size = nums.count/2\\n        \\n        while size > 0 {\\n            for i in 0 ..< size {\\n                nums[i] = i%2 == 0 ? min(nums[i*2], nums[i*2+1]) : max(nums[i*2], nums[i*2+1])\\n            }\\n            size /= 2\\n        }\\n\\n        return nums[0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395640,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        f, p, l = [min, max], 0, len(nums)\\n        while l > 1:\\n            for i in range(0, l, 2):\\n                nums[i // 2] = f[p](nums[i:i + 2])\\n                p = 1 - p\\n            l = l // 2\\n        return nums[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        f, p, l = [min, max], 0, len(nums)\\n        while l > 1:\\n            for i in range(0, l, 2):\\n                nums[i // 2] = f[p](nums[i:i + 2])\\n                p = 1 - p\\n            l = l // 2\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203157,
                "title": "c-solution-min-max-game",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        while(nums.size() != 1){\\n            vector<int> v(nums.size()/2);\\n            for(int i = 0 ; i < v.size() ; i++){\\n                if(i % 2 == 0)\\n                    v[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                else\\n                    v[i] = max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            nums = v;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        while(nums.size() != 1){\\n            vector<int> v(nums.size()/2);\\n            for(int i = 0 ; i < v.size() ; i++){\\n                if(i % 2 == 0)\\n                    v[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                else\\n                    v[i] = max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            nums = v;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162010,
                "title": "89-faster-82-less-memory-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums, int left, int right, bool formax) {\\n        if(left == right) return nums[left];\\n        int mid = left + (right - left)/2;\\n        if(formax) return max(func(nums, left, mid, 0), func(nums, mid+1, right, 1));\\n        return min(func(nums, left, mid, 0), func(nums, mid+1, right, 1));\\n    }\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        int minval = 0, maxval = nums.size()-1, medval = minval + (maxval - minval)/2;\\n        return min(func(nums, minval, medval, 0), func(nums, medval+1, maxval, 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums, int left, int right, bool formax) {\\n        if(left == right) return nums[left];\\n        int mid = left + (right - left)/2;\\n        if(formax) return max(func(nums, left, mid, 0), func(nums, mid+1, right, 1));\\n        return min(func(nums, left, mid, 0), func(nums, mid+1, right, 1));\\n    }\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        int minval = 0, maxval = nums.size()-1, medval = minval + (maxval - minval)/2;\\n        return min(func(nums, minval, medval, 0), func(nums, medval+1, maxval, 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160259,
                "title": "python-solution-87-74-faster",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        \\n        newNums=[]*n\\n        while(n!=1):\\n            n=n//2\\n            newNums=[]*n\\n            for i in range(n):\\n                if i%2==0:\\n                    newNums.append(min(nums[2 * i], nums[2 * i + 1]))\\n                else:\\n                    newNums.append(max(nums[2 * i], nums[2 * i + 1]))\\n            nums=newNums\\n        return nums[0] \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        \\n        newNums=[]*n\\n        while(n!=1):\\n            n=n//2\\n            newNums=[]*n\\n            for i in range(n):\\n                if i%2==0:\\n                    newNums.append(min(nums[2 * i], nums[2 * i + 1]))\\n                else:\\n                    newNums.append(max(nums[2 * i], nums[2 * i + 1]))\\n            nums=newNums\\n        return nums[0] \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158555,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size() > 1){\\n            vector<int> temp;\\n            bool m = false;\\n            for(int i = 1; i < nums.size(); i += 2){\\n                int n;\\n                m ? n = max(nums[i], nums[i - 1]) : n = min(nums[i], nums[i - 1]);\\n                temp.push_back(n);\\n                m = !m;\\n            }\\n            nums = temp;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size() > 1){\\n            vector<int> temp;\\n            bool m = false;\\n            for(int i = 1; i < nums.size(); i += 2){\\n                int n;\\n                m ? n = max(nums[i], nums[i - 1]) : n = min(nums[i], nums[i - 1]);\\n                temp.push_back(n);\\n                m = !m;\\n            }\\n            nums = temp;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147011,
                "title": "simple-java-solution",
                "content": "\\tclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1)\\n            return nums[0];\\n        int[] numsArr = new int[n/2];\\n        for(int i = 0; i < n/2; i++){\\n            if(i % 2 == 0){\\n                numsArr[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            else{\\n                numsArr[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        \\n        return minMaxGame(numsArr);\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1)\\n            return nums[0];\\n        int[] numsArr = new int[n/2];\\n        for(int i = 0; i < n/2; i++){\\n            if(i % 2 == 0){\\n                numsArr[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2146532,
                "title": "java-using-queue",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i : nums){\\n            q.add(i);\\n        }\\n        while(q.size() != 1){\\n            int size = q.size();\\n            int count = 0;\\n            for(int i = 0;i<size/2;i++){\\n                if(count % 2 == 0){\\n                    int x = q.poll();\\n                    int y = q.poll();\\n                    q.add(Math.min(x, y));\\n                }\\n                else{\\n                    q.add(Math.max(q.poll(), q.poll()));\\n                }\\n                count++;\\n            }\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i : nums){\\n            q.add(i);\\n        }\\n        while(q.size() != 1){\\n            int size = q.size();\\n            int count = 0;\\n            for(int i = 0;i<size/2;i++){\\n                if(count % 2 == 0){\\n                    int x = q.poll();\\n                    int y = q.poll();\\n                    q.add(Math.min(x, y));\\n                }\\n                else{\\n                    q.add(Math.max(q.poll(), q.poll()));\\n                }\\n                count++;\\n            }\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141840,
                "title": "c-simulation-recursive-time-o-n-auxiliary-space-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        int j = 0;\\n        for (int i = 0; i < n; i += 2) {\\n            nums[j++] = j & 1\\n                ? max(nums[i], nums[i + 1])\\n                : min(nums[i], nums[i + 1]);\\n        }\\n        nums.resize(j);\\n        return minMaxGame(nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return nums[0];\\n        int j = 0;\\n        for (int i = 0; i < n; i += 2) {\\n            nums[j++] = j & 1\\n                ? max(nums[i], nums[i + 1])\\n                : min(nums[i], nums[i + 1]);\\n        }\\n        nums.resize(j);\\n        return minMaxGame(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133334,
                "title": "rust-brutal-force",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2293)\\n\\n<b>Problem List</b>\\n#Array - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/min-max-game/\\n/// Time Complexity:    O(lg(`_len_n`))\\n/// Space Complexity:   O(`_len_n`)\\nimpl Solution {\\n    pub fn min_max_game(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        while nums.len() > 1{\\n            let len_n: usize = nums.len();\\n            let mut res: Vec<i32> = vec![];\\n            for idx in 0..len_n / 2{\\n                if idx % 2 == 0{\\n                    res.push(std::cmp::min(nums[2 * idx], nums[2 * idx + 1]));\\n                }else{\\n                    res.push(std::cmp::max(nums[2 * idx], nums[2 * idx + 1]));\\n                }\\n            }\\n            nums = res;\\n        }\\n        nums[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/min-max-game/\\n/// Time Complexity:    O(lg(`_len_n`))\\n/// Space Complexity:   O(`_len_n`)\\nimpl Solution {\\n    pub fn min_max_game(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        while nums.len() > 1{\\n            let len_n: usize = nums.len();\\n            let mut res: Vec<i32> = vec![];\\n            for idx in 0..len_n / 2{\\n                if idx % 2 == 0{\\n                    res.push(std::cmp::min(nums[2 * idx], nums[2 * idx + 1]));\\n                }else{\\n                    res.push(std::cmp::max(nums[2 * idx], nums[2 * idx + 1]));\\n                }\\n            }\\n            nums = res;\\n        }\\n        nums[0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129789,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, x: List[int]) -> int:\\n        return x[0] if len(x)==1 else self.minMaxGame([max(x[i],x[i+1]) if (i+2)%4==0 else min(x[i],x[i+1]) for i in range(0,len(x),2)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, x: List[int]) -> int:\\n        return x[0] if len(x)==1 else self.minMaxGame([max(x[i],x[i+1]) if (i+2)%4==0 else min(x[i],x[i+1]) for i in range(0,len(x),2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126729,
                "title": "java-0-ms-100",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int[] a=new int[nums.length/2];\\n        int k=0;\\n        for(int i=0;i<nums.length/2;i++){\\n            if(k==0){\\n                a[i]=Math.min(nums[i*2],nums[i*2+1]);\\n                k=1;\\n            }\\n            else{\\n                a[i]=Math.max(nums[i*2],nums[i*2+1]);\\n                k=0;\\n            }\\n        }\\n        return minMaxGame(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int[] a=new int[nums.length/2];\\n        int k=0;\\n        for(int i=0;i<nums.length/2;i++){\\n            if(k==0){\\n                a[i]=Math.min(nums[i*2],nums[i*2+1]);\\n                k=1;\\n            }\\n            else{\\n                a[i]=Math.max(nums[i*2],nums[i*2+1]);\\n                k=0;\\n            }\\n        }\\n        return minMaxGame(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115978,
                "title": "c-easy-constant-space",
                "content": "**Please do upvote if you like the solution:)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n==1)\\n            return nums[0];\\n        \\n        int ans = -1;\\n        n = n/2;\\n        \\n        while(n>=1){\\n            for(int i=0; i<n; i++)\\n            {\\n                if(i%2==0)\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                else\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            \\n            if(n==1)\\n                return nums[0];\\n            n /= 2;\\n        } \\n            \\n         \\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n==1)\\n            return nums[0];\\n        \\n        int ans = -1;\\n        n = n/2;\\n        \\n        while(n>=1){\\n            for(int i=0; i<n; i++)\\n            {\\n                if(i%2==0)\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                else\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            \\n            if(n==1)\\n                return nums[0];\\n            n /= 2;\\n        } \\n            \\n         \\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115134,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\t\\t\\tif len(nums) == 1: return nums[0]\\n\\t\\t\\tnewNums = [0]*(len(nums)//2)\\n\\t\\t\\tfor i in range(len(nums)//2):\\n\\t\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\t\\tnewNums[i] = min( nums[2*i], nums[2*i + 1]  )\\n\\t\\t\\t\\telse: newNums[i] = max(nums[2*i], nums[2*i + 1] )\\n\\t\\t\\treturn self.minMaxGame(newNums)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\t\\t\\tif len(nums) == 1: return nums[0]\\n\\t\\t\\tnewNums = [0]*(len(nums)//2)\\n\\t\\t\\tfor i in range(len(nums)//2):\\n\\t\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\t\\tnewNums[i] = min( nums[2*i], nums[2*i + 1]  )\\n\\t\\t\\t\\telse: newNums[i] = max(nums[2*i], nums[2*i + 1] )\\n\\t\\t\\treturn self.minMaxGame(newNums)",
                "codeTag": "Java"
            },
            {
                "id": 2114492,
                "title": "c-c-time-complexity-o-n-space-complexity-o-1-solution",
                "content": "**If you like please upvote and any query you can ask in comment**\\n\\t\\n\\tint minMaxGame(int* nums, int numsSize) {\\n    \\n\\t\\tint left = 0,\\n\\t\\tright = numsSize - 1,\\n\\t\\tindex = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((index & 1) == 0) {\\n\\t\\t\\t\\t// even condition\\n\\t\\t\\t\\tnums[index] = nums[index << 1] < nums[(index << 1) + 1] ? nums[index << 1] : nums[(index << 1) + 1];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// odd condition\\n\\t\\t\\t\\tnums[index] = nums[index << 1] > nums[(index << 1) + 1] ? nums[index << 1] : nums[(index << 1) + 1];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (index == right >> 1) {\\n\\t\\t\\t\\tindex = 0;\\n\\t\\t\\t\\tright >>= 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**If you like please upvote and any query you can ask in comment**\\n\\t\\n\\tint minMaxGame(int* nums, int numsSize) {\\n    \\n\\t\\tint left = 0,\\n\\t\\tright = numsSize - 1,\\n\\t\\tindex = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((index & 1) == 0) {\\n\\t\\t\\t\\t// even condition\\n\\t\\t\\t\\tnums[index] = nums[index << 1] < nums[(index << 1) + 1] ? nums[index << 1] : nums[(index << 1) + 1];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// odd condition\\n\\t\\t\\t\\tnums[index] = nums[index << 1] > nums[(index << 1) + 1] ? nums[index << 1] : nums[(index << 1) + 1];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (index == right >> 1) {\\n\\t\\t\\t\\tindex = 0;\\n\\t\\t\\t\\tright >>= 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2114491,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar minMaxGame = function (nums) {\\n    if(nums.length === 1) return nums[0]\\n\\t\\n    let result = [...nums];\\n\\n    while (result.length !== 2) {\\n        let tempResult = []\\n        for (let i = 0; i < result.length; i += 4) {\\n            tempResult.push(Math.min(result[i], result[i + 1]))\\n            tempResult.push(Math.max(result[i + 2], result[i + 3]))\\n        }\\n        result = tempResult\\n    }\\n\\n    return Math.min(result[0],result[1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMaxGame = function (nums) {\\n    if(nums.length === 1) return nums[0]\\n\\t\\n    let result = [...nums];\\n\\n    while (result.length !== 2) {\\n        let tempResult = []\\n        for (let i = 0; i < result.length; i += 4) {\\n            tempResult.push(Math.min(result[i], result[i + 1]))\\n            tempResult.push(Math.max(result[i + 2], result[i + 3]))\\n        }\\n        result = tempResult\\n    }\\n\\n    return Math.min(result[0],result[1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114305,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n!=1){\\n            int[] temp = new int[n/2];\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                temp[i]= Math.min(nums[2*i],nums[2*i+1]);\\n            }else{\\n                temp[i]= Math.max(nums[2*i],nums[2*i+1]); \\n            }\\n        }\\n            n/=2;\\n            nums = temp;\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n!=1){\\n            int[] temp = new int[n/2];\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                temp[i]= Math.min(nums[2*i],nums[2*i+1]);\\n            }else{\\n                temp[i]= Math.max(nums[2*i],nums[2*i+1]); \\n            }\\n        }\\n            n/=2;\\n            nums = temp;\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114211,
                "title": "4-liner-o-1-space",
                "content": "```\\nint minMaxGame(vector<int>& nums) {\\n        \\n        int k=nums.size();\\n       do\\n        {\\n            for(int i=0;i<k/2;i++)\\n            nums[i]=i&1?nums[2*i]<nums[2*i+1]?nums[2*i+1]:nums[2*i]:nums[2*i]<nums[2*i+1]?nums[2*i]:nums[2*i+1];\\n        } while(k/=2);\\n        \\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMaxGame(vector<int>& nums) {\\n        \\n        int k=nums.size();\\n       do\\n        {\\n            for(int i=0;i<k/2;i++)\\n            nums[i]=i&1?nums[2*i]<nums[2*i+1]?nums[2*i+1]:nums[2*i]:nums[2*i]<nums[2*i+1]?nums[2*i]:nums[2*i+1];\\n        } while(k/=2);\\n        \\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113487,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinMaxGame(int[] nums) {\\n        \\n        if(nums.Length == 1)\\n        {\\n            return nums[0];\\n        }\\n        List<int>numsL = nums.ToList();\\n        \\n        while(numsL.Count!=2)\\n        {\\n            List<int>newL = new List<int>();\\n            bool min = true;\\n            for(int i = 0;i<numsL.Count;)\\n            {\\n                if(min)\\n                {\\n                    newL.Add(Math.Min(numsL[i],numsL[i+1]));\\n                }\\n                else\\n                {\\n                    newL.Add(Math.Max(numsL[i],numsL[i+1]));\\n                }\\n                min = !min;\\n                i+=2;\\n            }\\n            numsL = newL;\\n        }\\n        \\n        \\n        return Math.Min(numsL[0],numsL[1]);\\n    }\\n}\\n```\\n\\nSee more LeetCode solution, you can visit my blog : [https://zyrastory.com/en/about-me-en/](https://zyrastory.com/en/about-me-en/)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinMaxGame(int[] nums) {\\n        \\n        if(nums.Length == 1)\\n        {\\n            return nums[0];\\n        }\\n        List<int>numsL = nums.ToList();\\n        \\n        while(numsL.Count!=2)\\n        {\\n            List<int>newL = new List<int>();\\n            bool min = true;\\n            for(int i = 0;i<numsL.Count;)\\n            {\\n                if(min)\\n                {\\n                    newL.Add(Math.Min(numsL[i],numsL[i+1]));\\n                }\\n                else\\n                {\\n                    newL.Add(Math.Max(numsL[i],numsL[i+1]));\\n                }\\n                min = !min;\\n                i+=2;\\n            }\\n            numsL = newL;\\n        }\\n        \\n        \\n        return Math.Min(numsL[0],numsL[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113434,
                "title": "simple-loop-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        vector<int>ans=nums;\\n        while(ans.size()!=1){\\n            vector<int>v1;\\n            int i=1,f=1;\\n            while(i<ans.size()){\\n                if(f==1){\\n                    v1.push_back(min(ans[i-1],ans[i]));\\n                    f=0;\\n                }else{\\n                    v1.push_back(max(ans[i-1],ans[i]));\\n                    f=1;\\n                }\\n                i+=2;\\n            }\\n            ans=v1;\\n        }\\n         return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        vector<int>ans=nums;\\n        while(ans.size()!=1){\\n            vector<int>v1;\\n            int i=1,f=1;\\n            while(i<ans.size()){\\n                if(f==1){\\n                    v1.push_back(min(ans[i-1],ans[i]));\\n                    f=0;\\n                }else{\\n                    v1.push_back(max(ans[i-1],ans[i]));\\n                    f=1;\\n                }\\n                i+=2;\\n            }\\n            ans=v1;\\n        }\\n         return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113247,
                "title": "easy-java-soln-constant-space",
                "content": "```\\n    public int minMaxGame(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        while(n/2 > 0)\\n        {\\n            n= n/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)  nums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n                else nums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n       return  nums[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minMaxGame(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        while(n/2 > 0)\\n        {\\n            n= n/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)  nums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n                else nums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n       return  nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113013,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size()!=1){\\n        vector<int> res;\\n           bool flag = true;\\n            for(int i=0;i<nums.size();i+=2){\\n                if(flag == true){\\n                    res.push_back(min(nums[i],nums[i+1]));\\n                    flag = false;\\n                }\\n                else{\\n                    res.push_back(max(nums[i],nums[i+1]));\\n                    flag = true;\\n                }\\n            }\\n            nums.clear();\\n            nums = res;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size()!=1){\\n        vector<int> res;\\n           bool flag = true;\\n            for(int i=0;i<nums.size();i+=2){\\n                if(flag == true){\\n                    res.push_back(min(nums[i],nums[i+1]));\\n                    flag = false;\\n                }\\n                else{\\n                    res.push_back(max(nums[i],nums[i+1]));\\n                    flag = true;\\n                }\\n            }\\n            nums.clear();\\n            nums = res;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112918,
                "title": "python-recursion-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,nums):\\n        n = len(nums)\\n        \\n        if(n == 1): return nums[0]\\n        \\n        newNums = [0 for i in range(n//2)]\\n        \\n        for i in range(n//2):\\n            if(i%2==0):\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            else:\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n        return self.helper(newNums)\\n        \\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return self.helper(nums)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,nums):\\n        n = len(nums)\\n        \\n        if(n == 1): return nums[0]\\n        \\n        newNums = [0 for i in range(n//2)]\\n        \\n        for i in range(n//2):\\n            if(i%2==0):\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            else:\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n        return self.helper(newNums)\\n        \\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        return self.helper(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112907,
                "title": "easy-c-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size()!=1){\\n            vector<int>temp(nums.size()/2);\\n            for(int i=0;i<nums.size()/2;i++){\\n                if(i&1){\\n                    temp[i]=max(nums[2*i],nums[2*i + 1]);\\n                }\\n                else{\\n                    temp[i]=min(nums[2*i],nums[2*i + 1]);\\n                }\\n            }\\n            nums.clear();\\n            for(auto it:temp){\\n                nums.push_back(it);\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        while(nums.size()!=1){\\n            vector<int>temp(nums.size()/2);\\n            for(int i=0;i<nums.size()/2;i++){\\n                if(i&1){\\n                    temp[i]=max(nums[2*i],nums[2*i + 1]);\\n                }\\n                else{\\n                    temp[i]=min(nums[2*i],nums[2*i + 1]);\\n                }\\n            }\\n            nums.clear();\\n            for(auto it:temp){\\n                nums.push_back(it);\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112643,
                "title": "faster-easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        \\n        while(nums.size() > 1)\\n        {\\n            int n = nums.size();\\n            \\n            vector<int> new_nums(n / 2);\\n            \\n            for(int i = 0; i < n / 2; i++)\\n            {\\n                if(i % 2 == 0)\\n                {\\n                    new_nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }\\n                else\\n                {\\n                     new_nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            \\n            nums = new_nums;\\n        }\\n        \\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        \\n        while(nums.size() > 1)\\n        {\\n            int n = nums.size();\\n            \\n            vector<int> new_nums(n / 2);\\n            \\n            for(int i = 0; i < n / 2; i++)\\n            {\\n                if(i % 2 == 0)\\n                {\\n                    new_nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }\\n                else\\n                {\\n                     new_nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n            \\n            nums = new_nums;\\n        }\\n        \\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112636,
                "title": "self-explanatory-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int f=0;\\n        if(nums.size()==1) return nums[0];\\n        while(nums.size()>1)\\n        {\\n            vector<int>temp;\\n            int n=nums.size();\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(f==0)\\n                {\\n                    temp.push_back(min(nums[i],nums[i+1]));\\n                    i++;\\n                    f=1;\\n                }\\n                else\\n                {\\n                    temp.push_back(max(nums[i],nums[i+1]));\\n                    i++;\\n                    f=0;\\n                }\\n            }\\n            nums=temp;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int f=0;\\n        if(nums.size()==1) return nums[0];\\n        while(nums.size()>1)\\n        {\\n            vector<int>temp;\\n            int n=nums.size();\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(f==0)\\n                {\\n                    temp.push_back(min(nums[i],nums[i+1]));\\n                    i++;\\n                    f=1;\\n                }\\n                else\\n                {\\n                    temp.push_back(max(nums[i],nums[i+1]));\\n                    i++;\\n                    f=0;\\n                }\\n            }\\n            nums=temp;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112595,
                "title": "python-simple-python-solution",
                "content": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tif len(nums) ==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\n\\t\\t\\twhile len(nums)>1:\\n\\n\\t\\t\\t\\tlength =len(nums)//2\\n\\n\\t\\t\\t\\ttemp_array = []\\n\\n\\t\\t\\t\\tfor i in range(length):\\n\\n\\t\\t\\t\\t\\tif i%2==0:\\n\\t\\t\\t\\t\\t\\ttemp_array.append(min(nums[2 * i], nums[2 * i + 1]))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttemp_array.append(max(nums[2 * i], nums[2 * i + 1]))\\n\\n\\t\\t\\t\\tnums = temp_array\\n\\n\\t\\t\\treturn nums[0]\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef minMaxGame(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tif len(nums) ==1:\\n\\t\\t\\t\\treturn nums[0]\\n\\n\\t\\t\\twhile len(nums)>1:\\n\\n\\t\\t\\t\\tlength =len(nums)//2\\n\\n\\t\\t\\t\\ttemp_array = []\\n\\n\\t\\t\\t\\tfor i in range(length):\\n\\n\\t\\t\\t\\t\\tif i%2==0:\\n\\t\\t\\t\\t\\t\\ttemp_array.append(min(nums[2 * i], nums[2 * i + 1]))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttemp_array.append(max(nums[2 * i], nums[2 * i + 1]))\\n\\n\\t\\t\\t\\tnums = temp_array\\n\\n\\t\\t\\treturn nums[0]\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2112493,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums) > 1:\\n            ans = []\\n            for i in range(0, len(nums), 2):\\n                if (i // 2) % 2 == 0:\\n                    ans.append(min(nums[i], nums[i+1]))\\n                else:\\n                    ans.append(max(nums[i], nums[i+1]))\\n            nums = ans\\n        return nums[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums) > 1:\\n            ans = []\\n            for i in range(0, len(nums), 2):\\n                if (i // 2) % 2 == 0:\\n                    ans.append(min(nums[i], nums[i+1]))\\n                else:\\n                    ans.append(max(nums[i], nums[i+1]))\\n            nums = ans\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112432,
                "title": "java-constant-space-o-log-n",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n     \\n        int n = nums.length;\\n        \\n        while(n>1){\\n           int k = 0;\\n           for(int i = 0; i < n/2; i++){\\n               \\n               if(i % 2 == 0){\\n                   nums[i] = Math.min(nums[k], nums[k+1]);\\n                   k = k + 2;\\n               }else{\\n                   nums[i] = Math.max(nums[k], nums[k+1]);\\n                   k = k + 2;\\n               }\\n           }\\n           \\n           n = n / 2; \\n        }\\n        \\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n     \\n        int n = nums.length;\\n        \\n        while(n>1){\\n           int k = 0;\\n           for(int i = 0; i < n/2; i++){\\n               \\n               if(i % 2 == 0){\\n                   nums[i] = Math.min(nums[k], nums[k+1]);\\n                   k = k + 2;\\n               }else{\\n                   nums[i] = Math.max(nums[k], nums[k+1]);\\n                   k = k + 2;\\n               }\\n           }\\n           \\n           n = n / 2; \\n        }\\n        \\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112360,
                "title": "constant-space-array-simulation-o-logn",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        i=len(nums)\\n        while(i>=1):\\n            \\n            for j in range(i//2):\\n                if(j%2):\\n                    nums[j]=max(nums[2*j], nums[2*j+1])\\n                else:\\n                    nums[j]=min(nums[2*j], nums[2*j+1])\\n            i=i//2\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        i=len(nums)\\n        while(i>=1):\\n            \\n            for j in range(i//2):\\n                if(j%2):\\n                    nums[j]=max(nums[2*j], nums[2*j+1])\\n                else:\\n                    nums[j]=min(nums[2*j], nums[2*j+1])\\n            i=i//2\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112265,
                "title": "c-o-1-space-easy-to-understand",
                "content": "```\\nint minMaxGame(vector<int>& nums) {\\n        int N = nums.size();\\n        while (N!=1) {\\n            N/=2;\\n            for (int i = 0; i < N; ++i)\\n                nums[i] = (i%2 == 0) ? min(nums[2*i], nums[2*i+1]) : max(nums[2*i], nums[2*i+1]);\\n        }\\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMaxGame(vector<int>& nums) {\\n        int N = nums.size();\\n        while (N!=1) {\\n            N/=2;\\n            for (int i = 0; i < N; ++i)\\n                nums[i] = (i%2 == 0) ? min(nums[2*i], nums[2*i+1]) : max(nums[2*i], nums[2*i+1]);\\n        }\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112203,
                "title": "easy-c-code",
                "content": "Simple approach whatever is given in question follow that only\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return nums[0];\\n        }\\n        int x = nums.size();\\n        while(x!=1){\\n            x = x/2;\\n            for(int i = 0 ;i<x;i++){\\n                if(i%2==0){\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return nums[0];\\n        }\\n        int x = nums.size();\\n        while(x!=1){\\n            x = x/2;\\n            for(int i = 0 ;i<x;i++){\\n                if(i%2==0){\\n                    nums[i] = min(nums[2 * i], nums[2 * i + 1]);\\n                }else{\\n                    nums[i] = max(nums[2 * i], nums[2 * i + 1]);\\n                }\\n            }\\n\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112171,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def div_two(nums):\\n            newNums = []\\n            n = len(nums)\\n            a = 0\\n            while n > 2 * a:\\n                while a < n / 2:\\n                    if a % 2 == 0:\\n                        newNums.append(min(nums[2 * a], nums[2 * a + 1]))\\n                        a += 1\\n                    else:\\n                        newNums.append(max(nums[2 * a], nums[2 * a + 1]))\\n                        a += 1\\n            return newNums\\n\\n        n = len(nums)\\n        while n > 1:\\n            nums = div_two(nums)\\n            n = len(nums)\\n            \\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def div_two(nums):\\n            newNums = []\\n            n = len(nums)\\n            a = 0\\n            while n > 2 * a:\\n                while a < n / 2:\\n                    if a % 2 == 0:\\n                        newNums.append(min(nums[2 * a], nums[2 * a + 1]))\\n                        a += 1\\n                    else:\\n                        newNums.append(max(nums[2 * a], nums[2 * a + 1]))\\n                        a += 1\\n            return newNums\\n\\n        n = len(nums)\\n        while n > 1:\\n            nums = div_two(nums)\\n            n = len(nums)\\n            \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112163,
                "title": "easy-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        \\n        int[] res = makeArray(nums);\\n        \\n        return res[0];\\n    }\\n    \\n    public int[] makeArray(int[] nums)\\n    {\\n        int j = 0;\\n        int[] arr = new int[nums.length/2];\\n        \\n        if(nums.length == 1)\\n        {\\n            return nums;\\n        }\\n        else\\n        {\\n            for(int i=0;i<nums.length/2;i++)\\n            {\\n                if(i%2 == 0)\\n                {\\n                    arr[j] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n                    j++;\\n                }\\n                else\\n                {\\n                    arr[j] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n                    j++;\\n                }\\n            }\\n        \\n            return makeArray(arr);\\n        } \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int minMaxGame(int[] nums) {\\n        \\n        int[] res = makeArray(nums);\\n        \\n        return res[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2112038,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length==1) return nums[0];\\n        int[] newNums = new int[nums.length/2];\\n        for (int i=0;i<newNums.length;++i){\\n            if ((i&1) ==0){\\n                 newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            else{\\n                 newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n           \\n        }\\n        return minMaxGame(newNums);\\n        \\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length==1) return nums[0];\\n        int[] newNums = new int[nums.length/2];\\n        for (int i=0;i<newNums.length;++i){\\n            if ((i&1) ==0){\\n                 newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            else{\\n                 newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n           \\n        }\\n        return minMaxGame(newNums);\\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112004,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int>ans(n/2);\\n        for(int i=0;i<n/2;++i){\\n            if(i&1){\\n                ans[i]=max(nums[2 * i], nums[2 * i + 1]);\\n            }else{\\n                 ans[i]=min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        int res= minMaxGame(ans) ;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n==1) return nums[0];\\n        vector<int>ans(n/2);\\n        for(int i=0;i<n/2;++i){\\n            if(i&1){\\n                ans[i]=max(nums[2 * i], nums[2 * i + 1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2111982,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def helper(self, nums, n):\\n        if n == 1:\\n            return nums\\n        newNums = [0] * (n // 2)\\n        \\n        for i in range(n // 2):\\n            if i % 2 == 0:\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            else:\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n        nums[:] = newNums[:]\\n        self.helper(nums, len(nums))\\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.helper(nums, n)\\n        return nums[0]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, nums, n):\\n        if n == 1:\\n            return nums\\n        newNums = [0] * (n // 2)\\n        \\n        for i in range(n // 2):\\n            if i % 2 == 0:\\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n            else:\\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n        nums[:] = newNums[:]\\n        self.helper(nums, len(nums))\\n        \\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.helper(nums, n)\\n        return nums[0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2111944,
                "title": "easy-recursion-c-easy-to-understand",
                "content": "\\nOkay, I did this question with simple recursion.\\nHere, I have made a helper function in which I pass everytime if we have to find the min or we have to find the max of the current series.\\n\\n```\\nclass Solution {\\nprivate:\\n    int helper(vector<int>& nums,int start, int end, bool findMin) {\\n        if(start == end)\\n            return nums[start];\\n        \\n        // we will get the middle element \\n        int mid = start + (end-start)/2;\\n        \\n        //Find the minimum of the left part and right part of the array if we have to find min\\n        if(findMin){\\n\\t\\t\\t// Here finding min of left half and max of right half \\n            return min(helper(nums,start,mid,true) , helper(nums,mid+1,end,false));\\n        }\\n        else{\\n            return max(helper(nums,start,mid,true) , helper(nums,mid+1,end,false));\\n        }\\n        return 0;\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //passing true because we have to find the minimum of the complete array firstly\\n        return helper(nums,0,n-1,true);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(vector<int>& nums,int start, int end, bool findMin) {\\n        if(start == end)\\n            return nums[start];\\n        \\n        // we will get the middle element \\n        int mid = start + (end-start)/2;\\n        \\n        //Find the minimum of the left part and right part of the array if we have to find min\\n        if(findMin){\\n\\t\\t\\t// Here finding min of left half and max of right half \\n            return min(helper(nums,start,mid,true) , helper(nums,mid+1,end,false));\\n        }\\n        else{\\n            return max(helper(nums,start,mid,true) , helper(nums,mid+1,end,false));\\n        }\\n        return 0;\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //passing true because we have to find the minimum of the complete array firstly\\n        return helper(nums,0,n-1,true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111891,
                "title": "java-simple-queue-solution",
                "content": "Simply add all the numbers into a queue, dequeue the first two numbers, take either the maximum or minimum depending on the current operation, flip the current operation, and add the appropriate number back to the queue. Repeat this until we are down to 1 number.\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        Queue<Integer> queue = new LinkedList();\\n        for(int i = 0; i < nums.length; i++){\\n            queue.add(nums[i]);\\n        }\\n        \\n        boolean min = true;\\n        while(queue.size() != 1){\\n            int i = queue.poll();\\n            int j = queue.poll();\\n            if(min){\\n                queue.add(Math.min(i, j));\\n            }else{\\n                queue.add(Math.max(i, j));\\n            }\\n            min = !min;\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        Queue<Integer> queue = new LinkedList();\\n        for(int i = 0; i < nums.length; i++){\\n            queue.add(nums[i]);\\n        }\\n        \\n        boolean min = true;\\n        while(queue.size() != 1){\\n            int i = queue.poll();\\n            int j = queue.poll();\\n            if(min){\\n                queue.add(Math.min(i, j));\\n            }else{\\n                queue.add(Math.max(i, j));\\n            }\\n            min = !min;\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092278,
                "title": "easy-and-understand-solution-using-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n\\n    if(nums.length==1)\\n     return nums[0];\\n    int[] arr = new int[nums.length/2];\\n    for(int i = 0;i<nums.length/2;i++){\\n        if(i%2==0){\\n            arr[i]= Math.min(nums[2 * i], nums[2 * i + 1]);\\n           \\n        }\\n        else\\n            arr[i]= Math.max(nums[2 * i], nums[2 * i + 1]);\\n           \\n\\n    }\\n    return minMaxGame(arr);\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n\\n    if(nums.length==1)\\n     return nums[0];\\n    int[] arr = new int[nums.length/2];\\n    for(int i = 0;i<nums.length/2;i++){\\n        if(i%2==0){\\n            arr[i]= Math.min(nums[2 * i], nums[2 * i + 1]);\\n           \\n        }\\n        else\\n            arr[i]= Math.max(nums[2 * i], nums[2 * i + 1]);\\n           \\n\\n    }\\n    return minMaxGame(arr);\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091757,
                "title": "c-easy-and-readable-solution-less-than-61",
                "content": "![image.png](https://assets.leetcode.com/users/images/3954e48c-6444-4759-9bff-dd706237160e_1695713494.4768639.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int MinMaxGame(int[] nums) {\\n        if (nums.Length == 1)\\n            return nums[0];\\n        int[] res = new int[nums.Length / 2];\\n        for (int i = 0; i < res.Length; i++)\\n            if (i % 2 == 0)\\n                res[i] = Math.Min(nums[i * 2], nums[(i * 2) + 1]);\\n            else\\n                res[i] = Math.Max(nums[i * 2], nums[(i * 2) + 1]);\\n        return MinMaxGame(res);\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMaxGame(int[] nums) {\\n        if (nums.Length == 1)\\n            return nums[0];\\n        int[] res = new int[nums.Length / 2];\\n        for (int i = 0; i < res.Length; i++)\\n            if (i % 2 == 0)\\n                res[i] = Math.Min(nums[i * 2], nums[(i * 2) + 1]);\\n            else\\n                res[i] = Math.Max(nums[i * 2], nums[(i * 2) + 1]);\\n        return MinMaxGame(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091486,
                "title": "minmaxgame-using-recursion-0ms-and-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nLog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] al) {//recursion\\n        int n=al.length;\\n        if(n==1)return al[0];//base condition\\n        int nn[] = new int [n/2];\\n        boolean state=false;\\n        int k=0;\\n        for(int i=1;i<al.length;i+=2){\\n            state=!state;\\n            if(state)nn[k++]=Math.min(al[i],al[i-1]);\\n            else nn[k++]=Math.max(al[i],al[i-1]);\\n        }\\n        return minMaxGame(nn);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] al) {//recursion\\n        int n=al.length;\\n        if(n==1)return al[0];//base condition\\n        int nn[] = new int [n/2];\\n        boolean state=false;\\n        int k=0;\\n        for(int i=1;i<al.length;i+=2){\\n            state=!state;\\n            if(state)nn[k++]=Math.min(al[i],al[i-1]);\\n            else nn[k++]=Math.max(al[i],al[i-1]);\\n        }\\n        return minMaxGame(nn);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085585,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n         if (nums.length == 1)\\n        return nums[0];\\n\\n        int[] nextNums = new int[nums.length / 2];\\n        for (int i = 0; i < nextNums.length; ++i)\\n        nextNums[i] = (i & 1) == 1 ? Math.max(nums[2 * i], nums[2 * i + 1])\\n                                    : Math.min(nums[2 * i], nums[2 * i + 1]);\\n        return minMaxGame(nextNums);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n         if (nums.length == 1)\\n        return nums[0];\\n\\n        int[] nextNums = new int[nums.length / 2];\\n        for (int i = 0; i < nextNums.length; ++i)\\n        nextNums[i] = (i & 1) == 1 ? Math.max(nums[2 * i], nums[2 * i + 1])\\n                                    : Math.min(nums[2 * i], nums[2 * i + 1]);\\n        return minMaxGame(nextNums);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074039,
                "title": "easiest-solution-and-shortest-of-all-other-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are going to shorten th array every time \\nin every even count it takes minimum of two but in odd count it takes maximum\\n\\nSo,whenever the array size becomes 1 element then loops end and return the first only element\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        vector<int>t=nums;\\n        \\n        while(t.size()!=1)\\n        {\\n            vector<int>temp;\\n            int c=0;\\n            for(int i=0;i<t.size()-1;i+=2)\\n            {\\n                if(c%2==0) temp.push_back( min(t[i],t[i+1]) );\\n                else temp.push_back( max(t[i],t[i+1]) );\\n                c++;\\n            }\\n            t=temp;\\n        }\\n        return t[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) \\n    {\\n        vector<int>t=nums;\\n        \\n        while(t.size()!=1)\\n        {\\n            vector<int>temp;\\n            int c=0;\\n            for(int i=0;i<t.size()-1;i+=2)\\n            {\\n                if(c%2==0) temp.push_back( min(t[i],t[i+1]) );\\n                else temp.push_back( max(t[i],t[i+1]) );\\n                c++;\\n            }\\n            t=temp;\\n        }\\n        return t[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073257,
                "title": "easy-cpp-solution-brute-force-approach-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int gameUtil(vector<int>& nums, bool type, int i, int j){\\n        if(type && j-i+1 == 2) return min(nums[i], nums[j]);\\n        if(!type && j-i+1 == 2) return max(nums[i], nums[j]);\\n        int mid = i + (j-i)/2;\\n        int a = gameUtil(nums, true, i, mid);\\n        int b = gameUtil(nums, false, mid+1, j);\\n        if(type) return min(a, b);\\n        return max(a, b);\\n    }\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        return gameUtil(nums, true, 0, nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gameUtil(vector<int>& nums, bool type, int i, int j){\\n        if(type && j-i+1 == 2) return min(nums[i], nums[j]);\\n        if(!type && j-i+1 == 2) return max(nums[i], nums[j]);\\n        int mid = i + (j-i)/2;\\n        int a = gameUtil(nums, true, i, mid);\\n        int b = gameUtil(nums, false, mid+1, j);\\n        if(type) return min(a, b);\\n        return max(a, b);\\n    }\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        return gameUtil(nums, true, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072422,
                "title": "python-without-recursion",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        while n > 1:            \\n            nums = [(max, min)[i % 4 == 0](nums[i], nums[i+1]) for i in range(0, n, 2)]\\n            n = len(nums)\\n        return nums[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        while n > 1:            \\n            nums = [(max, min)[i % 4 == 0](nums[i], nums[i+1]) for i in range(0, n, 2)]\\n            n = len(nums)\\n        return nums[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071743,
                "title": "0ms-java-solution-resursive",
                "content": "1. if nums length == 1 return nums[0]\\n2. else run minmax game\\n3. end of minmax game, rerun new minmax game with new int[]\\n```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        boolean odd = true;\\n        int[] temp = new int[nums.length / 2];\\n        for(int i = 0 ; i < nums.length ; i+=2) {                                \\n            temp[i/2] = odd ? Math.min(nums[i], nums[i+1]) : Math.max(nums[i], nums[i+1]);                \\n            odd = true ^ odd;\\n        }\\n        return minMaxGame(temp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1) {\\n            return nums[0];\\n        }\\n        \\n        boolean odd = true;\\n        int[] temp = new int[nums.length / 2];\\n        for(int i = 0 ; i < nums.length ; i+=2) {                                \\n            temp[i/2] = odd ? Math.min(nums[i], nums[i+1]) : Math.max(nums[i], nums[i+1]);                \\n            odd = true ^ odd;\\n        }\\n        return minMaxGame(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065424,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums, int size){\\n        if(size==1 ) return nums[0];\\n        int index=0;\\n        bool min = true;\\n        for(int i=0; i<size;i+=2){\\n            if(min){\\n                if(nums[i]<nums[i+1]){\\n                    nums[index++]= nums[i];\\n                    min = false;\\n                }\\n                else{\\n                    nums[index++] = nums[i+1];\\n                    min = false;\\n                }\\n            }\\n            else{\\n                if(nums[i]<nums[i+1]){\\n                    nums[index++] = nums[i+1];\\n                    min = true;\\n                }\\n                else{\\n                    nums[index++] = nums[i];\\n                    min = true;\\n                }\\n            }\\n        }\\n        return solve(nums,size/2);\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int size = nums.size();\\n        int ans = solve(nums,size);\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int>& nums, int size){\\n        if(size==1 ) return nums[0];\\n        int index=0;\\n        bool min = true;\\n        for(int i=0; i<size;i+=2){\\n            if(min){\\n                if(nums[i]<nums[i+1]){\\n                    nums[index++]= nums[i];\\n                    min = false;\\n                }\\n                else{\\n                    nums[index++] = nums[i+1];\\n                    min = false;\\n                }\\n            }\\n            else{\\n                if(nums[i]<nums[i+1]){\\n                    nums[index++] = nums[i+1];\\n                    min = true;\\n                }\\n                else{\\n                    nums[index++] = nums[i];\\n                    min = true;\\n                }\\n            }\\n        }\\n        return solve(nums,size/2);\\n    }\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int size = nums.size();\\n        int ans = solve(nums,size);\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059767,
                "title": "easy-solution-for-beginer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n       int n = nums.length;\\n        if(n==1)\\n        return nums[0];\\n        int a [] = new int[n/2];\\n        int count =0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(count%2==0)\\n            {\\n                a[count] = Math.min(nums[i],nums[i+1]);             \\n            }\\n            else\\n            {\\n                a[count]= Math.max(nums[i],nums[i+1]);\\n            }\\n            count++;\\n        }\\n        return  minMaxGame(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n       int n = nums.length;\\n        if(n==1)\\n        return nums[0];\\n        int a [] = new int[n/2];\\n        int count =0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(count%2==0)\\n            {\\n                a[count] = Math.min(nums[i],nums[i+1]);             \\n            }\\n            else\\n            {\\n                a[count]= Math.max(nums[i],nums[i+1]);\\n            }\\n            count++;\\n        }\\n        return  minMaxGame(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055276,
                "title": "beats-100-runtime-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int arr[] = new int[nums.length/2];\\n        boolean flag = false;\\n        int ind = 0;\\n        for(int i=0; (i+1)<nums.length; i+=2){\\n            if(!flag){\\n                arr[ind++] = Math.min(nums[i], nums[i+1]);\\n                flag = true;\\n            }\\n            else{\\n                arr[ind++] = Math.max(nums[i], nums[i+1]);\\n                flag = false;\\n            }\\n        }\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length == 1)\\n            return nums[0];\\n        int arr[] = new int[nums.length/2];\\n        boolean flag = false;\\n        int ind = 0;\\n        for(int i=0; (i+1)<nums.length; i+=2){\\n            if(!flag){\\n                arr[ind++] = Math.min(nums[i], nums[i+1]);\\n                flag = true;\\n            }\\n            else{\\n                arr[ind++] = Math.max(nums[i], nums[i+1]);\\n                flag = false;\\n            }\\n        }\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046156,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums)!=1:\\n            k,li=0,[]\\n            for i in range(0,len(nums),2):\\n                if k&1: li.append(max(nums[i],nums[i+1]))\\n                else: li.append(min(nums[i],nums[i+1]))\\n                k+=1\\n            nums=li\\n        return nums[0]\\n```\\n***Hope it helps...!!*** \\uD83D\\uDE07\\u270C\\uFE0F",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums)!=1:\\n            k,li=0,[]\\n            for i in range(0,len(nums),2):\\n                if k&1: li.append(max(nums[i],nums[i+1]))\\n                else: li.append(min(nums[i],nums[i+1]))\\n                k+=1\\n            nums=li\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045755,
                "title": "min-max-game",
                "content": "# Intuition\\nAfter every iteration array is getting half\\nIterate the array in set of 2 nos,\\nwe have to take min of the 2 nos, if the (first ind)%4==0\\nmax of the 2 nos, if (first ind)%4==2\\nthese nos will form new array\\n\\n# Approach\\nIterate throgh set the array in set of 2 nos, get the min and max\\nthen based i%4, \\n\\nTo make it O(1) Space complexity, start adding these nos in current array itself at ind i/2, for nos at ind i and i+1\\n \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false) ;\\n        cin.tie(nullptr) ;\\n        cout.tie(nullptr) ;\\n\\n        int n= nums.size() ;\\n\\n        while(n>1)\\n        {\\n            for(int i=0; i+1<n; i+=2)\\n            {\\n                if(i%4==0)\\n                    nums[i/2]=min(nums[i], nums[i+1]) ;\\n\\n                else\\n                    nums[i/2]=max(nums[i], nums[i+1]) ;\\n            }\\n\\n            n/=2 ;\\n        }\\n\\n        return nums[0] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false) ;\\n        cin.tie(nullptr) ;\\n        cout.tie(nullptr) ;\\n\\n        int n= nums.size() ;\\n\\n        while(n>1)\\n        {\\n            for(int i=0; i+1<n; i+=2)\\n            {\\n                if(i%4==0)\\n                    nums[i/2]=min(nums[i], nums[i+1]) ;\\n\\n                else\\n                    nums[i/2]=max(nums[i], nums[i+1]) ;\\n            }\\n\\n            n/=2 ;\\n        }\\n\\n        return nums[0] ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4017516,
                "title": "c-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 2293. Min Max Game\\n *\\n * You are given a 0-indexed integer array nums whose length is a power of 2.\\n * \\n * Apply the following algorithm on nums:\\n * \\n * Let n be the length of nums. If n == 1, end the process. Otherwise, \\n * create a new 0-indexed integer array newNums of length n / 2.\\n * For every even index i where 0 <= i < n / 2, assign the value of newNums[i] \\n * as min(nums[2 * i], nums[2 * i + 1]).\\n * For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] \\n * as max(nums[2 * i], nums[2 * i + 1]).\\n * Replace the array nums with newNums.\\n * Repeat the entire process starting from step 1.\\n * Return the last number that remains in nums after applying the algorithm.\\n *\\n * 1 <= nums.length <= 1024\\n * 1 <= nums[i] <= 10^9\\n * nums.length is a power of 2.\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\n\\nint minMaxGame(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     */\\n\\n    while (numsSize > 2) {\\n    \\n        for (int i = 0, j = 0; i < numsSize; i += 4, j += 2) {\\n            nums[j] = MIN(nums[i], nums[i + 1]);\\n            nums[j + 1] = MAX(nums[i + 2], nums[i + 3]);\\n        }\\n    \\n        numsSize >>= 1;\\n    }\\n    \\n    /*\\n     * Output:\\n     *  Return the last number that remains in nums after applying the algorithm.\\n     */\\n\\n    return (numsSize != 1) ? MIN(nums[0], nums[1]) : nums[0];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n/*\\n * 2293. Min Max Game\\n *\\n * You are given a 0-indexed integer array nums whose length is a power of 2.\\n * \\n * Apply the following algorithm on nums:\\n * \\n * Let n be the length of nums. If n == 1, end the process. Otherwise, \\n * create a new 0-indexed integer array newNums of length n / 2.\\n * For every even index i where 0 <= i < n / 2, assign the value of newNums[i] \\n * as min(nums[2 * i], nums[2 * i + 1]).\\n * For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] \\n * as max(nums[2 * i], nums[2 * i + 1]).\\n * Replace the array nums with newNums.\\n * Repeat the entire process starting from step 1.\\n * Return the last number that remains in nums after applying the algorithm.\\n *\\n * 1 <= nums.length <= 1024\\n * 1 <= nums[i] <= 10^9\\n * nums.length is a power of 2.\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\n\\nint minMaxGame(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     */\\n\\n    while (numsSize > 2) {\\n    \\n        for (int i = 0, j = 0; i < numsSize; i += 4, j += 2) {\\n            nums[j] = MIN(nums[i], nums[i + 1]);\\n            nums[j + 1] = MAX(nums[i + 2], nums[i + 3]);\\n        }\\n    \\n        numsSize >>= 1;\\n    }\\n    \\n    /*\\n     * Output:\\n     *  Return the last number that remains in nums after applying the algorithm.\\n     */\\n\\n    return (numsSize != 1) ? MIN(nums[0], nums[1]) : nums[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989294,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n!=1){\\n          n=n/2;\\n          int [] newnums = new int[n];\\n          for(int i=0;i<newnums.length;i++){\\n            if(i%2==0){\\n              newnums[i]=Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            else{\\n              newnums[i]=Math.max(nums[2 * i], nums[2 * i + 1]);\\n\\n            }\\n  \\n            nums[i]=newnums[i];\\n          }\\n          \\n          \\n          \\n          \\n        }\\n        return nums[0];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        while(n!=1){\\n          n=n/2;\\n          int [] newnums = new int[n];\\n          for(int i=0;i<newnums.length;i++){\\n            if(i%2==0){\\n              newnums[i]=Math.min(nums[2 * i], nums[2 * i + 1]);\\n            }\\n            else{\\n              newnums[i]=Math.max(nums[2 * i], nums[2 * i + 1]);\\n\\n            }\\n  \\n            nums[i]=newnums[i];\\n          }\\n          \\n          \\n          \\n          \\n        }\\n        return nums[0];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985439,
                "title": "easy-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int[] arr = nums;\\n        while(arr.length>1){\\n            int[] arr1 = new int[arr.length/2];\\n            int count = 0;\\n            for(int i = 0;i<arr.length-1;i+=2){\\n                if(count%2==0){\\n                    arr1[count] = Math.min(arr[i],arr[i+1]);\\n                    count++;\\n                }else{\\n                    arr1[count] = Math.max(arr[i],arr[i+1]);\\n                    count++;\\n                }\\n            }\\n            arr = arr1;\\n        }\\n        return arr[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int[] arr = nums;\\n        while(arr.length>1){\\n            int[] arr1 = new int[arr.length/2];\\n            int count = 0;\\n            for(int i = 0;i<arr.length-1;i+=2){\\n                if(count%2==0){\\n                    arr1[count] = Math.min(arr[i],arr[i+1]);\\n                    count++;\\n                }else{\\n                    arr1[count] = Math.max(arr[i],arr[i+1]);\\n                    count++;\\n                }\\n            }\\n            arr = arr1;\\n        }\\n        return arr[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983745,
                "title": "easiest-and-best-method-beats-100-java-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n            int[] newN=new int[nums.length/2];\\n            for(int i=0;i<nums.length;i=i+2){\\n                if(i%4==0){\\n                    newN[i/2]=Math.min(nums[i],nums[i+1]);\\n                }\\n                else{\\n                    newN[i/2]=Math.max(nums[i],nums[i+1]);\\n                }\\n            }\\n            nums=newN;\\n        return minMaxGame(newN);\\n    }\\n}\\n```\\n![cat upvote.png](https://assets.leetcode.com/users/images/dccd84d9-6b10-4552-9d7f-3325e2332167_1693472674.4840949.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n            int[] newN=new int[nums.length/2];\\n            for(int i=0;i<nums.length;i=i+2){\\n                if(i%4==0){\\n                    newN[i/2]=Math.min(nums[i],nums[i+1]);\\n                }\\n                else{\\n                    newN[i/2]=Math.max(nums[i],nums[i+1]);\\n                }\\n            }\\n            nums=newN;\\n        return minMaxGame(newN);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981157,
                "title": "java-0ms-recursive-solution-with-brief-explanation",
                "content": "The Three Laws of Recursion\\nA recursive algorithm must have a base case.\\nA recursive algorithm must change its state and move toward the base case.\\nA recursive algorithm must call itself, recursively.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length/2;\\n        if (n == 0) {\\n        \\treturn nums[0]; // 1. base case\\n        }\\n        int[] newNums = new int[n]; // 2. move towards base case\\n        int i = 0;\\n        while (i < n) {\\n        \\tif (i%2 == 0)\\n        \\t\\tnewNums[i] = Math.min(nums[2*i], nums[2*i + 1]);\\n        \\telse\\n        \\t\\tnewNums[i] = Math.max(nums[2*i], nums[2*i + 1]);\\n        \\ti++;\\n        }\\n        return minMaxGame(newNums); // 3. recursive call\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length/2;\\n        if (n == 0) {\\n        \\treturn nums[0]; // 1. base case\\n        }\\n        int[] newNums = new int[n]; // 2. move towards base case\\n        int i = 0;\\n        while (i < n) {\\n        \\tif (i%2 == 0)\\n        \\t\\tnewNums[i] = Math.min(nums[2*i], nums[2*i + 1]);\\n        \\telse\\n        \\t\\tnewNums[i] = Math.max(nums[2*i], nums[2*i + 1]);\\n        \\ti++;\\n        }\\n        return minMaxGame(newNums); // 3. recursive call\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979725,
                "title": "very-straigthforward-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem essentially involves iterating through the array and at each step, reducing its size by half while performing some operations (min/max) on adjacent pairs. The end goal is to arrive at a single value after these successive reductions. A natural approach is to use a loop to continuously update the array until it has only one element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a loop that continues as long as the length of the nums array is greater than 1.\\n2. In each iteration, create a new array newNums that will store either the minimum or the maximum of each adjacent pair from the nums array.\\n    - For even-indexed pairs (0-1, 4-5, 8-9, ...), take the minimum of the two numbers.\\n    - For odd-indexed pairs (2-3, 6-7, 10-11, ...), take the maximum of the two numbers.\\n3. Update nums to be newNums for the next iteration.\\n4. Continue until the length of nums is reduced to 1. Return the single remaining element.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is \\n$$O(n)$$ where $$n$$ is the length of the nums array. Each iteration takes linear time to go through the array and the number of iterations is logarithmic (since the array size is halved at each step).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is \\n$$O(n)$$ for the extra space used by the newNums array.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) > 1:\\n            newNums = range(len(nums)/2)\\n            for i in newNums:\\n                if (i % 2 == 0):\\n                    newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n                else:\\n                    newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n            nums = newNums                    \\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        while len(nums) > 1:\\n            newNums = range(len(nums)/2)\\n            for i in newNums:\\n                if (i % 2 == 0):\\n                    newNums[i] = min(nums[2 * i], nums[2 * i + 1])\\n                else:\\n                    newNums[i] = max(nums[2 * i], nums[2 * i + 1])\\n            nums = newNums                    \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979264,
                "title": "c-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if (n == 1) return nums[0];\\n        \\n        vector<int> s(n/2);\\n\\n        for (int i = 0; i < n / 2; i++){\\n            if (i % 2 == 0) s[i] = min(nums[2 * i], nums[2 * i + 1]);\\n            else s[i] = max(nums[2 * i], nums[2 * i + 1]);\\n        }\\n\\n        int res = minMaxGame(s);\\n\\n        return res;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if (n == 1) return nums[0];\\n        \\n        vector<int> s(n/2);\\n\\n        for (int i = 0; i < n / 2; i++){\\n            if (i % 2 == 0) s[i] = min(nums[2 * i], nums[2 * i + 1]);\\n            else s[i] = max(nums[2 * i], nums[2 * i + 1]);\\n        }\\n\\n        int res = minMaxGame(s);\\n\\n        return res;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976627,
                "title": "python-inplace-iteration",
                "content": "# Intuition\\nLet\\'s iterate over the original array and update array inplace.\\n\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        print(f\"n:{n}\")\\n\\n        if n == 1:\\n            return nums[0]\\n\\n        # print(n)\\n        k = 0\\n        while k < (n//2):\\n            i = 0\\n            while (2*i+1) < n:\\n                if i % 2 == 0:\\n                    v = min(nums[2*i], nums[2*i+1])\\n                else:\\n                    v = max(nums[2*i], nums[2*i+1])\\n                nums[i] = v\\n                i += 1\\n            # print(f\"[{k}] -> {nums}\")\\n            k += 1\\n\\n        return nums[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        print(f\"n:{n}\")\\n\\n        if n == 1:\\n            return nums[0]\\n\\n        # print(n)\\n        k = 0\\n        while k < (n//2):\\n            i = 0\\n            while (2*i+1) < n:\\n                if i % 2 == 0:\\n                    v = min(nums[2*i], nums[2*i+1])\\n                else:\\n                    v = max(nums[2*i], nums[2*i+1])\\n                nums[i] = v\\n                i += 1\\n            # print(f\"[{k}] -> {nums}\")\\n            k += 1\\n\\n        return nums[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974743,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def short(li):\\n        rli=[]\\n        c=0\\n        for i in range(0,len(li),2):\\n            if(c%2==0):\\n                rli.append(min(li[i],li[i+1]))\\n            else:\\n                rli.append(max(li[i],li[i+1]))\\n            c+=1\\n        return rli\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        if(len(nums)!=1):\\n            while(len(nums)!=1):\\n                nums=Solution.short(nums)\\n        return nums[0]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def short(li):\\n        rli=[]\\n        c=0\\n        for i in range(0,len(li),2):\\n            if(c%2==0):\\n                rli.append(min(li[i],li[i+1]))\\n            else:\\n                rli.append(max(li[i],li[i+1]))\\n            c+=1\\n        return rli\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        if(len(nums)!=1):\\n            while(len(nums)!=1):\\n                nums=Solution.short(nums)\\n        return nums[0]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962790,
                "title": "easy-to-understand-python3-solution-tc-o-log-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newnums = nums\\n\\n        l = len(nums) // 2\\n\\n        while l >= 1:\\n            i = 0\\n            newnums = []\\n            minTrue = True\\n\\n            while i < len(nums):\\n                if minTrue:\\n                    newnums.append(min(nums[i], nums[i+1]))\\n                else:\\n                    newnums.append(max(nums[i], nums[i+1]))\\n                minTrue = not minTrue\\n                i += 2\\n            nums = newnums\\n            l = len(nums) // 2\\n        \\n        return nums[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newnums = nums\\n\\n        l = len(nums) // 2\\n\\n        while l >= 1:\\n            i = 0\\n            newnums = []\\n            minTrue = True\\n\\n            while i < len(nums):\\n                if minTrue:\\n                    newnums.append(min(nums[i], nums[i+1]))\\n                else:\\n                    newnums.append(max(nums[i], nums[i+1]))\\n                minTrue = not minTrue\\n                i += 2\\n            nums = newnums\\n            l = len(nums) // 2\\n        \\n        return nums[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950385,
                "title": "ruby-recursive-88ms",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_max_game(nums)\\n  return nums[0] if nums.size == 1\\n  nums = nums.each_slice(2).to_a.map.with_index{|a, i| i.even? ? a.min : a.max}\\n  min_max_game(nums)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_max_game(nums)\\n  return nums[0] if nums.size == 1\\n  nums = nums.each_slice(2).to_a.map.with_index{|a, i| i.even? ? a.min : a.max}\\n  min_max_game(nums)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3942543,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minMaxGame(List<int> nums) {\\n      while (nums.length != 1) {\\n          final res = List.generate(nums.length ~/ 2, (index) => 0);\\n          for (int i = 0; i < res.length; i++) {\\n              if (i % 2 == 0) {\\n                  res[i] = min(nums[2*i], nums[2*i + 1]);\\n              } else {\\n                  res[i] = max(nums[2*i], nums[2*i + 1]);\\n              }      \\n          }\\n          nums = res;\\n      }\\n      return nums.first;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minMaxGame(List<int> nums) {\\n      while (nums.length != 1) {\\n          final res = List.generate(nums.length ~/ 2, (index) => 0);\\n          for (int i = 0; i < res.length; i++) {\\n              if (i % 2 == 0) {\\n                  res[i] = min(nums[2*i], nums[2*i + 1]);\\n              } else {\\n                  res[i] = max(nums[2*i], nums[2*i + 1]);\\n              }      \\n          }\\n          nums = res;\\n      }\\n      return nums.first;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927815,
                "title": "python-process-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt a high level, the problem is about constructing a new array from the old array repeatedly until we\\'re left with a single element. Specifically, for every pair of numbers in the old array, we want to take either the minimum or the maximum of the pair, depending on whether the position of the number in the new array is even or odd, respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialization: Begin with the original nums array.\\n\\n2.Building the New Array: Iterate over the old array in pairs. For every pair:\\n\\n3.If the index in the new array is even, take the min of the pair.\\nIf the index in the new array is odd, take the max of the pair.\\n4.Loop Continuation: Replace the old array with the newly formed array and repeat the process until only one element remains.\\n\\nReturn: Once we are left with a single element, return that as the answer.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums) > 1:\\n            new_nums = []\\n            for i in range(len(nums)//2):\\n                if i %2 ==0:\\n                    new_value = min(nums[2 * i], nums[2 * i + 1])\\n                    new_nums.append(new_value)\\n                else:\\n                    new_value = max(nums[2 * i], nums[2 * i + 1])\\n                    new_nums.append(new_value)\\n            nums = new_nums\\n        return nums[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        while len(nums) > 1:\\n            new_nums = []\\n            for i in range(len(nums)//2):\\n                if i %2 ==0:\\n                    new_value = min(nums[2 * i], nums[2 * i + 1])\\n                    new_nums.append(new_value)\\n                else:\\n                    new_value = max(nums[2 * i], nums[2 * i + 1])\\n                    new_nums.append(new_value)\\n            nums = new_nums\\n        return nums[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924036,
                "title": "python-super-fast-solution-with-comments-only-one-check",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newNums = []\\n        n = len(nums)\\n\\n        # log2 is math function to calculate the logarithm to the base 2,\\n        # we need amont of iteration to make len(nums) == 2 and this is \\n        # exactly what log2(len(nums))-1 gives to us. So for len(nums) == 8 we\\n        # need range(3) and 3 == log2(8)-1\\n        for _ in range(int(log2(n)-1)):\\n            # we build our newNums list so we know it\\'s len()\\n            n //= 2\\n\\n            # we don\\'t need any if else statement because we have step 2\\n            # so every first i is min and every second is max\\n            for i in range(0, n, 2):\\n                newNums.append(min(nums[i*2], nums[i*2+1]))\\n                newNums.append(max(nums[(i+1)*2], nums[(i+1)*2+1]))\\n            nums = newNums.copy()\\n            newNums.clear()\\n\\n        # the only if else statement here to check if len(nums) == 1.\\n        # this check can be here because if so previous entire loop section \\n        # would not execute\\n        return min(nums[0], nums[1]) if n == 2 else nums[0]\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        newNums = []\\n        n = len(nums)\\n\\n        # log2 is math function to calculate the logarithm to the base 2,\\n        # we need amont of iteration to make len(nums) == 2 and this is \\n        # exactly what log2(len(nums))-1 gives to us. So for len(nums) == 8 we\\n        # need range(3) and 3 == log2(8)-1\\n        for _ in range(int(log2(n)-1)):\\n            # we build our newNums list so we know it\\'s len()\\n            n //= 2\\n\\n            # we don\\'t need any if else statement because we have step 2\\n            # so every first i is min and every second is max\\n            for i in range(0, n, 2):\\n                newNums.append(min(nums[i*2], nums[i*2+1]))\\n                newNums.append(max(nums[(i+1)*2], nums[(i+1)*2+1]))\\n            nums = newNums.copy()\\n            newNums.clear()\\n\\n        # the only if else statement here to check if len(nums) == 1.\\n        # this check can be here because if so previous entire loop section \\n        # would not execute\\n        return min(nums[0], nums[1]) if n == 2 else nums[0]\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915114,
                "title": "easy-c-solution-beginner-s-friendly-vector",
                "content": "# Intuition\\nCan easily be solved using vector.\\n\\n# Approach\\nLogic is already mentioned in question.\\nJust implement the logic and it will be solved.\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        //If size is already 1 then return it\\'s first value.\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n\\n        vector<int> ans2;\\n    \\n        while(nums.size()!=1){\\n\\n            ans2.clear();\\n\\n            for(int i=0;i<nums.size()/2;i++){\\n\\n             //For even number\\n                ans2.push_back(min(nums[2*i],nums[2*i+1]));\\n\\n             //For odd number\\n                i++;    \\n             //If by increasing i it will go out of loop then \\n            //below case will not work.\\n                if(i!=nums.size()/2){\\n                    ans2.push_back(max(nums[2*i],nums[2*i+1]));\\n                }\\n            }\\n            nums.clear();\\n            nums=ans2;\\n        }\\n\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        //If size is already 1 then return it\\'s first value.\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n\\n        vector<int> ans2;\\n    \\n        while(nums.size()!=1){\\n\\n            ans2.clear();\\n\\n            for(int i=0;i<nums.size()/2;i++){\\n\\n             //For even number\\n                ans2.push_back(min(nums[2*i],nums[2*i+1]));\\n\\n             //For odd number\\n                i++;    \\n             //If by increasing i it will go out of loop then \\n            //below case will not work.\\n                if(i!=nums.size()/2){\\n                    ans2.push_back(max(nums[2*i],nums[2*i+1]));\\n                }\\n            }\\n            nums.clear();\\n            nums=ans2;\\n        }\\n\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914960,
                "title": "solving-the-min-max-game-problem-a-recursive-approach",
                "content": "\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem, our initial thoughts often revolve around breaking down the problem into smaller parts and solving them. In the case of the Min-Max Game problem, we can intuitively observe that we need to repeatedly find the minimum or maximum values among pairs of elements in a given list. This suggests a potential recursive approach, where we continuously reduce the list\\'s size until we\\'re left with a single element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur approach to solving the Min-Max Game problem involves a recursive algorithm that takes advantage of the observation that we can divide the list into pairs and compute either the minimum or maximum value of each pair. We then replace the original list with these computed values and continue the process until only one element remains. Let\\'s break down the steps of our approach:\\n\\nIf the size of the list is 1, return the only element as it is the ultimate result.\\n\\nCreate a new list v to store the computed minimum or maximum values of each pair of elements.\\n\\nIterate over the first half of the list, and for each pair of elements (x, y), compute the minimum or maximum based on the index i. Store the computed value in the v list.\\n\\nResize the original list to half of its size, effectively reducing the problem size.\\n\\nCopy the values from the v list back to the original list.\\n\\nRecursively call the same function with the updated list.\\n\\nRepeat the process until the list size becomes 1, and return the remaining element.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n\\n        vector<int> v(n / 2, 0);\\n        for (int i = 0; i < (n / 2); i++) {\\n            int x = nums[2 * i];\\n            int y = nums[(2 * i) + 1];\\n            if (i % 2 == 0) {\\n                v[i] = min(x, y);\\n            } else {\\n                v[i] = max(x, y);\\n            }\\n        }\\n\\n        nums.resize(n / 2); // Reduce the size of nums to half\\n\\n        for (int i = 0; i < (n / 2); i++) {\\n            nums[i] = v[i];\\n        }\\n        \\n        return minMaxGame(nums); // Recursively call the function with the updated array\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n\\n        vector<int> v(n / 2, 0);\\n        for (int i = 0; i < (n / 2); i++) {\\n            int x = nums[2 * i];\\n            int y = nums[(2 * i) + 1];\\n            if (i % 2 == 0) {\\n                v[i] = min(x, y);\\n            } else {\\n                v[i] = max(x, y);\\n            }\\n        }\\n\\n        nums.resize(n / 2); // Reduce the size of nums to half\\n\\n        for (int i = 0; i < (n / 2); i++) {\\n            nums[i] = v[i];\\n        }\\n        \\n        return minMaxGame(nums); // Recursively call the function with the updated array\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913035,
                "title": "min-operator-for-every-comparison-maths-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry maths!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$\\n-5 <-1 \\\\\\\\\\n5 < 1 \\\\\\\\\\n|-5| = 5 \\\\\\\\\\nmax(5, 1) = |(min(-5,-1)|\\n$$\\n# Complexity\\n- Time complexity: $$O(n)$$: \\n$$len/{2}^1 + len/{2}^2 + len/{2}^3 + \\\\ldots \\\\to len$$\\nFor a power of two it equals to $$len - 1$$: $$len/{2}^1 + len/{2}^2 + \\\\ldots + len/len = len - 1$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$: in-place\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```python\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        end = len(nums)\\n        while end := end // 2:\\n            for i in range(end):\\n                nums[i] = abs(min((-1)**i * nums[2 * i], (-1)**i * nums[2 * i + 1]))\\n        \\n        return nums[0]\\n```\\n\\nIt can be writen in three lines:\\n```python\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        for rnd in range(1, int(log2(len(nums))) + 1):\\n            for i in range(len(nums) // 2**rnd): nums[i] = abs(min((-1)**i * nums[2 * i], (-1)**i * nums[2 * i + 1]))\\n        \\n        return nums[0]\\n```\\n\\nRecursion ($$O(2^{log_{2} n +1}-1)$$ = $$O(2 \\\\cdot n - 1)$$ space/time):\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def req(l, r, sign, nums):\\n            return (nums[l] if l + 1 == r else \\n                    abs(min(sign * req(l, (l + r) // 2, 1, nums), \\n                            sign * req((l + r) // 2, r, -1, nums))))\\n        \\n        return req(0, len(nums), 1, nums)\\n```\\n\\nRecursion (in-place, $$O(n)$$ space/time):\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def req(l, r, sign, nums):\\n            c = l + (r - l) // 2\\n            if r - l != 2: req(l, c, 1, nums), req(c, r, -1, nums)\\n            nums[l] = abs(min(sign * nums[l], sign * nums[c]))\\n        \\n        if len(nums) > 1: req(0, len(nums), 1, nums)\\n        \\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        end = len(nums)\\n        while end := end // 2:\\n            for i in range(end):\\n                nums[i] = abs(min((-1)**i * nums[2 * i], (-1)**i * nums[2 * i + 1]))\\n        \\n        return nums[0]\\n```\n```python\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        for rnd in range(1, int(log2(len(nums))) + 1):\\n            for i in range(len(nums) // 2**rnd): nums[i] = abs(min((-1)**i * nums[2 * i], (-1)**i * nums[2 * i + 1]))\\n        \\n        return nums[0]\\n```\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def req(l, r, sign, nums):\\n            return (nums[l] if l + 1 == r else \\n                    abs(min(sign * req(l, (l + r) // 2, 1, nums), \\n                            sign * req((l + r) // 2, r, -1, nums))))\\n        \\n        return req(0, len(nums), 1, nums)\\n```\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def req(l, r, sign, nums):\\n            c = l + (r - l) // 2\\n            if r - l != 2: req(l, c, 1, nums), req(c, r, -1, nums)\\n            nums[l] = abs(min(sign * nums[l], sign * nums[c]))\\n        \\n        if len(nums) > 1: req(0, len(nums), 1, nums)\\n        \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906169,
                "title": "java-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n\\n        int[] newNums = new int[nums.length / 2];\\n\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            if (i % 2 == 0) {\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            } else {\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if (nums.length == 1) return nums[0];\\n\\n        int[] newNums = new int[nums.length / 2];\\n\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            if (i % 2 == 0) {\\n                newNums[i] = Math.min(nums[2 * i], nums[2 * i + 1]);\\n            } else {\\n                newNums[i] = Math.max(nums[2 * i], nums[2 * i + 1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904874,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int arr[]=new int[nums.length/2];\\n        for(int i=0;i<arr.length;i++){\\n            if(i%2==0)\\n                arr[i]=Math.min(nums[2*i], nums[2*i+1]);\\n            else\\n                arr[i]=Math.max(nums[2*i], nums[2*i+1]);\\n        }\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int arr[]=new int[nums.length/2];\\n        for(int i=0;i<arr.length;i++){\\n            if(i%2==0)\\n                arr[i]=Math.min(nums[2*i], nums[2*i+1]);\\n            else\\n                arr[i]=Math.max(nums[2*i], nums[2*i+1]);\\n        }\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895988,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust folow the algo given in the questions \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a recursive approach \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n- O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1){\\n            return nums[0];  // Base case\\n        }\\n\\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++){ \\n            if(i%2==0) {\\n                newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            }\\n            else {\\n                newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n            }\\n        } \\n        \\n        int res = minMaxGame(newNum); // Recursive call\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==1){\\n            return nums[0];  // Base case\\n        }\\n\\n        vector<int> newNum(n/2); \\n        for(int i=0; i<n/2; i++){ \\n            if(i%2==0) {\\n                newNum[i] = min(nums[2 * i], nums[2 * i + 1]); \\n            }\\n            else {\\n                newNum[i] = max(nums[2 * i], nums[2 * i + 1]); \\n            }\\n        } \\n        \\n        int res = minMaxGame(newNum); // Recursive call\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895930,
                "title": "simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minMaxGame = function(nums) {\\n    if(nums.length<=1){\\n        return nums[0]\\n    }\\n    let arr=[]\\n    let count=0\\n    for(let i=0;i<nums.length;i+=2){\\n       if(count==0){\\n           arr.push(Math.min(nums[i],nums[i+1]))\\n           count=1\\n\\n       }\\n       else{\\n           arr.push(Math.max(nums[i],nums[i+1]))\\n           count=0\\n       }\\n    }\\n    return minMaxGame(arr)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minMaxGame = function(nums) {\\n    if(nums.length<=1){\\n        return nums[0]\\n    }\\n    let arr=[]\\n    let count=0\\n    for(let i=0;i<nums.length;i+=2){\\n       if(count==0){\\n           arr.push(Math.min(nums[i],nums[i+1]))\\n           count=1\\n\\n       }\\n       else{\\n           arr.push(Math.max(nums[i],nums[i+1]))\\n           count=0\\n       }\\n    }\\n    return minMaxGame(arr)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881365,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n\\n        n /= 2;\\n        int[] arr = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            arr[i] = i % 2 == 0 ? Math.min(nums[2 * i], nums[2 * i + 1])\\n                                : Math.max(nums[2 * i], nums[2 * i + 1]);\\n        \\n\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n\\n        n /= 2;\\n        int[] arr = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            arr[i] = i % 2 == 0 ? Math.min(nums[2 * i], nums[2 * i + 1])\\n                                : Math.max(nums[2 * i], nums[2 * i + 1]);\\n        \\n\\n        return minMaxGame(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881360,
                "title": "c-solution-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(log n)$$\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                nums[i]=min(nums[2*i],nums[2*i+1]);\\n            }else{\\n                nums[i]=max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        nums.resize(n/2);\\n        return minMaxGame(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        for(int i=0;i<n/2;i++){\\n            if(i%2==0){\\n                nums[i]=min(nums[2*i],nums[2*i+1]);\\n            }else{\\n                nums[i]=max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        nums.resize(n/2);\\n        return minMaxGame(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872979,
                "title": "great-runtime-bad-memory-solution-from-python-noob",
                "content": "# Intuition\\n![Screenshot 2023-08-06 184424.png](https://assets.leetcode.com/users/images/4a13d0e0-6c5a-45ff-9160-0cf77646890e_1691340357.938441.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhile length of nums is not 1 we loop through two zipped lists of nums where first list is every second element starting from index 0 and the other one is every second element starting from index 1. Then we look at our variable current. If current is \"min\" we append to empty min element and set current to \"max\". The next time it is max we set current to min and append to empty max element of given i,j. at the end of the loop we set nums to empty and empty to [] so we can loop again. \\n.\\nsorry for my bad english\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        empty=[]\\n        current=\"min\"\\n        while len(nums)!=1:\\n\\n            for (i,j) in zip(nums[::2],nums[1::2]):\\n                print(i,j)\\n                if current==\"min\":\\n                    empty.append(min([i,j]))\\n                    current=\"max\"\\n                else:\\n                    empty.append(max([i,j]))\\n                    current=\"min\"\\n            nums=empty\\n            empty=[]\\n            \\n        return nums[0]\\n\\n\\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        empty=[]\\n        current=\"min\"\\n        while len(nums)!=1:\\n\\n            for (i,j) in zip(nums[::2],nums[1::2]):\\n                print(i,j)\\n                if current==\"min\":\\n                    empty.append(min([i,j]))\\n                    current=\"max\"\\n                else:\\n                    empty.append(max([i,j]))\\n                    current=\"min\"\\n            nums=empty\\n            empty=[]\\n            \\n        return nums[0]\\n\\n\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872271,
                "title": "simple-python-recursion-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'re just keep iterating through our nums array and every cycle decrease in half it\\'s size while met final result \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        else:\\n            filtered_nums = []\\n            flag = True\\n            for i in range(0, len(nums), 2):\\n                if flag:\\n                    filtered_nums.append(min(nums[i:i+2]))\\n                else:\\n                    filtered_nums.append(max(nums[i:i+2]))\\n                flag = not flag\\n            nums = filtered_nums\\n            return self.minMaxGame(nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        else:\\n            filtered_nums = []\\n            flag = True\\n            for i in range(0, len(nums), 2):\\n                if flag:\\n                    filtered_nums.append(min(nums[i:i+2]))\\n                else:\\n                    filtered_nums.append(max(nums[i:i+2]))\\n                flag = not flag\\n            nums = filtered_nums\\n            return self.minMaxGame(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871897,
                "title": "min-max-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n        return nums[0];\\n        int n= nums.length;\\n        int[] newnums = new int[n/2];\\n        for(int i=0;i<newnums.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                newnums[i] = Math.min(nums[2*i],nums[2*i+1]);\\n            }\\n            else if(i%2==1)\\n            {\\n                newnums[i] = Math.max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        return minMaxGame(newnums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        if(nums.length==1)\\n        return nums[0];\\n        int n= nums.length;\\n        int[] newnums = new int[n/2];\\n        for(int i=0;i<newnums.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                newnums[i] = Math.min(nums[2*i],nums[2*i+1]);\\n            }\\n            else if(i%2==1)\\n            {\\n                newnums[i] = Math.max(nums[2*i],nums[2*i+1]);\\n            }\\n        }\\n        return minMaxGame(newnums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871549,
                "title": "beats-100-easiest-approach-must-vote",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int flag=1;\\n        while(nums.size()!=1){\\n            vector<int>v;\\n            for(int i=0;i<nums.size();i+=2,flag+=1){\\n                if(flag%2==1)\\n                v.push_back(min(nums[i],nums[i+1]));\\n\\n                else\\n                v.push_back(max(nums[i],nums[i+1]));\\n            }\\n            nums.clear();\\n            nums=v;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        int flag=1;\\n        while(nums.size()!=1){\\n            vector<int>v;\\n            for(int i=0;i<nums.size();i+=2,flag+=1){\\n                if(flag%2==1)\\n                v.push_back(min(nums[i],nums[i+1]));\\n\\n                else\\n                v.push_back(max(nums[i],nums[i+1]));\\n            }\\n            nums.clear();\\n            nums=v;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869353,
                "title": "easy-c-solution-recursion-beats-100-users-runtime",
                "content": "\\n![Screenshot (333).png](https://assets.leetcode.com/users/images/75c8d619-719a-4e90-a861-22ce99a7cb35_1691273113.8266.png)\\n\\n# Approach\\nKind of Merge Sort.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int i,int j,int flag,vector<int> &v){\\n        if(j-i==1){\\n            if(flag) return max(v[i],v[j]);\\n            return min(v[i],v[j]);\\n        }\\n        if(j-i<1){\\n            if(flag) return -1e9;\\n            return 1e9;\\n        }\\n        int x=rec(i,(i+j)/2,0,v);\\n        int y=rec(((i+j)/2)+1,j,1,v);\\n        if(flag) {return max(x,y);}\\n        return min(x,y);\\n    }\\n    int minMaxGame(vector<int>& v) {\\n        int n=v.size();\\n        if(n==1|| n==2) return min(v[0],v[n-1]);\\n        return rec(0,n-1,0,v);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int i,int j,int flag,vector<int> &v){\\n        if(j-i==1){\\n            if(flag) return max(v[i],v[j]);\\n            return min(v[i],v[j]);\\n        }\\n        if(j-i<1){\\n            if(flag) return -1e9;\\n            return 1e9;\\n        }\\n        int x=rec(i,(i+j)/2,0,v);\\n        int y=rec(((i+j)/2)+1,j,1,v);\\n        if(flag) {return max(x,y);}\\n        return min(x,y);\\n    }\\n    int minMaxGame(vector<int>& v) {\\n        int n=v.size();\\n        if(n==1|| n==2) return min(v[0],v[n-1]);\\n        return rec(0,n-1,0,v);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865829,
                "title": "c-2-best-approaches-with-0ms-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        // int count = 0, n = nums.size();;\\n        // while(n > 1) {\\n        //     int i = 0, temp = count, flag = 0;\\n        //     if(count == 0) count++;\\n        //     while(i < nums.size()-count) {\\n        //         if(!flag) nums[i] = min(nums[i], nums[i+count]);\\n        //         else nums[i] = max(nums[i], nums[i+count]);\\n        //         i += temp == 0 ? 2 : 2*count;\\n        //         flag = !flag;\\n        //     }\\n        //     count += temp == 0 ? 1 : count;\\n        //     n /= 2;\\n        // }\\n        // return nums[0];\\n\\n\\n        int n = nums.size();;\\n        while(n > 1) {\\n            int k = 0;\\n            for(int i=0;i<n/2;i++) {\\n                if(k%2 == 0) nums[k++] = min(nums[2*i], nums[2*i+1]);\\n                else nums[k++] = max(nums[2*i], nums[2*i+1]);\\n            }\\n            n /= 2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        // int count = 0, n = nums.size();;\\n        // while(n > 1) {\\n        //     int i = 0, temp = count, flag = 0;\\n        //     if(count == 0) count++;\\n        //     while(i < nums.size()-count) {\\n        //         if(!flag) nums[i] = min(nums[i], nums[i+count]);\\n        //         else nums[i] = max(nums[i], nums[i+count]);\\n        //         i += temp == 0 ? 2 : 2*count;\\n        //         flag = !flag;\\n        //     }\\n        //     count += temp == 0 ? 1 : count;\\n        //     n /= 2;\\n        // }\\n        // return nums[0];\\n\\n\\n        int n = nums.size();;\\n        while(n > 1) {\\n            int k = 0;\\n            for(int i=0;i<n/2;i++) {\\n                if(k%2 == 0) nums[k++] = min(nums[2*i], nums[2*i+1]);\\n                else nums[k++] = max(nums[2*i], nums[2*i+1]);\\n            }\\n            n /= 2;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827883,
                "title": "queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<vector>\\nclass Solution {\\n    int c = 1;\\n    queue<int>q;\\npublic:\\n    int minMaxGame(vector<int>& v) {\\n        if(v.size()==1) return v[0];\\n       for(int i=0; i<v.size(); i++){\\n           q.push(v[i]);\\n       }\\n       while(q.size()>1){\\n           int l=q.front(); q.pop();\\n           int r=q.front(); q.pop();\\n            if(c&1){\\n                q.push(min(l,r));\\n            }\\n            else{\\n                q.push(max(l,r));\\n            }\\n            c++;\\n       }\\n       return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<vector>\\nclass Solution {\\n    int c = 1;\\n    queue<int>q;\\npublic:\\n    int minMaxGame(vector<int>& v) {\\n        if(v.size()==1) return v[0];\\n       for(int i=0; i<v.size(); i++){\\n           q.push(v[i]);\\n       }\\n       while(q.size()>1){\\n           int l=q.front(); q.pop();\\n           int r=q.front(); q.pop();\\n            if(c&1){\\n                q.push(min(l,r));\\n            }\\n            else{\\n                q.push(max(l,r));\\n            }\\n            c++;\\n       }\\n       return q.front();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3825151,
                "title": "easy-solution-python-beats-99-runtime",
                "content": "Here: \\n1. count is the counter inside a function set to maintain the max min pattern ( if count is odd => find min; else => find max)\\n2. final [] returns the modified list with max min values as list values which replaces the nums\\n3. repeating the process until we get only one element in nums\\n# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def minmax(lis):\\n            final = []\\n            count = 1\\n            for i in range(0,len(lis),2):\\n                temp = lis[i:i+2]\\n                if count%2 !=0:\\n                    final.append(min(temp))\\n                else:\\n                    final.append(max(temp)) \\n                count+=1\\n            return final\\n        while(len(nums)!=1):\\n            nums = minmax(nums)\\n        return nums[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        def minmax(lis):\\n            final = []\\n            count = 1\\n            for i in range(0,len(lis),2):\\n                temp = lis[i:i+2]\\n                if count%2 !=0:\\n                    final.append(min(temp))\\n                else:\\n                    final.append(max(temp)) \\n                count+=1\\n            return final\\n        while(len(nums)!=1):\\n            nums = minmax(nums)\\n        return nums[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807522,
                "title": "java-0ms-100-faster-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int l = nums.length;\\n        if(l == 1){\\n            return nums[0];\\n        }\\n        int newNums[] = new int[l/2];\\n        for(int i=0; i<newNums.length; i++){\\n            if(i%2 == 0){\\n                newNums[i] = Math.min(nums[2*i], nums[2*i+1]);\\n            }else{\\n                newNums[i] = Math.max(nums[2*i], nums[2*i+1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMaxGame(int[] nums) {\\n        int l = nums.length;\\n        if(l == 1){\\n            return nums[0];\\n        }\\n        int newNums[] = new int[l/2];\\n        for(int i=0; i<newNums.length; i++){\\n            if(i%2 == 0){\\n                newNums[i] = Math.min(nums[2*i], nums[2*i+1]);\\n            }else{\\n                newNums[i] = Math.max(nums[2*i], nums[2*i+1]);\\n            }\\n        }\\n        return minMaxGame(newNums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796840,
                "title": "iterative-approach-with-switching-flag-for-min-max",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        func = {False: min, True: max}\\n        while len(nums) > 1:\\n            flag = False\\n            temp = []\\n            for i in range(0, len(nums) - 1, 2):\\n                temp.append(func[flag](nums[i], nums[i + 1]))\\n                flag = not flag\\n            nums = temp[:]\\n        return nums[0]\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMaxGame(self, nums: List[int]) -> int:\\n        func = {False: min, True: max}\\n        while len(nums) > 1:\\n            flag = False\\n            temp = []\\n            for i in range(0, len(nums) - 1, 2):\\n                temp.append(func[flag](nums[i], nums[i + 1]))\\n                flag = not flag\\n            nums = temp[:]\\n        return nums[0]\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789247,
                "title": "pythonic-solution",
                "content": "# Recursion Version of (Simulate the Process)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        self.nums = nums\\n        start = 0\\n        end = len(nums)-1\\n        return self.find(start, end, 1)\\n        \\n\\n    def find(self, start, end, state):    \\n        if start == end:\\n            return self.nums[start] \\n\\n        mid = (start+end)//2\\n\\n        val1 = self.find(start, mid, 1)\\n        val2 = self.find(mid+1, end, 0)\\n\\n        if state:\\n            return min(val1, val2)\\n        return max(val1, val2)    \\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMaxGame(self, nums):\\n        self.nums = nums\\n        start = 0\\n        end = len(nums)-1\\n        return self.find(start, end, 1)\\n        \\n\\n    def find(self, start, end, state):    \\n        if start == end:\\n            return self.nums[start] \\n\\n        mid = (start+end)//2\\n\\n        val1 = self.find(start, mid, 1)\\n        val2 = self.find(mid+1, end, 0)\\n\\n        if state:\\n            return min(val1, val2)\\n        return max(val1, val2)    \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779198,
                "title": "c-solution-using-vector-simple-solution",
                "content": "# Flow of Code\\n1. Creating vector A and B, storing value of nums to A and A to B.\\n2. Iterating through the vector of B and calculating the conditions until the value of vector A becomes 1.\\n3. Returning A[0] as answer.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        vector<int> A,B;\\n        A=nums;\\n        while(true){\\n            if(A.size()==1)\\n                break;\\n            else{\\n                B=A;\\n                A.clear();\\n                int k=1;\\n                for(int i=0;i<B.size();i+=2){\\n                    if(k%2!=0)\\n                        A.push_back(min(B[i],B[i+1]));\\n                    else\\n                        A.push_back(max(B[i],B[i+1]));\\n                    k++;\\n                }\\n            }\\n        }\\n        return A[0];\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        vector<int> A,B;\\n        A=nums;\\n        while(true){\\n            if(A.size()==1)\\n                break;\\n            else{\\n                B=A;\\n                A.clear();\\n                int k=1;\\n                for(int i=0;i<B.size();i+=2){\\n                    if(k%2!=0)\\n                        A.push_back(min(B[i],B[i+1]));\\n                    else\\n                        A.push_back(max(B[i],B[i+1]));\\n                    k++;\\n                }\\n            }\\n        }\\n        return A[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779197,
                "title": "c-solution-using-vector-simple-solution",
                "content": "# Flow of Code\\n1. Creating vector A and B, storing value of nums to A and A to B.\\n2. Iterating through the vector of B and calculating the conditions until the value of vector A becomes 1.\\n3. Returning A[0] as answer.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        vector<int> A,B;\\n        A=nums;\\n        while(true){\\n            if(A.size()==1)\\n                break;\\n            else{\\n                B=A;\\n                A.clear();\\n                int k=1;\\n                for(int i=0;i<B.size();i+=2){\\n                    if(k%2!=0)\\n                        A.push_back(min(B[i],B[i+1]));\\n                    else\\n                        A.push_back(max(B[i],B[i+1]));\\n                    k++;\\n                }\\n            }\\n        }\\n        return A[0];\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMaxGame(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        vector<int> A,B;\\n        A=nums;\\n        while(true){\\n            if(A.size()==1)\\n                break;\\n            else{\\n                B=A;\\n                A.clear();\\n                int k=1;\\n                for(int i=0;i<B.size();i+=2){\\n                    if(k%2!=0)\\n                        A.push_back(min(B[i],B[i+1]));\\n                    else\\n                        A.push_back(max(B[i],B[i+1]));\\n                    k++;\\n                }\\n            }\\n        }\\n        return A[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1911327,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "how come when nums is [70,38,21,22], the output is expected to be 22, not 21?"
                    },
                    {
                        "username": "Pallavi_Dhakne",
                        "content": "In first step: you find min of first two element min(70,38) and max of 22 and 21 so the min=38 and max=22\nin second step: you find min of 38 and 22 which is 22 so the answer is 22 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@JTWittr624](/JTWittr624) Ohhhhh, I see!  Thank you for pointing this out, I didn\\u2019t read the instructions properly.  I was just dividing the list in half and finding the min value regardless of if the index was even or odd each time.  Thank you ;)"
                    },
                    {
                        "username": "JTWittr624",
                        "content": "Seems like whatever variable you are using to control the index (even or odd) isn\\'t working properly for you. I assume that your newNums before the last step looks like this {38,21}. Since the final step involves an even index it will return 21. The problem is in the step above, however. Check to see that it is not inserting the min both times"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Did you know that you can use only a min-operator without $$max()$$ to solve this one? The solution is [here](https://leetcode.com/problems/min-max-game/solutions/3913035/min-operator-for-every-comparison-maths-o-1-space/)."
                    },
                    {
                        "username": "abhisheky220920",
                        "content": "can we solve a this question for useing simple array.sort metthod `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2015241,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "how come when nums is [70,38,21,22], the output is expected to be 22, not 21?"
                    },
                    {
                        "username": "Pallavi_Dhakne",
                        "content": "In first step: you find min of first two element min(70,38) and max of 22 and 21 so the min=38 and max=22\nin second step: you find min of 38 and 22 which is 22 so the answer is 22 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@JTWittr624](/JTWittr624) Ohhhhh, I see!  Thank you for pointing this out, I didn\\u2019t read the instructions properly.  I was just dividing the list in half and finding the min value regardless of if the index was even or odd each time.  Thank you ;)"
                    },
                    {
                        "username": "JTWittr624",
                        "content": "Seems like whatever variable you are using to control the index (even or odd) isn\\'t working properly for you. I assume that your newNums before the last step looks like this {38,21}. Since the final step involves an even index it will return 21. The problem is in the step above, however. Check to see that it is not inserting the min both times"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Did you know that you can use only a min-operator without $$max()$$ to solve this one? The solution is [here](https://leetcode.com/problems/min-max-game/solutions/3913035/min-operator-for-every-comparison-maths-o-1-space/)."
                    },
                    {
                        "username": "abhisheky220920",
                        "content": "can we solve a this question for useing simple array.sort metthod `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1798792,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "how come when nums is [70,38,21,22], the output is expected to be 22, not 21?"
                    },
                    {
                        "username": "Pallavi_Dhakne",
                        "content": "In first step: you find min of first two element min(70,38) and max of 22 and 21 so the min=38 and max=22\nin second step: you find min of 38 and 22 which is 22 so the answer is 22 "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@JTWittr624](/JTWittr624) Ohhhhh, I see!  Thank you for pointing this out, I didn\\u2019t read the instructions properly.  I was just dividing the list in half and finding the min value regardless of if the index was even or odd each time.  Thank you ;)"
                    },
                    {
                        "username": "JTWittr624",
                        "content": "Seems like whatever variable you are using to control the index (even or odd) isn\\'t working properly for you. I assume that your newNums before the last step looks like this {38,21}. Since the final step involves an even index it will return 21. The problem is in the step above, however. Check to see that it is not inserting the min both times"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Did you know that you can use only a min-operator without $$max()$$ to solve this one? The solution is [here](https://leetcode.com/problems/min-max-game/solutions/3913035/min-operator-for-every-comparison-maths-o-1-space/)."
                    },
                    {
                        "username": "abhisheky220920",
                        "content": "can we solve a this question for useing simple array.sort metthod `your inline code...your inline code...`"
                    }
                ]
            }
        ]
    }
]