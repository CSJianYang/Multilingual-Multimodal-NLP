[
    {
        "title": "Most Common Word",
        "question_content": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n&nbsp;\nExample 1:\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\n\nExample 2:\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\n\n&nbsp;\nConstraints:\n\n\t1 <= paragraph.length <= 1000\n\tparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n\t0 <= banned.length <= 100\n\t1 <= banned[i].length <= 10\n\tbanned[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 123854,
                "title": "c-java-python-easy-solution-with-explanation",
                "content": "The description doesn\\'t clearify the case like \"word,word,word\".\\nAnd it doesn\\'t have this kind of corner cases at first.\\nThe test cases and OJ may not be perfect on this problem.\\n\\nAnyway I didn\\'t bother thinking this issue.\\nIn my opinion, the problem demands to extract words with only letters.\\nAll I did is just extract words with only letters.\\n\\n4 steps:\\n1. remove all punctuations\\n2. change to lowercase\\n3. words count for each word not in banned set\\n4. return the most common word\\n\\n**C++:**\\n```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\\n**Java:**\\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\\n\\n**Python:**\\nThanks to @sirxudi I change one line from\\n`words = re.sub(r\\'[^a-zA-Z]\\', \\' \\', p).lower().split()`\\nto \\n`words = re.findall(r\\'\\\\w+\\', p.lower())\\n`\\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 124286,
                "title": "clean-6ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123973,
                "title": "simple-java-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168958,
                "title": "store-words-in-trie-6ms-beats-99-java",
                "content": "Instead of using Map, storing words in **Trie** (or called **Prefix Tree**) requires less memory space.\\n\\nEach node has 26 sub-nodes, \\n```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\\nThe path from root to a specific node represents a word. The following diagram contains 3 words: `[cat, do, dog]`.  The integer `count` note the frequence of that word. A third boolean field is used to distinct a normal word from banned one.\\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\\n\\nHere is my solution. 6ms, beats 99%.\\nTime Complexity: **O (N + M)**\\nSpace Complexity: **O (N + M)**\\nwhere, `N` is the number of characters in banned list, while `M` is thoes in paragraph.\\n\\n\\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/helloshen/image_1536687882.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216788,
                "title": "easy-python-solution",
                "content": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "solutionTags": [],
                "code": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 411380,
                "title": "java-summary-of-usages-of-split-and-replace-vs-replaceall",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/most-common-word/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  **It is guaranteed there is at least one word that isn\\'t banned, and that the answer is unique.**\\n\\n> Words in the list of banned words are **given in lowercase**, and free of punctuation.  Words in the paragraph are not case sensitive. The answer is in **lowercase**.\\n\\n**Note:** \\n\\n- 1 <= `paragraph.length` <= 1000.\\n- 0 <= `banned.length` <= 100.\\n- 1 <= `banned[i].length` <= 10.\\n- The answer is unique, and written in lowercase (even if its occurrences in `paragraph` may have uppercase symbols, and even if it is a proper noun.)\\n- Paragraph only consists of `letters`, `spaces`, or the punctuation symbols `!?\\',;.`.\\n- There are no hyphens or hyphenated words.\\n- Words only consist of letters, never apostrophes or other punctuation symbols.\\n\\n**Example:** \\n\\n```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\\n\\n\\n## Analysis\\n\\n### Hash Set + Hash Map\\n\\n**Note:** `str.split(\"\\\\\\\\s+\")` is equivalent to `str.split(\"\\\\\\\\s+\", 0)`. It means split the string for as many times as possible, and remove empty result `\"\"`. So `trim()` is not necessary here.\\n\\nOriginal code:\\n\\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\\n\\nHere is the `preprocess` function:\\n\\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\nOr:\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\n**`replace()` vs. `replaceAll()`:**\\n\\n- `replace(char oldChar, char newChar)`\\n- `replace(CharSequence target, CharSequence replacement)`\\n- `replaceAll(String regex, String replacement)`\\n\\nNotice that they all replace all occurrences. `All` in the name of `replaceAll` doesn\\'t mean only it can replace all occurrences.\\n\\n\\nA succinct version:\\n\\n- `\\\\\\\\w+` matches all `alphanumeric` characters and `_`.\\n- `\\\\\\\\W+` matches all characters except `alphanumeric` characters and `_`.\\n- They are opposite.\\n\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\\n\\nA more succinct version:\\n\\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\\n\\nRules about `split()`: [271. Encode and Decode Strings](http://junhaow.com/lc/problems/string/271_encode-and-decode-strings.html)\\n\\n\\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500772,
                "title": "python-3-three-lines-easy-and-explained",
                "content": "Runtime: 36 ms, faster than 40.27% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```\\n\\nPlease, upvote if you like it so that others can see and learn from it. Thanks!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184971,
                "title": "c-4ms-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810141,
                "title": "c-super-short",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335407,
                "title": "python-solution-using-max-and-key-function-16-ms",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420553,
                "title": "clean-javascript-solution",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056547,
                "title": "java-map-set-solution-w-detailed-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}\\n\\n\\t\\t\\t-> {\\n\\t\\t\\t\\t\\tball:   2\\n\\t\\t\\t\\t\\tbob:    1\\n\\t\\t\\t\\t\\ta:      1\\n\\t\\t\\t\\t\\tthe:    1\\n\\t\\t\\t\\t\\tflew:   1\\n\\t\\t\\t\\t\\tfar:    1\\n\\t\\t\\t\\t\\tafter:  1\\n\\t\\t\\t\\t\\tit:     1\\n\\t\\t\\t\\t\\twas:    1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tResult: \"ball\"\\n\\n\\t\\t\\tALGORITHM\\n\\t\\t\\t\\tSTEP 1: ensure the passed string is not null or blank\\n\\t\\t\\t\\tSTEP 2: create a set to contain the banned words\\n\\t\\t\\t\\tSTEP 3: create a map to store word and count\\n\\t\\t\\t\\tSTEP 4: remove all other characters from the paragraph except A-Z or a-z\\n\\t\\t\\t\\tSTEP 5: tranform paragraph to have all lowercase letters\\n\\t\\t\\t\\tSTEP 6: create a string array containing the words of pargraph spilt by space\\n\\t\\t\\t\\tSTEP 7: populate the set with the banned words\\n\\t\\t\\t\\tSTEP 8: loop through all the words\\n\\t\\t\\t\\t\\tSTEP 9: if the word is not in the banned list\\n\\t\\t\\t\\t\\t\\t\\t-> add the word to the map with an updated count\\n\\t\\t\\t\\tSTEP 810: return the most common word from map \\n\\n\\n\\t\\t*/\\n\\t\\tpublic String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\t\\tif(paragraph == null || paragraph.length() == 0) {\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tSet<String> bannedWords = new HashSet<>();\\n\\t\\t\\tMap<String, Integer> wordCount = new HashMap<>();\\n            String[] words = paragraph.replaceAll(\"[^A-Za-z]\",\" \").toLowerCase().split(\" \");\\n\\n\\t\\t\\tfor(String word: banned) {\\n\\t\\t\\t\\tbannedWords.add(word);\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tfor(String word: words) {\\n\\t\\t\\t\\tif(!bannedWords.contains(word)) {\\n\\t\\t\\t\\t\\twordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tString mostCommonWord = \"\";\\n\\t\\t\\tfor(String word: wordCount.keySet()) {\\n\\t\\t\\t\\tif(mostCommonWord.equals(\"\")) {\\n\\t\\t\\t\\t\\tmostCommonWord = word;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmostCommonWord = wordCount.get(mostCommonWord) > wordCount.get(word) ? mostCommonWord : word; \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mostCommonWord;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}",
                "codeTag": "Java"
            },
            {
                "id": 196675,
                "title": "3ms-java-solution-beat-99-94",
                "content": "https://en.wikipedia.org/wiki/Trie\\nWe\\'ll use a Trie to solve this problem.\\nEvery TrieNode has 26 links, representing 26 lower-case letters.\\nThe root represents empty string, and each link points to the first character of a string.\\nWe use word to save the string that the node represents, and use cnt to count on number of times we meet the string.\\n\\nDuring \"mostCommonWord\", we could use StringBuilder to append the valid characters(and turn them to all lowercase),\\nwhile we meet any non-letter character, insert the string to the Trie.\\n\\nThe main part of TrieNode functions are describes below:\\n1. insert: \\nTake a char from string letter by letter, and go through the links.\\nIf curr.links[index] == null, that means we haven\\'t had a path pass by,\\nnew the TrieNode and set the \"word\".\\nAt the last of the TrieNode, we need to increase the cnt.\\n2. ban:\\nBan out the string means that we could set the cnt of string to zero.\\nNotice that if we meet null links, just return since the string is not exist in the paragraph.\\n3. findMax:\\nGo through all TrieNode and find the largest cnt and its word.\\n\\nThe following is for \\u4E2D\\u6587\\u4F7F\\u7528\\u8005\\u3002\\n\\u9019\\u500B\\u89E3\\u6CD5\\u662F\\u4F7F\\u7528\\u5B57\\u5178\\u6A39\\u4F86\\u89E3\\uFF0C\\u6A39\\u6839\\u4EE3\\u8868\\u7A7A\\u5B57\\u4E32\\uFF0C\\u6BCF\\u500B\\u5B57\\u4E32\\u90FD\\u6703\\u670926\\u500Blink\\uFF0C\\u4EE3\\u886826\\u500B\\u5C0F\\u5BEB\\u5B57\\u6BCD\\u3002\\n\\u6211\\u5011\\u5728\\u6BCF\\u500BTrieNode\\u4E2D\\u5B58\\u653Eword(\\u8D70\\u5230\\u9019\\u5BE6\\u969B\\u7684\\u5B57\\u4E32)\\u548Ccnt(\\u8A18\\u9304\\u9019\\u500B\\u5B57\\u4E32\\u6709\\u5E7E\\u500B)\\u3002\\n\\u5728mostCommonWord\\u4E2D\\uFF0C\\u4F7F\\u7528StringBuilder\\u6BCF\\u6B21\\u5C07\\u5408\\u6CD5\\u7684\\u5B57\\u5143(\\u5927\\u5C0F\\u5BEB\\u5B57\\u6BCD)\\u52A0\\u5165(\\u4E26\\u8F49\\u6210\\u5C0F\\u5BEB)\\uFF0C\\n\\u5728\\u9047\\u5230\\u975E\\u5B57\\u6BCD\\u7684\\u5B57\\u5143\\u7684\\u6642\\u5019\\uFF0C\\u5C31\\u628A\\u76EE\\u524D\\u7684\\u9019\\u500B\\u5B57\\u4E32\\u585E\\u9032\\u5B57\\u5178\\u6A39\\u88E1\\u3002\\n\\nTrieNode\\u9019\\u908A\\u6709\\u4E09\\u500Bfunctions:\\n1. insert:\\n\\u900F\\u904E\\u6BCF\\u500B\\u5B57\\u6BCD\\u6CBFlinks\\u7684\\u8DEF\\u5F91\\u8D70\\uFF0C\\u5982\\u679Ccurr.links[index] == null\\u5247\\u8868\\u793A\\u524D\\u9762\\u9084\\u6C92\\u8D70\\u904E\\uFF0C\\n\\u8981\\u81EA\\u884Cnew\\u51FA\\u4F86\\uFF0C\\u4E26\\u8A2D\\u5B9A\\u5176word\\u8B8A\\u6578\\u3002\\n\\u5728\\u8D70\\u5230\\u5E95\\u7684\\u6642\\u5019\\u6211\\u5011\\u8981\\u5C07cnt\\u6578\\u52A01\\u3002\\n2. ban:\\n\\u53EA\\u8981\\u5C07\\u8A72string\\u7684cnt\\u8A2D\\u6210\\u96F6\\u5373\\u53EF\\u3002\\n\\u5982\\u679C\\u5728\\u8D70\\u7684\\u8DEF\\u5F91\\u9014\\u4E2D\\u9047\\u5230null\\uFF0C\\u8868\\u793A\\u6BB5\\u843D\\u88E1\\u4E0D\\u5B58\\u5728\\u9019\\u500Bstring\\uFF0C\\u76F4\\u63A5return\\u5373\\u53EF\\u3002\\n3. findMax:\\n\\u904D\\u6B77\\u6240\\u6709TrieNode\\u4E26\\u627E\\u5230\\u6700\\u5927\\u7684cnt\\u53CA\\u5C0D\\u61C9\\u7684word\\u3002\\n\\n```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753471,
                "title": "c-8-ms-solution-easy-to-understand",
                "content": "***Runtime: 8 ms, faster than 93.85% of C++ online submissions for Most Common Word.\\nMemory Usage: 7.7 MB, less than 92.55% of C++ online submissions for Most Common Word.***\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328271,
                "title": "c-linq",
                "content": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125883,
                "title": "a-clean-o-n-javascript-es6-solution",
                "content": "Here is a shortened ES6 solution with explanation; It\\'s in `O(N)` *where `N` is the number of words in the `paragraph`*; \\n\\n```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```\\n\\n**Noteworthy here:** \\n- It doesn\\'t ever `delete` anything, cause it hurts performance in some JavaScript Engines, notably in v8 engine \\n- Note the oneliner trick of finding maximum element using a predicate, with the `[...].reduce()` trick. Similar to how I would have done it in C++ `std::max_element(...[](){})`;\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125686,
                "title": "java-simple-solution-using-hashmaps-along-with-asserts-to-test",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\\n\\nCan be tested by following two asserts:\\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484164,
                "title": "python-faster-than-92-97",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370291,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 123958,
                "title": "3-lines-python-solution-using-regex",
                "content": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2049770,
                "title": "python-brute-force-method-with-explanation",
                "content": "**Explanation**\\n1. make paragraph lowercase (case insensitive)\\n2. remove symbols from paragraph\\n3. split the paragraph into list of words\\n4. remove duplicate words\\n5. iterate through new paragraph\\n\\t6. if the current word isn\\'t in `banned` and it occurs more times in the old paragraph: update count and update the most common word\\n\\t7. return most common word\\n\\n```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429450,
                "title": "java-runtime-o-n-4ms-99-memory-o-n-36mb-96",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982633,
                "title": "python-dictionaries-clean-code",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 828958,
                "title": "swift-16ms",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823208,
                "title": "python-simple-and-clean-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 466877,
                "title": "python-counter-regex-solution-faster-than-98-5",
                "content": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348148,
                "title": "javascript-beats-99-hashmap",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274538,
                "title": "java-short-8-line-code-beats-95-45",
                "content": "# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613988,
                "title": "c-4ms-clean-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/84db0c16-77b3-495b-b83c-0122c8ffa289_1638759978.574484.jpeg)\\n\\n\\n\\n**If you have any questions, feel free to comment below.\\nPlease help to UPVOTE if this post is useful for you.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820773,
                "title": "python-solution-97-faster",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 692486,
                "title": "java-10ms-but-clear-code-many-comments",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686043,
                "title": "functional-solution-in-java",
                "content": "Probably not the best solution to choose in a coding interview but a fun way to solve this problem in Java.\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575644,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }, StringSplitOptions.RemoveEmptyEntries)\\n                                         .GroupBy(x => x)\\n                                         .OrderByDescending(x => x.Count())\\n                                         .Select(x => x.Key))\\n                if (!set.Contains(str))\\n                    return str;\\n\\n            return string.Empty;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }",
                "codeTag": "Java"
            },
            {
                "id": 500791,
                "title": "python-3-another-solution-explained",
                "content": "Runtime: 32 ms, faster than 69.45% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.6 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```\\n\\n**Explanation:**\\n\\n1. First, we create translation map using [str.maketrans](https://docs.python.org/3/library/stdtypes.html#str.maketrans) (<- link to the official doc) to remove all punctuation from the paragraph. If you print `print(string.punctuation)` you will get: `!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~`. The length of this string is 32 symbols. Since first two maketrans arguments must have equal length, we make second argument equal to 32 symbols by using \\' \\'*32 or 32 spaces. That\\'s how we tell to translate all punctuation symbols into spaces.\\n2. Then we convert our `paragraph` to lower case, translate all punctuation into spaces using translator from step one and then split paragraph into words by spaces.\\n3. Then we create new list by saving only those words from paragraph that are **not** in the banned list.\\n4. Finally, we return value that counted max times in our new list.\\n\\nPleaase, upvote if you like this solution so that others can see and learn from it. Thanks!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415594,
                "title": "simple-c-99-20-lines-o-n",
                "content": "Pretty straight forward, the two edge cases are \\n- making sure you count end-of-string as hitting a delimiter and working with whatever word is in the buffer at that time\\n- making sure you don\\'t count an empty string word in your wordCount structure\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408056,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "codeTag": "Java"
            },
            {
                "id": 374139,
                "title": "straightforward-c-solution",
                "content": "Firstly I am doing error checking to see if the given paragraph is empty or not. There are some important points in this code:\\n\\n1) I am transferring the values in the banned vector to a set, to later on search over those words efficiently. Also since set will have unique values, we are eliminating the possibility of wating our time with the same banned words if there are any.\\n2) In the for loop, I am cleaning the paragraph. Since our search will be case insensitive we will have to convert all characters in the paragraph to lower case since all of the banned words are in lower case. Doing this, we will have a common ground to search over. I am also replacing any non-alphabetic character with a space. Do not forget to iterate over the characters in the paragraph by reference since we want to modify them.\\n3) I am utilizing input string stream to parse words from the paragraph. Note that we could also have used a simple string stream but input string stream makes our intention clearer.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345695,
                "title": "c-very-easy-solution-o-n-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 332220,
                "title": "weird-bug-of-using-range-based-loop-for-unordered-map-c",
                "content": "This is my Accepted submission, I post it here for a full view of my code before describing the bug below.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\n\\nIn a previous submission, I did the last loop as follows\\n\\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```\\n\\nFor some unknown reasons, the loop doesn\\'t visit all key-value pairs in the map. For example, in the test `a, a, a, a, b,b,b,c, c`, the code will only check key `c` and skip key `b`. The part ` map[word]` seems to be problematic, I took it out and the problem went away. I am clueless about why it behaves as such, let me know if you have any idea.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305493,
                "title": "python3-solution-faster-than-99-74-submissions-using-dict",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153310,
                "title": "c-solution",
                "content": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "solutionTags": [],
                "code": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2504397,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424816,
                "title": "819-most-common-word",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432113,
                "title": "c-easy-and-understandable-solution-using-map-with-explanations",
                "content": "Approach:\\nFind the occurences of each word in the paragraph given and store it in a map. Then for each word in the banned vector, find if it is present in the map, delete that particular word from the map. Then iterate through each element of the map to the find the most frequent word and return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\nHope you find my solution useful and if you have any doubts or suggestions feel free to comment below.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544968,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509099,
                "title": "javascript-easy-one-pass-solution",
                "content": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```\\n\\n* 47/47 cases passed (56 ms)\\n* Your runtime beats 89.74 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468842,
                "title": "c-linq",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() })\\n\\t\\t\\t\\t.OrderByDescending(x => x.Num).First().str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() }",
                "codeTag": "Java"
            },
            {
                "id": 465703,
                "title": "python-easy-to-understand-small-code",
                "content": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463404,
                "title": "9-line-string-stream-solution-c",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 444321,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Convert to lower case, replace all punctuations\\n2. Build a hash and count the frequency\\n``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327924,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238232,
                "title": "c-solution",
                "content": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158761,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\\n*******\\nRevised solution taking into account the last test case \"a, a, a, a, b,b,b,c, c\" where there is no spacing between words. One can further do a `char_list = word.split(\",\")` after `word = word.strip(\"!?\\',;.\")`, and iterate over all words in `char_list`.\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138836,
                "title": "clean-java-8-solution-with-lamdas-and-streams",
                "content": "This solution uses simple java8 syntax. Not the fastest by design but easy to follow:\\n\\n```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "solutionTags": [],
                "code": "```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125933,
                "title": "a-clean-o-n-python-solution-with-explanation",
                "content": "Credit  for code : evdcush\\n\\nExplanation: Below steps are easily done with list comprehension\\n\\nSplit words by space in paragraph and remove all punctuations\\nCreate new paragraph containing word that are not in banned list\\nCalculate number of appereance of each word in new para and save it in a map\\nReturn the word from map with highest occurence value\\n\\n\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "solutionTags": [],
                "code": "```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3438342,
                "title": "100-beginners-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n        separate paragraph in  to String[] without non- word character\\n        add s[i] to hash map\\n        create  set and add all banned[i]\\n        Now check for max frequency of word\\n \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959634,
                "title": "beats-99-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830994,
                "title": "python-long-but-fast-memory-beats-82-67",
                "content": "# Code\\n```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b3d287b6-a400-4108-990e-93764aa592c0_1668883640.5485666.png)\\n![image.png](https://assets.leetcode.com/users/images/cc0d842d-b2e9-4124-8f29-d4579520da0e_1668883652.293298.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593807,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444390,
                "title": "stupid-but-it-works",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228491,
                "title": "easy-simple-java-solution-using-hashmap-hashset",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }\\n            }\\n        }\\n        return key;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2182514,
                "title": "python3-library-function-runtime-49ms-62-31-memory-14mb-37-05",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965850,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1883303,
                "title": "java-hashing-simple",
                "content": "The code is self explanatory, but feel free to ask any questions.\\n>**T/S:** O(m + n)/O(m + n), where m = size(paragraph), n = size(banned)\\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852243,
                "title": "c-o-n-time-unordered-map-easy-clean-code",
                "content": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```\\n\\n**Do share you suggestions & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596671,
                "title": "python-solution-all-test-cases-pass-except-the-last-one",
                "content": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```\\nAny help would really be appreciated",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581781,
                "title": "java-java-beats-100-time-and-memory-trie-solution-no-regex-or-string-split",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405371,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1352663,
                "title": "c-clear-solution-using-dictionary",
                "content": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342886,
                "title": "easiest-and-efficient-approach-newbie-friendly",
                "content": "The code is fully \\'commented\\' for your understanding. If you go through it once, I bet you will clearly understand this problem. Also very simple approach to understand as I had not used any fancy operation to reduce the code length (so that even a newbie will be able to understand this).\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```\\nHope this helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310164,
                "title": "simple-python-faster-than-98-98-and-less-than-90-27-memory",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107521,
                "title": "my-c-solution-using-map-with-comments",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }\\n            \\n        int start =0,end=0,n= paragraph.length();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            start = i;\\n            end=i;\\n            //to obtain start and end of every word\\n            while(i<n&&(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')||(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\')){\\n                i++;\\n                end++;\\n            }\\n            //to skip useless characters or spaces\\n            while(i<n&&!(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')&&!(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\'))\\n                i++;\\n            \\n            //converting every word to lowercase and inserting it into map if it is not banned\\n            string temp = paragraph.substr(start,end-start);\\n             transform(temp.begin(), temp.end(), temp.begin(), ::tolower); \\n            if(bannedset.find(temp)==bannedset.end())\\n            mp[temp]++;\\n                i--;\\n        }\\n        \\n        //finding the word with maximum frequency\\n        int commonmax = 0;\\n        string commonstr=\"\";\\n        for(auto it: mp){\\n            if(it.second>commonmax){\\n                commonstr=it.first;\\n                commonmax = it.second;\\n            }\\n        }\\n                \\n        return commonstr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 994700,
                "title": "python-less-than-99-memory-usage",
                "content": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "codeTag": "Unknown"
            },
            {
                "id": 874877,
                "title": "c-90-53-easy-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }\\n            else\\n            {\\n                if(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')\\n                    p[i]=p[i]+32;\\n                s+=p[i];\\n            }\\n        }\\n        m[s]++;\\n\\t\\t\\n        vector<pair<int,string>>v; // for sorting frequency in decsending order\\n        for(auto i=m.begin();i!=m.end();i++)\\n            v.push_back(make_pair(i->second,i->first));\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        for(auto i=v.begin();i!=v.end();i++)\\n        {\\n            if(ban.count(i->second)==0&&i->second!=\"\")\\n                return i->second;\\n        }\\n        return \"saat samundar paar me tere pichhe pichhe aa gyi \"; // control will never reach here :)\\n    }\\n\\t\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 790507,
                "title": "java-easy-solution-without-regex-95-time-and-93-storage",
                "content": "I took a set to have all the banned words and a map to keep a count of the un-banned words. I have also added \"\" as a banned word becuase there might not be any space between or extra space words. Whenever i encounter a space or other character I convert it to a string and add it into the map. \\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```\\nThank you for reading my post, if you come across any mistakes or suggestion please do let me know I will be thankful for your help. Have a great day!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635171,
                "title": "easy-python-solution-replace-split-count-sorted-and-for-loop",
                "content": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "solutionTags": [],
                "code": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "codeTag": "Unknown"
            },
            {
                "id": 628920,
                "title": "javascript-simple-solution-with-regex-85-100",
                "content": "Runtime: 56 ms, faster than 85.54% of JavaScript online submissions for Most Common Word.\\nMemory Usage: 35.4 MB, less than 100.00% of JavaScript online submissions for Most Common Word.\\n```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597636,
                "title": "swift",
                "content": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 565461,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530873,
                "title": "concise-javascript-solution-w-regexp",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485317,
                "title": "c-beats-98-transform-replace-erase-remove-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}), paragraph.end());\\n\\t\\t\\n\\t\\t// Make entire string lower case.\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n\\t\\t\\n\\t\\t// Converts string with spaces to a vector of strings without the spaces.\\n\\t\\t// Can have an arbitrary amount of spaces in between words.\\n        vector<string> ourWords = {istream_iterator<string>{istringstream() = istringstream(paragraph)},\\n                                   istream_iterator<string>{}};\\n              \\n        unordered_map<string, int> ourMap;\\n        \\n\\t\\t// Count the frequency of words.\\n        for (int i{}; i < ourWords.size(); ++i)\\n        {\\n            ourMap[ourWords[i]]++;\\n        }\\n        \\n\\t\\t// If a word is banned make its frequency 0\\n        for (int i{}; i < banned.size(); ++i)\\n        {\\n            if (ourMap.count(banned[i]))\\n            {\\n                ourMap[banned[i]] = 0;\\n            }\\n        }\\n        // Find the most frequent word.\\n        string res;\\n        int maxNum{};\\n        for (const auto& keyValue : ourMap)\\n        {\\n            if (keyValue.second > maxNum)\\n            {\\n                maxNum = keyValue.second;\\n                res = keyValue.first;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}",
                "codeTag": "Java"
            },
            {
                "id": 476194,
                "title": "easy-solution-tolower-ispunc-unordered-set-map-stringstream-c-beats-96-85",
                "content": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456818,
                "title": "python-simple-solution",
                "content": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "solutionTags": [],
                "code": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 454520,
                "title": "easy-to-understand-java-solution-16-ms",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440622,
                "title": "solution-using-hash-map",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "codeTag": "Java"
            },
            {
                "id": 389675,
                "title": "c-solution-linear-complexity-only-stl-methods",
                "content": "Algorithm is really straightforward:\\n1) Preprocess paragraph: transform all letters to lowercase, other symbols to spaces (hello, bloody 47-th test case) -- O(P), where P is paragraph size;\\n2) Compute paragraph words frequencies and store them in hash map -- O(P)\\n3) Delete banned words from hash map -- O(B)\\n4) Find element with maximal freq\\n\\n```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353016,
                "title": "simple-java-solution-using-map",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352230,
                "title": "swift-solution-clean-code-beats-99",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346981,
                "title": "swift-32ms-4-lines-of-code",
                "content": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 329448,
                "title": "python-using-counter-translate-table",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316277,
                "title": "python-solution-fix",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309775,
                "title": "rust-because-why-not-0ms-100",
                "content": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294238,
                "title": "accepted-c-simple-solution-using-uordered-map",
                "content": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 217718,
                "title": "python-1-liner-beats-91",
                "content": "Convert paragraph to lower-case. Find all word in paragraph (split it into words) omitting the punctuation marks by using ```\\\\w+``` regular expression. Count the occurences of word that are not banned and return the word with the highest count.\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```\\nTime: O(n + m) where n is the length of paragraph and m the length of banned\\nSpace: O(n + m)",
                "solutionTags": [],
                "code": "```\\\\w+```\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 207544,
                "title": "java-no-regex-simple-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124254,
                "title": "a-simple-java-solution",
                "content": "The core idea is how to use RE.\\n\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3518175,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481554,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\\n\\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139931,
                "title": "0-ms-100-faster-easy-you-understand",
                "content": "# Code\\n```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873929,
                "title": "most-common-word-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732090,
                "title": "java-solution-clean",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637819,
                "title": "easy-c-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613917,
                "title": "simple-python-solution-counter",
                "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 2549421,
                "title": "js-simple-solution-with-hashmap-and-regex",
                "content": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505584,
                "title": "python-c-java-easy-solution-using-hash-map-o-n",
                "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity :O(n)**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```\\n\\n\\n\\n\\n**Runtime: 74 ms, faster than 56.51% of Python3 online submissions for Most Common Word.\\nMemory Usage: 14 MB, less than 6.00% of Python3 online submissions for Most Common Word.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478761,
                "title": "python3-runtime-41-ms-faster-than-86-77",
                "content": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "codeTag": "Python3"
            },
            {
                "id": 2438707,
                "title": "most-common-word-easiest-solution-using-hash-map-with-proper-comments-kids-can-also-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424817,
                "title": "819-most-common-word-by-ashutosh-tomar",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }\\n                s += tolower(p[i]);\\n                i++;\\n            }\\n            if(s != \"\") m[s]++;\\n            s = \"\";\\n        }\\n        s = \"\";\\n        for(int i=0;i<b.size();i++){\\n            //s += b[i];\\n            m.erase(b[i]);\\n        }\\n        //m.erase(s);\\n        string ans = \"\";\\n        int check = 0;\\n        for(auto i : m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n        }\\n        for(auto i : m){\\n            check = max(i.second,check);\\n        }\\n        cout<<check;\\n        for(auto i : m){\\n            if(i.second == check){\\n                ans += i.first;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2408941,
                "title": "c-easy-to-understand-efficient",
                "content": "class Solution {\\npublic:\\n```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```\\n};",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347516,
                "title": "java-o-n-m-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337364,
                "title": "python-2-solutions-easy",
                "content": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "codeTag": "Java"
            },
            {
                "id": 2326791,
                "title": "100-faster-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310341,
                "title": "python-simple-hashmap",
                "content": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "solutionTags": [],
                "code": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "codeTag": "Python3"
            },
            {
                "id": 2167485,
                "title": "c-runtime-o-n-space-o-n-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115613,
                "title": "easy-python-faster-than-83",
                "content": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063672,
                "title": "simple-python-solution-o-n",
                "content": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002854,
                "title": "java-hasmap-hashset",
                "content": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949844,
                "title": "c-explained-code-very-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916788,
                "title": "python3-very-easy-yet-very-fast",
                "content": "***Runtime: 30 ms, faster than 99.86% of Python3 online submissions for Most Common Word.\\nMemory Usage: 13.9 MB, less than 40.82% of Python3 online submissions for Most Common Word.***\\n.\\n\\n**If you like this solution please upvote** \\u2714\\uD83D\\uDE80\\uD83D\\uDC96\\n```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900967,
                "title": "c",
                "content": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "solutionTags": [],
                "code": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838953,
                "title": "easiest-java-solution-beginner-level-o-m-n",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834826,
                "title": "c-easiest-solution-ever-few-lines-of-code",
                "content": "# Easy check it ;-)\\n[**@iprincekumark**](https://leetcode.com/iprincekumark/)\\n[```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```](https://leetcode.com/iprincekumark/)",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761144,
                "title": "easy-c-solution-0-ms-space-less-than-96",
                "content": "Please upvote the code if you like the content. It is always a great motivation :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734159,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696983,
                "title": "c-linq-2-lines-no-orderby-o-n-solution",
                "content": ".NET 5 doesn\\'t have ExceptBy.\\n```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673124,
                "title": "python3-53ms-runtime-17-11-memory-14-3mb-47-52",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1624949,
                "title": "4ms-faster-than-87-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }\\n            \\n            \\n            if(curr != \"\" && st.find(curr) == st.end()) \\n            mp[curr]++;\\n                \\n        } \\n        \\n        int count = 0;\\n        string res = \"\";\\n        \\n        for(auto it : mp)\\n        {\\n            if(it.second > count)\\n            {\\n                res = it.first;\\n                count = it.second;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590573,
                "title": "c-easy-solution-with-explanation",
                "content": "Here the main idea is we take all words from paragraph and store it into a map with its frequency. Here I inserted only those words which are not in banned array.\\n\\nAlgorithm :\\n* we first take a unordered_set<string>ban, where I inserted all banned elements so that I can get them in O(1) complexity.\\n* Then take a unordered map of string as a key and integer as its value.\\n* Then run a loop on paragraph\\n\\t\\t* if current character is a uppercase letter then substract 32 in it to make it lowercase(since we need lowercase words).\\n\\t\\t* if current letter is a alphabet then add it to a temporary string.\\n\\t\\t* otherwise if that temp is not banned then increase frequency in map. Here I am also maintaining a maximum frequency variable.\\n\\n* Now traverse to map and if a words frequency equals to maxfrequency then return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\nIf this post is helpful for you then please upvote. Thank you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499269,
                "title": "java-streams",
                "content": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426981,
                "title": "solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418114,
                "title": "easy-java-solution-hashmap-regex",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        stringstream ss(paragraph);\\n        string word;\\n        while(ss>>word)\\n        {ans[word]++;\\n        }\\n        int m=0;string a;\\n        for(auto i:ans){\\n            cout<<i.first<<\"- \"<<i.second<<\"\\\\n\";\\n            if(i.second>m && ban.find(i.first)==string::npos)\\n            { m=i.second;a=i.first;}\\n        }\\n        return a;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412891,
                "title": "c-regex-std-transform",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1376398,
                "title": "golang-runtime-beats-100",
                "content": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375849,
                "title": "c-1ms-runtime",
                "content": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374287,
                "title": "c-4ms-runtime-modified-from-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372545,
                "title": "c-solution-nested-stringstream-split-string-using-multiple-delimiters",
                "content": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1363990,
                "title": "ugly-but-100-faster-solution-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else if(i == paragraph.length() - 1) {\\n                if(tmp.length() > 0) {\\n                    tmp += tolower(c);\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else tmp += tolower(c);\\n        }\\n        \\n        for(string s : banned) {\\n            m.erase(s);\\n        }\\n        \\n        for(string s : tmpV) {\\n            cout << s << \" \";\\n            \\n            if(m[s] > maxfreq) {\\n                maxfreq = m[s];\\n                mostfreq = s;\\n            }\\n        }\\n    \\n        return mostfreq;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1316398,
                "title": "clean-c",
                "content": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304732,
                "title": "c-easy-understandable",
                "content": "\\t//First add the string into hashmap and then remove those string which is banned and then find the maximum frequency string from map and then return\\n\\tclass Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }else\\n            str+=paragraph[i];\\n        }\\n        unordered_map<string,int>:: iterator it;\\n        for(int i=0;i<banned.size();i++){\\n            if(freq.find(banned[i])!=freq.end()){\\n             it=freq.find(banned[i]);\\n            freq.erase(it);\\n            }\\n        }\\n        it=freq.begin();\\n            while(it!=freq.end())\\n            {\\n                  if(it->second > l){\\n                      l=it->second;\\n                      str=it->first;\\n                  }\\n                 it++;\\n            }   \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1301804,
                "title": "c-naive-approach-coicise-approach-with-comments",
                "content": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298297,
                "title": "golang-solution-faster-than-100",
                "content": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261831,
                "title": "easiest-java-solution-using-list-and-hashmap-with-steps",
                "content": "***Steps***\\n1. Convert paragraph to lowercase and string array.\\n2. Add elements that are not present in banned to hashmap.\\n3. If already present hashmap, increment value by 1.\\n4. Find max value in hashmap and return the key associated with max value.\\n\\n```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259678,
                "title": "c-approach-with-proper-comments",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }\\n        \\n        // Extract words from paragraph and store make a freq map of words\\n        \\n        stringstream ss(s);\\n        string word;\\n        unordered_map<string,int> mp;\\n      while(ss>>word){\\n          mp[word]++;\\n      }\\n        \\n    // make the freq of the banned words to 0 so that they can not be our output\\n\\n        for(auto ban:banned){\\n            mp[ban]=0;\\n        }\\n        int cnt=0;\\n        string res=\"\";\\n\\t\\t// Find the largest freq word and return the result\\n\\t\\t\\tfor(auto it:mp){\\n            if(it.second>cnt){\\n                cnt=it.second;\\n                res=it.first;\\n            }\\n        }\\n    \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240763,
                "title": "java-easy-solution",
                "content": "Approach is : \\n\\n1) Break down paragraph into words. Handled by trim, removal of fullstop,commas etc.\\n2) Store these words in a hashmap with their frequencies.\\n3) Store the banned words in a hashset for quick access.\\n4) Finally check for the words with maximum frequency in the hashmap, and which is not present in our hashset.\\n\\n```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239774,
                "title": "python3-simple-solution-using-dictionary",
                "content": "**Can be solved by both regrex or replace function**\\n```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218066,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213270,
                "title": "java-hashmap-beats-75-easy-to-understand",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160351,
                "title": "c-819-most-common-word",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145285,
                "title": "kotlin",
                "content": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Balloons",
        "question_content": "<p>Given a string <code>text</code>, you want to use the characters of <code>text</code> to form as many instances of the word <strong>&quot;balloon&quot;</strong> as possible.</p>\n\n<p>You can use each character in <code>text</code> <strong>at most once</strong>. Return the maximum number of instances that can be formed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG\" style=\"width: 132px; height: 35px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;nlaebolko&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG\" style=\"width: 267px; height: 35px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;loonbalxballpoon&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leetcode&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>text</code> consists of lower case English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 382401,
                "title": "withcomments-straightforward-java-simple-count-of-chars",
                "content": "```\\npublic int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; //count all letters\\n        for (char c : text.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1];//for b\\n        min = Math.min(min, chars[0]);//for a\\n        min = Math.min(min, chars[11] / 2);// for l /2 \\n        min = Math.min(min, chars[14] / 2);//similarly for o/2\\n        min = Math.min(min, chars[13]);//for n\\n        return min;        \\n    }\\n```\\nCoundn\\'t think of maps or any other DS :(\\nBut My space complexity is O(1) :P\\nHope you will understand :)\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; //count all letters\\n        for (char c : text.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1];//for b\\n        min = Math.min(min, chars[0]);//for a\\n        min = Math.min(min, chars[11] / 2);// for l /2 \\n        min = Math.min(min, chars[14] / 2);//similarly for o/2\\n        min = Math.min(min, chars[13]);//for n\\n        return min;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382396,
                "title": "java-python-3-count-solution-w-analysis",
                "content": "Count chars of both `text` and `balloon` and find the minimum of the times of the count of chars of `text / balloon`.\\n\\n```\\n    public int maxNumberOfBalloons(String text) {\\n        int[] cnt = new int[26], cntBaloon = new int[26];\\n        for (int i = 0; i < text.length(); ++i)\\n            ++cnt[text.charAt(i) - \\'a\\'];\\n        int min = text.length();\\n        for (char c : \"balloon\".toCharArray())\\n            ++cntBaloon[c - \\'a\\'];\\n        for (char c : \"balloon\".toCharArray())\\n            min = Math.min(min, cnt[c - \\'a\\'] / cntBaloon[c - \\'a\\']);\\n        return min;\\n    }\\n```\\n```\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = collections.Counter(text)\\n        cntBalloon = collections.Counter(\\'balloon\\')\\n        return min([cnt[c] // cntBalloon[c] for c in cntBalloon])\\n```\\n**Analysis:**\\n\\nTime: O(text.length()), space: O(1).",
                "solutionTags": [],
                "code": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int[] cnt = new int[26], cntBaloon = new int[26];\\n        for (int i = 0; i < text.length(); ++i)\\n            ++cnt[text.charAt(i) - \\'a\\'];\\n        int min = text.length();\\n        for (char c : \"balloon\".toCharArray())\\n            ++cntBaloon[c - \\'a\\'];\\n        for (char c : \"balloon\".toCharArray())\\n            min = Math.min(min, cnt[c - \\'a\\'] / cntBaloon[c - \\'a\\']);\\n        return min;\\n    }\\n```\n```\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = collections.Counter(text)\\n        cntBalloon = collections.Counter(\\'balloon\\')\\n        return min([cnt[c] // cntBalloon[c] for c in cntBalloon])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395059,
                "title": "c-3-line-solution-using-unordered-map-4ms-9mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```\\n\\n---\\n# **Suggestions listed below**\\n---\\n\\nSuggestion made by [muhammetzahitaydin](https://leetcode.com/muhammetzahitaydin/): you can use one min for return:\\n```\\nreturn min ( { mm[\\'b\\'] , mm[\\'a\\'] , mm[\\'l\\']/2 , mm[\\'o\\']/2 ,mm[\\'n\\'] } ) ;\\n```\\n\\nSuggestion made by [Body_sweep69](https://leetcode.com/body_sweep69/) to use array of size 256 instead of unordered map to reduce memory usage. [BSalwiczek](https://leetcode.com/bsalwiczek/) suggested using array of size 5 since we only care about 5 chars (b, a, l, o, n).\\n\\n---\\n\\n*suggestions added on June 29th 2020",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```\n```\\nreturn min ( { mm[\\'b\\'] , mm[\\'a\\'] , mm[\\'l\\']/2 , mm[\\'o\\']/2 ,mm[\\'n\\'] } ) ;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455926,
                "title": "python-easy-to-understand-solution-o-n-time-and-o-1-space",
                "content": "Intuitive Python Solution with O(n) time and O(1) space.\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = {\"b\":0, \"a\":0, \"l\":0, \"o\":0, \"n\":0}\\n        for char in text:\\n            if char in counter:\\n                counter[char] += 1\\n        counter[\"l\"] //= 2\\n        counter[\"o\"] //= 2\\n        return min(counter.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = {\"b\":0, \"a\":0, \"l\":0, \"o\":0, \"n\":0}\\n        for char in text:\\n            if char in counter:\\n                counter[char] += 1\\n        counter[\"l\"] //= 2\\n        counter[\"o\"] //= 2\\n        return min(counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382940,
                "title": "java-count-ballon-char-and-select-min-of-them",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        \\n        for(char ch : text.toCharArray()){\\n            switch(ch){\\n                case \\'b\\': ++b;\\n                        break;\\n                case \\'a\\': ++a;\\n                        break;\\n                case \\'l\\': ++l;\\n                        break;\\n                case \\'o\\': ++o;\\n                        break;\\n                case \\'n\\': ++n;\\n                        break;\\n            \\n            }\\n        }\\n        \\n        return Math.min(Math.min(o/2, l/2), Math.min(Math.min(b, a), n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        \\n        for(char ch : text.toCharArray()){\\n            switch(ch){\\n                case \\'b\\': ++b;\\n                        break;\\n                case \\'a\\': ++a;\\n                        break;\\n                case \\'l\\': ++l;\\n                        break;\\n                case \\'o\\': ++o;\\n                        break;\\n                case \\'n\\': ++n;\\n                        break;\\n            \\n            }\\n        }\\n        \\n        return Math.min(Math.min(o/2, l/2), Math.min(Math.min(b, a), n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948621,
                "title": "simple-solution-js",
                "content": "```\\nvar maxNumberOfBalloons = function(text) {\\n    const map = { b: 0, a: 0, l: 0, o: 0, n: 0, };\\n    \\n    for (const l of text) {\\n        map[l]++; \\n    }\\n    \\n    return Math.floor(\\n        Math.min(map.b, map.a, map.l / 2, map.o / 2, map.n)\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumberOfBalloons = function(text) {\\n    const map = { b: 0, a: 0, l: 0, o: 0, n: 0, };\\n    \\n    for (const l of text) {\\n        map[l]++; \\n    }\\n    \\n    return Math.floor(\\n        Math.min(map.b, map.a, map.l / 2, map.o / 2, map.n)\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460763,
                "title": "python-short-counter-solution-explained",
                "content": "All you need to do in this problem is to count number of each symbols, specifically `a`, `b`, `l`, `n`, `o`. Then we need to find letter with minimum frequency, but also taking into account that we need two `l` and two `o`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(26)` to keep counter.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        cnt = Counter(text)\\n        return min(cnt[\"b\"], cnt[\"a\"], cnt[\"l\"]//2, cnt[\"o\"]//2, cnt[\"n\"])\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, **please upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        cnt = Counter(text)\\n        return min(cnt[\"b\"], cnt[\"a\"], cnt[\"l\"]//2, cnt[\"o\"]//2, cnt[\"n\"])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572807,
                "title": "runtime-100-memory-usage-100-one-line-python3",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'), text.count(\\'l\\') // 2, text.count(\\'o\\') // 2, text.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'), text.count(\\'l\\') // 2, text.count(\\'o\\') // 2, text.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382763,
                "title": "python3-1-liner",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(\\'b\\'), t.count(\\'a\\'), t.count(\\'l\\') // 2, t.count(\\'o\\') // 2, t.count(\\'n\\'))\\n```\\n* For fun\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(c) // int(cnt) for c, cnt in zip(\\'balon\\', \\'11221\\'))\\n```\\n@lee215\\'s\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n          return min(t.count(c) // \\'balloon\\'.count(c) for c in \\'balon\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(\\'b\\'), t.count(\\'a\\'), t.count(\\'l\\') // 2, t.count(\\'o\\') // 2, t.count(\\'n\\'))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(c) // int(cnt) for c, cnt in zip(\\'balon\\', \\'11221\\'))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n          return min(t.count(c) // \\'balloon\\'.count(c) for c in \\'balon\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495650,
                "title": "very-simple-c-faster-then-99-99-o-1-space-with-explanation",
                "content": "```\\nIdea is to count characters using 5 variables. As in the \"balloon\"  char \\'l\\' and \\'o\\'\\noccours 2 times so at the end we will divide the total occourence of \\'l\\' and \\'o\\' with 2.\\n```\\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        int b=0, a=0, l2=0, o2=0, n=0;\\n            \\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]==\\'b\\') b++;\\n            else if(text[i]==\\'a\\') a++;\\n            else if(text[i]==\\'l\\') l2++;\\n            else if(text[i]==\\'o\\') o2++;\\n            else if(text[i]==\\'n\\') n++;\\n        }\\n        l2=l2/2;  o2=o2/2;  //both occours 2 times in the balloon\\n        int ans=min({b, a, l2, o2, n}); // min occourence of the char would be the solution\\n        return ans;\\n    }\\n```\\n\\n\\uD83D\\uDE42 ***why you guys always forget to upvote, it motivates me to make such post.***",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nIdea is to count characters using 5 variables. As in the \"balloon\"  char \\'l\\' and \\'o\\'\\noccours 2 times so at the end we will divide the total occourence of \\'l\\' and \\'o\\' with 2.\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        int b=0, a=0, l2=0, o2=0, n=0;\\n            \\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]==\\'b\\') b++;\\n            else if(text[i]==\\'a\\') a++;\\n            else if(text[i]==\\'l\\') l2++;\\n            else if(text[i]==\\'o\\') o2++;\\n            else if(text[i]==\\'n\\') n++;\\n        }\\n        l2=l2/2;  o2=o2/2;  //both occours 2 times in the balloon\\n        int ans=min({b, a, l2, o2, n}); // min occourence of the char would be the solution\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786786,
                "title": "3-approaches-easy-short-o-n-time",
                "content": "**Hope it helps. If you find it helpful, do UPVOTE. Comments are welcomed. Happy Coding!**\\n\\n**1. Using 5 variables (Best Approach)**\\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            b += (ch == \\'b\\');\\n            a += (ch == \\'a\\');\\n            l += (ch == \\'l\\');\\n            o += (ch == \\'o\\');\\n            n += (ch == \\'n\\');\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\\n\\n**2. Using Switch**\\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\' : b++; break;\\n                case \\'a\\' : a++; break;\\n                case \\'l\\' : l++; break;\\n                case \\'o\\' : o++; break;\\n                case \\'n\\' : n++; break;\\n            }\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\\n\\n**3. Using unordered_map :**\\n```\\nint maxNumberOfBalloons(string text) {\\n        string str = \"balloon\";\\n        unordered_map<char, int> str_freq, txt_freq;\\n        for (auto s : str) // Storing occurence of each letter of str in str_freq \\n            str_freq[s]++;\\n        for (auto s : text)  // Storing occurence of each letter of text in txt_freq \\n            txt_freq[s]++;\\n        int prev = txt_freq[\\'b\\']/str_freq[\\'b\\']; // no. of b in txt_freq / no. of b in str_freq\\n        for (auto e : str_freq) {\\n            int curr = txt_freq[e.first]/e.second; // finding no. of each letter in txt_freq / no. of that in str_freq \\n            prev = min(prev, curr); // minimum of the prev and current \\n        }\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            b += (ch == \\'b\\');\\n            a += (ch == \\'a\\');\\n            l += (ch == \\'l\\');\\n            o += (ch == \\'o\\');\\n            n += (ch == \\'n\\');\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\' : b++; break;\\n                case \\'a\\' : a++; break;\\n                case \\'l\\' : l++; break;\\n                case \\'o\\' : o++; break;\\n                case \\'n\\' : n++; break;\\n            }\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        string str = \"balloon\";\\n        unordered_map<char, int> str_freq, txt_freq;\\n        for (auto s : str) // Storing occurence of each letter of str in str_freq \\n            str_freq[s]++;\\n        for (auto s : text)  // Storing occurence of each letter of text in txt_freq \\n            txt_freq[s]++;\\n        int prev = txt_freq[\\'b\\']/str_freq[\\'b\\']; // no. of b in txt_freq / no. of b in str_freq\\n        for (auto e : str_freq) {\\n            int curr = txt_freq[e.first]/e.second; // finding no. of each letter in txt_freq / no. of that in str_freq \\n            prev = min(prev, curr); // minimum of the prev and current \\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382608,
                "title": "minimal-javascript-solution-with-object",
                "content": "```\\nconst maxNumberOfBalloons = text => {\\n  let obj = {}, balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] >0 && obj[\\'l\\']>1 && obj[\\'n\\']>0 && obj[\\'o\\']>1) {\\n    balloonCount++;\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n  return balloonCount;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxNumberOfBalloons = text => {\\n  let obj = {}, balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] >0 && obj[\\'l\\']>1 && obj[\\'n\\']>0 && obj[\\'o\\']>1) {\\n    balloonCount++;\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n  return balloonCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674737,
                "title": "java-solution-faster-than-74-71",
                "content": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\n        int a = 0, b = 0, l = 0, o = 0, n = 0, i = 0;\\n\\n        for (char c: text.toCharArray()){\\n            switch (c){\\n                case \\'a\\' -> a++;\\n                case \\'b\\' -> b++;\\n                case \\'l\\' -> l++;\\n                case \\'n\\' -> n++;\\n                case \\'o\\' -> o++;\\n            }\\n            if (a >= 1 && b >= 1 && n >= 1 && l >= 2 && o >= 2){\\n                i++;\\n                a -= 1; b -= 1; n -= 1; l -= 2; o -= 2;\\n            }\\n        }\\n        \\n        return i;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\n        int a = 0, b = 0, l = 0, o = 0, n = 0, i = 0;\\n\\n        for (char c: text.toCharArray()){\\n            switch (c){\\n                case \\'a\\' -> a++;\\n                case \\'b\\' -> b++;\\n                case \\'l\\' -> l++;\\n                case \\'n\\' -> n++;\\n                case \\'o\\' -> o++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 397260,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) \\n    {   \\n        char [] chars = text.toCharArray();\\n        double [] result = new double[5];\\n\\n        for(int i = 0; i < chars.length; i++)\\n        {\\n            if(chars[i] == \\'b\\')\\n            {\\n                result[0] += 1;\\n            }\\n            else if(chars[i] == \\'a\\')\\n            {\\n                result[1] += 1;\\n            }\\n            else if(chars[i] == \\'l\\')\\n            {\\n                result[2] += .5;\\n            }\\n            else if(chars[i] == \\'o\\')\\n            {\\n                result[3] += .5;\\n            }\\n            else if(chars[i] == \\'n\\')\\n            {\\n                result[4] += 1;\\n            }\\n        }\\n         \\n        Arrays.sort(result);\\n        \\n        return (int)result[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) \\n    {   \\n        char [] chars = text.toCharArray();\\n        double [] result = new double[5];\\n\\n        for(int i = 0; i < chars.length; i++)\\n        {\\n            if(chars[i] == \\'b\\')\\n            {\\n                result[0] += 1;\\n            }\\n            else if(chars[i] == \\'a\\')\\n            {\\n                result[1] += 1;\\n            }\\n            else if(chars[i] == \\'l\\')\\n            {\\n                result[2] += .5;\\n            }\\n            else if(chars[i] == \\'o\\')\\n            {\\n                result[3] += .5;\\n            }\\n            else if(chars[i] == \\'n\\')\\n            {\\n                result[4] += 1;\\n            }\\n        }\\n         \\n        Arrays.sort(result);\\n        \\n        return (int)result[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939263,
                "title": "easiest-python-o-n-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI saw multiple solutions implementing hash map here, which was also the first thing I thought about but came to think of an easier way to do this. The main thing here is to realise is that you can create the word \"balloon\" only as along as you have all the characters. For example if you have 5 of b,a,l,l,o,o but only 2 n then you can only make 2 balloon since you won\\'t have n for the next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of each letter in balloon, ie b,a,l,o,n for l and o take integer div by 2 since we need 2 characters per word\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b  = text.count(\\'b\\')\\n        a  = text.count(\\'a\\')\\n        l  = text.count(\\'l\\')//2\\n        o  = text.count(\\'o\\')//2\\n        n  = text.count(\\'n\\')\\n        \\n        return min(b,a,l,o,n)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b  = text.count(\\'b\\')\\n        a  = text.count(\\'a\\')\\n        l  = text.count(\\'l\\')//2\\n        o  = text.count(\\'o\\')//2\\n        n  = text.count(\\'n\\')\\n        \\n        return min(b,a,l,o,n)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872099,
                "title": "python-runtime-24ms-faster-than-98-25",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        strs = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n        counts = [0] * 5\\n\\n        for i in range(5):\\n            counts[i] = text.count(strs[i])\\n\\n        counts[2] = counts[2] // 2\\n        counts[3] = counts[3] // 2\\n\\n        return min(counts)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        strs = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n        counts = [0] * 5\\n\\n        for i in range(5):\\n            counts[i] = text.count(strs[i])\\n\\n        counts[2] = counts[2] // 2\\n        counts[3] = counts[3] // 2\\n\\n        return min(counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587044,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\tint[] arr = new int[5];\\n\\t\\tfor(char c : text.toCharArray()) {\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase \\'b\\' : arr[0]++; break;\\n\\t\\t\\t\\tcase \\'a\\' : arr[1]++; break;\\n\\t\\t\\t\\tcase \\'n\\' : arr[2]++; break;\\n\\t\\t\\t\\tcase \\'l\\' : arr[3]++; break;\\n\\t\\t\\t\\tcase \\'o\\' : arr[4]++; break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min1 = Math.min(Math.min(arr[0], arr[1]), arr[2]);\\n\\t\\tint min2 = Math.min(arr[3], arr[4]);\\n\\t\\treturn Math.min(min1, min2 / 2);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\tint[] arr = new int[5];\\n\\t\\tfor(char c : text.toCharArray()) {\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase \\'b\\' : arr[0]++; break;\\n\\t\\t\\t\\tcase \\'a\\' : arr[1]++; break;\\n\\t\\t\\t\\tcase \\'n\\' : arr[2]++; break;\\n\\t\\t\\t\\tcase \\'l\\' : arr[3]++; break;\\n\\t\\t\\t\\tcase \\'o\\' : arr[4]++; break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min1 = Math.min(Math.min(arr[0], arr[1]), arr[2]);\\n\\t\\tint min2 = Math.min(arr[3], arr[4]);\\n\\t\\treturn Math.min(min1, min2 / 2);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013213,
                "title": "2-line-python-using-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = collections.Counter(text)\\n        return min(c[\\'b\\'],c[\\'a\\'],c[\\'l\\']//2,c[\\'o\\']//2,c[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = collections.Counter(text)\\n        return min(c[\\'b\\'],c[\\'a\\'],c[\\'l\\']//2,c[\\'o\\']//2,c[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812956,
                "title": "4-approaches-include-hashmap-improved-version-c-best",
                "content": "\\n\\t\\t//1.Runtime: 12ms\\n\\t\\t\\n        class Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                map<char, int> M;\\n                for(auto ch : text) M[ch]++;\\n                return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n            }\\n        };\\n\\t\\t\\n        //2.Runtime: 8 ms\\n        \\n        class Solution {\\n        public:\\n                    int maxNumberOfBalloons(string text) {\\n                int b, a, l, o, n;\\n                b = a = l = o = n = 0;\\n                for (auto ch : text) {\\n                    b += (ch == \\'b\\');\\n                    a += (ch == \\'a\\');\\n                    l += (ch == \\'l\\');\\n                    o += (ch == \\'o\\');\\n                    n += (ch == \\'n\\');\\n                }\\n                return min({b, a, l/2, o/2, n});\\n            }\\n        };\\n\\t\\t\\n\\t\\t//3.improved version \\n\\t\\t//Runtime: 4 ms, faster than 98.97%\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                vector<int> map(5,0); //using only 5 indexes for b,a,l,o,n\\n                for(auto ch : text){ \\n                    if(ch==\\'b\\')\\n                        map[(ch-\\'a\\')]+=1; //(ch-\\'a\\')=98-97=1 (1st index)\\n                    else if(ch==\\'a\\')\\n                        map[(ch-\\'a\\')]+=1;//(ch-\\'a\\')=97-97=0 (0th index)\\n                    else if(ch==\\'l\\')\\n                        map[(ch-\\'a\\')-9]+=1;//(ch-\\'a\\')=108-97=11-9=2 (2nd index)\\n                    else if(ch==\\'n\\')\\n                        map[(ch-\\'a\\')-10]+=1;//(ch-\\'a\\')=110-97=13-10=3 (3rd index)\\n                    else if(ch==\\'o\\')\\n                        map[(ch-\\'a\\')-10]+=1; //(ch-\\'a\\')=111-97=14-10=4 (4th index)\\n                }\\n                return min({map[0],map[1],map[2]/2,map[3],map[4]/2});\\n            }\\n        };\\n\\t\\t\\n\\t\\t//4.using switch\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                int b, a, l, o, n;\\n                b = a = l = o = n = 0;\\n                for (auto ch : text) {\\n                    switch (ch) {\\n                        case \\'b\\' : b++; break;\\n                                case \\'a\\' : a++; break;\\n                        case \\'l\\' : l++; break;\\n                        case \\'o\\' : o++; break;\\n                        case \\'n\\' : n++; break;\\n                    }\\n                }\\n                return min({b, a, l/2, o/2, n});\\n            }\\n        };\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                map<char, int> M;\\n                for(auto ch : text) M[ch]++;\\n                return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']}",
                "codeTag": "Java"
            },
            {
                "id": 1460932,
                "title": "python-1-liner-c-simple-and-short-solutions",
                "content": "**Python:**\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\\n****\\n**C++:** \\n0 ms, faster than 100%\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\':\\n                    b++; break;\\n                case \\'a\\':\\n                    a++; break;\\n                case \\'l\\':\\n                    l++; break;\\n                case \\'o\\':\\n                    o++; break;\\n                case \\'n\\':\\n                    n++; break;\\n            }\\n        }\\n        \\n        return min({b, a, l/2, o/2, n});\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\':\\n                    b++; break;\\n                case \\'a\\':\\n                    a++; break;\\n                case \\'l\\':\\n                    l++; break;\\n                case \\'o\\':\\n                    o++; break;\\n                case \\'n\\':\\n                    n++; break;\\n            }\\n        }\\n        \\n        return min({b, a, l/2, o/2, n});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461896,
                "title": "easy-to-understand-using-hashmap-java",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        HashMap<Character,Integer> hm= new HashMap<>();\\n\\t    hm.put(\\'b\\',0);hm.put(\\'a\\',0);hm.put(\\'l\\',0);hm.put(\\'o\\',0);hm.put(\\'n\\',0);\\n\\t    for(char i:text.toCharArray()) {\\n\\t\\t    if(hm.containsKey(i)) hm.put(i, hm.get(i)+1);}\\n\\treturn(Math.min(hm.get(\\'b\\'), Math.min(hm.get(\\'a\\'), Math.min(hm.get(\\'l\\')/2, Math.min(hm.get(\\'o\\')/2,hm.get(\\'n\\'))))));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        HashMap<Character,Integer> hm= new HashMap<>();\\n\\t    hm.put(\\'b\\',0);hm.put(\\'a\\',0);hm.put(\\'l\\',0);hm.put(\\'o\\',0);hm.put(\\'n\\',0);\\n\\t    for(char i:text.toCharArray()) {\\n\\t\\t    if(hm.containsKey(i)) hm.put(i, hm.get(i)+1);}\\n\\treturn(Math.min(hm.get(\\'b\\'), Math.min(hm.get(\\'a\\'), Math.min(hm.get(\\'l\\')/2, Math.min(hm.get(\\'o\\')/2,hm.get(\\'n\\'))))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461862,
                "title": "c-1189-maximum-number-of-balloons",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461288,
                "title": "javascript-clean-simple-solution-hash-map",
                "content": "```\\nconst maxNumberOfBalloons = (text) => {\\n  let obj = {},\\n    balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] > 0 && obj[\\'l\\'] > 1 && obj[\\'n\\'] > 0 && obj[\\'o\\'] > 1) {\\n    balloonCount++;\\n\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n\\n  return balloonCount;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxNumberOfBalloons = (text) => {\\n  let obj = {},\\n    balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] > 0 && obj[\\'l\\'] > 1 && obj[\\'n\\'] > 0 && obj[\\'o\\'] > 1) {\\n    balloonCount++;\\n\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n\\n  return balloonCount;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179745,
                "title": "swift-8ms-readable-solution-beats-96",
                "content": "```swift\\nfinal class Solution {\\n\\t// O(n) time | O(1) space\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var b = 0, a = 0, l = 0, o = 0, n = 0\\n\\n        for char in text {\\n            switch char {\\n            case \"b\": b += 1\\n            case \"a\": a += 1\\n            case \"l\": l += 1\\n            case \"o\": o += 1\\n            case \"n\": n += 1\\n            default: continue\\n            }\\n        }\\n\\n        l /= 2; o /= 2 // we need 2 letters of each\\n\\n        return min(b, a, l, o, n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfinal class Solution {\\n\\t// O(n) time | O(1) space\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var b = 0, a = 0, l = 0, o = 0, n = 0\\n\\n        for char in text {\\n            switch char {\\n            case \"b\": b += 1\\n            case \"a\": a += 1\\n            case \"l\": l += 1\\n            case \"o\": o += 1\\n            case \"n\": n += 1\\n            default: continue\\n            }\\n        }\\n\\n        l /= 2; o /= 2 // we need 2 letters of each\\n\\n        return min(b, a, l, o, n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084649,
                "title": "simple-java-solution-100",
                "content": "We count the occurence of \\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\' and store them in array.\\n\\nThen divide the occurence of \\'l\\' and \\'o\\' by 2 as they occur twice in one \\'balloon\\' word.\\n\\nNow we just sort the array to get the minimum value amongst all the occurence...as it is the value needed to make a successful \\'balloon\\'.\\n\\n\\n```\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int ar[]=new int[5];\\n        \\n        for(char x:text.toCharArray()){\\n            \\n            switch(x){\\n                case \\'b\\':\\n                    ar[0]++;break;\\n                case \\'a\\':\\n                    ar[1]++;break;\\n                case \\'l\\':\\n                    ar[2]++;break;\\n                case \\'o\\':\\n                    ar[3]++;break;\\n                case \\'n\\':\\n                    ar[4]++;break;\\n            }\\n            \\n        }\\n        \\n        ar[2]/=2;\\n        ar[3]/=2;\\n        \\n        Arrays.sort(ar);\\n        \\n        return ar[0];\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int ar[]=new int[5];\\n        \\n        for(char x:text.toCharArray()){\\n            \\n            switch(x){\\n                case \\'b\\':\\n                    ar[0]++;break;\\n                case \\'a\\':\\n                    ar[1]++;break;\\n                case \\'l\\':\\n                    ar[2]++;break;\\n                case \\'o\\':\\n                    ar[3]++;break;\\n                case \\'n\\':\\n                    ar[4]++;break;\\n            }\\n            \\n        }\\n        \\n        ar[2]/=2;\\n        ar[3]/=2;\\n        \\n        Arrays.sort(ar);\\n        \\n        return ar[0];\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504526,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int> M;\\n        for(auto ch : text) M[ch]++;\\n        return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int> M;\\n        for(auto ch : text) M[ch]++;\\n        return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681289,
                "title": "python-use-counter-2-lines-my-first-solution-up-plz",
                "content": "# Approach\\nUse Counter and don\\'t worry about it\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = Counter(text)\\n        return min([cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'n\\'], cnt[\\'l\\'] // 2, cnt[\\'o\\'] // 2])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = Counter(text)\\n        return min([cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'n\\'], cnt[\\'l\\'] // 2, cnt[\\'o\\'] // 2])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244848,
                "title": "easy-python-again",
                "content": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        s = [c[\\'a\\'], c[\\'b\\'], c[\\'n\\'], c[\\'l\\'] / 2, c[\\'o\\'] / 2]\\n        return int(min(s))",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        s = [c[\\'a\\'], c[\\'b\\'], c[\\'n\\'], c[\\'l\\'] / 2, c[\\'o\\'] / 2]\\n        return int(min(s))",
                "codeTag": "Java"
            },
            {
                "id": 1115806,
                "title": "easy-python-solution-o-n-time-simple-if-else",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b = a = l = o = n = 0\\n        for i in text:\\n            if i == \\'b\\': b += 1\\n            elif i == \\'a\\': a += 1\\n            elif i == \\'l\\': l += 1\\n            elif i == \\'n\\': n += 1\\n            elif i == \\'o\\': o += 1\\n        count = 0\\n        while b and a and l and o and n:\\n            if b and a and l - 1 and o - 1 and n:\\n                count += 1\\n                b =- 1\\n                a -= 1\\n                l -= 2\\n                o -= 2\\n                n -= 1\\n            else: break\\n        return count\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b = a = l = o = n = 0\\n        for i in text:\\n            if i == \\'b\\': b += 1\\n            elif i == \\'a\\': a += 1\\n            elif i == \\'l\\': l += 1\\n            elif i == \\'n\\': n += 1\\n            elif i == \\'o\\': o += 1\\n        count = 0\\n        while b and a and l and o and n:\\n            if b and a and l - 1 and o - 1 and n:\\n                count += 1\\n                b =- 1\\n                a -= 1\\n                l -= 2\\n                o -= 2\\n                n -= 1\\n            else: break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428897,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter=collections.Counter(text)\\n        s={counter[\\'b\\'],counter[\\'a\\'],counter[\\'l\\']//2,counter[\\'o\\']//2,counter[\\'n\\']}\\n        return min(s)     \\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter=collections.Counter(text)\\n        s={counter[\\'b\\'],counter[\\'a\\'],counter[\\'l\\']//2,counter[\\'o\\']//2,counter[\\'n\\']}\\n        return min(s)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 383459,
                "title": "python-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = Counter(text)\\n        cc = Counter(\\'balloon\\')\\n        \\n        return min(c[k] // cc[k] for k in \\'balon\\')",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = Counter(text)\\n        cc = Counter(\\'balloon\\')\\n        \\n        return min(c[k] // cc[k] for k in \\'balon\\')",
                "codeTag": "Java"
            },
            {
                "id": 2746039,
                "title": "java-1-ms-faster-than-100-00",
                "content": "If you like it pls upvote\\n```\\n\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (char aChar : text.toCharArray())\\n            switch (aChar) {\\n                case \\'b\\' : b++;\\n                break;\\n                case \\'a\\' : a++;\\n                break;\\n                case \\'l\\' : l++;\\n                break;\\n                case \\'o\\' : o++;\\n                break;\\n                case \\'n\\' : n++;\\n                break;\\n            }\\n        return Math.min(Math.min(Math.min(b,a),n), Math.min(l/2,o/2));\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (char aChar : text.toCharArray())\\n            switch (aChar) {\\n                case \\'b\\' : b++;\\n                break;\\n                case \\'a\\' : a++;\\n                break;\\n                case \\'l\\' : l++;\\n                break;\\n                case \\'o\\' : o++;\\n                break;\\n                case \\'n\\' : n++;\\n                break;\\n            }\\n        return Math.min(Math.min(Math.min(b,a),n), Math.min(l/2,o/2));\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461968,
                "title": "max-number-of-balloons-easy-w-explanation-c-python3-one-liner-java",
                "content": "**IDEA**\\n\\n* Count number of each symbols, specifically `a`, `b`, `l`, `n`, `o`. \\n* Then we need to find letter with minimum frequency\\n\\t* Take into account that we need two `l` and two `o`.\\n\\n**TIME COMPLEXITY - O(N)\\nSPACE COMPLEXITY - O(26)**\\n\\n**SOLUTION**\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```\\n`Python3 One Liner`\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; \\n        for (char c : text.toCharArray()) \\n        {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1] ;\\n        min = Math.min(min, chars[0]);\\n        min = Math.min(min, chars[11] / 2); \\n        min = Math.min(min, chars[14] / 2);\\n        min = Math.min(min, chars[13]);\\n        return min;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; \\n        for (char c : text.toCharArray()) \\n        {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1] ;\\n        min = Math.min(min, chars[0]);\\n        min = Math.min(min, chars[11] / 2); \\n        min = Math.min(min, chars[14] / 2);\\n        min = Math.min(min, chars[13]);\\n        return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460887,
                "title": "python-3-two-solutions-comparison",
                "content": "Here\\'s my Python implementation:\\n**Solution #1:** CPU - 53%, Memory - 52%\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 0.5 if c in double_char else 1\\n        return int(min(word.values()))\\n```\\n**Solution #2:** CPU - 78%, Memory - 21%\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 1\\n        for c in double_char:\\n            word[c] //= 2\\n        return min(word.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 0.5 if c in double_char else 1\\n        return int(min(word.values()))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 1\\n        for c in double_char:\\n            word[c] //= 2\\n        return min(word.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440368,
                "title": "c-beats-8-83",
                "content": "# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> etalon{\\n            {\\'b\\', 1}, {\\'a\\', 1}, {\\'l\\', 2}, {\\'o\\', 2}, {\\'n\\', 1}};\\n\\n        std::map<char, int> temp {\\n            {\\'b\\', 0}, {\\'a\\', 0}, {\\'l\\', 0}, {\\'o\\', 0}, {\\'n\\', 0}};\\n        \\n        for (int i = 0; i < text.size(); i++){\\n            temp[text[i]] = temp[text[i]] + 1;\\n        }\\n        \\n        int count = 0;\\n        char* balon = \"balon\";\\n        while(true) {\\n            for (int i = 0; i < 5; i++) {\\n                temp[balon[i]] -= etalon[balon[i]];\\n                if (temp[balon[i]] < 0)\\n                    return count;\\n            }\\n            count++;\\n        }\\n    }\\n};\\n```\\nThe same code...\\n![photo_2023-04-21 11.07.03.jpeg](https://assets.leetcode.com/users/images/e6d759c3-1afe-4292-ab90-cc6b934d6ebc_1682064433.6018877.jpeg)\\n![photo_2023-04-21 11.07.07.jpeg](https://assets.leetcode.com/users/images/f3ff9517-7c03-4914-8aae-449a51943a0e_1682064454.1784246.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> etalon{\\n            {\\'b\\', 1}, {\\'a\\', 1}, {\\'l\\', 2}, {\\'o\\', 2}, {\\'n\\', 1}};\\n\\n        std::map<char, int> temp {\\n            {\\'b\\', 0}, {\\'a\\', 0}, {\\'l\\', 0}, {\\'o\\', 0}, {\\'n\\', 0}};\\n        \\n        for (int i = 0; i < text.size(); i++){\\n            temp[text[i]] = temp[text[i]] + 1;\\n        }\\n        \\n        int count = 0;\\n        char* balon = \"balon\";\\n        while(true) {\\n            for (int i = 0; i < 5; i++) {\\n                temp[balon[i]] -= etalon[balon[i]];\\n                if (temp[balon[i]] < 0)\\n                    return count;\\n            }\\n            count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938245,
                "title": "95-faster-easiest-java-solution-o-1-space-o-n-time-complexity",
                "content": "# Intuition\\n Letters occurance  \\n\\n# Approach\\nCheck count for the \\'BALON\\' inspite of \\'BALLOON\\'\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is size of string\\n- Space complexity:\\nO(1) as using constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //Store the result in only five size int array as below\\n        //BALLOON\\n        //0122334\\n        int balloon[]= new int[5];\\n\\n        //Base case, for BALLON as string it should be atleast six letter size\\n        if(text.length()<6) return 0;\\n\\n        //Check for each char and get it decided with switch case in faster way\\n        for(char k:text.toCharArray()){\\n            switch(k){\\n                case \\'b\\': balloon[0]++; break;\\n                case \\'a\\': balloon[1]++; break;\\n                case \\'l\\': balloon[2]++; break;\\n                case \\'o\\': balloon[3]++; break;\\n                case \\'n\\': balloon[4]++; break;\\n            }\\n        }\\n\\n        // Keep occurance of letter \\'L\\' and \\'O\\' as one,\\n        // so that finally for a single found, each char occurance of BALLON would be \\'BALON\\'\\n        // by changing 2 repetition of letter \\'L\\' and \\'O\\' into one by below statements\\n        balloon[2] /=2;\\n        balloon[3] /=2;\\n\\n        // If any of the occurance for letter \\'L\\' and \\'O\\' is zero or negative,\\n        // means there is no atleast one available \\'BALLON\\'\\n        if(balloon[2]<=0 || balloon[3]<=0) return 0;\\n\\n        // Assume the first char occurance as min possible \\'Ballon\\' in input string\\n        int min = balloon[0];\\n\\n        // Compare it with rest and choose the minimum\\n        for(int i=1;i<5;i++)\\n            if(balloon[i]<min)\\n                min = balloon[i];\\n        \\n        // If min value is negative or zero, means there is no atleast one available \\'BALLON\\'\\n        if(min<=0) return 0;\\n\\n        // Otherwise, return the min value for which input string contains min \\'BALLON\\'\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //Store the result in only five size int array as below\\n        //BALLOON\\n        //0122334\\n        int balloon[]= new int[5];\\n\\n        //Base case, for BALLON as string it should be atleast six letter size\\n        if(text.length()<6) return 0;\\n\\n        //Check for each char and get it decided with switch case in faster way\\n        for(char k:text.toCharArray()){\\n            switch(k){\\n                case \\'b\\': balloon[0]++; break;\\n                case \\'a\\': balloon[1]++; break;\\n                case \\'l\\': balloon[2]++; break;\\n                case \\'o\\': balloon[3]++; break;\\n                case \\'n\\': balloon[4]++; break;\\n            }\\n        }\\n\\n        // Keep occurance of letter \\'L\\' and \\'O\\' as one,\\n        // so that finally for a single found, each char occurance of BALLON would be \\'BALON\\'\\n        // by changing 2 repetition of letter \\'L\\' and \\'O\\' into one by below statements\\n        balloon[2] /=2;\\n        balloon[3] /=2;\\n\\n        // If any of the occurance for letter \\'L\\' and \\'O\\' is zero or negative,\\n        // means there is no atleast one available \\'BALLON\\'\\n        if(balloon[2]<=0 || balloon[3]<=0) return 0;\\n\\n        // Assume the first char occurance as min possible \\'Ballon\\' in input string\\n        int min = balloon[0];\\n\\n        // Compare it with rest and choose the minimum\\n        for(int i=1;i<5;i++)\\n            if(balloon[i]<min)\\n                min = balloon[i];\\n        \\n        // If min value is negative or zero, means there is no atleast one available \\'BALLON\\'\\n        if(min<=0) return 0;\\n\\n        // Otherwise, return the min value for which input string contains min \\'BALLON\\'\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461848,
                "title": "pythonic-2-liner-with-comments-o-n-time-space",
                "content": "As always, like if you found this solution helpful. \\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        # Counts the frequency of each character in text\\n        seen = collections.Counter(text)\\n        \\n        # The minimum number of Balloons can be no more than the least frequent character\\n        return min(seen[\\'b\\'], seen[\\'a\\'], seen[\\'l\\']//2, seen[\\'o\\']//2, seen[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        # Counts the frequency of each character in text\\n        seen = collections.Counter(text)\\n        \\n        # The minimum number of Balloons can be no more than the least frequent character\\n        return min(seen[\\'b\\'], seen[\\'a\\'], seen[\\'l\\']//2, seen[\\'o\\']//2, seen[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836271,
                "title": "python-methods-using-dict-counter-defaultdict",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons1(self, text):\\n        c = collections.Counter(text)\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n        \\n    def maxNumberOfBalloons2(self, text):\\n        c = collections.defaultdict(int)\\n        for item in text:\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons3(self, text):\\n        c = {}\\n        for item in text:\\n            if item not in c:\\n                c[item] = 0\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons(self, text):\\n        c = dict()\\n        for item in text:\\n            c[item] = c.get(item, 0) + 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons1(self, text):\\n        c = collections.Counter(text)\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n        \\n    def maxNumberOfBalloons2(self, text):\\n        c = collections.defaultdict(int)\\n        for item in text:\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons3(self, text):\\n        c = {}\\n        for item in text:\\n            if item not in c:\\n                c[item] = 0\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons(self, text):\\n        c = dict()\\n        for item in text:\\n            c[item] = c.get(item, 0) + 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829460,
                "title": "simple-java-solution-100-faster",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxNumberOfBalloons(String text) {\\n\\t\\t\\tint[] count = new int[26];\\n\\t\\t\\tfor(char ch : text.toCharArray()) count[ch-\\'a\\']++;\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\n\\t\\t\\tres = Math.min(res , count[\\'b\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'a\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'l\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'o\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'n\\'-\\'a\\']);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxNumberOfBalloons(String text) {\\n\\t\\t\\tint[] count = new int[26];\\n\\t\\t\\tfor(char ch : text.toCharArray()) count[ch-\\'a\\']++;\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\n\\t\\t\\tres = Math.min(res , count[\\'b\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'a\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'l\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'o\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'n\\'-\\'a\\']);\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 795493,
                "title": "java-easy-array-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[]counters = new int[\"balon\".length()];\\n        for (char c: text.toCharArray()){\\n            switch (c) {\\n                case \\'b\\':counters[0]++; break;\\n                case \\'a\\':counters[1]++; break;\\n                case \\'l\\':counters[2]++; break;\\n                case \\'o\\':counters[3]++; break;\\n                case \\'n\\':counters[4]++; break;\\n            }}\\n        \\n        int min = counters[0];\\n        for (int i=1;i<5;i++){\\n            min = Math.min(min, (i==2||i==3)?counters[i]/2:counters[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[]counters = new int[\"balon\".length()];\\n        for (char c: text.toCharArray()){\\n            switch (c) {\\n                case \\'b\\':counters[0]++; break;\\n                case \\'a\\':counters[1]++; break;\\n                case \\'l\\':counters[2]++; break;\\n                case \\'o\\':counters[3]++; break;\\n                case \\'n\\':counters[4]++; break;\\n            }}\\n        \\n        int min = counters[0];\\n        for (int i=1;i<5;i++){\\n            min = Math.min(min, (i==2||i==3)?counters[i]/2:counters[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780638,
                "title": "python-one-liner-simplest-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556647,
                "title": "go-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Number of Balloons.\\nMemory Usage: 2.2 MB, less than 100.00% of Go online submissions for Maximum Number of Balloons.\\n```\\nfunc maxNumberOfBalloons(text string) int {\\n    b,a,l,o,n := 0,0,0,0,0\\n    for _, r := range text{\\n        switch r{\\n            case \\'b\\':\\n                b++\\n            case \\'a\\':\\n                a++\\n            case \\'l\\':\\n                l++\\n            case \\'o\\':\\n                o++\\n            case \\'n\\':\\n                n++\\n        }\\n    }\\n    \\n    res := min(b, min(a,n))\\n    res = min(res, min(l/2,o/2))\\n    return res\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxNumberOfBalloons(text string) int {\\n    b,a,l,o,n := 0,0,0,0,0\\n    for _, r := range text{\\n        switch r{\\n            case \\'b\\':\\n                b++\\n            case \\'a\\':\\n                a++\\n            case \\'l\\':\\n                l++\\n            case \\'o\\':\\n                o++\\n            case \\'n\\':\\n                n++\\n        }\\n    }\\n    \\n    res := min(b, min(a,n))\\n    res = min(res, min(l/2,o/2))\\n    return res\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454346,
                "title": "python3-using-counter-from-collections",
                "content": "```\\nfrom collections import Counter as c\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        a = c(text)\\n        return min(a[\\'l\\'] // 2, a[\\'o\\'] // 2, a[\\'b\\'], a[\\'a\\'], a[\\'n\\'])\\n```\\n\\nA bit more readable:\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        count_map = collections.Counter(text)\\n        return min(count_map[\\'l\\'] >> 1, count_map[\\'o\\'] >> 1, count_map[\\'b\\'], count_map[\\'a\\'], count_map[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        a = c(text)\\n        return min(a[\\'l\\'] // 2, a[\\'o\\'] // 2, a[\\'b\\'], a[\\'a\\'], a[\\'n\\'])\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        count_map = collections.Counter(text)\\n        return min(count_map[\\'l\\'] >> 1, count_map[\\'o\\'] >> 1, count_map[\\'b\\'], count_map[\\'a\\'], count_map[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383197,
                "title": "c-and-javascript-solutions",
                "content": "**Synopsis:**\\nIn order to spell \"balloon\" we need: one ```b```, one ```a```, two ```l```, two ```o```, and one ```n```\\n* Iterate through the characters of text and count the number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n```.\\n* Divide the number of occurrences of ```l``` and ```o``` by 2 and return the minimum of the number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n```.  This minimum number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n``` is the answer because it is the \"limiting factor\" / \"bottleneck\" towards formulating another instance of \"balloon\".\\n\\n**Note:** The number of occurrences of ```l``` and ```o``` are divided by 2 in because we need twice as many ```l```\\'s and ```o```\\'s compared to ```a```\\'s, ```b```\\'s, and ```n```\\'s to formulate each instance of \"balloon\".\\n\\n**Runtime:** O(N)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<char, int>; \\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt;\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\\n\\n**C++ Supplemental:** the same counting concept can be performed with a vector of integers as the underlying data structure.  Most of the recent leetcode problems use lowercase letters, so a vector of size 123 is sufficient for storing the counts of characters \\'a\\' ( who\\'s ordinality is 97 ) to \\'z\\' ( who\\'s ordinality is 122 ).  This definitely wastes memory, but I feel that loss is outweighed by the benefit of cleaner code which doesn\\'t need to subtract by the offset \\'a\\' for a 0-based index along with a vector of size 26.  Note: only counts of letters up to \\'n\\' is needed, however, its simpler for me to remember that counting lowercase characters is as easy as 123...\\n\\n```\\nclass Solution {\\npublic:\\n    using Counter = vector<int>;\\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt(123);\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\\n\\n**Javascript:**\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (text) => {\\n  const cnt = [...text].reduce((A, ch) => {\\n    A[ch] = (A[ch] || 0) + 1;\\n    return A;\\n  }, {});\\n  return Math.floor(Math.min(cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\'])) || 0;\\n};\\n```\\n\\n**1-Liners:** just for fun...\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string S) {\\n        return min({\\n            count(S.begin(), S.end(), \\'b\\'),\\n            count(S.begin(), S.end(), \\'a\\'),\\n            count(S.begin(), S.end(), \\'l\\') / 2,\\n            count(S.begin(), S.end(), \\'o\\') / 2,\\n            count(S.begin(), S.end(), \\'n\\'),\\n        });\\n    }\\n};\\n```\\n\\n**Javascript:**\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (S) => {\\n  return Math.floor(Math.min(\\n      [...S].filter(c => c === \\'b\\').length,\\n      [...S].filter(c => c === \\'a\\').length,\\n      [...S].filter(c => c === \\'l\\').length / 2,\\n      [...S].filter(c => c === \\'o\\').length / 2,\\n      [...S].filter(c => c === \\'n\\').length,\\n  )) || 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```b```\n```a```\n```l```\n```o```\n```n```\n```b```\n```a```\n```l```\n```o```\n```n```\n```l```\n```o```\n```b```\n```a```\n```l```\n```o```\n```n```\n```b```\n```a```\n```l```\n```o```\n```n```\n```l```\n```o```\n```l```\n```o```\n```a```\n```b```\n```n```\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<char, int>; \\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt;\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using Counter = vector<int>;\\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt(123);\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (text) => {\\n  const cnt = [...text].reduce((A, ch) => {\\n    A[ch] = (A[ch] || 0) + 1;\\n    return A;\\n  }, {});\\n  return Math.floor(Math.min(cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\'])) || 0;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string S) {\\n        return min({\\n            count(S.begin(), S.end(), \\'b\\'),\\n            count(S.begin(), S.end(), \\'a\\'),\\n            count(S.begin(), S.end(), \\'l\\') / 2,\\n            count(S.begin(), S.end(), \\'o\\') / 2,\\n            count(S.begin(), S.end(), \\'n\\'),\\n        });\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (S) => {\\n  return Math.floor(Math.min(\\n      [...S].filter(c => c === \\'b\\').length,\\n      [...S].filter(c => c === \\'a\\').length,\\n      [...S].filter(c => c === \\'l\\').length / 2,\\n      [...S].filter(c => c === \\'o\\').length / 2,\\n      [...S].filter(c => c === \\'n\\').length,\\n  )) || 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382435,
                "title": "java-count-explained-easy-beats-100",
                "content": "As the order of letters is not important we can jus count them and then count number of each required character and take the min of those quantities.\\n\\nO(len(s)) for time for one pass to count each character, O(1) for memory - we use array of constant length 26. \\n\\n```\\n  public int maxNumberOfBalloons(String text) {\\n    if (text == null || text.length() < 7)\\n      return 0;\\n    int[] c = new int[26];\\n    for (char ch : text.toCharArray())\\n      c[ch - \\'a\\']++;\\n    int res = Integer.MAX_VALUE;\\n    res = Math.min(res, c[\\'b\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'a\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'l\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'o\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'n\\' - \\'a\\']);\\n    return res;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int maxNumberOfBalloons(String text) {\\n    if (text == null || text.length() < 7)\\n      return 0;\\n    int[] c = new int[26];\\n    for (char ch : text.toCharArray())\\n      c[ch - \\'a\\']++;\\n    int res = Integer.MAX_VALUE;\\n    res = Math.min(res, c[\\'b\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'a\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'l\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'o\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'n\\' - \\'a\\']);\\n    return res;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2926664,
                "title": "c-solution-using-map-fastest-solution",
                "content": "Store the number of occurrence of every character present in the string given in parameter.\\n\\nLoop over all the character of \\'balloon\\' and keep the smallest amount and return it\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> m;\\n        int res = INT_MAX;\\n        std::string balloon = \"balloon\";\\n\\n        for (auto c : text)\\n            if (c == \\'b\\' || c == \\'a\\' || c == \\'l\\' || c == \\'o\\' || c == \\'n\\' )\\n                m[c]++;\\n        for (auto c: balloon) {\\n            if (c == \\'l\\' || c == \\'o\\') {\\n                res = ( (res < m[c] / 2) ? res : m[c] / 2);\\n            } else {\\n                res = ((res < (m[c])) ? res : m[c]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> m;\\n        int res = INT_MAX;\\n        std::string balloon = \"balloon\";\\n\\n        for (auto c : text)\\n            if (c == \\'b\\' || c == \\'a\\' || c == \\'l\\' || c == \\'o\\' || c == \\'n\\' )\\n                m[c]++;\\n        for (auto c: balloon) {\\n            if (c == \\'l\\' || c == \\'o\\') {\\n                res = ( (res < m[c] / 2) ? res : m[c] / 2);\\n            } else {\\n                res = ((res < (m[c])) ? res : m[c]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625766,
                "title": "js-simple-solution-with-hashmap",
                "content": "```\\nconst BALLOON = {\\n    b: 1,\\n    a: 1,\\n    l: 2,\\n    o: 2,\\n    n: 1,\\n};\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < text.length; i++) {\\n        if (hashmap.has(text[i])) {\\n            hashmap.set(text[i], hashmap.get(text[i]) + 1);\\n        } else {\\n            hashmap.set(text[i], 1);\\n        }\\n    }\\n    \\n    let output = Infinity;\\n    const arr = Object.keys(BALLOON);\\n    for (let i = 0; i < arr.length; i++) {\\n        const character = arr[i];\\n        if (!hashmap.has(character)) return 0;\\n\\n        output = Math.min(Math.floor(hashmap.get(character)/(BALLOON[character])), output)\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst BALLOON = {\\n    b: 1,\\n    a: 1,\\n    l: 2,\\n    o: 2,\\n    n: 1,\\n};\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < text.length; i++) {\\n        if (hashmap.has(text[i])) {\\n            hashmap.set(text[i], hashmap.get(text[i]) + 1);\\n        } else {\\n            hashmap.set(text[i], 1);\\n        }\\n    }\\n    \\n    let output = Infinity;\\n    const arr = Object.keys(BALLOON);\\n    for (let i = 0; i < arr.length; i++) {\\n        const character = arr[i];\\n        if (!hashmap.has(character)) return 0;\\n\\n        output = Math.min(Math.floor(hashmap.get(character)/(BALLOON[character])), output)\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576645,
                "title": "c-3-lines-code",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> mp(26, 0);\\n        for(auto it : text) mp[it - \\'a\\']++;\\n        return min({mp[\\'b\\' - \\'a\\'], mp[\\'a\\' - \\'a\\'], mp[\\'n\\' - \\'a\\'], mp[\\'l\\' - \\'a\\'] / 2, mp[\\'o\\' - \\'a\\'] / 2});\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> mp(26, 0);\\n        for(auto it : text) mp[it - \\'a\\']++;\\n        return min({mp[\\'b\\' - \\'a\\'], mp[\\'a\\' - \\'a\\'], mp[\\'n\\' - \\'a\\'], mp[\\'l\\' - \\'a\\'] / 2, mp[\\'o\\' - \\'a\\'] / 2});\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1574357,
                "title": "python-very-easy-fast-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = collections.Counter(text)\\n        counter[\\'l\\'] //= 2\\n        counter[\\'o\\'] //= 2\\n        return min(counter[c] for c in \\'balon\\')",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = collections.Counter(text)\\n        counter[\\'l\\'] //= 2\\n        counter[\\'o\\'] //= 2\\n        return min(counter[c] for c in \\'balon\\')",
                "codeTag": "Java"
            },
            {
                "id": 1463128,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int c=0;\\n    int maxNumberOfBalloons(string t) \\n    {\\n        int n=t.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[t[i]]++;\\n        }\\n        for( int i=1;i<n;i++)\\n        {\\n            if(m[\\'b\\']>=i*1 && m[\\'a\\']>=i*1 && m[\\'l\\']>=i*2 && m[\\'o\\']>=i*2 && m[\\'n\\']>=i*1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int c=0;\\n    int maxNumberOfBalloons(string t) \\n    {\\n        int n=t.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[t[i]]++;\\n        }\\n        for( int i=1;i<n;i++)\\n        {\\n            if(m[\\'b\\']>=i*1 && m[\\'a\\']>=i*1 && m[\\'l\\']>=i*2 && m[\\'o\\']>=i*2 && m[\\'n\\']>=i*1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462409,
                "title": "two-javascript-simple-solution-hash-map-reduce-method",
                "content": "```\\n1.\\nconst maxNumberOfBalloons = function(text) {\\n   let map = {b:0, a:0, l:0, o:0, n:0};\\n   for(let char of text){\\n         map[char]++\\n   }\\n   return Math.floor(Math.min(map.b, map.a, map.l/2, map.o/2, map.n));\\n };\\n\\n2. \\nconst maxNumberOfBalloons = function(text) {\\n    let count = [...text].reduce((acc, char) => {\\n            acc[char] = ( acc[char] || 0 ) + 1;\\n            return acc;\\n    }, {});\\n    let minChar = Math.min(count[\\'b\\'], count[\\'a\\'], count[\\'l\\']/2, count[\\'o\\']/2, count[\\'n\\']);\\n    return minChar ? Math.floor(minChar) : 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n1.\\nconst maxNumberOfBalloons = function(text) {\\n   let map = {b:0, a:0, l:0, o:0, n:0};\\n   for(let char of text){\\n         map[char]++\\n   }\\n   return Math.floor(Math.min(map.b, map.a, map.l/2, map.o/2, map.n));\\n };\\n\\n2. \\nconst maxNumberOfBalloons = function(text) {\\n    let count = [...text].reduce((acc, char) => {\\n            acc[char] = ( acc[char] || 0 ) + 1;\\n            return acc;\\n    }, {});\\n    let minChar = Math.min(count[\\'b\\'], count[\\'a\\'], count[\\'l\\']/2, count[\\'o\\']/2, count[\\'n\\']);\\n    return minChar ? Math.floor(minChar) : 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461245,
                "title": "python-c-c-java-js-solutions",
                "content": "c:\\n```\\nint match_char_to_num(char chr) {\\n\\tswitch (chr)\\n\\t{\\n\\tcase \\'b\\':\\n\\t\\treturn 0;\\n\\tcase \\'a\\':\\n\\t\\treturn 1;\\n\\tcase \\'l\\':\\n\\t\\treturn 2;\\n\\tcase \\'o\\':\\n\\t\\treturn 3;\\n\\tcase \\'n\\':\\n\\t\\treturn 4;\\n\\tdefault:\\n\\t\\treturn -1;\\n\\t}\\n}\\nint maxNumberOfBalloons(char* text) {\\n\\tint count_balloons[5] = { 0,0,0,0,0 };\\n\\tint index;\\n\\tfor (int i = 0; i < strlen(text); i++) {\\n\\t\\tindex = match_char_to_num(text[i]);\\n\\t\\tif (index != -1) count_balloons[index]++;\\n\\t}\\n\\tint min = strlen(text) + 1;\\n\\tcount_balloons[2] /= 2;\\n\\tcount_balloons[3] /= 2;\\n\\tfor (int i = 0; i < 5; i++) {\\n\\t\\tif (count_balloons[i] < min) min = count_balloons[i];\\n\\t}\\n\\treturn min;\\n}\\n\\n```\\n\\nc++:\\n```\\n int maxNumberOfBalloons(string text) {\\n        int counter_balloons[5] = { 0,0,0,0,0 };\\n        string balloon = \"balon\";\\n        int index = -1;\\n        for (int i = 0; i < text.length(); i++) {\\n            index = balloon.find_first_of(text[i]);\\n            if (index != -1) counter_balloons[index]++;\\n        }\\n        counter_balloons[2] /= 2;\\n        counter_balloons[3] /= 2;\\n        int min = text.length() + 1;\\n        for (int i = 0; i < 5; i++) {\\n            if (counter_balloons[i] < min) min = counter_balloons[i];\\n        }\\n        return min;\\n    }\\n```\\n\\npython:\\n```\\n def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        counter_balloons = [0, 0, 0, 0, 0]\\n        balloon = \"balon\"\\n        for c in text:\\n            try:\\n                index = balloon.index(c)\\n                counter_balloons[index] += 1\\n            except:\\n                continue\\n        counter_balloons[2] //= 2\\n        counter_balloons[3] //= 2\\n        return min(counter_balloons)  \\n```\\n\\njava:\\n```\\n  public int maxNumberOfBalloons(String text) {\\n        int[] counter_balloons = {0, 0, 0, 0, 0};\\n         String balloon=\"balon\";\\n         int index=-1;\\n         for(int i=0; i<text.length(); i++){\\n             index=balloon.indexOf(text.charAt(i));\\n             if(index!=-1){\\n                 counter_balloons[index]++;\\n             }\\n         }\\n         counter_balloons[2]/=2;\\n         counter_balloons[3]/=2;\\n         int min=text.length()+1;\\n        for (int counter_balloon : counter_balloons) {\\n            if (counter_balloon < min) min = counter_balloon;\\n        }\\n         return min;\\n    }\\n```\\n\\njavaScript:\\n```\\nfunction maxNumberOfBalloons(text) {\\n    let counter_balloons = [0, 0, 0, 0, 0];\\n    let balloon = \"balon\";\\n    for (let i = 0; i < text.length; i++) {\\n        let index = balloon.indexOf(text[i]);\\n        if (index != -1) counter_balloons[index]++;\\n    }\\n    counter_balloons[2]= Math.floor(counter_balloons[2]/2);\\n    counter_balloons[3]= Math.floor(counter_balloons[3]/2);\\n    return Math.min.apply(Math, counter_balloons);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint match_char_to_num(char chr) {\\n\\tswitch (chr)\\n\\t{\\n\\tcase \\'b\\':\\n\\t\\treturn 0;\\n\\tcase \\'a\\':\\n\\t\\treturn 1;\\n\\tcase \\'l\\':\\n\\t\\treturn 2;\\n\\tcase \\'o\\':\\n\\t\\treturn 3;\\n\\tcase \\'n\\':\\n\\t\\treturn 4;\\n\\tdefault:\\n\\t\\treturn -1;\\n\\t}\\n}\\nint maxNumberOfBalloons(char* text) {\\n\\tint count_balloons[5] = { 0,0,0,0,0 };\\n\\tint index;\\n\\tfor (int i = 0; i < strlen(text); i++) {\\n\\t\\tindex = match_char_to_num(text[i]);\\n\\t\\tif (index != -1) count_balloons[index]++;\\n\\t}\\n\\tint min = strlen(text) + 1;\\n\\tcount_balloons[2] /= 2;\\n\\tcount_balloons[3] /= 2;\\n\\tfor (int i = 0; i < 5; i++) {\\n\\t\\tif (count_balloons[i] < min) min = count_balloons[i];\\n\\t}\\n\\treturn min;\\n}\\n\\n```\n```\\n int maxNumberOfBalloons(string text) {\\n        int counter_balloons[5] = { 0,0,0,0,0 };\\n        string balloon = \"balon\";\\n        int index = -1;\\n        for (int i = 0; i < text.length(); i++) {\\n            index = balloon.find_first_of(text[i]);\\n            if (index != -1) counter_balloons[index]++;\\n        }\\n        counter_balloons[2] /= 2;\\n        counter_balloons[3] /= 2;\\n        int min = text.length() + 1;\\n        for (int i = 0; i < 5; i++) {\\n            if (counter_balloons[i] < min) min = counter_balloons[i];\\n        }\\n        return min;\\n    }\\n```\n```\\n def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        counter_balloons = [0, 0, 0, 0, 0]\\n        balloon = \"balon\"\\n        for c in text:\\n            try:\\n                index = balloon.index(c)\\n                counter_balloons[index] += 1\\n            except:\\n                continue\\n        counter_balloons[2] //= 2\\n        counter_balloons[3] //= 2\\n        return min(counter_balloons)  \\n```\n```\\n  public int maxNumberOfBalloons(String text) {\\n        int[] counter_balloons = {0, 0, 0, 0, 0};\\n         String balloon=\"balon\";\\n         int index=-1;\\n         for(int i=0; i<text.length(); i++){\\n             index=balloon.indexOf(text.charAt(i));\\n             if(index!=-1){\\n                 counter_balloons[index]++;\\n             }\\n         }\\n         counter_balloons[2]/=2;\\n         counter_balloons[3]/=2;\\n         int min=text.length()+1;\\n        for (int counter_balloon : counter_balloons) {\\n            if (counter_balloon < min) min = counter_balloon;\\n        }\\n         return min;\\n    }\\n```\n```\\nfunction maxNumberOfBalloons(text) {\\n    let counter_balloons = [0, 0, 0, 0, 0];\\n    let balloon = \"balon\";\\n    for (let i = 0; i < text.length; i++) {\\n        let index = balloon.indexOf(text[i]);\\n        if (index != -1) counter_balloons[index]++;\\n    }\\n    counter_balloons[2]= Math.floor(counter_balloons[2]/2);\\n    counter_balloons[3]= Math.floor(counter_balloons[3]/2);\\n    return Math.min.apply(Math, counter_balloons);\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1460881,
                "title": "c-unordered-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        int ans=INT_MAX;\\n        ans=min(ans,mp[\\'b\\']);\\n        ans=min(ans,mp[\\'a\\']);\\n        ans=min(ans,mp[\\'l\\']/2);\\n        ans=min(ans,mp[\\'o\\']/2);\\n        ans=min(ans,mp[\\'n\\']);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        int ans=INT_MAX;\\n        ans=min(ans,mp[\\'b\\']);\\n        ans=min(ans,mp[\\'a\\']);\\n        ans=min(ans,mp[\\'l\\']/2);\\n        ans=min(ans,mp[\\'o\\']/2);\\n        ans=min(ans,mp[\\'n\\']);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441918,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn max_number_of_balloons(text: String) -> i32 {\\n        use std::collections::HashMap;\\n        \\n        let mut counter: HashMap<char, i32> = \"balloon\".chars().map(|c| (c, 0)).collect();\\n\\n        text.chars().for_each(|c| {\\n            counter.entry(c).and_modify(|e| *e += 1);\\n        });\\n\\n        counter\\n            .iter()\\n            .map(|(&c, &num)| num / if \"lo\".contains(c) { 2 } else { 1 })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_number_of_balloons(text: String) -> i32 {\\n        use std::collections::HashMap;\\n        \\n        let mut counter: HashMap<char, i32> = \"balloon\".chars().map(|c| (c, 0)).collect();\\n\\n        text.chars().for_each(|c| {\\n            counter.entry(c).and_modify(|e| *e += 1);\\n        });\\n\\n        counter\\n            .iter()\\n            .map(|(&c, &num)| num / if \"lo\".contains(c) { 2 } else { 1 })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276275,
                "title": "python-one-shot-code",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, s):\\n        return min(s.count(\"b\"),s.count(\"a\"),s.count(\"l\")//2,s.count(\"o\")//2,s.count(\"n\"))\\n```\\n\\nRuntime: 12 ms, faster than 99.38% of Python online submissions for Maximum Number of Balloons.\\nMemory Usage: 13.9 MB, less than 10.94% of Python online submissions for Maximum Number of Balloons.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, s):\\n        return min(s.count(\"b\"),s.count(\"a\"),s.count(\"l\")//2,s.count(\"o\")//2,s.count(\"n\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136712,
                "title": "1ms-simple-and-faster-than-100",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n      int arr[]=new int[26];\\n        for(char c : text.toCharArray()) arr[c-\\'a\\']++;\\n        arr[\\'l\\'-\\'a\\']/=2;\\n        arr[\\'o\\'-\\'a\\']/=2;\\n        int res=Integer.MAX_VALUE;\\n        char a[]=new char[]{\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\'};\\n        for(char c : a) res=Math.min(res,arr[c-\\'a\\']);\\n        return res;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n      int arr[]=new int[26];\\n        for(char c : text.toCharArray()) arr[c-\\'a\\']++;\\n        arr[\\'l\\'-\\'a\\']/=2;\\n        arr[\\'o\\'-\\'a\\']/=2;\\n        int res=Integer.MAX_VALUE;\\n        char a[]=new char[]{\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\'};\\n        for(char c : a) res=Math.min(res,arr[c-\\'a\\']);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588369,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        \\n        \\n        word = [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']\\n        \\n        dict_ = {i:0 for i in word}\\n        \\n        for i in range(len(text)):\\n            if(text[i] in dict_):\\n                dict_[text[i]] +=1\\n                \\n        \\n        l_count = dict_[\\'l\\'] // 2\\n        o_count = dict_[\\'o\\'] // 2\\n        b_count = dict_[\\'b\\']\\n        a_count = dict_[\\'a\\']\\n        n_count = dict_[\\'n\\']\\n        \\n        \\n        return min(l_count,o_count,a_count,b_count,n_count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        \\n        \\n        word = [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']\\n        \\n        dict_ = {i:0 for i in word}\\n        \\n        for i in range(len(text)):\\n            if(text[i] in dict_):\\n                dict_[text[i]] +=1\\n                \\n        \\n        l_count = dict_[\\'l\\'] // 2\\n        o_count = dict_[\\'o\\'] // 2\\n        b_count = dict_[\\'b\\']\\n        a_count = dict_[\\'a\\']\\n        n_count = dict_[\\'n\\']\\n        \\n        \\n        return min(l_count,o_count,a_count,b_count,n_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478585,
                "title": "c-no-loops-or-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int num = count(text.begin(),text.end(),\\'b\\');\\n        num = min(num,(int)count(text.begin(),text.end(),\\'a\\'));\\n        num = min(num,(int)count(text.begin(),text.end(),\\'l\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'o\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'n\\'));\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int num = count(text.begin(),text.end(),\\'b\\');\\n        num = min(num,(int)count(text.begin(),text.end(),\\'a\\'));\\n        num = min(num,(int)count(text.begin(),text.end(),\\'l\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'o\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'n\\'));\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400955,
                "title": "python-beats-98-25-12-ms-example-explanation",
                "content": "\\n```\\ndef maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        word = \"balloon\"\\n        return min(text.count(key)//word.count(key) for key in set(word))\\n```\\n\\nExample:\\nword = \"balloon\"\\nset(word) = \"balon\"\\ntext = \"nlaebolko\"\\n\\nNow for every character (ch) in set(word), it will find text.count(ch) // word.count(ch).\\nso,\\ntext.count(\\'b\\') // word.count(\\'b\\') = 1 // 1 = 1\\ntext.count(\\'a\\') // word.count(\\'a\\') = 1 // 1 = 1\\ntext.count(\\'l\\') // word.count(\\'l\\') = 2 // 2 = 1\\ntext.count(\\'o\\') // word.count(\\'o\\') = 2 // 2 = 1\\ntext.count(\\'n\\') // word.count(\\'n\\') = 1 // 1 = 1\\n\\nand then minimum of all the above calculated values. \\n\\nTime: O(26 * N) = O(N), N = length of the text. There would be at max 26 keys in set(word) and for each key we find count which iterates over whole text. \\n\\nSpace: O(1) \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        word = \"balloon\"\\n        return min(text.count(key)//word.count(key) for key in set(word))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395011,
                "title": "python-simple-solution",
                "content": "```\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = collections.Counter(text)\\n        return min(c[\"b\"], c[\"a\"], c[\"l\"] / 2, c[\"o\"] / 2, c[\"n\"])\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = collections.Counter(text)\\n        return min(c[\"b\"], c[\"a\"], c[\"l\"] / 2, c[\"o\"] / 2, c[\"n\"])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392450,
                "title": "javascript",
                "content": "```\\nvar countChars = function(str) {\\n    const map = {};\\n    for (let char of str) {\\n        map[char] = map[char] + 1 || 1;\\n    }\\n    return map;\\n}\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const chars = countChars(text);\\n    return Math.min(\\n        chars.b,\\n        chars.a,\\n        Math.floor(chars.l / 2),\\n        Math.floor(chars.o / 2),\\n        chars.n\\n    ) || 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countChars = function(str) {\\n    const map = {};\\n    for (let char of str) {\\n        map[char] = map[char] + 1 || 1;\\n    }\\n    return map;\\n}\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const chars = countChars(text);\\n    return Math.min(\\n        chars.b,\\n        chars.a,\\n        Math.floor(chars.l / 2),\\n        Math.floor(chars.o / 2),\\n        chars.n\\n    ) || 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382631,
                "title": "python-2-lines-with-counter",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        x = collections.Counter(text)\\n        return min(x[\\'b\\'], x[\\'a\\'], x[\\'l\\']//2, x[\\'o\\']//2, x[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        x = collections.Counter(text)\\n        return min(x[\\'b\\'], x[\\'a\\'], x[\\'l\\']//2, x[\\'o\\']//2, x[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658234,
                "title": "c-easy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        \\n        //time complexity - O(n)\\n        //space complexity - O(1)\\n\\n        // find the frequency for all characters in balloon string - constant time opertaion\\n        vector<int> balloonFreq(26,0);\\n        string target = \"balloon\";\\n        for(int i=0; i <target.size(); i++) {\\n            balloonFreq[target[i]-\\'a\\']++;\\n        }\\n\\n        // find the frequency for all characters in text string\\n        vector<int> textFreq(26, 0);\\n         for(int i=0; i <text.size(); i++) {\\n            textFreq[text[i]-\\'a\\']++;\\n        }\\n\\n        //find factor the divisiblity factor of the frequency of character in  text with that of balloon        \\n        \\n        vector<int> factorFreq(26, 0);\\n        int minFactor = INT_MAX;\\n        for(int i=0; i <factorFreq.size(); i++) {\\n            // case where the text string does not contain the frequency to even form balloon single time\\n            if(textFreq[i]==0 && balloonFreq[i]!=0) return 0;\\n            \\n            // case - text = bbaallloon =>\\n            //a freq 2 which means we can have max balloon string 2 times in text\\n             //b freq 2,  which means we can have max balloon string 2 times in text\\n            //l freq 3, the in target string l freq 2 , which means we now have max 1 chance to form balloon target.\\n            else if(textFreq[i]!=0 && balloonFreq[i]!=0) {\\n                factorFreq[i] = textFreq[i]/balloonFreq[i];\\n                minFactor = min(minFactor, factorFreq[i]);\\n            }\\n        }\\n\\n        return minFactor;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        \\n        //time complexity - O(n)\\n        //space complexity - O(1)\\n\\n        // find the frequency for all characters in balloon string - constant time opertaion\\n        vector<int> balloonFreq(26,0);\\n        string target = \"balloon\";\\n        for(int i=0; i <target.size(); i++) {\\n            balloonFreq[target[i]-\\'a\\']++;\\n        }\\n\\n        // find the frequency for all characters in text string\\n        vector<int> textFreq(26, 0);\\n         for(int i=0; i <text.size(); i++) {\\n            textFreq[text[i]-\\'a\\']++;\\n        }\\n\\n        //find factor the divisiblity factor of the frequency of character in  text with that of balloon        \\n        \\n        vector<int> factorFreq(26, 0);\\n        int minFactor = INT_MAX;\\n        for(int i=0; i <factorFreq.size(); i++) {\\n            // case where the text string does not contain the frequency to even form balloon single time\\n            if(textFreq[i]==0 && balloonFreq[i]!=0) return 0;\\n            \\n            // case - text = bbaallloon =>\\n            //a freq 2 which means we can have max balloon string 2 times in text\\n             //b freq 2,  which means we can have max balloon string 2 times in text\\n            //l freq 3, the in target string l freq 2 , which means we now have max 1 chance to form balloon target.\\n            else if(textFreq[i]!=0 && balloonFreq[i]!=0) {\\n                factorFreq[i] = textFreq[i]/balloonFreq[i];\\n                minFactor = min(minFactor, factorFreq[i]);\\n            }\\n        }\\n\\n        return minFactor;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561328,
                "title": "js-solution-using-map-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = function(text) {\\n    const map = {};\\n    const balloon = \\'balloon\\';\\n    let count = 0;\\n    for(let i = 0; i < text.length; i++) {\\n        map[text[i]] = map[text[i]] > 0 ? map[text[i]] + 1 : 1;\\n    }\\n\\n    while(true) {\\n        for(let i = 0; i < balloon.length; i++) {\\n            if(map[balloon[i]] > 0) {\\n                map[balloon[i]]--;\\n            } else {\\n                return count;\\n            }\\n        }\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = function(text) {\\n    const map = {};\\n    const balloon = \\'balloon\\';\\n    let count = 0;\\n    for(let i = 0; i < text.length; i++) {\\n        map[text[i]] = map[text[i]] > 0 ? map[text[i]] + 1 : 1;\\n    }\\n\\n    while(true) {\\n        for(let i = 0; i < balloon.length; i++) {\\n            if(map[balloon[i]] > 0) {\\n                map[balloon[i]]--;\\n            } else {\\n                return count;\\n            }\\n        }\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296463,
                "title": "easy-c-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<text.length();i++)\\n        mp[text[i]]++;\\n    while(1){\\n        string a=\"balloon\";\\n        int i=0,l=0;\\n for(i=0;i<a.length();i++){\\n     if(mp[a[i]]>0){\\n         mp[a[i]]--;\\n     }else{\\nl=1;\\n         break;\\n     }\\n }\\n if(i==a.length()){\\n     ans++;\\n }\\n if(l==1){\\n     break;\\n }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<text.length();i++)\\n        mp[text[i]]++;\\n    while(1){\\n        string a=\"balloon\";\\n        int i=0,l=0;\\n for(i=0;i<a.length();i++){\\n     if(mp[a[i]]>0){\\n         mp[a[i]]--;\\n     }else{\\nl=1;\\n         break;\\n     }\\n }\\n if(i==a.length()){\\n     ans++;\\n }\\n if(l==1){\\n     break;\\n }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143535,
                "title": "java-o-n-k-using-alphabet-array-solution",
                "content": "# Complexity\\n- Time complexity: O(N + K), where N - length of given String, K - number of occurences of \"balloon\".\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[] balloonAlph;\\n    public int maxNumberOfBalloons(String text) {\\n        if (text.length() < 7) return 0;\\n        int[] alphabet = new int[26];\\n        for (char c : text.toCharArray()) alphabet[c - \\'a\\']++;\\n        balloonAlph = balloonAlph == null ? createBalloonAlph() : balloonAlph;\\n        int count = 0;\\n        while (containsBalloon(alphabet)) count++;\\n        return count;\\n    }\\n\\n    private boolean containsBalloon(int[] alphabet) {\\n        for (int i = 0; i < balloonAlph.length; i++) {\\n            int count = balloonAlph[i], countA = alphabet[i];\\n            if (countA < count) return false;\\n            else alphabet[i] -= count;\\n        }\\n        return true;\\n    }\\n\\n    private int[] createBalloonAlph() {\\n        String s = \"balloon\";\\n        int[] alphabet = new int[26];\\n        for (char c : s.toCharArray()) alphabet[c - \\'a\\']++;\\n        return alphabet;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] balloonAlph;\\n    public int maxNumberOfBalloons(String text) {\\n        if (text.length() < 7) return 0;\\n        int[] alphabet = new int[26];\\n        for (char c : text.toCharArray()) alphabet[c - \\'a\\']++;\\n        balloonAlph = balloonAlph == null ? createBalloonAlph() : balloonAlph;\\n        int count = 0;\\n        while (containsBalloon(alphabet)) count++;\\n        return count;\\n    }\\n\\n    private boolean containsBalloon(int[] alphabet) {\\n        for (int i = 0; i < balloonAlph.length; i++) {\\n            int count = balloonAlph[i], countA = alphabet[i];\\n            if (countA < count) return false;\\n            else alphabet[i] -= count;\\n        }\\n        return true;\\n    }\\n\\n    private int[] createBalloonAlph() {\\n        String s = \"balloon\";\\n        int[] alphabet = new int[26];\\n        for (char c : s.toCharArray()) alphabet[c - \\'a\\']++;\\n        return alphabet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869075,
                "title": "java-hashmap-arraylist-8ms-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        if(text.length()<7) return 0;\\n        HashMap<Character,Integer> hp = new HashMap();\\n        ArrayList<Character> al = new ArrayList(Arrays.asList(\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'));\\n        \\n        for(int i=0;i<text.length();i++){\\n            char c = text.charAt(i);\\n            if(al.contains(c)){\\n                if(hp.containsKey(c)){\\n                    hp.put(c,hp.get(c)+1);\\n                }else{\\n                    hp.put(c,1);\\n                }\\n            }\\n        }\\n         for(int i=0;i<al.size();i++){\\n             if(!hp.containsKey(al.get(i))) return 0;\\n         }\\n               int min=Integer.MAX_VALUE;\\n               for(char x: hp.keySet()){\\n                 if(x==\\'l\\' || x==\\'o\\') min = Math.min(min,hp.get(x)/2);\\n                 else min = Math.min(min,hp.get(x));\\n               }\\n               for(char x: hp.keySet()){\\n                   if(hp.get(x)<min) return 0;\\n               }\\n        return min;\\n}\\n               }\\n```\\n![image](https://assets.leetcode.com/users/images/c6ae3da6-285e-430d-af3c-d4ae42deb2c8_1669966524.9816716.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        if(text.length()<7) return 0;\\n        HashMap<Character,Integer> hp = new HashMap();\\n        ArrayList<Character> al = new ArrayList(Arrays.asList(\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'));\\n        \\n        for(int i=0;i<text.length();i++){\\n            char c = text.charAt(i);\\n            if(al.contains(c)){\\n                if(hp.containsKey(c)){\\n                    hp.put(c,hp.get(c)+1);\\n                }else{\\n                    hp.put(c,1);\\n                }\\n            }\\n        }\\n         for(int i=0;i<al.size();i++){\\n             if(!hp.containsKey(al.get(i))) return 0;\\n         }\\n               int min=Integer.MAX_VALUE;\\n               for(char x: hp.keySet()){\\n                 if(x==\\'l\\' || x==\\'o\\') min = Math.min(min,hp.get(x)/2);\\n                 else min = Math.min(min,hp.get(x));\\n               }\\n               for(char x: hp.keySet()){\\n                   if(hp.get(x)<min) return 0;\\n               }\\n        return min;\\n}\\n               }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850850,
                "title": "c-o-n-easy-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0 ; i < text.length(); i++)\\n            mp[text[i]]++;\\n\\t\\t\\t\\n        int count = 0;\\n        while(mp[\\'b\\'] >= 1 and mp[\\'a\\'] >= 1 and mp[\\'l\\'] >= 2 and mp[\\'o\\'] >= 2 and mp[\\'n\\'] >= 1){\\n            count++;\\n            mp[\\'b\\']--;\\n            mp[\\'a\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'n\\']--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0 ; i < text.length(); i++)\\n            mp[text[i]]++;\\n\\t\\t\\t\\n        int count = 0;\\n        while(mp[\\'b\\'] >= 1 and mp[\\'a\\'] >= 1 and mp[\\'l\\'] >= 2 and mp[\\'o\\'] >= 2 and mp[\\'n\\'] >= 1){\\n            count++;\\n            mp[\\'b\\']--;\\n            mp[\\'a\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'n\\']--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830325,
                "title": "easiest-approach-shortest-solution-only-3-steps-beginner-friendly",
                "content": "# Only 3 Steps\\n1.  declare an hashmap, get the frequency of all char of string\\n2.  have a loop and increase the coun till u have char like \\'b\\', \\'a\\' \\'n\\' greater than 0 and char like \\'l\\' , \\'o\\' greater than 1 coz they are required twice in a balloon \\n3.  decrease them in the loop and return count after loop gets over\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char,int> m;\\n        int count = 0;\\n        for(auto it : text)m[it]++;\\n        while(m[\\'b\\'] > 0 and m[\\'a\\'] > 0 and m[\\'l\\'] > 1 and m[\\'o\\'] > 1 and m[\\'n\\'] > 0){\\n            m[\\'b\\']--;\\n            m[\\'a\\']--;\\n            m[\\'l\\']--;\\n            m[\\'l\\']--;\\n            m[\\'o\\']--;\\n            m[\\'o\\']--;\\n            m[\\'n\\']--;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n ## LIKED IT ?\\n## UPVOTE\\n\\u2728\\uD83D\\uDE80",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char,int> m;\\n        int count = 0;\\n        for(auto it : text)m[it]++;\\n        while(m[\\'b\\'] > 0 and m[\\'a\\'] > 0 and m[\\'l\\'] > 1 and m[\\'o\\'] > 1 and m[\\'n\\'] > 0){\\n            m[\\'b\\']--;\\n            m[\\'a\\']--;\\n            m[\\'l\\']--;\\n            m[\\'l\\']--;\\n            m[\\'o\\']--;\\n            m[\\'o\\']--;\\n            m[\\'n\\']--;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826438,
                "title": "java-hashmap-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>(){{\\n            put(\\'b\\', 1); put(\\'a\\', 1);\\n            put(\\'l\\', 2); put(\\'o\\', 2);\\n            put(\\'n\\', 1);\\n        }};\\n\\n        for (char c : text.toCharArray()) {\\n            if (map2.containsKey(c)) {\\n                map1.put(c, map1.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        int count = text.length();\\n\\n        for (char c : map2.keySet()) {\\n            count = Math.min(count, map1.getOrDefault(c, 0) / map2.get(c));\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n\\n// SC: O(5) => O(1) \\n// - only the letters of \"balloon\" will be stored in the maps.\\n// - size of map would never exceed 5\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>(){{\\n            put(\\'b\\', 1); put(\\'a\\', 1);\\n            put(\\'l\\', 2); put(\\'o\\', 2);\\n            put(\\'n\\', 1);\\n        }};\\n\\n        for (char c : text.toCharArray()) {\\n            if (map2.containsKey(c)) {\\n                map1.put(c, map1.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        int count = text.length();\\n\\n        for (char c : map2.keySet()) {\\n            count = Math.min(count, map1.getOrDefault(c, 0) / map2.get(c));\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n\\n// SC: O(5) => O(1) \\n// - only the letters of \"balloon\" will be stored in the maps.\\n// - size of map would never exceed 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754730,
                "title": "very-simple-c-faster-then-99-99-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n        //\"loonbalxballpoon\"    b a ll oo n     b a x y n   b a x y n b a x y n\\n\\n        //getting the frequencies of the target string\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        //getting all the frequencies of the s string\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  //all the occurence of the s string\\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            //considering multiple occurecne ones only by deviding\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n        //\"loonbalxballpoon\"    b a ll oo n     b a x y n   b a x y n b a x y n\\n\\n        //getting the frequencies of the target string\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        //getting all the frequencies of the s string\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  //all the occurence of the s string\\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            //considering multiple occurecne ones only by deviding\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389105,
                "title": "c-simple-and-clean-solution",
                "content": "**Please upvote if ti helped you !!!\\nHappy Coding :)**\\n```\\nint maxNumberOfBalloons(string text) \\n    {\\n        int count=0;\\n        map<char,int> mp;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        \\n        return min(mp[\\'b\\'],min(mp[\\'a\\'],min(mp[\\'l\\']/2,min(mp[\\'o\\']/2,mp[\\'n\\']))));\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) \\n    {\\n        int count=0;\\n        map<char,int> mp;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        \\n        return min(mp[\\'b\\'],min(mp[\\'a\\'],min(mp[\\'l\\']/2,min(mp[\\'o\\']/2,mp[\\'n\\']))));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1800282,
                "title": "maximum-number-of-balloons",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        int arr[]=new int[5];\\n        for(int i=0;i<text.length();i++){\\n            if(text.charAt(i)==\\'b\\')\\n                arr[0]=arr[0]+1;\\n             else if(text.charAt(i)==\\'a\\')\\n                arr[1]=arr[1]+1;\\n             else if(text.charAt(i)==\\'l\\')\\n                arr[2]=arr[2]+1;\\n             else if(text.charAt(i)==\\'o\\')\\n                arr[3]=arr[3]+1;\\n             else if(text.charAt(i)==\\'n\\')\\n                arr[4]=arr[4]+1;\\n        }\\n        arr[2]=arr[2]/2;\\n        arr[3]=arr[3]/2;\\n        int min=10000;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<min)\\n                min=Math.min(min,arr[i]);\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        int arr[]=new int[5];\\n        for(int i=0;i<text.length();i++){\\n            if(text.charAt(i)==\\'b\\')\\n                arr[0]=arr[0]+1;\\n             else if(text.charAt(i)==\\'a\\')\\n                arr[1]=arr[1]+1;\\n             else if(text.charAt(i)==\\'l\\')\\n                arr[2]=arr[2]+1;\\n             else if(text.charAt(i)==\\'o\\')\\n                arr[3]=arr[3]+1;\\n             else if(text.charAt(i)==\\'n\\')\\n                arr[4]=arr[4]+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1677698,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int b=count(s.begin(),s.end(),\\'b\\');\\n        int a=count(s.begin(),s.end(),\\'a\\');\\n        int l=count(s.begin(),s.end(),\\'l\\');\\n        int o=count(s.begin(),s.end(),\\'o\\');\\n        int n=count(s.begin(),s.end(),\\'n\\');\\n        \\n        vector<int> v{b,a,l/2,o/2,n};\\n        sort(v.begin(),v.end());\\n        return v.front();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int b=count(s.begin(),s.end(),\\'b\\');\\n        int a=count(s.begin(),s.end(),\\'a\\');\\n        int l=count(s.begin(),s.end(),\\'l\\');\\n        int o=count(s.begin(),s.end(),\\'o\\');\\n        int n=count(s.begin(),s.end(),\\'n\\');\\n        \\n        vector<int> v{b,a,l/2,o/2,n}",
                "codeTag": "Java"
            },
            {
                "id": 1542293,
                "title": "3-line-simple-solution-python",
                "content": "```\\n#Import Counter\\nfrom collections import Counter\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        #Use Counter to create a dictionary with count of all letters\\n\\t\\tletters = Counter(text)\\n        \\n\\t\\t#Find the minimum of all 5 letters dividing by 2 for l and o since they are used twice in the word balloon\\n        return min(letters[\\'b\\'],letters[\\'a\\'],letters[\\'l\\']//2, letters[\\'o\\']//2, letters[\\'n\\'])\\n```",
                "solutionTags": [],
                "code": "```\\n#Import Counter\\nfrom collections import Counter\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        #Use Counter to create a dictionary with count of all letters\\n\\t\\tletters = Counter(text)\\n        \\n\\t\\t#Find the minimum of all 5 letters dividing by 2 for l and o since they are used twice in the word balloon\\n        return min(letters[\\'b\\'],letters[\\'a\\'],letters[\\'l\\']//2, letters[\\'o\\']//2, letters[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516161,
                "title": "python-super-easy",
                "content": "def maxNumberOfBalloons(self, text: str) -> int:\\n        b = text.count(\\'b\\')\\n        a = text.count(\\'a\\')\\n        l = text.count(\\'l\\')//2\\n        o = text.count(\\'o\\')//2\\n        n = text.count(\\'n\\')\\n        return min(b,a,l,o,n)",
                "solutionTags": [],
                "code": "def maxNumberOfBalloons(self, text: str) -> int:\\n        b = text.count(\\'b\\')\\n        a = text.count(\\'a\\')\\n        l = text.count(\\'l\\')//2\\n        o = text.count(\\'o\\')//2\\n        n = text.count(\\'n\\')\\n        return min(b,a,l,o,n)",
                "codeTag": "Python3"
            },
            {
                "id": 1461323,
                "title": "maximum-number-of-balloons-3-line-code-c",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        unordered_map<char, int>mp;\\n        for(char x: text) mp[x]++;\\n        int x = min(min(mp[\\'o\\'],mp[\\'l\\'])/2, min(mp[\\'b\\'],min(mp[\\'a\\'],mp[\\'n\\'])));\\n        if(mp[\\'o\\'] >= 2*x && mp[\\'l\\'] >= 2*x)    return x;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        unordered_map<char, int>mp;\\n        for(char x: text) mp[x]++;\\n        int x = min(min(mp[\\'o\\'],mp[\\'l\\'])/2, min(mp[\\'b\\'],min(mp[\\'a\\'],mp[\\'n\\'])));\\n        if(mp[\\'o\\'] >= 2*x && mp[\\'l\\'] >= 2*x)    return x;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460909,
                "title": "c-single-pass-minimum-memory-solution-explained-100-time-99-space",
                "content": "This problem boils down to a frequency count, with a bit of extra logic for double words (`\\'l\\'` and `\\'o\\'`s).\\n\\nIn order to solve it, I gave myself the extra challenge of using as little memory as possible, so we will use a simple array `matches` to store the frequancy of each meaningful character we encouter and set all its values to `0`.\\n\\nWe will then proceed to parse `text` and for each character `c` that matches one of our cases, we will update `matches` accordingly.\\n\\nAfter that, we can just `return` the minimum across all the values, after remembering we need to divide by `2` the values of the frequencies of `\\'l\\'` and `\\'o\\'`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n\\t\\t// support variables\\n        int matches[5] = {};\\n\\t\\t// parsing text\\n        for (char c: text) {\\n            switch(c) {\\n                case \\'b\\':\\n                    matches[0]++;\\n                    break;\\n                case \\'a\\':\\n                    matches[1]++;\\n                    break;\\n                case \\'l\\':\\n                    matches[2]++;\\n                    break;\\n                case \\'o\\':\\n                    matches[3]++;\\n                    break;\\n                case \\'n\\':\\n                    matches[4]++;\\n                    break;\\n            }\\n        }\\n        return min(matches[0], min(matches[1], min(matches[2] >> 1, min(matches[3] >> 1, matches[4]))));\\n    }\\n};\\n```\\n\\nBut, wait a moment: all those nested `min`s might actually use a bit more memory?\\n\\nWell, regardless, I felt like playing a bit with bitwise operator a tad more, so I refactored in order to store the final result just in `matches[0]`, mindful that the only cases in which we want to divide the frequency are indexes `2` and `3`, which can are also the only one not giving us `0` when you do `i & 2`.\\n\\nAnd so I refactored the last bit, right after the loop:\\n\\n```cpp\\n        for (int i = 4; i; i--) matches[0] = min(matches[0], matches[i] >> ((i & 2) >> 1));\\n        return matches[0];\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n\\t\\t// support variables\\n        int matches[5] = {};\\n\\t\\t// parsing text\\n        for (char c: text) {\\n            switch(c) {\\n                case \\'b\\':\\n                    matches[0]++;\\n                    break;\\n                case \\'a\\':\\n                    matches[1]++;\\n                    break;\\n                case \\'l\\':\\n                    matches[2]++;\\n                    break;\\n                case \\'o\\':\\n                    matches[3]++;\\n                    break;\\n                case \\'n\\':\\n                    matches[4]++;\\n                    break;\\n            }\\n        }\\n        return min(matches[0], min(matches[1], min(matches[2] >> 1, min(matches[3] >> 1, matches[4]))));\\n    }\\n};\\n```\n```cpp\\n        for (int i = 4; i; i--) matches[0] = min(matches[0], matches[i] >> ((i & 2) >> 1));\\n        return matches[0];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460840,
                "title": "go-solution",
                "content": "```\\nfunc maxNumberOfBalloons(text string) int {\\n\\tm := [26]int{}\\n\\tfor i := range text {\\n\\t\\tm[text[i]-\\'a\\']++\\n\\t}\\n\\n\\tm[\\'l\\'-\\'a\\'] /= 2\\n\\tm[\\'o\\'-\\'a\\'] /= 2\\n\\n\\tmin := math.MaxInt32\\n\\tfor _, ch := range \"balon\" {\\n\\t\\tif s := m[ch-\\'a\\']; s < min {\\n\\t\\t\\tmin = s\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxNumberOfBalloons(text string) int {\\n\\tm := [26]int{}\\n\\tfor i := range text {\\n\\t\\tm[text[i]-\\'a\\']++\\n\\t}\\n\\n\\tm[\\'l\\'-\\'a\\'] /= 2\\n\\tm[\\'o\\'-\\'a\\'] /= 2\\n\\n\\tmin := math.MaxInt32\\n\\tfor _, ch := range \"balon\" {\\n\\t\\tif s := m[ch-\\'a\\']; s < min {\\n\\t\\t\\tmin = s\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460836,
                "title": "c-unordered-map-two-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        for(auto ch:text)\\n            mp[ch]++;\\n        \\n        /* soln 1\\n        int count=0;\\n        bool flag=true;\\n        while(flag)\\n        {\\n            if(mp[\\'b\\']>0 && mp[\\'a\\']>0 && mp[\\'l\\']>=2 && mp[\\'o\\']>=2 && mp[\\'n\\']>0)\\n            {\\n                count++;\\n                mp[\\'b\\']--;\\n                mp[\\'a\\']--;\\n                mp[\\'l\\']--;mp[\\'l\\']--;\\n                mp[\\'o\\']--;mp[\\'o\\']--;\\n                mp[\\'n\\']--;\\n            }\\n            else\\n                flag=false;\\n        }\\n        return count;\\n        */\\n        \\n        //Soln 2\\n        return min(mp[\\'b\\'], min(mp[\\'a\\'], min(mp[\\'l\\']/2, min(mp[\\'o\\']/2, mp[\\'n\\']))));\\n        \\n        \\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        for(auto ch:text)\\n            mp[ch]++;\\n        \\n        /* soln 1\\n        int count=0;\\n        bool flag=true;\\n        while(flag)\\n        {\\n            if(mp[\\'b\\']>0 && mp[\\'a\\']>0 && mp[\\'l\\']>=2 && mp[\\'o\\']>=2 && mp[\\'n\\']>0)\\n            {\\n                count++;\\n                mp[\\'b\\']--;\\n                mp[\\'a\\']--;\\n                mp[\\'l\\']--;mp[\\'l\\']--;\\n                mp[\\'o\\']--;mp[\\'o\\']--;\\n                mp[\\'n\\']--;\\n            }\\n            else\\n                flag=false;\\n        }\\n        return count;\\n        */\\n        \\n        //Soln 2\\n        return min(mp[\\'b\\'], min(mp[\\'a\\'], min(mp[\\'l\\']/2, min(mp[\\'o\\']/2, mp[\\'n\\']))));\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460795,
                "title": "max-num-of-balloons-c-o-n-runtime-explained",
                "content": "The intuition behind the solution is that the maximum number of shuffled subsequences of string *\"balloon\"* will be the minimum number of occurances of any character of the string *\"balloon\"* . So a simple traversal through the given input string *text* and keeping a count of all the usefull characters ie *\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'* . and then iterating in the map for the minimum occuring character will give us the answer. \\n\\nReason behind dividing the occurances of letter \\'l\\' and \\'o\\' is becasue they are ocuuring twice in *\\'balloon\\'*, so say if there were 7 occurances of *\\'l\\'*,then there will be maximum of 3( floor(7/2) ) *\\'balloon\\'* strings possible. \\n\\n\\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        unordered_map<char, int> letters; \\n        letters.insert({\\'b\\', 0});\\n        letters.insert({\\'a\\', 0});\\n        letters.insert({\\'l\\', 0});\\n        letters.insert({\\'o\\', 0});\\n        letters.insert({\\'n\\', 0});\\n        \\n        for(int i=0; i<text.size(); i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                case \\'a\\':\\n                case \\'l\\':\\n                case \\'o\\':\\n                case \\'n\\':\\n                    letters[text[i]]++;\\n                    break;\\n            }\\n        }\\n        \\n        letters[\\'l\\'] = letters[\\'l\\']/2;       //floor value of the division\\n        letters[\\'o\\'] = letters[\\'o\\']/2;       //floor value of the division\\n        \\n        int ans = INT_MAX; \\n        for(auto it = letters.begin(); it != letters.end(); it++)\\n            ans = min(it->second, ans);\\n        \\n        return ans;       \\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        \\n        unordered_map<char, int> letters; \\n        letters.insert({\\'b\\', 0});\\n        letters.insert({\\'a\\', 0});\\n        letters.insert({\\'l\\', 0});\\n        letters.insert({\\'o\\', 0});\\n        letters.insert({\\'n\\', 0});\\n        \\n        for(int i=0; i<text.size(); i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                case \\'a\\':\\n                case \\'l\\':\\n                case \\'o\\':\\n                case \\'n\\':\\n                    letters[text[i]]++;\\n                    break;\\n            }\\n        }\\n        \\n        letters[\\'l\\'] = letters[\\'l\\']/2;       //floor value of the division\\n        letters[\\'o\\'] = letters[\\'o\\']/2;       //floor value of the division\\n        \\n        int ans = INT_MAX; \\n        for(auto it = letters.begin(); it != letters.end(); it++)\\n            ans = min(it->second, ans);\\n        \\n        return ans;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460722,
                "title": "c-linq-two-liner",
                "content": "```csharp\\npublic int MaxNumberOfBalloons(string text)\\n{\\n    var frequencies = text.ToLookup(c => c);\\n    return \"balloon\".ToLookup(c => c).Min(g => frequencies[g.Key].Count() / g.Count());\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxNumberOfBalloons(string text)\\n{\\n    var frequencies = text.ToLookup(c => c);\\n    return \"balloon\".ToLookup(c => c).Min(g => frequencies[g.Key].Count() / g.Count());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403528,
                "title": "c-3-lines-of-code-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int>mp;\\n        for(auto &i : text)\\n            mp[i]++;\\n        return min({mp[\\'b\\'], mp[\\'a\\'], mp[\\'n\\'], mp[\\'o\\']/2, mp[\\'l\\']/2});\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int>mp;\\n        for(auto &i : text)\\n            mp[i]++;\\n        return min({mp[\\'b\\'], mp[\\'a\\'], mp[\\'n\\'], mp[\\'o\\']/2, mp[\\'l\\']/2});\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274774,
                "title": "concise-solution-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257853,
                "title": "constant-space-0-1-o-n-time-10-lines-of-code",
                "content": "``` \\nvar maxNumberOfBalloons = function(string) {\\nlet map = {\"b\":0, \"a\": 0, \"l\":0 ,\"o\":0 ,\"n\":0}; \\nfor(let i = 0; i < string.length; i++){\\n       if(map[string[i]] !== undefined){\\n        map[string[i]]++; \\n   } \\n};\\n map[\"l\"] = Math.floor(map[\"l\"] / 2)\\n map[\"o\"] = Math.floor(map[\"o\"] / 2)\\nlet allVals =  Object.values(map); \\nreturn Math.min(...allVals)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar maxNumberOfBalloons = function(string) {\\nlet map = {\"b\":0, \"a\": 0, \"l\":0 ,\"o\":0 ,\"n\":0}; \\nfor(let i = 0; i < string.length; i++){\\n       if(map[string[i]] !== undefined){\\n        map[string[i]]++; \\n   } \\n};\\n map[\"l\"] = Math.floor(map[\"l\"] / 2)\\n map[\"o\"] = Math.floor(map[\"o\"] / 2)\\nlet allVals =  Object.values(map); \\nreturn Math.min(...allVals)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235069,
                "title": "java-clean-concise-optimal-code-1ms-time-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int[] count = new int[26];\\n        \\n        for (char c : text.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        int min = count[1];\\n        min = Math.min (min, count[0]);\\n        min = Math.min (min, count[11] / 2);\\n        min = Math.min (min, count[14] / 2);\\n        min = Math.min (min, count[13]);\\n        \\n        return min;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int[] count = new int[26];\\n        \\n        for (char c : text.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        int min = count[1];\\n        min = Math.min (min, count[0]);\\n        min = Math.min (min, count[11] / 2);\\n        min = Math.min (min, count[14] / 2);\\n        min = Math.min (min, count[13]);\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228957,
                "title": "python-3-1-line-faster-than-97",
                "content": "```\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return int(min(text.count(\"b\"),text.count(\"a\"),text.count(\"l\")//2,text.count(\"o\")//2,text.count(\"n\")))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return int(min(text.count(\"b\"),text.count(\"a\"),text.count(\"l\")//2,text.count(\"o\")//2,text.count(\"n\")))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208118,
                "title": "easy-to-understand-and-efficient-solution-98",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n      b = text.count(\"b\")\\n      a = text.count(\"a\")\\n      l = text.count(\"l\")//2\\n      o = text.count(\"o\")//2\\n      n = text.count(\"n\")\\n      \\n            \\n      \\n      return min(b,a,l,o,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n      b = text.count(\"b\")\\n      a = text.count(\"a\")\\n      l = text.count(\"l\")//2\\n      o = text.count(\"o\")//2\\n      n = text.count(\"n\")\\n      \\n            \\n      \\n      return min(b,a,l,o,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169080,
                "title": "very-easy-java-solution",
                "content": "Very Easy Java Solution \\nHope this helps!!\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] letters = new int[5];\\n        int count = 0;\\n        \\n        for (int i = 0; i < text.length(); i++){\\n            if(text.charAt(i) == \\'b\\'){letters[0]++; }\\n            if(text.charAt(i) == \\'a\\'){letters[1]++; }\\n            if(text.charAt(i) == \\'l\\'){letters[2]++; }\\n            if(text.charAt(i) == \\'o\\'){letters[3]++; }\\n            if(text.charAt(i) == \\'n\\'){letters[4]++; }\\n        }\\n        \\n        while(letters[0]>=1 && letters[1]>=1 && letters[2]>=2 && letters[3]>=2 && letters[4] >= 1){\\n            count++;\\n            letters[0]--;\\n            letters[1]--;\\n            letters[2]-=2;\\n            letters[3]-=2;\\n            letters[4]--;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nThe array is just used to represent the number of the specific characters are found in the string.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] letters = new int[5];\\n        int count = 0;\\n        \\n        for (int i = 0; i < text.length(); i++){\\n            if(text.charAt(i) == \\'b\\'){letters[0]++; }\\n            if(text.charAt(i) == \\'a\\'){letters[1]++; }\\n            if(text.charAt(i) == \\'l\\'){letters[2]++; }\\n            if(text.charAt(i) == \\'o\\'){letters[3]++; }\\n            if(text.charAt(i) == \\'n\\'){letters[4]++; }\\n        }\\n        \\n        while(letters[0]>=1 && letters[1]>=1 && letters[2]>=2 && letters[3]>=2 && letters[4] >= 1){\\n            count++;\\n            letters[0]--;\\n            letters[1]--;\\n            letters[2]-=2;\\n            letters[3]-=2;\\n            letters[4]--;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082563,
                "title": "python3-94-lesser-memory-dictionary-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        temp = Counter(text)\\n        mini = sys.maxsize\\n        b = temp[\\'b\\']\\n        mini = min(b,mini)\\n        b = temp[\\'a\\']\\n        mini = min(b,mini)\\n        b = temp[\\'n\\']\\n        mini = min(b,mini)\\n        b = int(temp[\\'l\\']/2)\\n        mini = min(b,mini)\\n        b = int(temp[\\'o\\']/2)\\n        mini = min(b,mini)\\n        return mini\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        temp = Counter(text)\\n        mini = sys.maxsize\\n        b = temp[\\'b\\']\\n        mini = min(b,mini)\\n        b = temp[\\'a\\']\\n        mini = min(b,mini)\\n        b = temp[\\'n\\']\\n        mini = min(b,mini)\\n        b = int(temp[\\'l\\']/2)\\n        mini = min(b,mini)\\n        b = int(temp[\\'o\\']/2)\\n        mini = min(b,mini)\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993909,
                "title": "easy-clear-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int occ[26]={0};\\n        int n=s.size();\\n        for(int i=0;i<n;i++)occ[s[i]-\\'a\\']++;\\n        return min({\\n            occ[\\'b\\'-\\'a\\'],occ[\\'a\\'-\\'a\\'],occ[\\'n\\'-\\'a\\'],occ[\\'l\\'-\\'a\\']/2,occ[\\'o\\'-\\'a\\']/2\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int occ[26]={0};\\n        int n=s.size();\\n        for(int i=0;i<n;i++)occ[s[i]-\\'a\\']++;\\n        return min({\\n            occ[\\'b\\'-\\'a\\'],occ[\\'a\\'-\\'a\\'],occ[\\'n\\'-\\'a\\'],occ[\\'l\\'-\\'a\\']/2,occ[\\'o\\'-\\'a\\']/2\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984363,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        l=[]\\n        l.append(text.count(\\'b\\'))\\n        l.append(text.count(\\'a\\'))\\n        l.append(text.count(\\'l\\')//2)\\n        l.append(text.count(\\'o\\')//2)\\n        l.append(text.count(\\'n\\'))\\n        return(min(l))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        l=[]\\n        l.append(text.count(\\'b\\'))\\n        l.append(text.count(\\'a\\'))\\n        l.append(text.count(\\'l\\')//2)\\n        l.append(text.count(\\'o\\')//2)\\n        l.append(text.count(\\'n\\'))\\n        return(min(l))",
                "codeTag": "Java"
            },
            {
                "id": 971378,
                "title": "python-easy-soln",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = set(\"balloon\")\\n\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char, 0)\\n        for char in text:\\n            if char in d:\\n                d[char] = d.get(char) + 1\\n        \\n        return min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'], d[\\'l\\']/2, d[\\'o\\']/2)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = set(\"balloon\")\\n\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 948456,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        text = collections.Counter(text)\\n        return min(text[ch] // 2 if ch in \"lo\" else text[ch] for ch in \"balon\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        text = collections.Counter(text)\\n        return min(text[ch] // 2 if ch in \"lo\" else text[ch] for ch in \"balon\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893294,
                "title": "c-94",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(const string& text) {\\n        vector<int> v(5);\\n        for(auto i:text)\\n            switch(i) {\\n                case\\'b\\': ++v[0]; break;\\n                case\\'a\\': ++v[1]; break;\\n                case\\'l\\': ++v[2]; break;\\n                case\\'o\\': ++v[3]; break;\\n                case\\'n\\': ++v[4]; break;\\n            }\\n        v[2]/=2;\\n        v[3]/=2;\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(const string& text) {\\n        vector<int> v(5);\\n        for(auto i:text)\\n            switch(i) {\\n                case\\'b\\': ++v[0]; break;\\n                case\\'a\\': ++v[1]; break;\\n                case\\'l\\': ++v[2]; break;\\n                case\\'o\\': ++v[3]; break;\\n                case\\'n\\': ++v[4]; break;\\n            }\\n        v[2]/=2;\\n        v[3]/=2;\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888372,
                "title": "explained-easy-c-4ms-top-96",
                "content": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        //if length of string will be less than 7 letters then it will be impossible to make the string \"balloon\" .\\n        if(text.length() < 7){return 0 ;}\\n        \\n       // taking a empty array to store occurance of letters \\n        int a[5] = {0,0,0,0,0} ;\\n        //checking for each alphabet if present \\n        for(char chars : text){\\n            if(chars == \\'b\\' ){\\n                a[0]++ ;\\n            }\\n            if(chars == \\'a\\' ){\\n                a[1]++ ;\\n            }\\n            if(chars == \\'l\\' ){\\n                a[2]++ ;\\n            }\\n            if(chars == \\'o\\' ){\\n                a[3]++ ;\\n            }\\n            if(chars == \\'n\\' ){\\n                a[4]++ ;\\n            }\\n            \\n        }\\n        //taking a integer variable answer to store the answer\\n        int answer = INT_MAX ;\\n        \\n        // checking occurence of letters \\'l\\' and \\'o\\'\\n        a[2] = int(a[2]/2) ; \\n        a[3] = int(a[3]/2) ;\\n        \\n        //checking the number of time \\'balloon\\' occurs\\n        for(int i = 0 ; i < 5 ; i++ ){\\n            if(answer > a[i]){\\n                answer = a[i] ;\\n            }\\n        }\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        //if length of string will be less than 7 letters then it will be impossible to make the string \"balloon\" .\\n        if(text.length() < 7){return 0 ;}",
                "codeTag": "Java"
            },
            {
                "id": 870946,
                "title": "fastest-and-easiest-with-one-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int f[26]={};          //frequency array\\n        \\n        for(int i=0;i<text.size();i++)\\n            f[text[i]-\\'a\\']++;\\n\\n        return min({f[0],f[1],f[11]/2,f[13],f[14]/2});     //returning the minimum no of words that can be made\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int f[26]={};          //frequency array\\n        \\n        for(int i=0;i<text.size();i++)\\n            f[text[i]-\\'a\\']++;\\n\\n        return min({f[0],f[1],f[11]/2,f[13],f[14]/2});     //returning the minimum no of words that can be made\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860372,
                "title": "python-solution-easy",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0}\\n        for item in text:\\n            if item in (\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'):\\n                d[item] += 1\\n        if len(d) < 5 or d[\\'l\\'] == 1 or d[\\'o\\'] == 1:\\n            return 0\\n        d[\\'l\\'] = int(d[\\'l\\'] / 2)\\n        d[\\'o\\'] = int(d[\\'o\\'] / 2)\\n        return min(d.values())",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 817755,
                "title": "python3-simple-dictionary-implementation",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        h=dict({\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0})\\n        for i in text: \\n            if i in [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']:\\n                h[i]+=1\\n        h[\\'o\\']//=2\\n        h[\\'l\\']//=2\\n        return min(h.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        h=dict({\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0})\\n        for i in text: \\n            if i in [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']:\\n                h[i]+=1\\n        h[\\'o\\']//=2\\n        h[\\'l\\']//=2\\n        return min(h.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800629,
                "title": "java-faster-than-100-commented-easy-code",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //0-num B\\'s, 1-num L\\'s, 2-num A\\'s, 3-num O\\'s, 4-num N\\'s\\n        //L\\'s and O\\'s are odd indexes (only double letters)\\n        int[] balloon = new int[5];\\n        \\n        for(char c: text.toCharArray()){\\n            switch(c){\\n                case \\'b\\':\\n                    balloon[0]++;\\n                    break;\\n                case \\'l\\':\\n                    balloon[1]++;\\n                    break;\\n                case \\'a\\':\\n                    balloon[2]++;\\n                    break;\\n                case \\'o\\':\\n                    balloon[3]++;\\n                    break;\\n                case \\'n\\':\\n                    balloon[4]++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        int min = balloon[0];\\n        for(int i=1; i<balloon.length; i++){\\n            int num = balloon[i];\\n            if(i%2!=0) num/=2;\\n            if(num < min) min = num;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //0-num B\\'s, 1-num L\\'s, 2-num A\\'s, 3-num O\\'s, 4-num N\\'s\\n        //L\\'s and O\\'s are odd indexes (only double letters)\\n        int[] balloon = new int[5];\\n        \\n        for(char c: text.toCharArray()){\\n            switch(c){\\n                case \\'b\\':\\n                    balloon[0]++;\\n                    break;\\n                case \\'l\\':\\n                    balloon[1]++;\\n                    break;\\n                case \\'a\\':\\n                    balloon[2]++;\\n                    break;\\n                case \\'o\\':\\n                    balloon[3]++;\\n                    break;\\n                case \\'n\\':\\n                    balloon[4]++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        int min = balloon[0];\\n        for(int i=1; i<balloon.length; i++){\\n            int num = balloon[i];\\n            if(i%2!=0) num/=2;\\n            if(num < min) min = num;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781802,
                "title": "python3-98-25-faster",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        balloon_dict = {}\\n        balloon_dict[\\'b\\'] = text.count(\\'b\\')\\n        balloon_dict[\\'a\\'] = text.count(\\'a\\')\\n        balloon_dict[\\'l\\'] = text.count(\\'l\\')\\n        balloon_dict[\\'o\\'] = text.count(\\'o\\')\\n        balloon_dict[\\'n\\'] = text.count(\\'n\\')\\n  \\n        \\n        return min(balloon_dict[\\'b\\'], balloon_dict[\\'a\\'], balloon_dict[\\'l\\'] // 2, balloon_dict[\\'o\\'] // 2, balloon_dict[\\'n\\'])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        balloon_dict = {}\\n        balloon_dict[\\'b\\'] = text.count(\\'b\\')\\n        balloon_dict[\\'a\\'] = text.count(\\'a\\')\\n        balloon_dict[\\'l\\'] = text.count(\\'l\\')\\n        balloon_dict[\\'o\\'] = text.count(\\'o\\')\\n        balloon_dict[\\'n\\'] = text.count(\\'n\\')\\n  \\n        \\n        return min(balloon_dict[\\'b\\'], balloon_dict[\\'a\\'], balloon_dict[\\'l\\'] // 2, balloon_dict[\\'o\\'] // 2, balloon_dict[\\'n\\'])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 762459,
                "title": "java-char-count",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] count = new int[26];\\n        for(int i = 0; i < text.length(); i ++) \\n            count[text.charAt(i) - 97] ++ ;\\n        int b = count[1], a = count[0], l = count[11] / 2, o = count[14] / 2, n = count[13];\\n        int ba = Math.min(b, a), lo = Math.min(l, o);\\n        int balo = Math.min(ba, lo);\\n        return Math.min(balo, n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] count = new int[26];\\n        for(int i = 0; i < text.length(); i ++) \\n            count[text.charAt(i) - 97] ++ ;\\n        int b = count[1], a = count[0], l = count[11] / 2, o = count[14] / 2, n = count[13];\\n        int ba = Math.min(b, a), lo = Math.min(l, o);\\n        int balo = Math.min(ba, lo);\\n        return Math.min(balo, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742842,
                "title": "java-hashset-and-map",
                "content": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int res = Integer.MAX_VALUE;\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> dbl = Set.of(\\'l\\', \\'o\\'), single = Set.of(\\'b\\', \\'a\\', \\'n\\'), all = Set.of(\\'b\\', \\'a\\', \\'n\\', \\'l\\', \\'o\\');\\n        for (char c : text.toCharArray()) {\\n            if (all.contains(c)) map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : single) {\\n            res = Math.min(res, map.getOrDefault(c, 0));\\n        }\\n        for (char c : dbl) {\\n            res = Math.min(res, map.getOrDefault(c, 0) / 2);\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int res = Integer.MAX_VALUE;\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> dbl = Set.of(\\'l\\', \\'o\\'), single = Set.of(\\'b\\', \\'a\\', \\'n\\'), all = Set.of(\\'b\\', \\'a\\', \\'n\\', \\'l\\', \\'o\\');\\n        for (char c : text.toCharArray()) {\\n            if (all.contains(c)) map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : single) {\\n            res = Math.min(res, map.getOrDefault(c, 0));\\n        }\\n        for (char c : dbl) {\\n            res = Math.min(res, map.getOrDefault(c, 0) / 2);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717864,
                "title": "c-o-n-time-o-1-space-8-ms",
                "content": "***Runtime: 8 ms, faster than 69.88% of C++ online submissions for Maximum Number of Balloons.\\nMemory Usage: 6.7 MB, less than 61.43% of C++ online submissions for Maximum Number of Balloons.***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b_count = 0,a_count = 0,l_count = 0,o_count = 0,n_count = 0;\\n        for(char& ch:text){\\n            switch(ch){\\n                case \\'b\\' : b_count++;   break;\\n                case \\'a\\' : a_count++;   break;\\n                case \\'o\\' : o_count++;   break;\\n                case \\'l\\' : l_count++;   break;\\n                case \\'n\\' : n_count++;   break;\\n            }\\n        }\\n        return min(b_count,min(min(a_count, n_count),min(l_count,o_count)/2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b_count = 0,a_count = 0,l_count = 0,o_count = 0,n_count = 0;\\n        for(char& ch:text){\\n            switch(ch){\\n                case \\'b\\' : b_count++;   break;\\n                case \\'a\\' : a_count++;   break;\\n                case \\'o\\' : o_count++;   break;\\n                case \\'l\\' : l_count++;   break;\\n                case \\'n\\' : n_count++;   break;\\n            }\\n        }\\n        return min(b_count,min(min(a_count, n_count),min(l_count,o_count)/2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704716,
                "title": "java-simple-1ms-o-n-faster-than-100-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] map=new int[26];\\n        for(char c:text.toCharArray()){\\n            map[c-\\'a\\']++;\\n        }\\n        return Math.min(map[\\'b\\'-\\'a\\'], Math.min(map[\\'a\\'-\\'a\\'], Math.min(map[\\'n\\'-\\'a\\'], Math.min(map[\\'l\\'-\\'a\\']/2, map[\\'o\\'-\\'a\\']/2))));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] map=new int[26];\\n        for(char c:text.toCharArray()){\\n            map[c-\\'a\\']++;\\n        }\\n        return Math.min(map[\\'b\\'-\\'a\\'], Math.min(map[\\'a\\'-\\'a\\'], Math.min(map[\\'n\\'-\\'a\\'], Math.min(map[\\'l\\'-\\'a\\']/2, map[\\'o\\'-\\'a\\']/2))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658342,
                "title": "python-87-77-hash-table-int",
                "content": "```\\ndef maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\': 0, \\'a\\': 0, \\'l\\': 0, \\'o\\': 0, \\'n\\': 0}\\n    \\n     \\n        for e in text:\\n            if e in d:\\n                if e == \\'l\\' or e == \\'o\\':\\n                    d[e] += 0.5\\n                else:\\n                    d[e] += 1\\n        \\n        return int(min(d.values()))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\': 0, \\'a\\': 0, \\'l\\': 0, \\'o\\': 0, \\'n\\': 0}\\n    \\n     \\n        for e in text:\\n            if e in d:\\n                if e == \\'l\\' or e == \\'o\\':\\n                    d[e] += 0.5\\n                else:\\n                    d[e] += 1\\n        \\n        return int(min(d.values()))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 640096,
                "title": "short-and-simple-c-solution",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> v(5,0);\\n        for(int i:text){\\n            if(i==\\'b\\') ++v[0];\\n            if(i==\\'a\\') ++v[1];            \\n            if(i==\\'n\\') ++v[2];\\n            if(i==\\'o\\') ++v[3];\\n            if(i==\\'l\\') ++v[4];           \\n        }\\n        return min(*min_element(v.begin(),v.begin()+3),min(v[3],v[4])/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> v(5,0);\\n        for(int i:text){\\n            if(i==\\'b\\') ++v[0];\\n            if(i==\\'a\\') ++v[1];            \\n            if(i==\\'n\\') ++v[2];\\n            if(i==\\'o\\') ++v[3];\\n            if(i==\\'l\\') ++v[4];           \\n        }\\n        return min(*min_element(v.begin(),v.begin()+3),min(v[3],v[4])/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588524,
                "title": "c-simple-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map <char, int> m;\\n        for(char c : text) m[c]++;\\n        int cnt = std::min(m[\\'b\\'], m[\\'a\\']);\\n        cnt = std::min(m[\\'l\\']/2, m[\\'o\\']/2);\\n        cnt = std::min(cnt, m[\\'n\\']);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map <char, int> m;\\n        for(char c : text) m[c]++;\\n        int cnt = std::min(m[\\'b\\'], m[\\'a\\']);\\n        cnt = std::min(m[\\'l\\']/2, m[\\'o\\']/2);\\n        cnt = std::min(cnt, m[\\'n\\']);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566035,
                "title": "simple-and-intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = {}\\n        for l in text:\\n            c[l] = c.get(l, 0) +1\\n        return min(c.get(\\'b\\', 0),\\n                   c.get(\\'a\\', 0), \\n                   c.get(\\'n\\', 0), \\n                   c.get(\\'l\\', 0)//2, \\n                   c.get(\\'o\\', 0)//2)\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = {}\\n        for l in text:\\n            c[l] = c.get(l, 0) +1\\n        return min(c.get(\\'b\\', 0),\\n                   c.get(\\'a\\', 0), \\n                   c.get(\\'n\\', 0), \\n                   c.get(\\'l\\', 0)//2, \\n                   c.get(\\'o\\', 0)//2)\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 518449,
                "title": "java-generic-solution-for-any-search-string",
                "content": "```\\nclass Solution {\\n    \\n    public int maxNumberOfBalloons(String text){\\n\\n        //you can replace any string to be searched here or pass as parameter\\n        String str = \"balloon\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        //populate only search string chars from text string\\n        for (int i = 0; i < text.length(); i++) {\\n            char ch = text.charAt(i);\\n            if (str.indexOf(ch) >= 0) {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        //populate map for searchString to require get frequency of each char\\n        Map<Character, Integer> strMap = new HashMap<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n            strMap.put(ch, strMap.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        //find min words can be made from text string chars\\n        for (Map.Entry<Character, Integer> entry : strMap.entrySet()) {\\n\\n            char key = entry.getKey();\\n            int value = entry.getValue();\\n\\n            if (!map.containsKey(key))\\n                return 0;\\n\\n            int occurValue = map.get(key);\\n\\n            if (occurValue / value < min) {\\n                min = occurValue / value;\\n            }\\n\\n        }\\n        return min;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxNumberOfBalloons(String text){\\n\\n        //you can replace any string to be searched here or pass as parameter\\n        String str = \"balloon\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        //populate only search string chars from text string\\n        for (int i = 0; i < text.length(); i++) {\\n            char ch = text.charAt(i);\\n            if (str.indexOf(ch) >= 0) {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        //populate map for searchString to require get frequency of each char\\n        Map<Character, Integer> strMap = new HashMap<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n            strMap.put(ch, strMap.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        //find min words can be made from text string chars\\n        for (Map.Entry<Character, Integer> entry : strMap.entrySet()) {\\n\\n            char key = entry.getKey();\\n            int value = entry.getValue();\\n\\n            if (!map.containsKey(key))\\n                return 0;\\n\\n            int occurValue = map.get(key);\\n\\n            if (occurValue / value < min) {\\n                min = occurValue / value;\\n            }\\n\\n        }\\n        return min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498937,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for(char c : text.toCharArray()) {\\n            if(c == \\'b\\') b++;\\n            else if(c == \\'a\\') a++;\\n            else if(c == \\'l\\') l++;\\n            else if(c == \\'o\\') o++;\\n            else if(c == \\'n\\') n++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        res = Math.min(res, b);\\n        res = Math.min(res, a);\\n        res = Math.min(res, l / 2);\\n        res = Math.min(res, o / 2);\\n        res = Math.min(res, n);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for(char c : text.toCharArray()) {\\n            if(c == \\'b\\') b++;\\n            else if(c == \\'a\\') a++;\\n            else if(c == \\'l\\') l++;\\n            else if(c == \\'o\\') o++;\\n            else if(c == \\'n\\') n++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        res = Math.min(res, b);\\n        res = Math.min(res, a);\\n        res = Math.min(res, l / 2);\\n        res = Math.min(res, o / 2);\\n        res = Math.min(res, n);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470320,
                "title": "js-100-t-100-s-o-n-t-o-1-s-adaptable-and-commented-solution",
                "content": "For O(n) time complexity: Even though there is a nested loop, the number of iterations equals the length of the text. For O(1) space complexity, we can use a 26-length array for any size input string, so space is constant.\\n\\nI could definitely see the follow up question being \"How do we adapt this solution to match a given string other than balloon?\" So I used a variable instead of a string literal, like `\"balloon\".split(\\'\\')...`\\n\\n```\\nvar maxNumberOfBalloons = function(text) {\\n    // Use a variable so we can easily change the \"balloon\" string (or could just use a target param if given)\\n    const target = \"balloon\";\\n    \\n    // Edge cases \\n    if (text.length < target.length) return 0;\\n    \\n    // Use a 26 length array to keep track of character counts\\n    let countByCharArr = Array(26).fill(0);\\n    \\n    // Load character counts into arr\\n    text.split(\\'\\').forEach( char => countByCharArr[char.charCodeAt(0)-97]++);\\n    \\n    // Only iterate for the possible number of balloons based on length\\n    const maxTargetMatches = text.length / target.length;\\n    \\n    // Decrement, returning if there are no target characters left (use var so you can return the count outside of the for-loop block scope)\\n    for (var count = 0; count < maxTargetMatches; count++){\\n        if (target.split(\\'\\').some( char => 0 > --countByCharArr[char.charCodeAt(0)-97])){\\n            return count;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumberOfBalloons = function(text) {\\n    // Use a variable so we can easily change the \"balloon\" string (or could just use a target param if given)\\n    const target = \"balloon\";\\n    \\n    // Edge cases \\n    if (text.length < target.length) return 0;\\n    \\n    // Use a 26 length array to keep track of character counts\\n    let countByCharArr = Array(26).fill(0);\\n    \\n    // Load character counts into arr\\n    text.split(\\'\\').forEach( char => countByCharArr[char.charCodeAt(0)-97]++);\\n    \\n    // Only iterate for the possible number of balloons based on length\\n    const maxTargetMatches = text.length / target.length;\\n    \\n    // Decrement, returning if there are no target characters left (use var so you can return the count outside of the for-loop block scope)\\n    for (var count = 0; count < maxTargetMatches; count++){\\n        if (target.split(\\'\\').some( char => 0 > --countByCharArr[char.charCodeAt(0)-97])){\\n            return count;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467938,
                "title": "concise-100-rust-solution",
                "content": "**Solution 1:**\\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tlet mut T = vec![0; 5];\\n\\tfor ch in s.chars() {\\n\\t\\tmatch ch {\\n\\t\\t\\t\\'b\\' => T[0] += 2,\\n\\t\\t\\t\\'a\\' => T[1] += 2,\\n\\t\\t\\t\\'l\\' => T[2] += 1,\\n\\t\\t\\t\\'o\\' => T[3] += 1,\\n\\t\\t\\t\\'n\\' => T[4] += 2,\\n\\t\\t\\t_ => (),\\n\\t\\t}\\n\\t}\\n\\t*T.iter().min().unwrap() / 2\\n}\\n```\\n\\n**Solution 1:**\\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tfn idx(ch: char) -> usize { ch as usize - 97 }\\n\\tlet mut T = vec![0; 26];\\n\\tfor ch in s.chars() {\\n\\t\\tT[idx(ch)] += 1;\\n\\t}\\n\\t*vec![T[idx(\\'b\\')], T[idx(\\'a\\')], T[idx(\\'l\\')] / 2, T[idx(\\'o\\')] / 2, T[idx(\\'n\\')]]\\n\\t\\t.iter().min().unwrap()\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tlet mut T = vec![0; 5];\\n\\tfor ch in s.chars() {\\n\\t\\tmatch ch {\\n\\t\\t\\t\\'b\\' => T[0] += 2,\\n\\t\\t\\t\\'a\\' => T[1] += 2,\\n\\t\\t\\t\\'l\\' => T[2] += 1,\\n\\t\\t\\t\\'o\\' => T[3] += 1,\\n\\t\\t\\t\\'n\\' => T[4] += 2,\\n\\t\\t\\t_ => (),\\n\\t\\t}\\n\\t}\\n\\t*T.iter().min().unwrap() / 2\\n}\\n```\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tfn idx(ch: char) -> usize { ch as usize - 97 }\\n\\tlet mut T = vec![0; 26];\\n\\tfor ch in s.chars() {\\n\\t\\tT[idx(ch)] += 1;\\n\\t}\\n\\t*vec![T[idx(\\'b\\')], T[idx(\\'a\\')], T[idx(\\'l\\')] / 2, T[idx(\\'o\\')] / 2, T[idx(\\'n\\')]]\\n\\t\\t.iter().min().unwrap()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459519,
                "title": "c",
                "content": "```\\npublic int MaxNumberOfBalloons(string text) {\\n\\tvar freqs = text.ToCharArray().GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\tif (\"balon\".Any(c => !freqs.ContainsKey(c))) return 0;\\n\\tvar balon = new[] { freqs[\\'b\\'], freqs[\\'a\\'], freqs[\\'l\\'] / 2, freqs[\\'o\\'] / 2, freqs[\\'n\\'] };\\n\\treturn balon.Min();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxNumberOfBalloons(string text) {\\n\\tvar freqs = text.ToCharArray().GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\tif (\"balon\".Any(c => !freqs.ContainsKey(c))) return 0;\\n\\tvar balon = new[] { freqs[\\'b\\'], freqs[\\'a\\'], freqs[\\'l\\'] / 2, freqs[\\'o\\'] / 2, freqs[\\'n\\'] };\\n\\treturn balon.Min();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434417,
                "title": "c-100-run-time-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n  // 100% runtime, 100% memory\\n  static int maxNumberOfBalloons(string text) {\\n    vector<int> mp(26, 0);\\n    for (char s : text)\\n      if (s == \\'b\\' || s == \\'a\\' || s == \\'l\\' || s == \\'o\\' || s == \\'n\\')\\n        ++mp[s - \\'a\\'];\\n\\n    int ans = 10000;\\n    for (auto s : \"balon\")\\n      if (s == \\'l\\' || s == \\'o\\')\\n        ans = min(ans, mp[s - \\'a\\'] / 2);\\n      else if (s != \\'\\\\0\\')\\n        ans = min(ans, mp[s - \\'a\\']);\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  // 100% runtime, 100% memory\\n  static int maxNumberOfBalloons(string text) {\\n    vector<int> mp(26, 0);\\n    for (char s : text)\\n      if (s == \\'b\\' || s == \\'a\\' || s == \\'l\\' || s == \\'o\\' || s == \\'n\\')\\n        ++mp[s - \\'a\\'];\\n\\n    int ans = 10000;\\n    for (auto s : \"balon\")\\n      if (s == \\'l\\' || s == \\'o\\')\\n        ans = min(ans, mp[s - \\'a\\'] / 2);\\n      else if (s != \\'\\\\0\\')\\n        ans = min(ans, mp[s - \\'a\\']);\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430778,
                "title": "python-simple-beats-99-67time-and-100pct-space",
                "content": "```class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = collections.Counter(text) \\n        bans = min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'])  # we need 1 of these letters for every word\\n        los = min(d[\\'l\\'], d[\\'o\\'])  # we need 2 of these for every word\\n        counter = 0\\n        while bans>=1 and los>=2: #while we have at least one ban and 2 los, increment count\\n            counter+=1\\n            bans-=1 \\n            los-=2 \\n        return counter",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = collections.Counter(text) \\n        bans = min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'])  # we need 1 of these letters for every word\\n        los = min(d[\\'l\\'], d[\\'o\\'])  # we need 2 of these for every word\\n        counter = 0\\n        while bans>=1 and los>=2: #while we have at least one ban and 2 los, increment count\\n            counter+=1\\n            bans-=1 \\n            los-=2 \\n        return counter",
                "codeTag": "Java"
            },
            {
                "id": 404872,
                "title": "python-1-liner-super-easy-to-understand",
                "content": "```\\ndic = Counter(string)\\nreturn min(dic[\\'b\\'], dic[\\'a\\'], dic[\\'l\\'] // 2, dic[\\'o\\'] // 2, dic[\\'n\\'])\\n```",
                "solutionTags": [],
                "code": "```\\ndic = Counter(string)\\nreturn min(dic[\\'b\\'], dic[\\'a\\'], dic[\\'l\\'] // 2, dic[\\'o\\'] // 2, dic[\\'n\\'])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396008,
                "title": "beautiful-scala-solution-1-liner",
                "content": "I love functional programming <3\\n```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)) \\n                  .map(p => text.count(_ == p._1) / p._2)\\n                  .min;\\n}\\n```\\nThe one-liner (although it looks much less beautiful):\\n```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)).map(p => text.count(_ == p._1) / p._2).min;\\n}",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)) \\n                  .map(p => text.count(_ == p._1) / p._2)\\n                  .min;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 389464,
                "title": "c-o-n",
                "content": "```\\npublic class Solution {\\n    public int MaxNumberOfBalloons(string text) {\\n        text = text.ToLower();\\n        \\n        int b=0, a=0, l=0, o=0, n=0;\\n        \\n        for(var i = 0; i< text.Length; i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                    b++;\\n                    break;\\n                case \\'a\\':\\n                    a++;\\n                    break;\\n                case \\'l\\':\\n                    l++;\\n                    break;\\n                case \\'n\\':\\n                    n++;\\n                    break;\\n                case \\'o\\':\\n                    o++;\\n                    break;\\n            }\\n        }\\n        \\n        l = l/2;\\n        o = o/2;\\n        \\n        //find min\\n        var min = Math.Min(b, Math.Min(a,Math.Min(l, Math.Min(o,n))));\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxNumberOfBalloons(string text) {\\n        text = text.ToLower();\\n        \\n        int b=0, a=0, l=0, o=0, n=0;\\n        \\n        for(var i = 0; i< text.Length; i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                    b++;\\n                    break;\\n                case \\'a\\':\\n                    a++;\\n                    break;\\n                case \\'l\\':\\n                    l++;\\n                    break;\\n                case \\'n\\':\\n                    n++;\\n                    break;\\n                case \\'o\\':\\n                    o++;\\n                    break;\\n            }\\n        }\\n        \\n        l = l/2;\\n        o = o/2;\\n        \\n        //find min\\n        var min = Math.Min(b, Math.Min(a,Math.Min(l, Math.Min(o,n))));\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388762,
                "title": "short-simple-python",
                "content": "Self-explainatory:\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cb= text.count(\\'b\\')\\n        ca= text.count(\\'a\\')\\n        cl= text.count(\\'l\\')\\n        co= text.count(\\'o\\')\\n        cn= text.count(\\'n\\')\\n        return(min(cb,ca,cl//2,co//2,cn))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cb= text.count(\\'b\\')\\n        ca= text.count(\\'a\\')\\n        cl= text.count(\\'l\\')\\n        co= text.count(\\'o\\')\\n        cn= text.count(\\'n\\')\\n        return(min(cb,ca,cl//2,co//2,cn))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383012,
                "title": "python-with",
                "content": "```\\n   def maxNumberOfBalloons(self, text: str) -> int:\\n        c,b = Counter(text), Counter(\"balloon\")\\n\\n        res = 0\\n        while b == c & b:\\n            res += 1\\n            c = c-b\\n\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\n   def maxNumberOfBalloons(self, text: str) -> int:\\n        c,b = Counter(text), Counter(\"balloon\")\\n\\n        res = 0\\n        while b == c & b:\\n            res += 1\\n            c = c-b\\n\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 382464,
                "title": "java-solution-using-count-array-beats-100-runtime-and-memory",
                "content": "```\\n\\n\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int ans=0;\\n    char count[]=new char[26];\\n        for(int i=0;i<text.length();i++){\\n            count[text.charAt(i)-\\'a\\']++;\\n        }\\n        String res=\"balloon\";\\n        while(true){\\n        for(int i=0;i<res.length();i++){\\n          if (count[res.charAt(i) - \\'a\\']-- <= 0) \\n                return ans;\\n            \\n        }\\n            ans++;\\n        }\\n        \\n    }\\n}\\n ```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int ans=0;\\n    char count[]=new char[26];\\n        for(int i=0;i<text.length();i++){\\n            count[text.charAt(i)-\\'a\\']++;\\n        }\\n        String res=\"balloon\";\\n        while(true){\\n        for(int i=0;i<res.length();i++){\\n          if (count[res.charAt(i) - \\'a\\']-- <= 0) \\n                return ans;\\n            \\n        }\\n            ans++;\\n        }\\n        \\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 382369,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Solution1**\\nIt will be the min of frequencies of `[b,a,n]` or half of freqncies of `[l,o]`.\\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        int count = 10000;\\n        for(char ch : \"balloon\".toCharArray()){\\n            if(ch == \\'l\\' || ch == \\'o\\')\\n                count = Math.min(count, freq[ch-\\'a\\']/2);\\n            else\\n                count = Math.min(count, freq[ch-\\'a\\']);\\n        }\\n        return count;\\n    }\\n```\\n**Solution2**\\nRecord frequencies of all chars. Now, from `freq` array keep taking out required chars of \"balloon\" and stop when we can\\'t form \"balloon\" \\n(i.e `freq` of some char from it will be <= 0).\\n\\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int count = 0;\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        while(true){\\n            for(char ch : \"balloon\".toCharArray()){\\n                if(freq[ch-\\'a\\'] <= 0)\\n                    return count;\\n                else\\n                    freq[ch-\\'a\\']--;\\n            }\\n            ++count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxNumberOfBalloons(String s) {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        int count = 10000;\\n        for(char ch : \"balloon\".toCharArray()){\\n            if(ch == \\'l\\' || ch == \\'o\\')\\n                count = Math.min(count, freq[ch-\\'a\\']/2);\\n            else\\n                count = Math.min(count, freq[ch-\\'a\\']);\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int count = 0;\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        while(true){\\n            for(char ch : \"balloon\".toCharArray()){\\n                if(freq[ch-\\'a\\'] <= 0)\\n                    return count;\\n                else\\n                    freq[ch-\\'a\\']--;\\n            }\\n            ++count;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041638,
                "title": "hashmap-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nWe will use HashMap tosolve this problem\\n# Approach\\nFirst we create HashSet to store each char of \"balloon\" to make O(1) checking if char from text is char from \"balloon\". Next we populate HashMap with count of chars that is in HashSet, next we iterate over our HashMap and find minimum count of each char, for \"l\" and \"o\", we divide it by 2 and floor it, and at the end we return min count.\\n# Complexity\\n- Time complexity:\\nO(n) -> we iterate 3n but discard constants\\n- Space complexity:\\nO(1) -> we use constant HashSet and constant HashMap\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        // declare HashSet to store word \"balloon\"\\n        Set<Character> map =  new HashSet();\\n        // declare our word balloon\\n        String baloon = \"balloon\";\\n        // iterate over balloon word:\\n        for(int i = 0; i < baloon.length(); i++) {\\n            // store each character in HashSet\\n            map.add(baloon.charAt(i));\\n        }\\n        // declare HashMap to calculate count\\n        Map<Character, Integer> hash = new HashMap();\\n        // iterate over text string:\\n        for(int i = 0; i < text.length(); i ++) {\\n            // get char from string\\n            char word = text.charAt(i);\\n            // if HashSet contains char:\\n            if(map.contains(word)) {\\n                // count char in HashMap\\n                hash.put(word, hash.getOrDefault(word, 0) + 1);\\n            }\\n        }  \\n        // declare min variable to store answer\\n        int min = Integer.MAX_VALUE;\\n        // check if hash have all chars to make balloon word, if no return 0\\n        if(hash.size() < 5) return 0;\\n        // iterate over HashMap:\\n        for(Map.Entry<Character, Integer> entry: hash.entrySet()) {\\n            // get char from HashMap\\n            char word = entry.getKey();\\n            // get count of char from HashMap\\n            int count = entry.getValue();\\n            // check if char is \"l\" or \"o\":\\n            if(word == \\'l\\' || word == \\'o\\') {\\n                // if true: set min as devision of count by 2 and floor it\\n                min = Math.min(min, (int)Math.floor(count / 2));\\n            } else {\\n                // if false: set min as min value of min or count\\n                min = Math.min(min, count);\\n            }\\n        }\\n        // return answer\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        // declare HashSet to store word \"balloon\"\\n        Set<Character> map =  new HashSet();\\n        // declare our word balloon\\n        String baloon = \"balloon\";\\n        // iterate over balloon word:\\n        for(int i = 0; i < baloon.length(); i++) {\\n            // store each character in HashSet\\n            map.add(baloon.charAt(i));\\n        }\\n        // declare HashMap to calculate count\\n        Map<Character, Integer> hash = new HashMap();\\n        // iterate over text string:\\n        for(int i = 0; i < text.length(); i ++) {\\n            // get char from string\\n            char word = text.charAt(i);\\n            // if HashSet contains char:\\n            if(map.contains(word)) {\\n                // count char in HashMap\\n                hash.put(word, hash.getOrDefault(word, 0) + 1);\\n            }\\n        }  \\n        // declare min variable to store answer\\n        int min = Integer.MAX_VALUE;\\n        // check if hash have all chars to make balloon word, if no return 0\\n        if(hash.size() < 5) return 0;\\n        // iterate over HashMap:\\n        for(Map.Entry<Character, Integer> entry: hash.entrySet()) {\\n            // get char from HashMap\\n            char word = entry.getKey();\\n            // get count of char from HashMap\\n            int count = entry.getValue();\\n            // check if char is \"l\" or \"o\":\\n            if(word == \\'l\\' || word == \\'o\\') {\\n                // if true: set min as devision of count by 2 and floor it\\n                min = Math.min(min, (int)Math.floor(count / 2));\\n            } else {\\n                // if false: set min as min value of min or count\\n                min = Math.min(min, count);\\n            }\\n        }\\n        // return answer\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009508,
                "title": "kotlin-simple-solution",
                "content": "# Complexity\\n- Time complexity O(n):\\n\\n- Space complexity O(n):\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val counter = text.groupingBy{it}.eachCount()\\n        val letters = setOf(\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\')\\n        letters.forEach {\\n            if (!counter.containsKey(it)){\\n                return 0\\n            }\\n        }\\n        var minn = counter[\\'a\\']!!\\n        counter.forEach { (k, v) ->\\n            if (letters.contains(k)){\\n                if (k == \\'l\\' || k == \\'o\\'){\\n                    minn = minOf(minn, v / 2)\\n                } else {\\n                    minn = minOf(minn, v)\\n                }\\n            }\\n        }\\n        return minn\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val counter = text.groupingBy{it}.eachCount()\\n        val letters = setOf(\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\')\\n        letters.forEach {\\n            if (!counter.containsKey(it)){\\n                return 0\\n            }\\n        }\\n        var minn = counter[\\'a\\']!!\\n        counter.forEach { (k, v) ->\\n            if (letters.contains(k)){\\n                if (k == \\'l\\' || k == \\'o\\'){\\n                    minn = minOf(minn, v / 2)\\n                } else {\\n                    minn = minOf(minn, v)\\n                }\\n            }\\n        }\\n        return minn\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893401,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe function aims to find the maximum number of instances of the word \"balloon\" that can be formed from the characters in the given string `text`. To achieve this, we can count the occurrence of each character in `text` and iteratively decrease the counts as we form each instance of the word \"balloon\".\\n\\n# Approach\\n1. **Initialize the Hashmap**: We create a hashmap `store` to record the occurrence count of each character in the input string `text`.\\n  \\n2. **Count Occurrences**: Iterate through the `text`, and for each character, increment the corresponding count in the `store`.\\n\\n3. **Check and Form Words**: Initialize `result` to 0, which will store the count of instances of the word \"balloon\". Define a `template` string as \"balloon\". In an infinite loop, iterate through the characters in the `template`, and for each character, decrement its count in the `store`. If any count becomes negative, we cannot form any more instances of the word, so we return the `result`.\\n\\n# Complexity\\n- **Time Complexity**: The time complexity is O(n), where n is the number of characters in `text`. Counting the occurrences takes O(n), and then we loop through the `template` in the worst case n/len(template) times.\\n  \\n- **Space Complexity**: The space complexity is O(c), where c is the number of unique characters in `text`. This accounts for the storage used by our hashmap.\\n\\n# Code\\n```go\\nfunc maxNumberOfBalloons(text string) int {\\n\\tstore := make(map[byte]int, len(text))\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tstore[text[i]] = store[text[i]] + 1\\n\\t}\\n\\tresult := 0\\n\\ttemplate := \"balloon\"\\n\\tfor {\\n\\t\\tfor i := 0; i < len(template); i++ {\\n\\t\\t\\tstore[template[i]]--\\n\\t\\t\\tif store[template[i]] < 0 {\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult++\\n\\t}\\n}\\n",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "# Intuition\\nThe function aims to find the maximum number of instances of the word \"balloon\" that can be formed from the characters in the given string `text`. To achieve this, we can count the occurrence of each character in `text` and iteratively decrease the counts as we form each instance of the word \"balloon\".\\n\\n# Approach\\n1. **Initialize the Hashmap**: We create a hashmap `store` to record the occurrence count of each character in the input string `text`.\\n  \\n2. **Count Occurrences**: Iterate through the `text`, and for each character, increment the corresponding count in the `store`.\\n\\n3. **Check and Form Words**: Initialize `result` to 0, which will store the count of instances of the word \"balloon\". Define a `template` string as \"balloon\". In an infinite loop, iterate through the characters in the `template`, and for each character, decrement its count in the `store`. If any count becomes negative, we cannot form any more instances of the word, so we return the `result`.\\n\\n# Complexity\\n- **Time Complexity**: The time complexity is O(n), where n is the number of characters in `text`. Counting the occurrences takes O(n), and then we loop through the `template` in the worst case n/len(template) times.\\n  \\n- **Space Complexity**: The space complexity is O(c), where c is the number of unique characters in `text`. This accounts for the storage used by our hashmap.\\n\\n# Code\\n```go\\nfunc maxNumberOfBalloons(text string) int {\\n\\tstore := make(map[byte]int, len(text))\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tstore[text[i]] = store[text[i]] + 1\\n\\t}\\n\\tresult := 0\\n\\ttemplate := \"balloon\"\\n\\tfor {\\n\\t\\tfor i := 0; i < len(template); i++ {\\n\\t\\t\\tstore[template[i]]--\\n\\t\\t\\tif store[template[i]] < 0 {\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult++\\n\\t}\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3821301,
                "title": "hash-map-solution-6-ms-beats-65-5-19-12-mb-beats-87-5",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$, `k` is `5` here.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $text\\n     * @return Integer\\n     */\\n    function maxNumberOfBalloons($text) {\\n        $balloon = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'];\\n        $freq = [];\\n        for ($i = 0; $i < strlen($text); $i++) {\\n            if (!in_array($text[$i], $balloon)) {\\n                continue;\\n            }\\n            $freq[$text[$i]] = ($freq[$text[$i]] ?? 0) + 1;\\n        }\\n        \\n        if (count($freq) !== count($balloon)) {\\n            return 0;\\n        }\\n\\n        $freq[\\'l\\'] = (int)($freq[\\'l\\'] / 2);\\n        $freq[\\'o\\'] = (int)($freq[\\'o\\'] / 2);\\n\\n        return min($freq);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $text\\n     * @return Integer\\n     */\\n    function maxNumberOfBalloons($text) {\\n        $balloon = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'];\\n        $freq = [];\\n        for ($i = 0; $i < strlen($text); $i++) {\\n            if (!in_array($text[$i], $balloon)) {\\n                continue;\\n            }\\n            $freq[$text[$i]] = ($freq[$text[$i]] ?? 0) + 1;\\n        }\\n        \\n        if (count($freq) !== count($balloon)) {\\n            return 0;\\n        }\\n\\n        $freq[\\'l\\'] = (int)($freq[\\'l\\'] / 2);\\n        $freq[\\'o\\'] = (int)($freq[\\'o\\'] / 2);\\n\\n        return min($freq);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744821,
                "title": "java-2ms-clean-code-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736980,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var characters = Array(text)\\n        var bCounts = 0\\n        var aCounts = 0\\n        var lCounts = 0\\n        var oCounts = 0\\n        var nCounts = 0\\n\\n        for char in characters {\\n            switch (char) {\\n                case \"b\":\\n                    bCounts = bCounts + 1\\n                case \"a\":\\n                    aCounts = aCounts + 1\\n                case \"l\":\\n                    lCounts = lCounts + 1\\n                case \"o\":\\n                    oCounts = oCounts + 1\\n                case \"n\":\\n                    nCounts = nCounts + 1\\n                default:\\n                    continue\\n            }\\n        }\\n\\n        var ans = min(bCounts,aCounts,lCounts/2,oCounts/2,nCounts)\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var characters = Array(text)\\n        var bCounts = 0\\n        var aCounts = 0\\n        var lCounts = 0\\n        var oCounts = 0\\n        var nCounts = 0\\n\\n        for char in characters {\\n            switch (char) {\\n                case \"b\":\\n                    bCounts = bCounts + 1\\n                case \"a\":\\n                    aCounts = aCounts + 1\\n                case \"l\":\\n                    lCounts = lCounts + 1\\n                case \"o\":\\n                    oCounts = oCounts + 1\\n                case \"n\":\\n                    nCounts = nCounts + 1\\n                default:\\n                    continue\\n            }\\n        }\\n\\n        var ans = min(bCounts,aCounts,lCounts/2,oCounts/2,nCounts)\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618829,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, s: str) -> int:\\n        return min(s.count(\\'b\\'), s.count(\\'a\\'), s.count(\\'l\\')//2, s.count(\\'o\\')//2, s.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, s: str) -> int:\\n        return min(s.count(\\'b\\'), s.count(\\'a\\'), s.count(\\'l\\')//2, s.count(\\'o\\')//2, s.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603205,
                "title": "o-n-maximum-number-of-balloons-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int i, b=0, a=0, l=0, o=0, n=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\'b\\')\\n                b++;\\n            else if(text[i]==\\'a\\')\\n                a++;\\n            else if(text[i]==\\'l\\')\\n                l++;\\n            else if(text[i]==\\'o\\')\\n                o++;\\n            else if(text[i]==\\'n\\')\\n                n++;\\n        }\\n        while(true)\\n        {\\n            b--;\\n            a--;\\n            l -= 2;\\n            o -= 2;\\n            n--;\\n            if(b>=0 && a>=0 && l>=0 && o>=0 && n>=0)\\n                count++;\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5c5fc37e-a4f5-431b-be39-02554516d2b3_1686028095.3401299.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int i, b=0, a=0, l=0, o=0, n=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\'b\\')\\n                b++;\\n            else if(text[i]==\\'a\\')\\n                a++;\\n            else if(text[i]==\\'l\\')\\n                l++;\\n            else if(text[i]==\\'o\\')\\n                o++;\\n            else if(text[i]==\\'n\\')\\n                n++;\\n        }\\n        while(true)\\n        {\\n            b--;\\n            a--;\\n            l -= 2;\\n            o -= 2;\\n            n--;\\n            if(b>=0 && a>=0 && l>=0 && o>=0 && n>=0)\\n                count++;\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370649,
                "title": "python-with-explanation-runtime-7ms-beats-100",
                "content": "![Screenshot 2023-04-02 5.41.59 PM.png](https://assets.leetcode.com/users/images/0a71cb21-ca80-4381-9fda-b3f2cd2634a1_1680438303.0569677.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # Letters to make \\'balloon\\'.\\n        a = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n\\n        # Counting letters [\\'b\\', \\'a\\', \\'l\\', \\'o\\',\\'n\\'] from string.\\n        # Appending that in a list.\\n        b = [text.count(i) for i in a]\\n\\n        # Counter for counting word balloon.\\n        c = 0\\n\\n        # Looping infinitly till break.\\n        while True:\\n\\n            # To make word \\'balloon\\', we need 1 b, a, & n, & 2 l & o.\\n            # The following condition will check if the above mentioned minimum numbers are in the list in that order.\\n            if b[0] >= 1 and b[1] >= 1 and b[2] >= 2 and b[3] >= 2 and b[4] >= 1:\\n\\n                # When the above condition is satisfied.\\n                # The same numbers are subtracted respectively from the count list b.\\n                b = b[0] - 1, b[1] - 1, b[2] - 2, b[3] - 2, b[4] - 1\\n\\n                # Incrementing 1 to c after each balloon.\\n                c += 1\\n\\n            # If the above condition is false then break the loop.\\n            else:\\n                break\\n\\n        # Return total of c.\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-02 5.41.59 PM.png](https://assets.leetcode.com/users/images/0a71cb21-ca80-4381-9fda-b3f2cd2634a1_1680438303.0569677.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # Letters to make \\'balloon\\'.\\n        a = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n\\n        # Counting letters [\\'b\\', \\'a\\', \\'l\\', \\'o\\',\\'n\\'] from string.\\n        # Appending that in a list.\\n        b = [text.count(i) for i in a]\\n\\n        # Counter for counting word balloon.\\n        c = 0\\n\\n        # Looping infinitly till break.\\n        while True:\\n\\n            # To make word \\'balloon\\', we need 1 b, a, & n, & 2 l & o.\\n            # The following condition will check if the above mentioned minimum numbers are in the list in that order.\\n            if b[0] >= 1 and b[1] >= 1 and b[2] >= 2 and b[3] >= 2 and b[4] >= 1:\\n\\n                # When the above condition is satisfied.\\n                # The same numbers are subtracted respectively from the count list b.\\n                b = b[0] - 1, b[1] - 1, b[2] - 2, b[3] - 2, b[4] - 1\\n\\n                # Incrementing 1 to c after each balloon.\\n                c += 1\\n\\n            # If the above condition is false then break the loop.\\n            else:\\n                break\\n\\n        # Return total of c.\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 3238928,
                "title": "using-counter",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        CountText = Counter(text)\\n        balloon = Counter(\"balloon\")\\n\\n        res = len(text)\\n        for c in balloon:\\n            res = min(res,CountText[c]//balloon[c])\\n        return res\\n\\n\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        CountText = Counter(text)\\n        balloon = Counter(\"balloon\")\\n\\n        res = len(text)\\n        for c in balloon:\\n            res = min(res,CountText[c]//balloon[c])\\n        return res\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134573,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        unordered_map<char,int>m;\\n        int flag=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'a\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'n\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n        }\\n        \\n        if(m.find(\\'b\\')==m.end()||m.find(\\'a\\')==m.end()||m.find(\\'l\\')==m.end()||m.find(\\'o\\')==m.end()||m.find(\\'n\\')==m.end())return 0;\\n        m[\\'o\\']=m[\\'o\\']/2;\\n        m[\\'l\\']=m[\\'l\\']/2;\\n        int ans=INT_MAX;\\n        for(auto it:m)\\n        {\\n            \\n            ans=min(ans,it.second);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        unordered_map<char,int>m;\\n        int flag=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'a\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'n\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n        }\\n        \\n        if(m.find(\\'b\\')==m.end()||m.find(\\'a\\')==m.end()||m.find(\\'l\\')==m.end()||m.find(\\'o\\')==m.end()||m.find(\\'n\\')==m.end())return 0;\\n        m[\\'o\\']=m[\\'o\\']/2;\\n        m[\\'l\\']=m[\\'l\\']/2;\\n        int ans=INT_MAX;\\n        for(auto it:m)\\n        {\\n            \\n            ans=min(ans,it.second);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120155,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string t) {\\n      int n=t.size();\\n      vector<int>v;\\n      int a1=0,a2=0,a3=0,a4=0,a5=0;  \\n      for(int i=0;i<n;i++)\\n      {\\n          if(t[i]==\\'b\\')\\n          {\\n              a1++;\\n          }\\n          else if(t[i]==\\'a\\')\\n          {\\n              a2++;\\n          }\\n        else if(t[i]==\\'l\\')\\n          {\\n              a3++;\\n          }\\n          else if(t[i]==\\'o\\')\\n          {\\n              a4++;\\n          }\\n          else if(t[i]==\\'n\\')\\n          {\\n              a5++;\\n          }}\\n   a3=a3/2;\\n   a4=a4/2;\\n   for(int i=0;i<1;i++)\\n   {\\n     v.push_back(a1);\\n      v.push_back(a2);\\n       v.push_back(a3);\\n        v.push_back(a4);\\n         v.push_back(a5);\\n   }\\n   int s=*min_element(v.begin(),v.end());\\n   return s;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string t) {\\n      int n=t.size();\\n      vector<int>v;\\n      int a1=0,a2=0,a3=0,a4=0,a5=0;  \\n      for(int i=0;i<n;i++)\\n      {\\n          if(t[i]==\\'b\\')\\n          {\\n              a1++;\\n          }\\n          else if(t[i]==\\'a\\')\\n          {\\n              a2++;\\n          }\\n        else if(t[i]==\\'l\\')\\n          {\\n              a3++;\\n          }\\n          else if(t[i]==\\'o\\')\\n          {\\n              a4++;\\n          }\\n          else if(t[i]==\\'n\\')\\n          {\\n              a5++;\\n          }}\\n   a3=a3/2;\\n   a4=a4/2;\\n   for(int i=0;i<1;i++)\\n   {\\n     v.push_back(a1);\\n      v.push_back(a2);\\n       v.push_back(a3);\\n        v.push_back(a4);\\n         v.push_back(a5);\\n   }\\n   int s=*min_element(v.begin(),v.end());\\n   return s;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105301,
                "title": "kotlin-using-a-map-and-counting-characters",
                "content": "# Intuition\\nWe count the number of each character in `\"Balloon\"` in the `text` String, then check for the minimun of the word `\"Balloon\"` we can create from the counted characters.\\n\\n# Approach\\nWe check for each occurence of any of the characters in `\"balon\"` in the String `text`. \\n\\nThen again, for each character in `\"balon\"`, we check if it occurs zero times. If it does, we return 0 as our final answer since we won\\'t be able to create any `\"Balloon\"` words. \\n\\nIf not zero, we check if it\\'s either a `\\'l\\'` or `\\'o\\'`, or any of `\\'b\\'`,`\\'a\\'` or `\\'c\\'`. If it\\'s any of the former, then we divide the number of occurences of that character in half, otherwise we keep it as is for the latter characters. \\n\\nThen we will take the `min` of all these characters to find out the minimum number of the word `Balloon` we can create.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)` since we have to traverse the whole String `text`\\n\\n- Space complexity:\\n`O(1)` since we use a map the size of the english alphabet in lowercase (`O(26)` is the same as `O(1)`)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val map = IntArray(26)\\n        text.forEach {\\n            if(it in \"balon\") map[it - \\'a\\']++\\n        }\\n        var min = Integer.MAX_VALUE\\n        \"balon\".forEach {\\n            if(map[it - \\'a\\'] == 0) return 0\\n            else if(it == \\'l\\' || it == \\'o\\') min = minOf(min, map[it-\\'a\\']/2)\\n            else min = minOf(min, map[it-\\'a\\'])\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val map = IntArray(26)\\n        text.forEach {\\n            if(it in \"balon\") map[it - \\'a\\']++\\n        }\\n        var min = Integer.MAX_VALUE\\n        \"balon\".forEach {\\n            if(map[it - \\'a\\'] == 0) return 0\\n            else if(it == \\'l\\' || it == \\'o\\') min = minOf(min, map[it-\\'a\\']/2)\\n            else min = minOf(min, map[it-\\'a\\'])\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970038,
                "title": "python-solution-with-hash-map",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        count = defaultdict(lambda: 0)\\n        for char in text:\\n            count[char] += 1\\n        \\n        ans = min(count[\"l\"] // 2, count[\"o\"] // 2)\\n        ans = min(ans, count[\"b\"], count[\"a\"], count[\"n\"])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        count = defaultdict(lambda: 0)\\n        for char in text:\\n            count[char] += 1\\n        \\n        ans = min(count[\"l\"] // 2, count[\"o\"] // 2)\\n        ans = min(ans, count[\"b\"], count[\"a\"], count[\"n\"])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941181,
                "title": "python-solution-using-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        ctrText = Counter(text)\\n        cntB, cntA, cntN = ctrText[\\'b\\'], ctrText[\\'a\\'], ctrText[\\'n\\']\\n        cntL, cntO = ctrText[\\'l\\'] // 2, ctrText[\\'o\\'] // 2\\n        return min(cntB, cntA, cntL, cntO, cntN)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        ctrText = Counter(text)\\n        cntB, cntA, cntN = ctrText[\\'b\\'], ctrText[\\'a\\'], ctrText[\\'n\\']\\n        cntL, cntO = ctrText[\\'l\\'] // 2, ctrText[\\'o\\'] // 2\\n        return min(cntB, cntA, cntL, cntO, cntN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897447,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int maxNumberOfBalloons(string text) {\\n       map<char,int> v;\\n       for(int i =0;i<text.length();i++){\\n           if(text[i]==\\'b\\'||text[i]==\\'a\\'||text[i]==\\'l\\'||text[i]==\\'o\\'||text[i]==\\'n\\'){\\n           v[text[i]]+=1;\\n           }\\n       }\\n       return min(v[\\'b\\'],min(v[\\'a\\'],min(v[\\'l\\']/2,min(v[\\'o\\']/2,v[\\'n\\']))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int maxNumberOfBalloons(string text) {\\n       map<char,int> v;\\n       for(int i =0;i<text.length();i++){\\n           if(text[i]==\\'b\\'||text[i]==\\'a\\'||text[i]==\\'l\\'||text[i]==\\'o\\'||text[i]==\\'n\\'){\\n           v[text[i]]+=1;\\n           }\\n       }\\n       return min(v[\\'b\\'],min(v[\\'a\\'],min(v[\\'l\\']/2,min(v[\\'o\\']/2,v[\\'n\\']))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787148,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  \\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  \\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764238,
                "title": "if-else-method-easy-java-c-faster",
                "content": "# Please upvote if you like it\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int b=0,a=0,l=0,o=0,n=0;\\n        \\n        for(char ch: text.toCharArray()){\\n            if(ch==\\'b\\') b++;\\n            if(ch==\\'a\\') a++;\\n            if(ch==\\'l\\') l++;\\n            if(ch==\\'o\\') o++;\\n            if(ch==\\'n\\') n++;\\n        }\\n        \\n        int ans=0;\\n        \\n        while(b>=1 && a>=1 && l>=2 && o>=2 && n>=1){\\n            ans++;\\n            \\n            b=b-1;\\n            a=a-1;\\n            l=l-2;\\n            o=o-2;\\n            n=n-1;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int b=0,a=0,l=0,o=0,n=0;\\n        \\n        for(char ch: text.toCharArray()){\\n            if(ch==\\'b\\') b++;\\n            if(ch==\\'a\\') a++;\\n            if(ch==\\'l\\') l++;\\n            if(ch==\\'o\\') o++;\\n            if(ch==\\'n\\') n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2633073,
                "title": "javascript-this-is-dumb-but-fast-97-5",
                "content": "```\\n    let map = {\\n        a: 1,\\n        b: 1,\\n        l: 2,\\n        o: 2,\\n        n: 1\\n    };\\n    \\n    for (let char of text){\\n        if (map[char]) map[char] ++;\\n    }\\n    \\n    map[\\'l\\'] = Math.floor(map[\\'l\\']/2);\\n    map[\\'o\\'] = Math.floor(map[\\'o\\']/2);\\n    let arr = Object.values(map);\\n    \\n    return Math.min(...arr) - 1;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    let map = {\\n        a: 1,\\n        b: 1,\\n        l: 2,\\n        o: 2,\\n        n: 1\\n    };\\n    \\n    for (let char of text){\\n        if (map[char]) map[char] ++;\\n    }\\n    \\n    map[\\'l\\'] = Math.floor(map[\\'l\\']/2);\\n    map[\\'o\\'] = Math.floor(map[\\'o\\']/2);\\n    let arr = Object.values(map);\\n    \\n    return Math.min(...arr) - 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593760,
                "title": "c-using-map-easy-understanding-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        mp[\\'b\\']=0;\\n        mp[\\'a\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'n\\']=0;\\n        \\n        transform(text.begin(), text.end(), text.begin(), ::tolower);\\n        \\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\'b\\')mp[\\'b\\']++;\\n            else if(text[i]==\\'a\\')mp[\\'a\\']++;\\n            else if(text[i]==\\'l\\')mp[\\'l\\']++;\\n            else if(text[i]==\\'o\\')mp[\\'o\\']++;\\n            else if(text[i]==\\'n\\')mp[\\'n\\']++;\\n        }\\n        int mi=INT_MAX;\\n        \\n        if(mp[\\'l\\']<2)return 0;\\n        if(mp[\\'o\\']<2)return 0;\\n        \\n        mp[\\'l\\']=floor(mp[\\'l\\']/2);   //because thier are two l in \\'balloon\\'  \\n        mp[\\'o\\']=floor(mp[\\'o\\']/2); ////because thier are two o in \\'balloon\\'\\n            \\n        for(auto i:mp)\\n        {\\n            if(i.second==0)return 0;   //if any letter is missing from balloon return 0 \\n            mi=min(mi,i.second);\\n        }\\n        \\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        mp[\\'b\\']=0;\\n        mp[\\'a\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'n\\']=0;\\n        \\n        transform(text.begin(), text.end(), text.begin(), ::tolower);\\n        \\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\'b\\')mp[\\'b\\']++;\\n            else if(text[i]==\\'a\\')mp[\\'a\\']++;\\n            else if(text[i]==\\'l\\')mp[\\'l\\']++;\\n            else if(text[i]==\\'o\\')mp[\\'o\\']++;\\n            else if(text[i]==\\'n\\')mp[\\'n\\']++;\\n        }\\n        int mi=INT_MAX;\\n        \\n        if(mp[\\'l\\']<2)return 0;\\n        if(mp[\\'o\\']<2)return 0;\\n        \\n        mp[\\'l\\']=floor(mp[\\'l\\']/2);   //because thier are two l in \\'balloon\\'  \\n        mp[\\'o\\']=floor(mp[\\'o\\']/2); ////because thier are two o in \\'balloon\\'\\n            \\n        for(auto i:mp)\\n        {\\n            if(i.second==0)return 0;   //if any letter is missing from balloon return 0 \\n            mi=min(mi,i.second);\\n        }\\n        \\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567386,
                "title": "easy-c-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:text) mp1[it]++;\\n        string s=\"balloon\";\\n        for(auto it:s) mp2[it]++;\\n        int mini=INT_MAX;\\n        for(auto &ch:mp2) {\\n            if(mp1.find(ch.first)==mp1.end()) {\\n                mini=0;\\n                break;\\n            }\\n            else {\\n                mini= min(mini, mp1[ch.first]/ch.second);\\n            }\\n        }\\n        return mini;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:text) mp1[it]++;\\n        string s=\"balloon\";\\n        for(auto it:s) mp2[it]++;\\n        int mini=INT_MAX;\\n        for(auto &ch:mp2) {\\n            if(mp1.find(ch.first)==mp1.end()) {\\n                mini=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2520722,
                "title": "python-simple-using-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        return min(c[\\'b\\'], c[\\'a\\'], c[\\'n\\'], c[\\'l\\']//2, c[\\'o\\']//2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        return min(c[\\'b\\'], c[\\'a\\'], c[\\'n\\'], c[\\'l\\']//2, c[\\'o\\']//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465545,
                "title": "elegant-python-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        x = collections.Counter(text)\\n        y = collections.Counter(\"balloon\")\\n        return min(x[c]//y[c] for c in y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        x = collections.Counter(text)\\n        y = collections.Counter(\"balloon\")\\n        return min(x[c]//y[c] for c in y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441764,
                "title": "maximum-number-of-balloons",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0; \\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == \\'b\\') b++;\\n            else if (text.charAt(i) == \\'a\\') a++;\\n            else if (text.charAt(i) == \\'l\\') l++;\\n            else if (text.charAt(i) == \\'o\\') o++;\\n            else if (text.charAt(i) == \\'n\\') n++;\\n        }\\n        l = l/2;\\n        o = o/2;\\n        return Collections.min(List.of(b,a,l,o,n));  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0; \\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == \\'b\\') b++;\\n            else if (text.charAt(i) == \\'a\\') a++;\\n            else if (text.charAt(i) == \\'l\\') l++;\\n            else if (text.charAt(i) == \\'o\\') o++;\\n            else if (text.charAt(i) == \\'n\\') n++;\\n        }\\n        l = l/2;\\n        o = o/2;\\n        return Collections.min(List.of(b,a,l,o,n));  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338145,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < text.length() ; i++){\\n            if(\"balloon\".contains(\"\"+text.charAt(i)))\\n            map.put(text.charAt(i),map.getOrDefault(text.charAt(i),0)+1);\\n        }\\n        \\n        int noi = 0;\\n         \\n if(map.containsKey(\\'a\\')&& map.containsKey(\\'b\\') && map.containsKey(\\'l\\') && map.containsKey(\\'o\\')&& map.containsKey(\\'n\\')){\\n        while(true){\\n if(map.get(\\'a\\') < 1 || map.get(\\'b\\') < 1 || map.get(\\'l\\') < 2 || map.get(\\'o\\') < 2 || map.get(\\'n\\') < 1) break;\\n            map.put(\\'a\\',map.get(\\'a\\')-1);\\n            map.put(\\'b\\',map.get(\\'b\\')-1);\\n            map.put(\\'l\\',map.get(\\'l\\')-2);\\n            map.put(\\'o\\',map.get(\\'o\\')-2);\\n            map.put(\\'n\\',map.get(\\'n\\')-1);\\n          \\n            noi++;\\n        }\\n      } \\n        return noi;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < text.length() ; i++){\\n            if(\"balloon\".contains(\"\"+text.charAt(i)))\\n            map.put(text.charAt(i),map.getOrDefault(text.charAt(i),0)+1);\\n        }\\n        \\n        int noi = 0;\\n         \\n if(map.containsKey(\\'a\\')&& map.containsKey(\\'b\\') && map.containsKey(\\'l\\') && map.containsKey(\\'o\\')&& map.containsKey(\\'n\\')){\\n        while(true){\\n if(map.get(\\'a\\') < 1 || map.get(\\'b\\') < 1 || map.get(\\'l\\') < 2 || map.get(\\'o\\') < 2 || map.get(\\'n\\') < 1) break;\\n            map.put(\\'a\\',map.get(\\'a\\')-1);\\n            map.put(\\'b\\',map.get(\\'b\\')-1);\\n            map.put(\\'l\\',map.get(\\'l\\')-2);\\n            map.put(\\'o\\',map.get(\\'o\\')-2);\\n            map.put(\\'n\\',map.get(\\'n\\')-1);\\n          \\n            noi++;\\n        }\\n      } \\n        return noi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278692,
                "title": "100-faster-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        vector<int> dp(26, 0);\\n        for(int i=0;i<text.size();++i){\\n            dp[text[i]-\\'a\\']++;\\n        }\\n        return min({ dp[\\'a\\'-\\'a\\'], dp[\\'b\\'-\\'a\\'], dp[\\'l\\'-\\'a\\']/2, dp[\\'o\\'-\\'a\\']/2, dp[\\'n\\'-\\'a\\']});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        vector<int> dp(26, 0);\\n        for(int i=0;i<text.size();++i){\\n            dp[text[i]-\\'a\\']++;\\n        }\\n        return min({ dp[\\'a\\'-\\'a\\'], dp[\\'b\\'-\\'a\\'], dp[\\'l\\'-\\'a\\']/2, dp[\\'o\\'-\\'a\\']/2, dp[\\'n\\'-\\'a\\']});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255484,
                "title": "c-easy-to-understand",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        int b=0;\\n        int a=0;\\n        int l=0;\\n        int o=0;\\n        int n=0;\\n        for(auto i:text){\\n            if(i==\\'b\\'){\\n                b++;\\n            }\\n            else if(i==\\'a\\'){\\n                a++;\\n            }\\n            else if(i==\\'l\\'){\\n                l++;\\n            }\\n            else if(i==\\'o\\'){\\n                o++;\\n            }\\n            else if(i==\\'n\\'){\\n                n++;\\n            }\\n        }\\n        \\n        l=l/2;\\n        o=o/2;\\n        return min(b,min(a,min(l,min(o,n))));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        int b=0;\\n        int a=0;\\n        int l=0;\\n        int o=0;\\n        int n=0;\\n        for(auto i:text){\\n            if(i==\\'b\\'){\\n                b++;\\n            }\\n            else if(i==\\'a\\'){\\n                a++;\\n            }\\n            else if(i==\\'l\\'){\\n                l++;\\n            }\\n            else if(i==\\'o\\'){\\n                o++;\\n            }\\n            else if(i==\\'n\\'){\\n                n++;\\n            }\\n        }\\n        \\n        l=l/2;\\n        o=o/2;\\n        return min(b,min(a,min(l,min(o,n))));\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1904792,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1932454,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1793949,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1941968,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1935303,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            }
        ]
    },
    {
        "title": "Kth Smallest Instructions",
        "question_content": "<p>Bob is standing at cell <code>(0, 0)</code>, and he wants to reach <code>destination</code>: <code>(row, column)</code>. He can only travel <strong>right</strong> and <strong>down</strong>. You are going to help Bob by providing <strong>instructions</strong> for him to reach <code>destination</code>.</p>\n\n<p>The <strong>instructions</strong> are represented as a string, where each character is either:</p>\n\n<ul>\n\t<li><code>&#39;H&#39;</code>, meaning move horizontally (go <strong>right</strong>), or</li>\n\t<li><code>&#39;V&#39;</code>, meaning move vertically (go <strong>down</strong>).</li>\n</ul>\n\n<p>Multiple <strong>instructions</strong> will lead Bob to <code>destination</code>. For example, if <code>destination</code> is <code>(2, 3)</code>, both <code>&quot;HHHVV&quot;</code> and <code>&quot;HVHVH&quot;</code> are valid <strong>instructions</strong>.</p>\n\n<p>However, Bob is very picky. Bob has a lucky number <code>k</code>, and he wants the <code>k<sup>th</sup></code> <strong>lexicographically smallest instructions</strong> that will lead him to <code>destination</code>. <code>k</code> is <strong>1-indexed</strong>.</p>\n\n<p>Given an integer array <code>destination</code> and an integer <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> <strong>lexicographically smallest instructions</strong> that will take Bob to </em><code>destination</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex1.png\" style=\"width: 300px; height: 229px;\" /></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 1\n<strong>Output:</strong> &quot;HHHVV&quot;\n<strong>Explanation:</strong> All the instructions that reach (2, 3) in lexicographic order are as follows:\n[&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 2\n<strong>Output:</strong> &quot;HHVHV&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 3\n<strong>Output:</strong> &quot;HHVVH&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 &lt;= row, column &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= nCr(row + column, row)</code>, where <code>nCr(a, b)</code> denotes <code>a</code> choose <code>b</code>​​​​​.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 918396,
                "title": "python-math-solution-introduction-to-combinatorics",
                "content": "*Feel free to skip to the solution below if you already understand combinatorics.*\\n\\n**Introduction**\\n\"Combinatorics\" is basically the mathematical science of counting. In our case, as software engineers, it\\'s usually about the efficient automation of that counting - and there\\'s a lot of counting to be done here, for sure!\\n\\nFirst of all, we know these things, regardless of the destination:\\n1. Since Bob has to walk from `(0, 0)` to `(r, c)`, he has to follow a total of `r + c` instructions.\\n2. `r` of those instructions will be downward (`\"V\"`) movements, and `c` of the instructions will be horizontal (`\"H\"`) movements.\\n\\nSo, we know that every set of instructions for Bob will be some string that is the combination of `\"H\"` and `\"V\"` with length `r + c`, exactly `r` characters will be `\"V\"`, and exactly `c` characters will be `\"H\"`.\\n\\n**Combinatorics**\\nNow that we have that out of the way, let\\'s analyze a hint that the problem gives us. The final constraint says this:\\n> `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`.\\n\\n`nCr(a, b)`, or \"`a` choose `b`\" as they put it, is the number of ways that you can select `b` elements from a set of `a` unique elements.  Let\\'s consider `nCr(3, 2)` for example: that means we have 3 unique elements - `000`. Let `1` represent an element that we\\'ve selected: there are three ways to select exactly 2 elements, shown below:\\n- `011`\\n- `101`\\n- `110`\\n \\nYou don\\'t need the formula for `nCr(a, b)` since your language most likely has it as a library, but here it is if you\\'re interested (`!` is the [factorial](https://en.wikipedia.org/wiki/Factorial) function):\\n> `nCr(a, b) = (a!) / ((b!) * (a - b)!)`\\n\\n**Solution**\\n`\"H\"` is lexicographically smaller than `\"V\"`. That means that, at index `i` of an arbitrary solution, placing an `\"H\"` at `i` will make the resulting instruction set lexicographically smaller than if we placed a `\"V\"` at that index instead.\\n\\nLet\\'s break this down in terms of what we\\'ve learned about Combinatorics. If we have `r + c` total elements and `r` of those elements are `\"V\"`, then we have `nCr(r + c, r)` possible instruction sets that Bob can walk. At each of his `r + c` total steps, we have two options:\\n- Walk right one column, which will leave us with the same number of `\"V\"`\\'s\\n- Walk down one row, which will decrease our number of `\"V\"`\\'s by 1 (remember that we only have `r` of these!)\\n\\n**If we choose to walk down a row when we have N more steps and R possible rows left to walk down (including the current step), then we\\'re cutting out the number of combinations of (N - 1) steps with R rows to walk down, because all of those combinations would result in a lexicographically smaller instruction set.**\\n\\nSo, for each step where we have N more possible steps (including the current step), calculate `nCr(N - 1, R)`. If k is less than or equal to this number, travel horizontally. Otherwise, subtract that number from k, decrease the number of vertical movements we\\'re allowed to make, and then travel vertically.\\n\\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```\\n\\nPlease leave a comment if you have any questions!",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 918375,
                "title": "c-combination",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Combination\\n\\nGiven `destination: (row, column)`, we will have `column` `H` and `row` `V` in the result.\\n\\nLet\\'s denote `h = column`, `v = row` meaning the number of `H` and `V` left to pick, respectively. The result is of length `h + v`.\\n\\nWe pick the character one by one for the result.\\n\\nFor the first character, if we pick `H`, the rest of characters can form `c = nCr(h - 1 + v, v)` combinations.\\n\\nIf `k <= c`, it means that the result is one of these `c` combinations. So we should pick `H` here. We append `H` to the result and `--h`.\\n\\nOtherwise, we should pick `V` instead, and do `--v` and `k -= c` (skip these `c` combinations).\\n\\nWe keep doing this until we made choice for all the `h + v` characters.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-213/problems/kth-smallest-instructions/\\n// Author: github.com/lzl124631x\\n// Time: O((H + V)^2)\\n// Space: O(1)\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // if we pick H at the current position, there will be `c` combinations for the rest of characters\\n                if (k <= c) { // k is covered within `c`, so we should pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // otherwise we should pick V\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { // no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate 11/1/2020:\\n\\nWhy `k -= c`?\\n\\nExample:\\n\\nAssume `k = 4` and we have `2H2V` to pick.\\n\\nIf the first character is `H`, then there are `1H2V` left which can form `nCr(3, 2) = 3` combinations.\\n\\n```\\nH HVV\\nH VHV\\nH VVH\\n\\nV HHV   <\\nV HVH\\nV VHH\\n```\\n\\nBut since `k = 4 > 3` so the first character must not be `H`. So `V` is selected. \\n\\nNow we have `2H1V` left. It is `k\\' = 4 - 3 = 1`st string that we are looking for now.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-213/problems/kth-smallest-instructions/\\n// Author: github.com/lzl124631x\\n// Time: O((H + V)^2)\\n// Space: O(1)\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // if we pick H at the current position, there will be `c` combinations for the rest of characters\\n                if (k <= c) { // k is covered within `c`, so we should pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // otherwise we should pick V\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { // no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nH HVV\\nH VHV\\nH VVH\\n\\nV HHV   <\\nV HVH\\nV VHH\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918436,
                "title": "java-o-r-c-very-easy-to-understand",
                "content": "time complexity O(row * col)\\nit\\'s a variation of the dungeon games, we can solve it in a similar way\\n```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        \\n        int ti = destination[0], tj = destination[1];\\n        int[][] dp = new int[ti+1][tj+1];\\n        for(int i = ti; i >= 0; i--){\\n            for(int j = tj; j >= 0; j--){\\n                if(i == ti && j == tj){\\n                    dp[i][j] = 1;\\n                }else if(i == ti){\\n                    dp[i][j] = dp[i][j+1];\\n                }else if(j == tj){\\n                    dp[i][j] = dp[i+1][j];\\n                }else{\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        \\n        // in each (i, j), we have dp[i][j] kind of instructions, which equal to dp[i][j+1] + dp[i+1][j]\\n        // all dp[i][j+1] kinds of instructions are lexicographically smaller than the left dp[i+1][j] kinds of instructions.\\n        // we can just compare k with dp[i][j+1] to determin how to choose next step.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        helper(dp, 0, 0, k, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[][] dp, int i, int j, int k, StringBuilder sb){\\n        \\n        if(i == dp.length -1){\\n            // if we came to most down position then we can only go right\\n            while(++j < dp[0].length)sb.append(\"H\");\\n            return;\\n        }\\n        if(j == dp[0].length - 1){\\n            //if we came to most right position then we can only go down\\n            while(++i < dp.length)sb.append(\"V\");\\n            return;\\n        }\\n        if(dp[i][j+1] >= k){\\n            //if k is smaller than the first dp[i][j+1] solutions, then we should go right\\n            sb.append(\"H\");\\n            helper(dp, i, j+1, k, sb);\\n        }else{\\n            //else we go donw, and we should also minus the first dp[i][j+1] solutions from k\\n            sb.append(\"V\");\\n            helper(dp, i+1, j, k-dp[i][j+1], sb);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        \\n        int ti = destination[0], tj = destination[1];\\n        int[][] dp = new int[ti+1][tj+1];\\n        for(int i = ti; i >= 0; i--){\\n            for(int j = tj; j >= 0; j--){\\n                if(i == ti && j == tj){\\n                    dp[i][j] = 1;\\n                }else if(i == ti){\\n                    dp[i][j] = dp[i][j+1];\\n                }else if(j == tj){\\n                    dp[i][j] = dp[i+1][j];\\n                }else{\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        \\n        // in each (i, j), we have dp[i][j] kind of instructions, which equal to dp[i][j+1] + dp[i+1][j]\\n        // all dp[i][j+1] kinds of instructions are lexicographically smaller than the left dp[i+1][j] kinds of instructions.\\n        // we can just compare k with dp[i][j+1] to determin how to choose next step.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        helper(dp, 0, 0, k, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[][] dp, int i, int j, int k, StringBuilder sb){\\n        \\n        if(i == dp.length -1){\\n            // if we came to most down position then we can only go right\\n            while(++j < dp[0].length)sb.append(\"H\");\\n            return;\\n        }\\n        if(j == dp[0].length - 1){\\n            //if we came to most right position then we can only go down\\n            while(++i < dp.length)sb.append(\"V\");\\n            return;\\n        }\\n        if(dp[i][j+1] >= k){\\n            //if k is smaller than the first dp[i][j+1] solutions, then we should go right\\n            sb.append(\"H\");\\n            helper(dp, i, j+1, k, sb);\\n        }else{\\n            //else we go donw, and we should also minus the first dp[i][j+1] solutions from k\\n            sb.append(\"V\");\\n            helper(dp, i+1, j, k-dp[i][j+1], sb);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918393,
                "title": "python-o-m-n-2-solution-explained",
                "content": "Actualy, I was suprised, why this problem is marked as Hard: all you need to do is to on each moment of time see how many options we have if we go to the right and if we can afford this step or no. If we are out of options, that is `k = 1`, then we build the rest of the sequence either with `H` or with `V`.\\n\\n**Complexity**: time complexity is `O((m+n)^2)` for time: we use `comb()` function `O(m+n)` times, where complexity of each evaluation is `O(m+n)` as well. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        m, n, ans = destination[0], destination[1], \"\"\\n        for i in range(m+n):\\n            if k == 1:  #no options left\\n                ans += \"H\"*n + \"V\"*m\\n                break\\n\\n            if k <= comb(m+n-1, m):\\n                n -= 1\\n                ans += \"H\"\\n            else:\\n                ans += \"V\"\\n                k -= comb(m+n-1, m)\\n                m -= 1\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        m, n, ans = destination[0], destination[1], \"\"\\n        for i in range(m+n):\\n            if k == 1:  #no options left\\n                ans += \"H\"*n + \"V\"*m\\n                break\\n\\n            if k <= comb(m+n-1, m):\\n                n -= 1\\n                ans += \"H\"\\n            else:\\n                ans += \"V\"\\n                k -= comb(m+n-1, m)\\n                m -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918569,
                "title": "java-bottom-up-dp-o-m-n-solution",
                "content": "just need to pre calculate the combination in the dp array. then at every step, choose to go right if the rest of matrix with i rows, j - 1 columns has more paths than k. choose to go down otherwise. \\n\\n```\\npublic String kthSmallestPath(int[] destination, int k) {\\n    // dp(i, j) means how many paths are there for matrix of size i row and j column.\\n\\tint[][] dp = new int[destination[0] + 1][destination[1] + 1];\\n\\tfor(int i = 0; i <= destination[0]; i++){\\n\\t\\tfor(int j = 0; j <= destination[1]; j++) {\\n\\t\\t\\tif(i == 0 && j == 0) dp[i][j] = 1;\\n\\t\\t\\telse if(i == 0) dp[i][j] = dp[i][j - 1];\\n\\t\\t\\telse if(j == 0) dp[i][j] = dp[i - 1][j];\\n\\t\\t\\telse dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint i = destination[0], j = destination[1];\\n\\twhile(i != 0 && j != 0) {\\n\\t    // if k is smaller than or equal with the number of paths starting with H, then we pick \\'H\\' for current position.\\n\\t\\tif(dp[i][j - 1] >= k) {\\n\\t\\t\\tj--;\\n\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t// if k is larger than the number of paths starting with \\'H\\', we have to pick V then.\\n\\t\\t}else {\\n\\t\\t\\tk -= dp[i][j - 1];\\n\\t\\t\\ti--;\\n\\t\\t\\tsb.append(\\'V\\');\\n\\t\\t}\\n\\t}\\n\\tfor(int m = 0; m < i; m++) sb.append(\\'V\\');\\n\\tfor(int m = 0; m < j; m++) sb.append(\\'H\\');\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n    // dp(i, j) means how many paths are there for matrix of size i row and j column.\\n\\tint[][] dp = new int[destination[0] + 1][destination[1] + 1];\\n\\tfor(int i = 0; i <= destination[0]; i++){\\n\\t\\tfor(int j = 0; j <= destination[1]; j++) {\\n\\t\\t\\tif(i == 0 && j == 0) dp[i][j] = 1;\\n\\t\\t\\telse if(i == 0) dp[i][j] = dp[i][j - 1];\\n\\t\\t\\telse if(j == 0) dp[i][j] = dp[i - 1][j];\\n\\t\\t\\telse dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint i = destination[0], j = destination[1];\\n\\twhile(i != 0 && j != 0) {\\n\\t    // if k is smaller than or equal with the number of paths starting with H, then we pick \\'H\\' for current position.\\n\\t\\tif(dp[i][j - 1] >= k) {\\n\\t\\t\\tj--;\\n\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t// if k is larger than the number of paths starting with \\'H\\', we have to pick V then.\\n\\t\\t}else {\\n\\t\\t\\tk -= dp[i][j - 1];\\n\\t\\t\\ti--;\\n\\t\\t\\tsb.append(\\'V\\');\\n\\t\\t}\\n\\t}\\n\\tfor(int m = 0; m < i; m++) sb.append(\\'V\\');\\n\\tfor(int m = 0; m < j; m++) sb.append(\\'H\\');\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918388,
                "title": "python-simple-fast-solution-explained",
                "content": "**Observations**\\n1. We know for certain number of **\\'H\\'** and **\\'V\\'**, the total number of instructions are **comb(h + v, v)**\\n2. They should be sorted **lexicographically**, which means: the **order** of instructions with first character of **\\'H\\'** are always smaller than instructions with first character of **\\'V\\'**:\\nFor example, **destination = [2,3], k = 1**:\\n[\"**H**HHVV\", \"**H**HVHV\", \"**H**HVVH\", \"**H**VHHV\", \"**H**VHVH\", \"**H**VVHH\", \"**V**HHHV\", \"**V**HHVH\", \"**V**HVHH\", \"**V**VHHH\"]\\n3. If the first character is **\\'H\\'**, we know there will be **comb(h + v - 1, v)** number of instructions for the rest of characters because we used **one** **\\'H\\'**.\\n\\n**Algo**\\n1. Use the above 3 facts, we know after sored, **comb(h + v - 1, v)** number of instructions starting with **\\'H\\'**, and the rest of the instructions are starting with **\\'V\\'**\\n2. Based on value of **k**, we will know which **group** the kth instructions belongs to\\n3. Then we can get the characters one by one\\n4. Available characters will be **decreasing** until one of them hit **0**\\n\\n**Code:**\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        res = \\'\\'\\n        while h > 0 and v > 0:\\n            pre = comb(h + v - 1, v)\\n            \\n            if k <= pre:\\n                res += \\'H\\'\\n                h -= 1\\n            else:\\n                res += \\'V\\'\\n                v -= 1\\n                k -= pre\\n\\n        if h == 0:\\n            res += \\'V\\' * v\\n        if v == 0:\\n            res += \\'H\\' * h\\n            \\n        return res\\n```\\n**Runtime: 32ms**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        res = \\'\\'\\n        while h > 0 and v > 0:\\n            pre = comb(h + v - 1, v)\\n            \\n            if k <= pre:\\n                res += \\'H\\'\\n                h -= 1\\n            else:\\n                res += \\'V\\'\\n                v -= 1\\n                k -= pre\\n\\n        if h == 0:\\n            res += \\'V\\' * v\\n        if v == 0:\\n            res += \\'H\\' * h\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919710,
                "title": "c-pascal-triangle",
                "content": "OK, I am not good at this - but I wanted to solve it on intuition (without looking into textbooks). Took me a while. This may not be the best solution - there are several great math solutions with explanations in the discussion thread - check them out!\\n\\nInitially, I used \"next_permutation\" `k` times. That was too slow, obviously, but gave insight on how the string changes.\\n\\nLet\\'s think about it - imagine you have \"HHHHVVVV\". How many steps do we need to get to these states:\\n- \"HHHVVVV**H**\"?\\n- \"HHVVVV**HH**\"?\\n- \"HVVVV**HHH**\"?\\n- \"VVVV**HHHH**\"?\\n\\nThese are the largest combinations with 4 \"V\" and `i` \"H\". We get to these states after we exhausted all combinations with:\\n- 4 \"V\" and 1 \"H\" = nCr(4, 1) = 5 steps\\n- 4 \"V\" and 2 \"H\" = nCr(4, 2) = 15 steps\\n- 4 \"V\" and 3 \"H\" = nCr(4, 3) = 35 steps\\n- 4 \"V\" and 4 \"H\" = nCr(4, 4) = 70 steps\\n\\n`nCr(a, b)` is the number of combinations to choose `b` elements out of `a`. I am using the Pascal Triangle with memoisation to compute this. You get `Comb` for free if you use Python, and you better know this method if you want to stick with C++.\\n\\nSo the idea is to find out how many \"H\" we can move all the way to the right within `k`. Now, if \\'k\\' is zero - we construct and return the string - easy. \\n\\nOtherwise, we need to do one more step. What is the next permutation for \"HHHVVVV**H**\" (`i == 1`) ? It\\'s \"HH**V**HHVVV\". The first \"V\" is in its final position, and the rest of the string - the smallest combination of remaining Hs and Vs. So, we keep `i + 1` \"H\", add 1 \"V\", and call `kthSmallestPath` for remaining \"H\", \"V\" and `k`.\\n\\nExample: [4, 4], k == \\'9\\'.\\n1. 5 steps to get from \"HHHHVVVV\" to \"HHHVVVV**H**\", `i == 1`. \\n2. Keep \"HHV\", and call our function for [2, 3], `k == 4`.\\n3. 4 steps to get from \"HHVVV\" to \"HVVV**H**\", `i == 1`.\\n4. `k == 0`, return \"HVVVH\".\\n5. Combine strings, the final result is \"HHV\" + \"HVVVH\".\\n\\n**C++**\\n```cpp\\nint dp[17][17] = {};\\nclass Solution {\\n    int nCr(int i, int j) {\\n        if (i == 1 || j == 1)\\n            return 1;\\n        return dp[i][j] ? dp[i][j] : dp[i][j] = nCr(i - 1, j) + nCr(i, j - 1);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int h = d[1], v = d[0], cur = 1, i = 1;\\n        for (; i <= h; ++i) {\\n            if (nCr(v + 1, i + 1) > k)\\n                break;                \\n            cur = nCr(v + 1, i + 1);\\n        }\\n        if (k - cur == 0)\\n            return string(h - i + 1, \\'H\\') + string(v, \\'V\\') + string(i - 1, \\'H\\');\\n        return string(h - i, \\'H\\')  + \"V\" + kthSmallestPath(vector<int>() = {v - 1 , i}, k - cur);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[17][17] = {};\\nclass Solution {\\n    int nCr(int i, int j) {\\n        if (i == 1 || j == 1)\\n            return 1;\\n        return dp[i][j] ? dp[i][j] : dp[i][j] = nCr(i - 1, j) + nCr(i, j - 1);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int h = d[1], v = d[0], cur = 1, i = 1;\\n        for (; i <= h; ++i) {\\n            if (nCr(v + 1, i + 1) > k)\\n                break;                \\n            cur = nCr(v + 1, i + 1);\\n        }\\n        if (k - cur == 0)\\n            return string(h - i + 1, \\'H\\') + string(v, \\'V\\') + string(i - 1, \\'H\\');\\n        return string(h - i, \\'H\\')  + \"V\" + kthSmallestPath(vector<int>() = {v - 1 , i}, k - cur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922323,
                "title": "c-o-n-explained",
                "content": "#### Fundamentals\\n\\n- We need to move to the right `col` steps and down `row` steps to reach to the destination (bottom right) cell => the result string is always:\\n  - of length `col + row`\\n  - consisted of `row` \\'H\\'s and `col` \\'V\\'s\\n- The possible strings are **lexicographically ordered** => \\'H\\' < \\'V\\'\\n- The total number of possible paths (number of combinations of `row` \\'H\\'s and `col` \\'V\\'s) is `nCr(row + col, row)`. i.e., `\"length of string\" choose \"number of H\"`\\n  - Why? We have `row + col` positions in the string, we need to choose `row` of them for \\'H\\'.\\n- How to calculate `N choose K`?\\n  - `N!/(N-K)!/K!` (Why? this is a math question. I\\'m not going to explain it here)\\n  - `tgamma(x)` returns `(x-1)!`\\n  - There are many other methods to calculate `N choose K`\\n\\n#### Solve the Problem\\n\\n1. Let\\'s only consider the first letter.\\n  a) Say, we have `h` of \\'H\\'s and `v` of \\'V\\'s, there are `x` possible combinations (`x = nCr(h+v, h)`)\\n  b) The chance we choose \\'H\\' for the first letter is `h/(h+v)` => in all combinations, there are `y` of them (`y = x * h/(h+v)`) have \\'H\\' as the first letter\\n  c) All the combinations are *lexicographically ordered* => the **first** `y` combinations have \\'H\\' as the first letter\\n  d) We want the *kth* combination => **if `k <= y`, the first letter should be \\'H\\', otherwise it should be \\'V\\'.**\\n2. We have found the first letter. Now let\\'s look at the next one:\\n\\ta) If the first letter is \\'H\\'\\n\\t\\t- The number of combinations start with \\'H\\' is `y` (calculated in step 1)\\n\\t\\t- We have used one \\'H\\', and we have `h-1` left\\n\\t\\t- The length of rest of strting is `h+v-1`\\n\\t\\t- The remaining combinations (all start with \\'H\\') - from 1st to yth, since k fell into this range, it remains the same (we need to find kth combination of 1 to y).\\n\\tb) If the first letter is \\'V\\'\\n\\t\\t- The number of combinations start with \\'V\\' is `x - y`\\n\\t\\t- We didn\\'t use \\'H\\', so we still have `h` \\'H\\'s left\\n\\t\\t- The length of rest of strting is `h+v-1`\\n\\t\\t- The remaining combinations (all start with \\'V\\') are from `y+1` to `x` => we need to find (kth from 1st, that is) `k-y`th combination from `y+1`.\\n\\tc) Apply same method of step 1, we can find the 2nd letter.\\n3. Repeated step 2 until we used either all \\'H\\'s or all \\'V\\'s.\\n4. Fill rest of the string with the other letter.\\n\\n#### Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    size_t NChooseK(int n, int k) {\\n        return round(tgamma(n+1)/tgamma(k+1)/tgamma(n-k+1));\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int numHLeft = destination[1], numCharsToBuild = destination[0] + destination[1];\\n        uint64_t totalMax = NChooseK(numCharsToBuild, numHLeft);\\n        string ans = \"\";\\n        while (numHLeft && numHLeft < numCharsToBuild) {\\n            uint64_t maxH = totalMax*numHLeft/numCharsToBuild;\\n            if (k <= maxH) {\\n                ans += \"H\";\\n                numHLeft--;\\n                totalMax = maxH;\\n            } else {\\n                ans += \"V\";\\n                totalMax -= maxH;\\n\\t\\t\\t\\tk -= maxH;\\n            }\\n            numCharsToBuild--;\\n        }\\n        ans += string(numCharsToBuild, numHLeft ? \\'H\\' : \\'V\\');\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Complexity\\n\\nWe built the string of length `row + col` letter by letter => O(n), where `n = row + col`\\n\\n#### Additional Note\\n\\nCalculating `N choose K` can be time consuming. We only need to calculate it **once** in this solution, instead of _every step_ (like many other solutions do).\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    size_t NChooseK(int n, int k) {\\n        return round(tgamma(n+1)/tgamma(k+1)/tgamma(n-k+1));\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int numHLeft = destination[1], numCharsToBuild = destination[0] + destination[1];\\n        uint64_t totalMax = NChooseK(numCharsToBuild, numHLeft);\\n        string ans = \"\";\\n        while (numHLeft && numHLeft < numCharsToBuild) {\\n            uint64_t maxH = totalMax*numHLeft/numCharsToBuild;\\n            if (k <= maxH) {\\n                ans += \"H\";\\n                numHLeft--;\\n                totalMax = maxH;\\n            } else {\\n                ans += \"V\";\\n                totalMax -= maxH;\\n\\t\\t\\t\\tk -= maxH;\\n            }\\n            numCharsToBuild--;\\n        }\\n        ans += string(numCharsToBuild, numHLeft ? \\'H\\' : \\'V\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400653,
                "title": "c-no-math",
                "content": "```\\n//idea\\n  we calculate the no of ways of reaching the dest from each point in\\n  advance , how?\\n  let goal (n,m)  let put distance in dp[][] matrix;\\n  obviuosly dp[n][m] = 0; \\n  other base cases if(i == n || j == m) means we can\\'t move down / we can\\'t move right\\n  so ,dp[i][j] = 1; for all these , i.e; there is only one way to reach goal.\\n  o.w. if we are at i ,j we have dp[i][j] = dp[i+1][j] + dp[i][j+1] ways\\n  \\n  that\\'s precomputation done , now we can move according to following:-\\n  1) if our k < total horizontal move we will moving this way\\n  2) if not , then we need to move verticaly down and also need to update k as k = k- horzizontal ways\\n```\\n\\n```\\n string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[0]+1 , m = dest[1]+1;\\n        int dp[n][m];\\n        dp[n-1][m-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--) dp[i][m-1] = 1;\\n        for(int i=m-2;i>=0;i--) dp[n-1][i] = 1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans;\\n        int i = 0, j =0;\\n        while(i<n && j < m)\\n        {\\n             if(i+1 == n && j+1 == m) break;\\n                \\n                if(i+1 == n)\\n                {\\n                    ans += \\'H\\';\\n                    j++;\\n                }\\n                else if(j+1 == m)\\n                {\\n                    ans += \\'V\\';\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(k <= dp[i][j+1])\\n                    {\\n                        ans += \\'H\\';\\n                        j++;\\n                    }\\n                    else\\n                    {\\n                        ans += \\'V\\';\\n                        k -= dp[i][j+1];\\n                        i++;\\n                    }\\n                }\\n        }\\n       \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//idea\\n  we calculate the no of ways of reaching the dest from each point in\\n  advance , how?\\n  let goal (n,m)  let put distance in dp[][] matrix;\\n  obviuosly dp[n][m] = 0; \\n  other base cases if(i == n || j == m) means we can\\'t move down / we can\\'t move right\\n  so ,dp[i][j] = 1; for all these , i.e; there is only one way to reach goal.\\n  o.w. if we are at i ,j we have dp[i][j] = dp[i+1][j] + dp[i][j+1] ways\\n  \\n  that\\'s precomputation done , now we can move according to following:-\\n  1) if our k < total horizontal move we will moving this way\\n  2) if not , then we need to move verticaly down and also need to update k as k = k- horzizontal ways\\n```\n```\\n string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[0]+1 , m = dest[1]+1;\\n        int dp[n][m];\\n        dp[n-1][m-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--) dp[i][m-1] = 1;\\n        for(int i=m-2;i>=0;i--) dp[n-1][i] = 1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans;\\n        int i = 0, j =0;\\n        while(i<n && j < m)\\n        {\\n             if(i+1 == n && j+1 == m) break;\\n                \\n                if(i+1 == n)\\n                {\\n                    ans += \\'H\\';\\n                    j++;\\n                }\\n                else if(j+1 == m)\\n                {\\n                    ans += \\'V\\';\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(k <= dp[i][j+1])\\n                    {\\n                        ans += \\'H\\';\\n                        j++;\\n                    }\\n                    else\\n                    {\\n                        ans += \\'V\\';\\n                        k -= dp[i][j+1];\\n                        i++;\\n                    }\\n                }\\n        }\\n       \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918394,
                "title": "c-o-r-c-2-solution-with-explanation",
                "content": "We can restate this problem as finding the ```k``` th string in lexicographic order among strings consisting of ```c``` \\u201CV\\u201Ds and ```r``` \\u201CH\\u201Ds. Let ```s(r, c, k)``` denote the answer string for inputs ```r, c, k```. \\n\\nNote that if ```r == 0```, the only possible string is that having ```c``` \\u201CH\\u201Ds and if ```c == 0```, the only possible string is that having ```r``` \\u201CV\\u201Ds. So, these two cases can be handled easily. Now we come to the case where both ```r``` and ```c``` and non-zero. \\nNote that all strings starting with \\u201CH\\u201D appear before those starting with \\u201CV\\u201D. To find the number of strings starting with \\u201CH\\u201D, we place \\u201CH\\u201D in the first position, and compute the number of strings of length ```r + c - 1``` which can be formed using ```c-1``` \\u201CH\\u201Ds and ```r``` \\u201CV\\u201Ds. This is given by ```nCr(r + c - 1, c-1)```. \\n\\nSo, if ```k <= nCr(r + c - 1, c-1)```, we know that the answer starts with an \\u201CH\\u201D. Having placed \\u201CH\\u201D in the first position, we can forget about it, and solve the problem of constructing the string having ```r``` \\u201CV\\u201Ds and ```c-1``` \\u201CH\\u201Ds (because we used one up). Because all strings starting with \\u201CH\\u201D appear at the top of the list, and we know that the answer starts with an \\u201CH\\u201D, the ```k``` th string in the list of strings of size ```r + c``` will be the ```k``` th string in the list of strings of size ```r + c - 1```. So, the answer is ``` \\u201CH\\u201D + s(r, c-1, k)```. \\n\\nIf ```k > nCr(r + c - 1, c-1)```, then we know that it starts with a \\u201CV\\u201D. Having placed one \\u201CV\\u201D, we consider the problem of creating strings of size ```r + c - 1```, using ```r - 1``` \\u201CV\\u201Ds and ```c``` \\u201CH\\u201Ds. Now, because we have removed the ```nCr(r + c - 1, c-1)``` strings starting with \\u201CH\\u201D, the ```k``` th string in the list of strings of size ```r + c``` will be the ```k - nCr(r + c - 1, c-1)``` th string in the list of strings of size ```r + c - 1```. So, the answer in this case is ``` \\u201CV\\u201D + s(r-1, c-1, k - nCr(r + c - 1, c-1))```.\\n\\nThe only \\u201Ctrick\\u201D here is to precompute values of ```nCr``` by using the relationship ```nCr(a, b) = nCr(a-1, b) + nCr(a-1, b-1)```. That way, when performing the recursion to construct the strings, we can just query these values instead of recomputing them.\\n\\nThe time complexity of constructing strings is ```O(r+c)```, because at each step, either ```r``` or ```c``` decreases by 1. The time complexity of computing all relevant ```nCr``` values is ```O((r+c)^2)```, but in this case it is practically constant because we know ```0 <= r + c <= 15```.\\n```\\nclass Solution {\\n    vector<vector<long long int>> chooses;\\n    string help(int r, int c, int k){\\n        if (c == 0)\\n            return string(r, \\'V\\');\\n\\n        if (r == 0)\\n            return string(c, \\'H\\');\\n\\n        if (k <= chooses[r+c-1][c-1])\\n            return \"H\" + help(r, c-1, k);\\n        \\n        return \"V\" + help(r-1, c, k - chooses[r+c-1][c-1]);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        chooses = vector<vector<long long int>>(40, vector<long long int>(40));\\n        for (int i = 0; i <= 35; ++i){\\n            chooses[i][0] = chooses[i][i] = 1;\\n        }\\n        for (int i = 2; i <= 35; ++i){\\n            for (int j = 1; j <= i/2; ++j){\\n                chooses[i][j] = chooses[i-1][j] + chooses[i-1][j-1];\\n                chooses[i][i-j] = chooses[i][j];\\n            }\\n        }\\n        return help(destination[0], destination[1], k);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```k```\n```c```\n```r```\n```s(r, c, k)```\n```r, c, k```\n```r == 0```\n```c```\n```c == 0```\n```r```\n```r```\n```c```\n```r + c - 1```\n```c-1```\n```r```\n```nCr(r + c - 1, c-1)```\n```k <= nCr(r + c - 1, c-1)```\n```r```\n```c-1```\n```k```\n```r + c```\n```k```\n```r + c - 1```\n``` \\u201CH\\u201D + s(r, c-1, k)```\n```k > nCr(r + c - 1, c-1)```\n```r + c - 1```\n```r - 1```\n```c```\n```nCr(r + c - 1, c-1)```\n```k```\n```r + c```\n```k - nCr(r + c - 1, c-1)```\n```r + c - 1```\n``` \\u201CV\\u201D + s(r-1, c-1, k - nCr(r + c - 1, c-1))```\n```nCr```\n```nCr(a, b) = nCr(a-1, b) + nCr(a-1, b-1)```\n```O(r+c)```\n```r```\n```c```\n```nCr```\n```O((r+c)^2)```\n```0 <= r + c <= 15```\n```\\nclass Solution {\\n    vector<vector<long long int>> chooses;\\n    string help(int r, int c, int k){\\n        if (c == 0)\\n            return string(r, \\'V\\');\\n\\n        if (r == 0)\\n            return string(c, \\'H\\');\\n\\n        if (k <= chooses[r+c-1][c-1])\\n            return \"H\" + help(r, c-1, k);\\n        \\n        return \"V\" + help(r-1, c, k - chooses[r+c-1][c-1]);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        chooses = vector<vector<long long int>>(40, vector<long long int>(40));\\n        for (int i = 0; i <= 35; ++i){\\n            chooses[i][0] = chooses[i][i] = 1;\\n        }\\n        for (int i = 2; i <= 35; ++i){\\n            for (int j = 1; j <= i/2; ++j){\\n                chooses[i][j] = chooses[i-1][j] + chooses[i-1][j-1];\\n                chooses[i][i-j] = chooses[i][j];\\n            }\\n        }\\n        return help(destination[0], destination[1], k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918368,
                "title": "python-binomial-problem-dp-top-down-w-memoization",
                "content": "Main insight: There are two choices at each index, go with \"H\" or go with \"V\". The one to choose can be determined by k. \\n\\nMath prerequisite: How many bitstrings can you make with i 0\\'s and j 1\\'s? nCr(i+j,j). You have i+j slots and j of them must be 1\\'s. Out of all these bitstrings, how many of them start with 0? nCr(i+j-1,j). This is because you set the first bit as 0, and you are left with i+j-1 bits remaining to assign, j of them must be ones. How many of the bitstrings start with 1? nCr(i+j-1,j-1), by the same reasoning, i+j-1 bits left to assign, j-1 of them must be 1. \\n\\nState representation: (i,j,k) as (number of \"V\"\\'s to assign, number of \"H\"\\'s to assign, index of answer). \\n\\nSo then the recurrence is: If k <= nCr(i+j-1,j-1), then we know that our answer must start with \"H\". Then, all that is left to do is the assign the rest of the bits, and we make our recursive call. If k > nCr(i+j-1,j-1), then our answer must start with \"V\", and we subtract nCr(i+1-1,j-1) from k and make recursive call. We can do this subtraction because we bypass all the strings that start with \"H\", all of which are lexicographically smaller than the strings that start with \"V\". \\n\\nThe base case is k = 1, just assign the lexicographically smallest string, using all \"H\"\\'s first then using all \"V\"\\'s. j*\"H\"+i*\"V\".\\n\\nExample: [2,3] k = 9\\n\\n\\t\\t\\t\\t***** (no letters assigned)\\n\\t\\t\\t/\\t\\t\\t\\t\\\\ (Go right, k is now 9-6=3, bypassed all leaves on left)\\n\\t\\tH**** \\t\\t\\t\\tV****  (nCr(2+2,2)=6<k, so go right.)\\n\\t\\t\\t\\t\\t\\t/\\t\\t\\t\\\\     \\n\\t\\t\\t\\t\\t\\tVH***\\t\\tVV*** (nCr(3,2)=3>=k, go left.)\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tVHH**\\t\\tVHV** (nCr(2,1)=2<k, go right. k is 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tVHVV* (k is 1, reached base case)\\n\\nVHVVV is the answer. \\n\\nO(MN) O(MN), can improve memory by constant multiplier of we do bottom up DP, instead of memoization. \\n\\nNote: This week\\'s contest last 3 problems all are the same flavor of DP. Know what state you are at, define the recurrence relation by possible moves, then perform the recursion by doing those moves.  \\n\\n```\\nfrom math import comb\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        i,j = destination\\n        \\n        @lru_cache(None)\\n        def helper(i,j,k):\\n            if k == 1:\\n                return \"H\"*j+\"V\"*i\\n            else:\\n                horizontal = comb(i+j-1,j-1)\\n                if k <= horizontal:\\n                    return \"H\" + helper(i,j-1,k)\\n                else:\\n                    return \"V\" + helper(i-1,j,k-horizontal)\\n        \\n        return helper(i,j,k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        i,j = destination\\n        \\n        @lru_cache(None)\\n        def helper(i,j,k):\\n            if k == 1:\\n                return \"H\"*j+\"V\"*i\\n            else:\\n                horizontal = comb(i+j-1,j-1)\\n                if k <= horizontal:\\n                    return \"H\" + helper(i,j-1,k)\\n                else:\\n                    return \"V\" + helper(i-1,j,k-horizontal)\\n        \\n        return helper(i,j,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919444,
                "title": "c-simple-explanation",
                "content": "First thing to keep in mind is if the destination is (r,c) the string whose kth combination we have to find is made up of \\'c\\' number of H\\'s and \\'r\\' number of V\\'s.\\n\\n***Intuition***: Now to find the kth lexographical string in order made up of \\'a\\' H\\'s and \\'b\\' V\\'s, let\\'s start by thinking what the first character in our string should be.\\nFor that we need : \\nNumber of strings starting with H i.e equal to ``` fact(a-1+b)/(fact(a-1)*fact(b)) which is equal to (a+b-1)Cb where C  stands for Combinations```.\\n\\nNow, if ```k <  x (where x = number of strings starting with H), our answer string should start with H. else our answer string should start with V and k = k-x.```\\n\\nHere is the code for reference.\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n       \\n        vector<vector<int>> vec(destination[0] + destination[1] + 1,vector<int>());  /// Vector to store the required nCr we need.\\n        int n = destination[0] + destination[1];\\n        vec[1].push_back(1);\\n        vec[1].push_back(1);\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0; j<=vec[i-1].size();j++){\\n                if(j == vec[i-1].size() || j == 0)\\n                    vec[i].push_back(1);\\n                else vec[i].push_back(vec[i-1][j-1] + vec[i-1][j]);\\n            }\\n        }  \\n        string ans;\\n        int a = destination[1];\\n        int b = destination[0];\\n        while( k > 0){\\n            int x = vec[a-1+b][b];  /// x is the number of strings starting with \\'H\\'.\\n\\t\\t\\t\\n\\t\\t\\tif(k <= x){    \\n                ans += \\'H\\';\\n                a--;\\n\\t\\t\\t\\tif(k == x)\\n\\t\\t\\t\\t\\tk-=x;\\n\\t\\t\\t}\\n            else if(k > x){\\n                ans += \\'V\\';\\n                k -= x;\\n                b--;\\n            }\\n            if(a == 0 || b == 0){   /// if at any point either a or b == 0, we should break;\\n                break;\\n            }\\n        }\\n  \\n        for(int i = 0;i<b;i++)    /// add remaining V\\'s\\n            ans += \\'V\\';\\n        for(int i = 0;i<a;i++)   /// add remaining H\\'s\\n             ans += \\'H\\';\\n        return ans;      \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "``` fact(a-1+b)/(fact(a-1)*fact(b)) which is equal to (a+b-1)Cb where C  stands for Combinations```\n```k <  x (where x = number of strings starting with H), our answer string should start with H. else our answer string should start with V and k = k-x.```\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n       \\n        vector<vector<int>> vec(destination[0] + destination[1] + 1,vector<int>());  /// Vector to store the required nCr we need.\\n        int n = destination[0] + destination[1];\\n        vec[1].push_back(1);\\n        vec[1].push_back(1);\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0; j<=vec[i-1].size();j++){\\n                if(j == vec[i-1].size() || j == 0)\\n                    vec[i].push_back(1);\\n                else vec[i].push_back(vec[i-1][j-1] + vec[i-1][j]);\\n            }\\n        }  \\n        string ans;\\n        int a = destination[1];\\n        int b = destination[0];\\n        while( k > 0){\\n            int x = vec[a-1+b][b];  /// x is the number of strings starting with \\'H\\'.\\n\\t\\t\\t\\n\\t\\t\\tif(k <= x){    \\n                ans += \\'H\\';\\n                a--;\\n\\t\\t\\t\\tif(k == x)\\n\\t\\t\\t\\t\\tk-=x;\\n\\t\\t\\t}\\n            else if(k > x){\\n                ans += \\'V\\';\\n                k -= x;\\n                b--;\\n            }\\n            if(a == 0 || b == 0){   /// if at any point either a or b == 0, we should break;\\n                break;\\n            }\\n        }\\n  \\n        for(int i = 0;i<b;i++)    /// add remaining V\\'s\\n            ans += \\'V\\';\\n        for(int i = 0;i<a;i++)   /// add remaining H\\'s\\n             ans += \\'H\\';\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278031,
                "title": "c-dp-math-atcoder-editorial",
                "content": "A similar question came ino an Atcoder contest:-\\nquestion Link -[https://atcoder.jp/contests/abc202/tasks/abc202_d]()\\neditorial Link - [https://atcoder.jp/contests/abc202/editorial/1893](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    int ncr[31][31];\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n\\n        // calculating the combination values\\n        for(int n=1;n<31;++n)\\n        {\\n            ncr[n][0]=1;\\n            for(int r=1;r<n;++r)\\n            {\\n                ncr[n][r]=ncr[n-1][r]+ncr[n-1][r-1];\\n            }\\n            ncr[n][n]=1;\\n\\n        }\\n        string res=\"\";\\n        int H=destination[1];\\n        int V=destination[0];\\n        \\n        while(H!=0 && V!=0)\\n        {\\n            int ways=ncr[H+V-1][H-1];\\n            \\n            \\n            if(ways>=k)\\n            {\\n                res+=\\'H\\';\\n                H--;\\n            }\\n            else\\n            {\\n                res+=\\'V\\';\\n                k-=ways;\\n                V--;\\n            }\\n        }\\n        while(H--)\\n            res+=\\'H\\';\\n        while(V--)\\n            res+=\\'V\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ncr[31][31];\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n\\n        // calculating the combination values\\n        for(int n=1;n<31;++n)\\n        {\\n            ncr[n][0]=1;\\n            for(int r=1;r<n;++r)\\n            {\\n                ncr[n][r]=ncr[n-1][r]+ncr[n-1][r-1];\\n            }\\n            ncr[n][n]=1;\\n\\n        }\\n        string res=\"\";\\n        int H=destination[1];\\n        int V=destination[0];\\n        \\n        while(H!=0 && V!=0)\\n        {\\n            int ways=ncr[H+V-1][H-1];\\n            \\n            \\n            if(ways>=k)\\n            {\\n                res+=\\'H\\';\\n                H--;\\n            }\\n            else\\n            {\\n                res+=\\'V\\';\\n                k-=ways;\\n                V--;\\n            }\\n        }\\n        while(H--)\\n            res+=\\'H\\';\\n        while(V--)\\n            res+=\\'V\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919332,
                "title": "simple-cpp-dp-m-x-n",
                "content": "First let\\'s calculate and save how many ways we can arrive to destination starting from i, j.\\nFor example for [2, 3] k = 1\\nour dp will look like\\n10 6  3  1 \\n 4  3  2  1 \\n 1  1  1  1 \\n starting from 0,0 if ```dp[i][j] >= k``` we will go to right until `dp[i][j] < k` then we go down.\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int n = d[0], m = d[1];\\n        string res;\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 1));\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n            for (int j = m - 1; j >= 0; j--)\\n                dp[i][j] = dp[i][j + 1] + dp[i + 1][j];\\n\\n        for (int j = 0, i = 0; j < m || i < n;) {\\n            if (dp[i][j] >= k && j < m) {\\n                res.push_back(\\'H\\');\\n                j++;\\n            }\\n            else {\\n                if ((k -= dp[i][j]) > 0) // else we are on the final column so we dont have to decrement value of j\\n                    j--, res.pop_back();\\n                res.push_back(\\'V\\');\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nEdit \\nI started with brute force `dfs` at the beginning (Not knowing `k` can go to a very high number).  Then I realized that we don\\'t have to generate all those combinations. So I decided to start from the destination save how many ways we can reach to destination from [i, j]. So we will avoid `k - 1` ways and looking for `k`th route.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j] >= k```\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int n = d[0], m = d[1];\\n        string res;\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 1));\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n            for (int j = m - 1; j >= 0; j--)\\n                dp[i][j] = dp[i][j + 1] + dp[i + 1][j];\\n\\n        for (int j = 0, i = 0; j < m || i < n;) {\\n            if (dp[i][j] >= k && j < m) {\\n                res.push_back(\\'H\\');\\n                j++;\\n            }\\n            else {\\n                if ((k -= dp[i][j]) > 0) // else we are on the final column so we dont have to decrement value of j\\n                    j--, res.pop_back();\\n                res.push_back(\\'V\\');\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520795,
                "title": "c-easy-solution-do-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n=destination[0]+1,m=destination[1]+1;\\n        \\n        //this code is straight forward it calculate and stores no. ways to go to destination from i,j\\n        vector<vector<int>> ways(n,vector<int> (m));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1||j==m-1){\\n                    ways[i][j]=1; continue;\\n                }\\n                ways[i][j]=ways[i][j+1]+ways[i+1][j];\\n            }\\n        }\\n\\t\\t \\n\\t\\t\\n\\t\\t// with the help of above table ans can be generated\\n\\t\\t//suppose we are at (i, j)   we need to decide whether to go Horizontal or Vertical\\n\\t\\n        string ans=\"\";\\n        \\n        int i=0,j=0;\\n        while(i<n-1&&j<m-1){\\n\\t\\t    // if k is less than no of ways to go from selecting horizontal path\\n             if(k<=ways[i][j+1]){\\n                ans=ans+\\'H\\';j++; \\n             }\\n\\t\\t\\t // else we chose vertical for greater k\\n            else{\\n                k=k-ways[i][j+1];\\n                i++;\\n                ans=ans+\\'V\\';\\n            }\\n            \\n         }\\n         while(j++<m-1) ans=ans+\\'H\\';\\n         while(i++<n-1) ans=ans+\\'V\\';\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n=destination[0]+1,m=destination[1]+1;\\n        \\n        //this code is straight forward it calculate and stores no. ways to go to destination from i,j\\n        vector<vector<int>> ways(n,vector<int> (m));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1||j==m-1){\\n                    ways[i][j]=1; continue;\\n                }\\n                ways[i][j]=ways[i][j+1]+ways[i+1][j];\\n            }\\n        }\\n\\t\\t \\n\\t\\t\\n\\t\\t// with the help of above table ans can be generated\\n\\t\\t//suppose we are at (i, j)   we need to decide whether to go Horizontal or Vertical\\n\\t\\n        string ans=\"\";\\n        \\n        int i=0,j=0;\\n        while(i<n-1&&j<m-1){\\n\\t\\t    // if k is less than no of ways to go from selecting horizontal path\\n             if(k<=ways[i][j+1]){\\n                ans=ans+\\'H\\';j++; \\n             }\\n\\t\\t\\t // else we chose vertical for greater k\\n            else{\\n                k=k-ways[i][j+1];\\n                i++;\\n                ans=ans+\\'V\\';\\n            }\\n            \\n         }\\n         while(j++<m-1) ans=ans+\\'H\\';\\n         while(i++<n-1) ans=ans+\\'V\\';\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918996,
                "title": "intuitive-solution-similar-to-find-rank-of-word-in-dictionary-c",
                "content": "This question is similar to finding rank of a given word in dictionary which is constituted by \"H\" and \"V\" characters only. \\nFirst thing we need to know is the number of steps needed to reach the destination. Suppose destination is (x, y) and we know that starting point is (0, 0), then the number of steps would be:\\n```\\ndistance = (x-0) + (y-0) = x+y\\n```\\n\\nSo the string\\'s length would be of length ```x+y```. \\n\\nOne more thing to observe is that this string will be made up of **x** V\\'s and **y** H\\'s. This is because we whichever path we take we will have to move x steps downwards and y steps rightwards. So the final string will be a permutation of the string\\n```\\n\"HHHH....(y-times)VVVVVV.....(x-times)\"\\n```\\n\\n**Combination**\\nThe number of strings with x V\\'s and y H\\'s can be written as:\\nN = (h + v)! / ( h! * v! )\\n\\nThis is equivalent to : ``` (h+v)C(h) or  (h+v)C(v)``` \\n\\nThus the required string can be formed by finding the ```kth``` permutation of this string. \\nSteps to find the ```kth``` string:\\n```\\nlet v = number of vertical steps\\n\\th = number of horizontal steps\\n\\tans = reuired string\\n\\tcomb = number permutations of string having h - H\\'s and v - V\\'s\\n\\tcurr = rank of current string\\n\\tk = rank of the required string\\n1. Take an empty string, suppose ans = \"\"\\n2. Since the smallest string of length h+v will start with \"H\", \\n\\t\\t1. \\tIf h!=0, then we find number of string starting with H as \\n\\t\\t\\t\\t\\t\\t\\tcomb = \"H\" + Combination( (h-1) + v, h-1)\\n\\t\\t\\t\\t\\t\\t\\th--;\\n\\t\\t2. Else, no H is left so we add \"V\" at the end\\n\\t\\t\\t\\t\\t\\t\\tans = ans + \"V\"\\n\\t\\t\\t\\t\\t\\t\\tv--\\n3. Check if the curr+comb<=k, if yes then replace \"H\" with \"V\" and curr = curr+comb. This indicates that the required string has rank greater than the rank of largest rank string with \"H\" at the current index.\\n4. If ans.length< required string\\'s length, go back to step 2\\n5. Else the ans is the required string.\\n```\\n\\n**Note**\\n* I have implemented the function `Combination (int n, int r) ` separately in order to calculate nCr without overflow\\n* **curr** starts with 1 because rank is 1-indexed and the first string generated would be at rank 1 and not rank 0. e.g: \"HHVV\" will be at rank 1, but if curr starts with 0 the answers comes out to be 0 as there are no other strings before 1.\\nCode:\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0]+destination[1];\\n        int curr=1, v=destination[0], h=destination[1];\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            if(h>0){\\n                ans += \"H\";\\n                h--;\\n            }\\n            else{\\n                ans += \"V\";\\n                v--;\\n            }\\n            ll comb = combination(h+v, h);\\n            if(curr+comb<=k){\\n                curr += comb;\\n                ans[ans.size()-1] = \\'V\\';\\n                h++;\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    ll combination(int n, int r){\\n        ll ans = 1, k=1;\\n        if (n - r < r) \\n            r = n - r; \\n\\n        if (r != 0) { \\n            while (r) { \\n                ans *= n; \\n                k *= r; \\n                long long m = __gcd(ans, k);\\n                ans /= m; \\n                k /= m; \\n\\n                n--; \\n                r--; \\n            }  \\n        } \\n        else\\n            ans = 1;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** `O((r+c)*r*log(r))`\\n**Explaination:** `r+c - is constituted by the first for loop, r - constituted by while loop if function combination(), log(r) - is constituted by the __gcd() function`\\n\\n**Space Complexity:** `O(r+c), taken by the answer string`",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\ndistance = (x-0) + (y-0) = x+y\\n```\n```x+y```\n```\\n\"HHHH....(y-times)VVVVVV.....(x-times)\"\\n```\n``` (h+v)C(h) or  (h+v)C(v)```\n```kth```\n```kth```\n```\\nlet v = number of vertical steps\\n\\th = number of horizontal steps\\n\\tans = reuired string\\n\\tcomb = number permutations of string having h - H\\'s and v - V\\'s\\n\\tcurr = rank of current string\\n\\tk = rank of the required string\\n1. Take an empty string, suppose ans = \"\"\\n2. Since the smallest string of length h+v will start with \"H\", \\n\\t\\t1. \\tIf h!=0, then we find number of string starting with H as \\n\\t\\t\\t\\t\\t\\t\\tcomb = \"H\" + Combination( (h-1) + v, h-1)\\n\\t\\t\\t\\t\\t\\t\\th--;\\n\\t\\t2. Else, no H is left so we add \"V\" at the end\\n\\t\\t\\t\\t\\t\\t\\tans = ans + \"V\"\\n\\t\\t\\t\\t\\t\\t\\tv--\\n3. Check if the curr+comb<=k, if yes then replace \"H\" with \"V\" and curr = curr+comb. This indicates that the required string has rank greater than the rank of largest rank string with \"H\" at the current index.\\n4. If ans.length< required string\\'s length, go back to step 2\\n5. Else the ans is the required string.\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0]+destination[1];\\n        int curr=1, v=destination[0], h=destination[1];\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            if(h>0){\\n                ans += \"H\";\\n                h--;\\n            }\\n            else{\\n                ans += \"V\";\\n                v--;\\n            }\\n            ll comb = combination(h+v, h);\\n            if(curr+comb<=k){\\n                curr += comb;\\n                ans[ans.size()-1] = \\'V\\';\\n                h++;\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    ll combination(int n, int r){\\n        ll ans = 1, k=1;\\n        if (n - r < r) \\n            r = n - r; \\n\\n        if (r != 0) { \\n            while (r) { \\n                ans *= n; \\n                k *= r; \\n                long long m = __gcd(ans, k);\\n                ans /= m; \\n                k /= m; \\n\\n                n--; \\n                r--; \\n            }  \\n        } \\n        else\\n            ans = 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918429,
                "title": "python3-greedy",
                "content": "Algo \\nGiven `m` H and `n` V to place, we check if it is possible to place H. If so, decrement `n`; otherwise decrement `m`. Since there are `comb(m+n-1, n-1)` instructions starting with H, the condition to check for placing H is `comb(m+n-1, n-1) >= k`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination # m \"V\" & n \"H\" in total \\n        ans = \"\"\\n        while n: \\n            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with \"H\"  \\n            if kk >= k: \\n                ans += \"H\"\\n                n -= 1\\n            else: \\n                ans += \"V\"\\n                m -= 1\\n                k -= kk \\n        return ans + m*\"V\"\\n```\\n\\nAnalysis\\nTime complexity `O(M*N + N^2)`\\nSpace complexity `O(M+N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination # m \"V\" & n \"H\" in total \\n        ans = \"\"\\n        while n: \\n            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with \"H\"  \\n            if kk >= k: \\n                ans += \"H\"\\n                n -= 1\\n            else: \\n                ans += \"V\"\\n                m -= 1\\n                k -= kk \\n        return ans + m*\"V\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290018,
                "title": "c-brute-force-soln-tle-and-optimal-combinatrics-soln",
                "content": "Lets take given test case as example, with 2,3 eding point we know we will need 2vertical movements and 3 horizontal movements.\\n\\n```\\n/*\\n   1        2       3         4        5        6         7        8       9\\n\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \\n  \\n  10\\n\"VVHHH\"\\n\\n(VV , HHH)\\n\\nH H _ _ _\\n*/\\n\\n```\\n\\nIf we fix H as first position we know we will get 6 possible path and our k is less than that so we will fix H there and calculate for next step. If is k out of range we will fix V there.\\n\\nMoving H _ if we fix 2nd h there we will get 3 combinations and if k less equal than than then H is fixed.\\n\\nAnd if we fix V so we are removing all the earlier combinations from k. As V _ _ _ _ _ is at 7 index  so remove 6 from k.\\n\\nHope this helps even a bit.\\n\\n```\\n//upvote if found helpful\\n int comb(int n, int r){\\n        \\n        //nCr = n! / (n-r)! r! => n .... n-r+1/r! => n/1 * n-1/2 * n-2/3 ... n-r+1/r \\n        int ans = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            \\n            ans = ans * (n-i+1)/i;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& d, int k){\\n            \\n        int h = d[1], v = d[0];\\n        int n = h+v;\\n        string path = \"\";\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(h){\\n                \\n                int tot_comb = comb(h+v-1, v);\\n                \\n                if(tot_comb >= k){\\n                    path.push_back(\\'H\\');\\n                    h--;\\n                }\\n                else {\\n                    path.push_back(\\'V\\'); \\n                    v--; \\n                    k -= tot_comb;  \\n                }\\n            }\\n            else{\\n                path.push_back(\\'V\\'); \\n                v--;\\n            }\\n        }\\n        \\n        return path;\\n    }\\n    \\n};\\n```\\n\\nBrute force : \\n\\n```\\n    void dfs(int r, int c, int m, int n, string path, vector<string>& allPath){\\n        \\n        if(r<0 or r>m or c<0 or c>n) return;\\n        \\n        if(r==m and c==n){\\n            allPath.push_back(path);\\n            return;\\n        }\\n        \\n        dfs(r+1, c, m, n, path + \"V\", allPath);\\n        dfs(r, c+1, m, n, path + \"H\", allPath);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        vector<string> allPath;\\n        int m = destination[0]; int n = destination[1];\\n        dfs(0, 0, m, n, \"\", allPath);\\n        sort(allPath.begin(), allPath.end());\\n        return allPath[k-1];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n   1        2       3         4        5        6         7        8       9\\n\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \\n  \\n  10\\n\"VVHHH\"\\n\\n(VV , HHH)\\n\\nH H _ _ _\\n*/\\n\\n```\n```\\n//upvote if found helpful\\n int comb(int n, int r){\\n        \\n        //nCr = n! / (n-r)! r! => n .... n-r+1/r! => n/1 * n-1/2 * n-2/3 ... n-r+1/r \\n        int ans = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            \\n            ans = ans * (n-i+1)/i;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& d, int k){\\n            \\n        int h = d[1], v = d[0];\\n        int n = h+v;\\n        string path = \"\";\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(h){\\n                \\n                int tot_comb = comb(h+v-1, v);\\n                \\n                if(tot_comb >= k){\\n                    path.push_back(\\'H\\');\\n                    h--;\\n                }\\n                else {\\n                    path.push_back(\\'V\\'); \\n                    v--; \\n                    k -= tot_comb;  \\n                }\\n            }\\n            else{\\n                path.push_back(\\'V\\'); \\n                v--;\\n            }\\n        }\\n        \\n        return path;\\n    }\\n    \\n};\\n```\n```\\n    void dfs(int r, int c, int m, int n, string path, vector<string>& allPath){\\n        \\n        if(r<0 or r>m or c<0 or c>n) return;\\n        \\n        if(r==m and c==n){\\n            allPath.push_back(path);\\n            return;\\n        }\\n        \\n        dfs(r+1, c, m, n, path + \"V\", allPath);\\n        dfs(r, c+1, m, n, path + \"H\", allPath);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        vector<string> allPath;\\n        int m = destination[0]; int n = destination[1];\\n        dfs(0, 0, m, n, \"\", allPath);\\n        sort(allPath.begin(), allPath.end());\\n        return allPath[k-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088665,
                "title": "python-3-easy-dp-o-m-n-solution-explained",
                "content": "* First, we build DP array to compute number of unique paths from ```grid[i][j]``` to destination ```grid[-1][-1]```.\\n![image](https://assets.leetcode.com/users/images/a135e9aa-8f74-4cc8-99c3-5b95ae7a5073_1614626616.2132363.png)\\nApparently, dp[i][j] = dp[i][j + 1] + dp[i + 1][j], the number of path in the current grid is equal to the number of which in the next right grid, and in the next bottom grid.\\nSo the question is like to find the k-th path from ```dp[0][0]``` to ```dp[m][n]```, in the lexicographical order.\\n\\n* Next, start from top-left corner of ```dp```, we have two choices: go to the next right grid, or go to the next bottom grid. The key is **Every path in the next bottom grid is larger every path in the next right grid**, because **every path in the next right bottom start with \"H\", while paths in the next bottom grid start with \"V\"**. \\n\\nTherefore:\\n1.  If the current index ```k``` is no larger than the number of paths in the right grid ( ```dp[i][j + 1]```), we will go to the next right grid, and add \"H\" to the answer, because we are moving rightward.\\n\\n2.  If the current index ```k``` is larger than ```dp[i][j + 1]```, meanning we can only find the path downward, so we will go to dp[i + 1][j], and k -= dp[i][j + 1], since we have passed the first dp[i][j + 1]-th paths, and add \"V\" to the ans since we are moving downward.\\n\\n![image](https://assets.leetcode.com/users/images/e935cd7f-1473-4aa5-97f0-e8014343a887_1614627227.0005882.png)\\n\\n\\n* Until we reach ```i == m or j == n```, meaning we can only go rightward or downward from then on, so we just need to add numbers of \"H\" or \"V\" accordingly.\\n\\n\\n\\n\\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        for i in range(m):\\n            dp[i][-1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n                \\n        ans, i , j = \"\", 0, 0\\n        while i < m and j < n:\\n            if k > dp[i][j + 1]:\\n                k -= dp[i][j + 1]\\n                i += 1\\n                ans += \"V\"\\n            else:\\n                j += 1\\n                ans += \"H\"\\n        ans += (n - j) * \"H\" + (m - i) * \"V\"  \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```grid[i][j]```\n```grid[-1][-1]```\n```dp[0][0]```\n```dp[m][n]```\n```dp```\n```k```\n```dp[i][j + 1]```\n```k```\n```dp[i][j + 1]```\n```i == m or j == n```\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        for i in range(m):\\n            dp[i][-1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n                \\n        ans, i , j = \"\", 0, 0\\n        while i < m and j < n:\\n            if k > dp[i][j + 1]:\\n                k -= dp[i][j + 1]\\n                i += 1\\n                ans += \"V\"\\n            else:\\n                j += 1\\n                ans += \"H\"\\n        ans += (n - j) * \"H\" + (m - i) * \"V\"  \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953738,
                "title": "c-dynamic-programming-approach-0ms-100-bottom-up",
                "content": "```c++\\nconst int MXN = 15 + 2;\\n\\nclass Solution {\\n    int n, m;\\n\\n    int dp[MXN][MXN];\\n\\n    int go(int x, int y) {\\n        if(x==n && y==m) return 1;\\n        if(x < 0 || x > n || y < 0 || y > m) return 0;\\n        int &ans = dp[x][y];\\n        if(ans != -1) return ans;\\n        ans = go(x+1, y) + go(x, y+1);\\n        return ans;\\n    }\\n    \\n    string way;\\n    void build(int x, int y, int k) {\\n        if(x==n && y==m) return;\\n        if(x < 0 || x > n || y < 0 || y > m) return;\\n        if(k <= go(x, y+1)) {\\n            way.push_back(\\'H\\');\\n            build(x, y+1, k);\\n        } else {\\n            k -= go(x, y+1);\\n            way.push_back(\\'V\\');\\n            build(x+1, y, k);\\n        }\\n    }\\n\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        n = destination[0];\\n        m = destination[1];\\n        memset(dp, -1LL, sizeof(dp));\\n        go(0, 0);\\n        build(0, 0, k);\\n        return way;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nconst int MXN = 15 + 2;\\n\\nclass Solution {\\n    int n, m;\\n\\n    int dp[MXN][MXN];\\n\\n    int go(int x, int y) {\\n        if(x==n && y==m) return 1;\\n        if(x < 0 || x > n || y < 0 || y > m) return 0;\\n        int &ans = dp[x][y];\\n        if(ans != -1) return ans;\\n        ans = go(x+1, y) + go(x, y+1);\\n        return ans;\\n    }\\n    \\n    string way;\\n    void build(int x, int y, int k) {\\n        if(x==n && y==m) return;\\n        if(x < 0 || x > n || y < 0 || y > m) return;\\n        if(k <= go(x, y+1)) {\\n            way.push_back(\\'H\\');\\n            build(x, y+1, k);\\n        } else {\\n            k -= go(x, y+1);\\n            way.push_back(\\'V\\');\\n            build(x+1, y, k);\\n        }\\n    }\\n\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        n = destination[0];\\n        m = destination[1];\\n        memset(dp, -1LL, sizeof(dp));\\n        go(0, 0);\\n        build(0, 0, k);\\n        return way;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620167,
                "title": "recursive-iterative-solution-c",
                "content": "# Recursive\\n```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    void solve(int a,int b,int k,string s){\\n        if(a<0||b<0)return ;\\n        if(a==0&&b==0)ans = s;\\n        long long int x = get(a,b-1);\\n        if(k==1){\\n            if(a==0){\\n                solve(a,b-1,k,s+\\'H\\');\\n            }else if(b==0){\\n                solve(a-1,b,k,s+\\'V\\');\\n            }\\n        }\\n        if(k*1LL>x){\\n            solve(a-1,b,k-x,s+\\'V\\');\\n        }else{\\n            solve(a,b-1,k,s+\\'H\\');\\n        }\\n    }\\n    string kthSmallestPath(vector<int>& v, int k) {\\n        solve(v[0],v[1],k,\"\");\\n        return ans;\\n    }\\n};\\n```\\n\\n# Iterator\\n````\\nclass Solution {\\npublic:\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& a, int b) {\\n        int h = a[1],v=a[0],n=a[0]+a[1],i;\\n        long long int x;\\n        long long int k = b;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++){\\n            if(h){\\n                x = get(h-1,v);\\n                cout<<x<<\" \"<<k<<endl;\\n                if(x>=k){\\n                    ans += \\'H\\';\\n                    h--;\\n                }else{\\n                    k -= x;\\n                    ans += \\'V\\';\\n                    v--;\\n                }\\n            }else{\\n                ans += \\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    void solve(int a,int b,int k,string s){\\n        if(a<0||b<0)return ;\\n        if(a==0&&b==0)ans = s;\\n        long long int x = get(a,b-1);\\n        if(k==1){\\n            if(a==0){\\n                solve(a,b-1,k,s+\\'H\\');\\n            }else if(b==0){\\n                solve(a-1,b,k,s+\\'V\\');\\n            }\\n        }\\n        if(k*1LL>x){\\n            solve(a-1,b,k-x,s+\\'V\\');\\n        }else{\\n            solve(a,b-1,k,s+\\'H\\');\\n        }\\n    }\\n    string kthSmallestPath(vector<int>& v, int k) {\\n        solve(v[0],v[1],k,\"\");\\n        return ans;\\n    }\\n};\\n```\n````\\nclass Solution {\\npublic:\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& a, int b) {\\n        int h = a[1],v=a[0],n=a[0]+a[1],i;\\n        long long int x;\\n        long long int k = b;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++){\\n            if(h){\\n                x = get(h-1,v);\\n                cout<<x<<\" \"<<k<<endl;\\n                if(x>=k){\\n                    ans += \\'H\\';\\n                    h--;\\n                }else{\\n                    k -= x;\\n                    ans += \\'V\\';\\n                    v--;\\n                }\\n            }else{\\n                ans += \\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3219366,
                "title": "python-3-13-lines-iterative-recursive-versions-w-example-t-m-94-81",
                "content": "The iterative version:\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        (v, h), ans = destination, \\'\\'   # Example: destination = [3, 4]   k = 16 \\n\\n        while h and v:          #   h      v      k      c               Ans       \\n                                #  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013              \\u2013\\u2013\\u2013\\n            c = comb(h+v-1,v)   #   4      3      16    comb(6,3) = 20   \"H\"\\n                                #   3      3      16    comb(5,3) = 10   \"HV\"      \\n            if c < k:           #   3      2       6    comb(4,2) =  6   \"HVH\"\\n                ans+= \\'V\\'       #   2      2       6    comb(3,1) =  3   \"HVHV\"\\n                v-= 1           #   2      1       3    comb(2,1) =  2   \"HVHV\"\\n                k-= c           #   2      0       1                     \"HVHVV\"\\n            else: \\n                ans+= \\'H\\'       #   return \"HVHVV\" + \"H\"*2 = \"HVHVVHH\"\\n                h-= 1\\n          \\n        if not h: ans+= \\'V\\'*v\\n        if not v: ans+= \\'H\\'*h    \\n        \\n        return ans\\n```\\n[https://leetcode.com/problems/kth-smallest-instructions/submissions/903074964/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n\\n_______\\n\\nThe recursive version:\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        v, h = destination\\n\\n        def dp(h: int,v: int,k: int)-> str:\\n\\n            if not h: return \\'V\\'*v\\n            if not v: return \\'H\\'*h\\n\\n            c = comb(h+v-1,v)\\n\\n            if c < k: return \\'V\\' + dp(h  ,v-1,k - c)\\n            else    : return \\'H\\' + dp(h-1,v  ,k)\\n        \\n        return dp(h,v,k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        (v, h), ans = destination, \\'\\'   # Example: destination = [3, 4]   k = 16 \\n\\n        while h and v:          #   h      v      k      c               Ans       \\n                                #  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013              \\u2013\\u2013\\u2013\\n            c = comb(h+v-1,v)   #   4      3      16    comb(6,3) = 20   \"H\"\\n                                #   3      3      16    comb(5,3) = 10   \"HV\"      \\n            if c < k:           #   3      2       6    comb(4,2) =  6   \"HVH\"\\n                ans+= \\'V\\'       #   2      2       6    comb(3,1) =  3   \"HVHV\"\\n                v-= 1           #   2      1       3    comb(2,1) =  2   \"HVHV\"\\n                k-= c           #   2      0       1                     \"HVHVV\"\\n            else: \\n                ans+= \\'H\\'       #   return \"HVHVV\" + \"H\"*2 = \"HVHVVHH\"\\n                h-= 1\\n          \\n        if not h: ans+= \\'V\\'*v\\n        if not v: ans+= \\'H\\'*h    \\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        v, h = destination\\n\\n        def dp(h: int,v: int,k: int)-> str:\\n\\n            if not h: return \\'V\\'*v\\n            if not v: return \\'H\\'*h\\n\\n            c = comb(h+v-1,v)\\n\\n            if c < k: return \\'V\\' + dp(h  ,v-1,k - c)\\n            else    : return \\'H\\' + dp(h-1,v  ,k)\\n        \\n        return dp(h,v,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176711,
                "title": "java-100-faster-dp-best-explanation",
                "content": "Combinations[i][j] tells us how many combinations of strings/paths is possible if we start from i,j and reach destination. Number of paths/strings which can be formed at Combinations[i][j] = Combinations[i+1][j] + Combinations[i][j+1].  consider making dp for destination 2,3.\\nTo start from 1,2 and reach 2,3 we will have one \\'H\\' and one \\'V\\' which is why Combinations[i][j]  will be 2(HV and VH). If we use H at first position we move right and we are left with one \\'V\\'.\\nNow consider being on position 1,1 and same desitination.\\ncombinations[i][j]= 3 because we can move right twice and down once so we have 2 \\'H\\' and 1 \\'V\\'. paths: HHV HVH VHH\\nIf we choose 1st char as V and move down we will be left with HH which can make only one combination but if we go right that means curr char should be H and we are left with 1 H and 1 V which gives us 2 combinations(HV VH).\\nIn conclusion if we use H as curr char we move right which give us access to strings/paths which are lexicographically smaller compared to moving down and using curr char as V.\\nConsidering same destination 2,3 let k be 4 and lets start from 0,0.\\nwe see that moving right means we are using 1st char as \\'H\\'. We compare k to strings/paths to the right(lexicographically smaller strings compared to down) combination[i][j+1]= 6 Those strings are HHHVV HHVHV HHVVH HVHHV HVHVH HVVHH combination[i+1][j]= 4 These are the strings starting from \\'V\\'. since k=4 is less than equal to number of strings to right It means our ans string in within them. so we move to the right. Now we are at 0,1 where num of strings is 6. On the right we have combination[i][j+1]= 3 Because these strings/paths are HVV VHV VVH and combination[i+1][j]= 3 are strings HHV HVH VHH. At position 0,0 on right we had top 6 lexicographically smallest paths and below we had 4 bigger strings and since we want 4th smallest we go right.\\nNow at 0,1 we compare k with combination[i][j+1]. 4 is not less than or equal to 3 which says that 4th smallest string is not among the top 3 smallest (top 3 out of 10 and also top 3 out of top 6) which tells us that we need to move down and search for bigger top 3 string out of 1st chosen top 6 strings at 0,0. so we discard strings with rank 1,2 and 3 and choose bottom 3 which means now we will choose from 4th 5th 6th smallest strings out of original 10. But we cant keep k as 4 since we discarded 1st 2nd and 3rd smallest string and 4th smallest is actual 1st smallest from 4th 5th and 6th string that is the reason we subtract combinations[i][j+1] from k.\\n```\\n\\tpublic String kthSmallestPath(int[] destination, int k) {\\n        int rows= destination[0]+1, cols= destination[1]+1;\\n        int[][] combinations= new int[rows][cols];\\n        for(int i=rows-1; i>=0; i--){\\n            for(int j=cols-1; j>=0; j--){\\n                combinations[i][j]= (i==rows-1 || j==cols-1) ? 1 : combinations[i][j+1] + combinations[i+1][j];\\n            }\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        int i=0, j=0;\\n        while(i != rows-1 || j != cols-1){\\n            if(i==rows-1){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else if(j==cols-1){\\n                sb.append(\\'V\\');\\n                i++;\\n            }else if(combinations[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else{\\n                sb.append(\\'V\\');\\n                k-= combinations[i][j+1];\\n                i++;\\n            }\\n        }\\n        return String.valueOf(sb);\\n    }",
                "solutionTags": [],
                "code": "Combinations[i][j] tells us how many combinations of strings/paths is possible if we start from i,j and reach destination. Number of paths/strings which can be formed at Combinations[i][j] = Combinations[i+1][j] + Combinations[i][j+1].  consider making dp for destination 2,3.\\nTo start from 1,2 and reach 2,3 we will have one \\'H\\' and one \\'V\\' which is why Combinations[i][j]  will be 2(HV and VH). If we use H at first position we move right and we are left with one \\'V\\'.\\nNow consider being on position 1,1 and same desitination.\\ncombinations[i][j]= 3 because we can move right twice and down once so we have 2 \\'H\\' and 1 \\'V\\'. paths: HHV HVH VHH\\nIf we choose 1st char as V and move down we will be left with HH which can make only one combination but if we go right that means curr char should be H and we are left with 1 H and 1 V which gives us 2 combinations(HV VH).\\nIn conclusion if we use H as curr char we move right which give us access to strings/paths which are lexicographically smaller compared to moving down and using curr char as V.\\nConsidering same destination 2,3 let k be 4 and lets start from 0,0.\\nwe see that moving right means we are using 1st char as \\'H\\'. We compare k to strings/paths to the right(lexicographically smaller strings compared to down) combination[i][j+1]= 6 Those strings are HHHVV HHVHV HHVVH HVHHV HVHVH HVVHH combination[i+1][j]= 4 These are the strings starting from \\'V\\'. since k=4 is less than equal to number of strings to right It means our ans string in within them. so we move to the right. Now we are at 0,1 where num of strings is 6. On the right we have combination[i][j+1]= 3 Because these strings/paths are HVV VHV VVH and combination[i+1][j]= 3 are strings HHV HVH VHH. At position 0,0 on right we had top 6 lexicographically smallest paths and below we had 4 bigger strings and since we want 4th smallest we go right.\\nNow at 0,1 we compare k with combination[i][j+1]. 4 is not less than or equal to 3 which says that 4th smallest string is not among the top 3 smallest (top 3 out of 10 and also top 3 out of top 6) which tells us that we need to move down and search for bigger top 3 string out of 1st chosen top 6 strings at 0,0. so we discard strings with rank 1,2 and 3 and choose bottom 3 which means now we will choose from 4th 5th 6th smallest strings out of original 10. But we cant keep k as 4 since we discarded 1st 2nd and 3rd smallest string and 4th smallest is actual 1st smallest from 4th 5th and 6th string that is the reason we subtract combinations[i][j+1] from k.\\n```\\n\\tpublic String kthSmallestPath(int[] destination, int k) {\\n        int rows= destination[0]+1, cols= destination[1]+1;\\n        int[][] combinations= new int[rows][cols];\\n        for(int i=rows-1; i>=0; i--){\\n            for(int j=cols-1; j>=0; j--){\\n                combinations[i][j]= (i==rows-1 || j==cols-1) ? 1 : combinations[i][j+1] + combinations[i+1][j];\\n            }\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        int i=0, j=0;\\n        while(i != rows-1 || j != cols-1){\\n            if(i==rows-1){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else if(j==cols-1){\\n                sb.append(\\'V\\');\\n                i++;\\n            }else if(combinations[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else{\\n                sb.append(\\'V\\');\\n                k-= combinations[i][j+1];\\n                i++;\\n            }\\n        }\\n        return String.valueOf(sb);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 923436,
                "title": "c-less-than-4ms-easy-approach",
                "content": "Step by step fill the string ans\\n\\n* Count the number of permutations that exist if H is placed at index i of string ans\\n* If the kth permutation lies in this set of permutations, then place H and continue for the next i\\n* Else place V and move the search window to the next set, and continue for the next i\\n\\n```\\n#include<bits/stdc++.h>\\ntypedef unsigned long long int ll;\\nclass Solution {\\npublic:\\n    ll ncr(int n, int r)\\n    {\\n        ll ans = 1;\\n        int r1 = max(r, n-r);\\n        int r2 = n-r1;\\n        \\n        for(int i = 1; i<=r2; i++)\\n        {\\n            ans*=ll(n);\\n            n--;\\n            ans/=ll(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& ds, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        string ans = \"\";\\n        int x = ds[1];\\n        int y = ds[0];\\n        int n = (x+y);\\n        \\n        ll np = ncr(n, y);\\n        \\n        ll l = 1;\\n        ll r = np;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(x==0)\\n            {\\n                ans+=\"V\";\\n                y--;\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                ans+=\"H\";\\n                x--;\\n                continue;\\n            }\\n            \\n            ll nph = ncr(x-1+y, y);\\n            ll nr = l+nph-ll(1);\\n            if(nr >= ll(k))\\n            {\\n                ans+=\"H\";\\n                x--;\\n            }\\n            else\\n            {\\n                ans+=\"V\";\\n                y--;\\n                l = nr+ll(1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\ntypedef unsigned long long int ll;\\nclass Solution {\\npublic:\\n    ll ncr(int n, int r)\\n    {\\n        ll ans = 1;\\n        int r1 = max(r, n-r);\\n        int r2 = n-r1;\\n        \\n        for(int i = 1; i<=r2; i++)\\n        {\\n            ans*=ll(n);\\n            n--;\\n            ans/=ll(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& ds, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        string ans = \"\";\\n        int x = ds[1];\\n        int y = ds[0];\\n        int n = (x+y);\\n        \\n        ll np = ncr(n, y);\\n        \\n        ll l = 1;\\n        ll r = np;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(x==0)\\n            {\\n                ans+=\"V\";\\n                y--;\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                ans+=\"H\";\\n                x--;\\n                continue;\\n            }\\n            \\n            ll nph = ncr(x-1+y, y);\\n            ll nr = l+nph-ll(1);\\n            if(nr >= ll(k))\\n            {\\n                ans+=\"H\";\\n                x--;\\n            }\\n            else\\n            {\\n                ans+=\"V\";\\n                y--;\\n                l = nr+ll(1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 920248,
                "title": "golang-o-m-n-solution-with-picture-explain-end-start-then-start-end",
                "content": "First we calculate how many paths from any point to end point, using f(i, j) = f(i+1, j) + f(i, j+1).\\n![image](https://assets.leetcode.com/users/images/44cb68ae-1586-4c43-9504-9e7b4133e027_1604299930.3191037.png)\\n\\nThen we can walk from start point to end point, say we want kth path where k=3.\\nNow we know from (0, 1) to end point there are 6 paths, and from (1, 0) to end point there are 4 paths.\\n![image](https://assets.leetcode.com/users/images/7737b68a-ea31-4582-aeb3-a56f5f4b40a1_1604300198.8034694.png)\\n\\nNo matter what the suffix is, the 6 paths from (0, 1) must be:\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nand the 4 paths from (1, 0) must be:\\nVxxxx\\nVxxxx\\nVxxxx\\nVxxxx\\n\\nSo it is certain that any path in the 6 paths from (0, 1) **must be smaller than** any path in the 4 paths from (1, 0), so the 3rd path must in (0, 1).\\nAnd if k=7, the 7th path must in (1, 0).\\n\\nRepeat this until we reach the end point.\\n\\n```go\\nfunc kthSmallestPath(destination []int, k int) string {\\n    row, col := destination[0], destination[1]\\n    f := make([][]int, row+2)\\n    for i := 0; i <= row+1; i++ {\\n        f[i] = make([]int, col+2)\\n    }\\n    f[row][col] = 1\\n    for i := row; i >= 0; i-- {\\n        for j := col; j >= 0; j-- {\\n            if i == row && j == col {\\n                continue\\n            }\\n            f[i][j] = f[i+1][j] + f[i][j+1]\\n        }\\n    }\\n    result := \"\"\\n    i, j := 0, 0\\n    for {\\n        if i == row {\\n            j++\\n            result = result + \"H\"\\n        } else if j == col {\\n            i++\\n            result = result + \"V\"\\n        } else {\\n            if k <= f[i][j+1] {\\n                j++\\n                result = result + \"H\"\\n            } else {\\n                k -= f[i][j+1]\\n                i++\\n                result = result + \"V\"\\n            }\\n        }\\n        if i == row && j == col {\\n            break\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc kthSmallestPath(destination []int, k int) string {\\n    row, col := destination[0], destination[1]\\n    f := make([][]int, row+2)\\n    for i := 0; i <= row+1; i++ {\\n        f[i] = make([]int, col+2)\\n    }\\n    f[row][col] = 1\\n    for i := row; i >= 0; i-- {\\n        for j := col; j >= 0; j-- {\\n            if i == row && j == col {\\n                continue\\n            }\\n            f[i][j] = f[i+1][j] + f[i][j+1]\\n        }\\n    }\\n    result := \"\"\\n    i, j := 0, 0\\n    for {\\n        if i == row {\\n            j++\\n            result = result + \"H\"\\n        } else if j == col {\\n            i++\\n            result = result + \"V\"\\n        } else {\\n            if k <= f[i][j+1] {\\n                j++\\n                result = result + \"H\"\\n            } else {\\n                k -= f[i][j+1]\\n                i++\\n                result = result + \"V\"\\n            }\\n        }\\n        if i == row && j == col {\\n            break\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918638,
                "title": "java-simple-solution",
                "content": "If k is bigger than total number of combination that starts with `H` then we should pick `V`\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    private String helper(int H, int V, int k, String result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        Long combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH.intValue(),result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n    private long combination(Integer M, Integer N){\\n        long result = 1l;\\n        for(int i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2853322,
                "title": "python3-solution-combination",
                "content": "# Solution - 1\\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\\n\\n# Solution - 2\\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        C = comb(H + V - 1, H - 1)\\n        ans = \\'\\'\\n        while K and H and V:\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n                C *= (V + 1)\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n                C *= H\\n            C //= (V + H)\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        C = comb(H + V - 1, H - 1)\\n        ans = \\'\\'\\n        while K and H and V:\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n                C *= (V + 1)\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n                C *= H\\n            C //= (V + H)\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716250,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { \\n                int c = comb(h - 1 + v, v); \\n                if (k <= c) { \\n                    s += \\'H\\';\\n                    --h;\\n                } else { \\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { \\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { \\n                int c = comb(h - 1 + v, v); \\n                if (k <= c) { \\n                    s += \\'H\\';\\n                    --h;\\n                } else { \\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { \\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084437,
                "title": "c-dynamic-programming",
                "content": "The idea is to a matrix \"dp\". where dp[i][j] stores the number of ways from (i,j) to (m, n).\\nAt (i, j), we need to determine the next move: whether to (i+1, j) or (i, j+1).\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        \\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        dp[m][n] = 1;\\n        for(int i=m; i>=0; i--) {\\n            for(int j=n; j>=0; j--) {\\n                if(i == m && j == n) continue;\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int r = 0, c = 0;\\n        int step = 0, remain = k;\\n        for(int step = 0; step < m+n; step++) {\\n            if(dp[r][c+1] >= remain) {\\n                c = c+1;\\n                ans += \\'H\\';\\n            } else {\\n                remain -= dp[r][c+1];\\n                r = r+1;\\n                ans += \\'V\\';\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        \\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        dp[m][n] = 1;\\n        for(int i=m; i>=0; i--) {\\n            for(int j=n; j>=0; j--) {\\n                if(i == m && j == n) continue;\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int r = 0, c = 0;\\n        int step = 0, remain = k;\\n        for(int step = 0; step < m+n; step++) {\\n            if(dp[r][c+1] >= remain) {\\n                c = c+1;\\n                ans += \\'H\\';\\n            } else {\\n                remain -= dp[r][c+1];\\n                r = r+1;\\n                ans += \\'V\\';\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933974,
                "title": "java-combinatorics-solution",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = destination[0] + destination[1];\\n        for (int i = 0; i < n; i++) {\\n            long cnt = comb(n - i - 1, destination[0]); //look at the subsequent possible characters after this one. n - i - 1.\\n            if (destination[0] == 0) {\\n                sb.append(\\'H\\');\\n                destination[1]--;\\n                continue;\\n            }\\n            if (destination[1] == 0) {\\n                sb.append(\\'V\\');\\n                destination[0]--;\\n                continue;\\n            }\\n            if (k <= cnt) {\\n                destination[1]--;\\n                sb.append(\\'H\\');\\n            }\\n            else {\\n                destination[0]--;\\n                k -= cnt;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long res = 1;\\n        for (int i = 0; i < k; i++) {\\n            res *= n - i; // getting rid of n - k and onwards.\\n            res /= i + 1; // including division of k!.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = destination[0] + destination[1];\\n        for (int i = 0; i < n; i++) {\\n            long cnt = comb(n - i - 1, destination[0]); //look at the subsequent possible characters after this one. n - i - 1.\\n            if (destination[0] == 0) {\\n                sb.append(\\'H\\');\\n                destination[1]--;\\n                continue;\\n            }\\n            if (destination[1] == 0) {\\n                sb.append(\\'V\\');\\n                destination[0]--;\\n                continue;\\n            }\\n            if (k <= cnt) {\\n                destination[1]--;\\n                sb.append(\\'H\\');\\n            }\\n            else {\\n                destination[0]--;\\n                k -= cnt;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long res = 1;\\n        for (int i = 0; i < k; i++) {\\n            res *= n - i; // getting rid of n - k and onwards.\\n            res /= i + 1; // including division of k!.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921112,
                "title": "java-simple-solution-using-dfs-and-memoization-beats-83",
                "content": "The idea is to first write a method to do dfs (with memoization) to find number of ways to reach destination from coordinates `x` and `y`.  This is the key step to the solution.\\nOnce we have done that then we can realize that\\n\\n- `dfs(dest, x, y) == dfs(dest, x, y+1) + dfs(dest, x+1, y)`.  This is because these are only two ways to reach the destination. Let\\'s call these search spaces `hSpace` and `vSpace` respectively. \\n- the `hSpace` is lexicographically smaller than `vSpace`.\\n- If `k <= dfs(dest, x, y+1)` then we know the search space starts with an \"H\", and we can continue in `hSpace`. Like say total ways to reach destination are 1000, of which 900 are in `hSpace` and 100 in `vSpace`. Now if we are looking for 200th entry then we know that we need to start with an \"H\", and look for 200 in the `hSpace`. \\n- If `k > dfs(dest, x, y+1)` then we know search space starts with a \"V\", and we are looking for `(k - dfs(dest, x, y+1)` entry in this search space space. Like say total ways to reach destination are 1000, of which 900 are in `hSpace` and 100 in `vSpace`. Now if we are looking for 950th entry then we know that we need to start with a \"V\", and look for (950-900 == 50th) position in the `vSpace`. \\n- We add an \"H\", or a \"V\" based on which track we followed in the last step(s).\\n- We continue updating our `x`,` y` and `k` in a loop\\n- We continue doing this till we reach our destination\\n\\n```\\nclass Solution {\\n    Integer[][] cache = null;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        cache = new Integer[destination[0]+1][destination[1]+1];\\n        StringBuffer sb = new StringBuffer();\\n        int x = 0, y = 0;\\n        while (true) {\\n            if (x == destination[0] && y == destination[1]) break;\\n            int h = (y < destination[1]) ? dfs(destination, x, y+1) : 0;\\n            int v = (x < destination[0]) ? dfs(destination, x+1, y) : 0;\\n            \\n            if (k <= h) {\\n                sb.append(\"H\");\\n                y += 1;\\n            } else {\\n                sb.append(\"V\");\\n                k = k-h;\\n                x += 1;\\n            }\\n        }\\n        return sb.toString(); \\n    }\\n    \\n    int dfs(int[] dest, int x, int y) {\\n        if (cache[x][y] != null) return cache[x][y];\\n        if (x == dest[0] && y == dest[1])  return 1;\\n        \\n        int tot = 0;\\n        if (y+1 <= dest[1])\\n            tot += dfs(dest, x, y+1);\\n        \\n        if (x+1 <= dest[0])\\n            tot += dfs(dest, x+1, y);\\n        \\n        cache[x][y] = tot;\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] cache = null;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        cache = new Integer[destination[0]+1][destination[1]+1];\\n        StringBuffer sb = new StringBuffer();\\n        int x = 0, y = 0;\\n        while (true) {\\n            if (x == destination[0] && y == destination[1]) break;\\n            int h = (y < destination[1]) ? dfs(destination, x, y+1) : 0;\\n            int v = (x < destination[0]) ? dfs(destination, x+1, y) : 0;\\n            \\n            if (k <= h) {\\n                sb.append(\"H\");\\n                y += 1;\\n            } else {\\n                sb.append(\"V\");\\n                k = k-h;\\n                x += 1;\\n            }\\n        }\\n        return sb.toString(); \\n    }\\n    \\n    int dfs(int[] dest, int x, int y) {\\n        if (cache[x][y] != null) return cache[x][y];\\n        if (x == dest[0] && y == dest[1])  return 1;\\n        \\n        int tot = 0;\\n        if (y+1 <= dest[1])\\n            tot += dfs(dest, x, y+1);\\n        \\n        if (x+1 <= dest[0])\\n            tot += dfs(dest, x+1, y);\\n        \\n        cache[x][y] = tot;\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918827,
                "title": "short-c-solution-using-incremental-combinatorics",
                "content": "```\\nstring kthSmallestPath(vector<int>& D, int k) {\\n    k--; // make 0-indexed\\n    int n = D[0] + D[1];\\n    string ans(n, \\'H\\');\\n    for (int i = D[0]; i > 0; i--) {\\n        int a = i - 1, b = 0, c = 1;\\n        while (k >= c) {\\n            k -= c;\\n            c = c * ++a / ++b;\\n        }\\n        ans[n - 1 - a] = \\'V\\';\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring kthSmallestPath(vector<int>& D, int k) {\\n    k--; // make 0-indexed\\n    int n = D[0] + D[1];\\n    string ans(n, \\'H\\');\\n    for (int i = D[0]; i > 0; i--) {\\n        int a = i - 1, b = 0, c = 1;\\n        while (k >= c) {\\n            k -= c;\\n            c = c * ++a / ++b;\\n        }\\n        ans[n - 1 - a] = \\'V\\';\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918741,
                "title": "java-100-fast-iterative-dp",
                "content": "Similar to @useliuqing\\'s solution, but iterative fashion.. all credits to @useliuqing \\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        //create a dp of how many ways to reach destination from present row and col\\n      int rows = destination[0];\\n      int cols = destination[1];\\n      \\n      int[][] dp = new int[rows+1][cols+1];\\n      \\n      Arrays.fill(dp[rows],1); //the bottom rows, only possible way . move right\\n      \\n      for(int row=0;row<=rows;row++) //the righmost wall, only possible way.. move down\\n        dp[row][cols]=1;\\n      \\n      for(int row=rows-1;row>=0;row--){\\n        for(int col=cols-1;col>=0;col--){\\n          dp[row][col] = dp[row+1][col] + dp[row][col+1];\\n        }\\n      }\\n      \\n      //we know for fact that all dp[i][j+1] paths are lexicographically smaller than dp[i+1][j], since \\'H\\' movement is lexicographically smaller than \\'V\\', we compare k with horizontal movement\\n\\t  //if moving horizontal gives more ways than k, then we move horizontal, if it gives less ways than we need for k, we move vertical and since we are skipping all ways created by moving horizontal, we decrement k by those all ways created by moving horizontal...\\n      //if we reach wall, we keep moving along the wall, only possible way\\n      \\n      StringBuilder result = new StringBuilder();\\n      \\n      int positionX = 0, positionY=0;\\n      \\n      while(positionX!=rows || positionY!=cols){\\n        \\n        if(positionX==rows){\\n          while(positionY!=cols){\\n            result.append(\\'H\\');\\n            positionY++;\\n          }\\n           return result.toString();\\n        }\\n        \\n        if(positionY==cols){\\n          while(positionX!=rows){\\n            result.append(\\'V\\');\\n            positionX++;\\n          }\\n          return result.toString();\\n        }\\n        \\n        if(dp[positionX][positionY+1] >= k){\\n          result.append(\\'H\\');\\n          positionY++;\\n        }else{\\n           result.append(\\'V\\');\\n           k-= dp[positionX][positionY+1]; //skipping all horizontal moving ways\\n           positionX++;\\n        } \\n      }      \\n      \\n      return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        //create a dp of how many ways to reach destination from present row and col\\n      int rows = destination[0];\\n      int cols = destination[1];\\n      \\n      int[][] dp = new int[rows+1][cols+1];\\n      \\n      Arrays.fill(dp[rows],1); //the bottom rows, only possible way . move right\\n      \\n      for(int row=0;row<=rows;row++) //the righmost wall, only possible way.. move down\\n        dp[row][cols]=1;\\n      \\n      for(int row=rows-1;row>=0;row--){\\n        for(int col=cols-1;col>=0;col--){\\n          dp[row][col] = dp[row+1][col] + dp[row][col+1];\\n        }\\n      }\\n      \\n      //we know for fact that all dp[i][j+1] paths are lexicographically smaller than dp[i+1][j], since \\'H\\' movement is lexicographically smaller than \\'V\\', we compare k with horizontal movement\\n\\t  //if moving horizontal gives more ways than k, then we move horizontal, if it gives less ways than we need for k, we move vertical and since we are skipping all ways created by moving horizontal, we decrement k by those all ways created by moving horizontal...\\n      //if we reach wall, we keep moving along the wall, only possible way\\n      \\n      StringBuilder result = new StringBuilder();\\n      \\n      int positionX = 0, positionY=0;\\n      \\n      while(positionX!=rows || positionY!=cols){\\n        \\n        if(positionX==rows){\\n          while(positionY!=cols){\\n            result.append(\\'H\\');\\n            positionY++;\\n          }\\n           return result.toString();\\n        }\\n        \\n        if(positionY==cols){\\n          while(positionX!=rows){\\n            result.append(\\'V\\');\\n            positionX++;\\n          }\\n          return result.toString();\\n        }\\n        \\n        if(dp[positionX][positionY+1] >= k){\\n          result.append(\\'H\\');\\n          positionY++;\\n        }else{\\n           result.append(\\'V\\');\\n           k-= dp[positionX][positionY+1]; //skipping all horizontal moving ways\\n           positionX++;\\n        } \\n      }      \\n      \\n      return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377464,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int getCount(int h, int v)\\n    {\\n        if(h == 0 || v == 0) return 1;\\n        long long res = 1;\\n        if(h < v) swap(h, v);\\n        for(int i = h + 1; i <= (h+v); i++) res *= i;\\n        for(int i = 1; i <= v; i++) res /= i;\\n        return (int)res;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int h = dest[1];\\n        int v = dest[0];\\n        int len = h + v;\\n        string res;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(h == 0) \\n            {\\n                v--;\\n                res.push_back(\\'V\\');\\n                continue;\\n            }\\n            if(v == 0) \\n            {\\n                h--;\\n                res.push_back(\\'H\\');\\n                continue;\\n            }\\n            int cnt = getCount(h - 1, v);\\n            if(cnt >= k)\\n            {\\n                res.push_back(\\'H\\');\\n                h--;\\n            }\\n            else\\n            {\\n                k -= cnt;\\n                v--;\\n                res.push_back(\\'V\\');\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\\n```Java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getCount(int h, int v)\\n    {\\n        if(h == 0 || v == 0) return 1;\\n        long long res = 1;\\n        if(h < v) swap(h, v);\\n        for(int i = h + 1; i <= (h+v); i++) res *= i;\\n        for(int i = 1; i <= v; i++) res /= i;\\n        return (int)res;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int h = dest[1];\\n        int v = dest[0];\\n        int len = h + v;\\n        string res;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(h == 0) \\n            {\\n                v--;\\n                res.push_back(\\'V\\');\\n                continue;\\n            }\\n            if(v == 0) \\n            {\\n                h--;\\n                res.push_back(\\'H\\');\\n                continue;\\n            }\\n            int cnt = getCount(h - 1, v);\\n            if(cnt >= k)\\n            {\\n                res.push_back(\\'H\\');\\n                h--;\\n            }\\n            else\\n            {\\n                k -= cnt;\\n                v--;\\n                res.push_back(\\'V\\');\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\n```Java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591572,
                "title": "o-m-n-time-o-1-space-combination-1-less-when-we-add-h-or-v",
                "content": "```\\n  /*  Approach 1 ( Normla matrix dfs approach dont work here TLE )\\n    void solve(int i,int j,string out=\"\")\\n    {\\n        if(i>m or j>n)\\n            return;\\n        \\n        if(i==m and j==n)\\n        {\\n            k--;\\n            if(k==0)\\n                ans=out;\\n            \\n            return;\\n        }\\n        solve(i,j+1,out+\\'H\\');\\n        solve(i+1,j,out+\\'V\\');\\n    }*/\\n    \\n    //Optimized apprpach Time : O(M+N) Space : O(1)\\n   //refer this video if you dont get the code -->  https://www.youtube.com/watch?v=-nQJGAY7oMc&list=PLKZaSt2df1gyrDJMAcAEV4j7Q5aFA22RU&index=1\\n    \\n    int comb(int n,int r)\\n    {\\n        //caclulating nCr\\n        //nCr= { n*(n-1)*(n-2)*.... *(n-r-1) } / {1*2*3..... *r}\\n        \\n        int ans=1;\\n        for(int i=1;i<=r;i++)\\n            ans=ans*(n-i+1)/i;   //ans=ans*(n/1)  ans=ans*(n-1)/2  ans\\n        \\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        int h=destination[1];\\n        int v=destination[0];\\n        \\n        string ans=\"\";\\n        \\n        while(h>0 or v>0)\\n        {\\n            //Case 1 --> Bhai \\'h\\' pde hue hai to chota instruction shyd bnjaye dekho\\n            if(h>0)\\n            {\\n//IMPORTANT --> h ek kam hai hmare pas aur v utne hi to uske combinations bnao\\n                int c=comb(h-1+v,v); \\n                \\n//k mera combination number ke andr ara to mtlb is jgh pe to \\'H\\' hi ayega brother\\n                if(k<=c)  \\n                {\\n                    ans+=\\'H\\';\\n                    h--;\\n                }\\n                    \\n                else if(k>c)\\n                {\\n                    ans+=\\'V\\';\\n                    v--;\\n                    k-=c;  //k>c ab maine k ko kam krdiya kya pta aage \\'H\\' add krpau\\n                }   \\n            }\\n            \\n    //case 2 -->bhai agar \\'H\\' hai hi nahi to fr to \\'V\\' hi add krte rho jitne bche\\n            else\\n            {\\n                ans+=\\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n  /*  Approach 1 ( Normla matrix dfs approach dont work here TLE )\\n    void solve(int i,int j,string out=\"\")\\n    {\\n        if(i>m or j>n)\\n            return;\\n        \\n        if(i==m and j==n)\\n        {\\n            k--;\\n            if(k==0)\\n                ans=out;\\n            \\n            return;\\n        }\\n        solve(i,j+1,out+\\'H\\');\\n        solve(i+1,j,out+\\'V\\');\\n    }*/\\n    \\n    //Optimized apprpach Time : O(M+N) Space : O(1)\\n   //refer this video if you dont get the code -->  https://www.youtube.com/watch?v=-nQJGAY7oMc&list=PLKZaSt2df1gyrDJMAcAEV4j7Q5aFA22RU&index=1\\n    \\n    int comb(int n,int r)\\n    {\\n        //caclulating nCr\\n        //nCr= { n*(n-1)*(n-2)*.... *(n-r-1) } / {1*2*3..... *r}\\n        \\n        int ans=1;\\n        for(int i=1;i<=r;i++)\\n            ans=ans*(n-i+1)/i;   //ans=ans*(n/1)  ans=ans*(n-1)/2  ans\\n        \\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        int h=destination[1];\\n        int v=destination[0];\\n        \\n        string ans=\"\";\\n        \\n        while(h>0 or v>0)\\n        {\\n            //Case 1 --> Bhai \\'h\\' pde hue hai to chota instruction shyd bnjaye dekho\\n            if(h>0)\\n            {\\n//IMPORTANT --> h ek kam hai hmare pas aur v utne hi to uske combinations bnao\\n                int c=comb(h-1+v,v); \\n                \\n//k mera combination number ke andr ara to mtlb is jgh pe to \\'H\\' hi ayega brother\\n                if(k<=c)  \\n                {\\n                    ans+=\\'H\\';\\n                    h--;\\n                }\\n                    \\n                else if(k>c)\\n                {\\n                    ans+=\\'V\\';\\n                    v--;\\n                    k-=c;  //k>c ab maine k ko kam krdiya kya pta aage \\'H\\' add krpau\\n                }   \\n            }\\n            \\n    //case 2 -->bhai agar \\'H\\' hai hi nahi to fr to \\'V\\' hi add krte rho jitne bche\\n            else\\n            {\\n                ans+=\\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2523350,
                "title": "dp",
                "content": "Use DP to find the number of ways to get to the destination cell (m-1, n-1) from every cell (i, j)\\n\\nAt cell (i, j) deciding to go horizontal or vertical, if dp[i][j+1] <= k, go horizontal, otherwise vertical then update k.\\n\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tm, n := destination[0] + 1, destination[1] + 1\\n\\tdp := make([][]int, m)\\n\\tfor i := range dp { dp[i] = make([]int, n) }\\n\\tfor i := 0; i < n - 1; i++ { dp[m-1][i] = 1 }\\n\\tfor i := 0; i < m - 1; i++ { dp[i][n-1] = 1 }\\n\\tfor i := m - 2; i >= 0; i-- { for j := n - 2; j >= 0; j-- { dp[i][j] = dp[i][j+1] + dp[i+1][j] } }\\n\\tvar ret string\\n\\ti, j := 0, 0\\n\\tfor i < m - 1 || j < n - 1 {\\n\\t\\tif i == m - 1 {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else if j == n - 1 {\\n\\t\\t\\tret += \"V\"\\n\\t\\t\\ti++\\n\\t\\t} else if k <= dp[i][j+1] {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else {\\n\\t\\t\\tret += \"V\"\\n            k -= dp[i][j+1]\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tm, n := destination[0] + 1, destination[1] + 1\\n\\tdp := make([][]int, m)\\n\\tfor i := range dp { dp[i] = make([]int, n) }\\n\\tfor i := 0; i < n - 1; i++ { dp[m-1][i] = 1 }\\n\\tfor i := 0; i < m - 1; i++ { dp[i][n-1] = 1 }\\n\\tfor i := m - 2; i >= 0; i-- { for j := n - 2; j >= 0; j-- { dp[i][j] = dp[i][j+1] + dp[i+1][j] } }\\n\\tvar ret string\\n\\ti, j := 0, 0\\n\\tfor i < m - 1 || j < n - 1 {\\n\\t\\tif i == m - 1 {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else if j == n - 1 {\\n\\t\\t\\tret += \"V\"\\n\\t\\t\\ti++\\n\\t\\t} else if k <= dp[i][j+1] {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else {\\n\\t\\t\\tret += \"V\"\\n            k -= dp[i][j+1]\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431010,
                "title": "c-kth-permutation",
                "content": "\\tclass Solution {\\npublic:\\n    \\n\\t// function to calculate factorial of a number with a little adjustment \\n\\t//so that it does not go out of the memory bound\\n    long long fact(long long n, long long t)\\n    {\\n        if(n == 0 || n == 1 || n == t) return 1;\\n        return n * fact(n - 1,t);\\n    }\\n\\t\\n\\t//function to calculate total permutation keeping a character at first index\\n    int calculate(char ch, map<char,int>& mp, int len)\\n    {\\n        int k = ch==\\'H\\'?mp[\\'H\\']-1:mp[\\'H\\'];\\n        int j = ch==\\'V\\'?mp[\\'V\\']-1:mp[\\'V\\'];\\n        \\n        long long sum =  fact(len,max(k,j));\\n        sum /= fact(min(k,j),1);\\n        \\n        return (int)sum;\\n    }\\n    \\n    string kthper(int n, int k, map<char,int>& mp)\\n    {\\n        if(mp.size() == 1)\\n        {\\n            string temp = \"\";\\n            for(auto it:mp)\\n            {\\n                while(it.second > 0)\\n                {\\n                    temp.push_back(it.first);\\n                    it.second--;\\n                }\\n            }\\n            return temp;\\n        }\\n        \\n        string res = \"\";\\n        for(auto it: mp)\\n        {\\n            int cal = calculate(it.first, mp, n-1);\\n            if(cal < k)\\n            {\\n                k -= cal;\\n            }\\n            else\\n            {\\n                res.push_back(it.first);\\n                mp[it.first]--;\\n                if(mp[it.first] == 0) mp.erase(it.first);\\n                res += kthper(n-1,k,mp);\\n                break;\\n            }\\n        }\\n        return res;   \\n    }\\n    \\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int n = des[0]+1;\\n        int m = des[1]+1;\\n        string str = \"\";\\n        for(int i=0;i<m-1;i++)\\n        {\\n            str += \"H\";\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            str += \"V\";\\n        }\\n        \\n        map<char,int> mp;\\n        for(auto ch : str)\\n        {\\n            mp[ch]++;\\n        }\\n        return kthper(str.size(),k,mp);\\n    }\\n\\t};\\n\\nWhat i am doing in this solution is , I am picking the smallest character from the string and keeping that character at the first index and finding all possible permutations of rest of the character. Just like you have done in your highschool at the time of permutation and combinations lecture (finding the rank of a word in a dictionary).\\nLets say there are x total permutations if x < k, that means in the kth permutation the letter currently on first index can not be at first index as all the permutations keeping that at first index is less than k; decrease k by x as i have already checked x permutations.\\nNow i will put the next greater character i.e V at first index and calculate all possible permutations and check if no of permutations are less than k (which it should be as there are only 2 char in string) that means V should be my first character in kth permutation.\\nNow i will just call recursion for the rest of the string and finally will return the ans;\\nPS: IT USES THE CONCEPT OF \"FINDING THE RANK OF A WORD IN A DICTIONARY\".",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\t// function to calculate factorial of a number with a little adjustment \\n\\t//so that it does not go out of the memory bound\\n    long long fact(long long n, long long t)\\n    {\\n        if(n == 0 || n == 1 || n == t) return 1;\\n        return n * fact(n - 1,t);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2421911,
                "title": "python-easy-to-understand-explained",
                "content": "Key idea in my solution can be expressed by a simple example:\\n\\n\\n**e.g.** Let\\'s say there are 2 \"V\"s and 3 \"H\"s in the final string.\\n**Q:** How many strings are smaller than, e.g., \"VHHVH\"?\\n\\n**A:** Obviously the smallest one in this case is \"HHHVV\", focusing on the \"V\" which is pulled to the beginning now, if it isn\\'t there, then there are C(4,2) = 6 (4 spots for 2 \"V\"s) strings smaller than \"VHHHV\". Next looking at the 2nd \"V\", if it isn\\'t pulled to the higher position, then there is C(1,1) = 1 (1 spot for 1 \"V\") string smaller than \"_ _ _ VH\". So totally 6 + 1 = 7 strings are smaller than \"VHHHV\", indicating it the 8th smallest string.\\n\\t  \\n\\t  \\nTo find the specific string given a number k is pretty much the same idea, but reversely.\\n\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        m, n = destination\\n        base = [\"H\" for i in range(m+n)] \\n        t = k-1 # num of instructions smaller than the kth smallest one\\n        v_left = m # how many \"V\" left to be put to the right side\\n        \\n        \\n        for i in range(m+n):\\n            if comb(m+n-i-1, v_left) <= t:\\n                base[i] = \"V\"\\n                t -= comb(m+n-i-1, v_left)\\n                v_left -= 1\\n\\n                \\n            #if t == 0, that means the left \"V\" should all be put to the rightmost places\\n            if t == 0:\\n                for j in range(m+n-v_left, m+n):\\n                    base[j] = \"V\"\\n                break\\n        \\n        return \"\".join(base)\\n        \\n        ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        m, n = destination\\n        base = [\"H\" for i in range(m+n)] \\n        t = k-1 # num of instructions smaller than the kth smallest one\\n        v_left = m # how many \"V\" left to be put to the right side\\n        \\n        \\n        for i in range(m+n):\\n            if comb(m+n-i-1, v_left) <= t:\\n                base[i] = \"V\"\\n                t -= comb(m+n-i-1, v_left)\\n                v_left -= 1\\n\\n                \\n            #if t == 0, that means the left \"V\" should all be put to the rightmost places\\n            if t == 0:\\n                for j in range(m+n-v_left, m+n):\\n                    base[j] = \"V\"\\n                break\\n        \\n        return \"\".join(base)\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2385096,
                "title": "c-combinatorial-solution-with-explanation",
                "content": "A path that leads to the destination is a binary string (each position can contain one of only two chars H or V)\\nDefine:\\n`V = destination[0]` = number of vertical steps to be taken and, \\n`H = destination[1]` = number of horizontal steps to be taken\\n`N = H + V`              = total path length\\n\\nnumber of paths = `nCk(N,H) = N! / ((N-H)! * H!) = nCk(N,V) = N! / ((N-V)! * V!)`\\n\\n\\nTake the example: `H=3, V=2, k=4`\\n`path = _ _ _ _ _`\\nWhere `path[i]` represents the `i-th` step\\n\\nInitial state: `H=3, V=2, k=4`\\nStart completing the path from left to right. \\nLet\\'s try adding `H` as the first step, `path_tmp = H _ _ _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(4, max(2,2)) = nCk(4,2) = 6`\\nWhich means there are `num0=6` paths that have `H` in the first location \\nWe are looking for `k=4`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H _ _ _ _; H=2, V=2, k=4`\\n\\n\\nState: `H=2, V=2, k=4`\\nLet\\'s try adding `H` as the first step, `path_tmp = H H _ _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(3, max(1,2)) = nCk(3,2) = 3`\\nWhich means there are `num0=3` paths that have `H H` in the first two locations \\nWe are looking for `k=4`, so having `H` in the first step will **NOT** lead us to the correct path\\nSo let\\'s add `V` instead - `path = H V _ _ _`\\nAlso update `k` because after inserting a `V`, we have already ignored the first `num0=3` paths in lexicographical order\\nNow, `path = H V _ _ _; H=2, V=1, k=1`\\n\\nState: `H=2, V=1, k=1`\\nLet\\'s try adding `H` as the first step, `path_tmp = H V H _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(2, max(1,1)) = nCk(2,1) = 2`\\nWhich means there are `num0=2` paths that have `H V H _ _` in the first three locations \\nWe are looking for `k=1`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H V H _ _; H=1, V=1, k=1`\\n\\nState: `H=1, V=1, k=1`\\nLet\\'s try adding `H` as the first step, `path_tmp = H V H H _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(1, max(0,1)) = nCk(2,1) = 1`\\nWhich means there are `num0=2` paths that have `H V H H _` in the first three locations \\nWe are looking for `k=1`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H V H H _; H=0, V=1, k=1`\\n\\n\\nState: `H=0, V=1, k=1`\\nThis case is easy because only `V` is a valid choice since no `H`-s are left \\nFinal path found by algo: ` H V H H V`\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, long long> fact_cache;\\n    unordered_map<string, long long> nck_cache; \\n    long long factorial(long long x) {\\n        if (fact_cache.count(x)) return fact_cache[x];\\n        long long res = 1;\\n        \\n        if (x > 0) res = (long long) x * factorial(x-1);\\n        \\n        fact_cache[x] = res;\\n        return res;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        // long long den = factorial(k) * factorial(n-k);\\n        // long long num = factorial(n);\\n        \\n        string key = to_string(n) + \"C\" + to_string(k);\\n        if (nck_cache.count(key)) return nck_cache[key];\\n        long long den = factorial(min(k,n-k));\\n        long long num = 1;\\n        for (long long nn = n; nn > (long long) max(n-k,k); --nn) {\\n            num *= nn;\\n        }\\n        int res = (int) (num/den);\\n        nck_cache[key] = res;\\n        \\n        \\n        return res;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0], H = destination[1];\\n        int n = H + V;\\n        vector<char> order({\\'H\\', \\'V\\'});\\n        string path = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (!H) {\\n                --V;\\n                path.push_back(\\'V\\');\\n            }\\n            else if (!V) {\\n                --H;\\n                path.push_back(\\'H\\');\\n            }\\n            else {\\n                // if 0 placed in place i\\n                int num0 = nCk(V+H-1, max(V,H-1));\\n                // cout << k << \" \" << H << \" \" << V << \" \" << n-i-1 << \"C\" << max(H-1,V) << \" \" << num0 << endl;\\n\\n                if (num0+1 > k) {\\n                    --H;\\n                    path.push_back(order[0]);\\n                }\\n                else {\\n                    k -= num0;\\n                    --V;\\n                    path.push_back(order[1]);\\n                }\\n            }\\n        }\\n    \\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, long long> fact_cache;\\n    unordered_map<string, long long> nck_cache; \\n    long long factorial(long long x) {\\n        if (fact_cache.count(x)) return fact_cache[x];\\n        long long res = 1;\\n        \\n        if (x > 0) res = (long long) x * factorial(x-1);\\n        \\n        fact_cache[x] = res;\\n        return res;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        // long long den = factorial(k) * factorial(n-k);\\n        // long long num = factorial(n);\\n        \\n        string key = to_string(n) + \"C\" + to_string(k);\\n        if (nck_cache.count(key)) return nck_cache[key];\\n        long long den = factorial(min(k,n-k));\\n        long long num = 1;\\n        for (long long nn = n; nn > (long long) max(n-k,k); --nn) {\\n            num *= nn;\\n        }\\n        int res = (int) (num/den);\\n        nck_cache[key] = res;\\n        \\n        \\n        return res;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0], H = destination[1];\\n        int n = H + V;\\n        vector<char> order({\\'H\\', \\'V\\'});\\n        string path = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (!H) {\\n                --V;\\n                path.push_back(\\'V\\');\\n            }\\n            else if (!V) {\\n                --H;\\n                path.push_back(\\'H\\');\\n            }\\n            else {\\n                // if 0 placed in place i\\n                int num0 = nCk(V+H-1, max(V,H-1));\\n                // cout << k << \" \" << H << \" \" << V << \" \" << n-i-1 << \"C\" << max(H-1,V) << \" \" << num0 << endl;\\n\\n                if (num0+1 > k) {\\n                    --H;\\n                    path.push_back(order[0]);\\n                }\\n                else {\\n                    k -= num0;\\n                    --V;\\n                    path.push_back(order[1]);\\n                }\\n            }\\n        }\\n    \\n        return path;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2253721,
                "title": "combinatorics-with-linear-runtime-python",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        V, H = destination\\n        n = H + V\\n        res = \"\"\\n        for i in range(1, n+1):\\n            if H == 0 or V == 0:\\n                res += \"V\"*V + \"H\"*H\\n                break\\n                \\n            if k <= math.comb(H-1+V, H-1):\\n                res += \"H\"\\n                H -= 1\\n            else:\\n                res += \"V\"\\n                k -= math.comb(H-1+V, H-1)\\n                V -= 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        V, H = destination\\n        n = H + V\\n        res = \"\"\\n        for i in range(1, n+1):\\n            if H == 0 or V == 0:\\n                res += \"V\"*V + \"H\"*H\\n                break\\n                \\n            if k <= math.comb(H-1+V, H-1):\\n                res += \"H\"\\n                H -= 1\\n            else:\\n                res += \"V\"\\n                k -= math.comb(H-1+V, H-1)\\n                V -= 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323910,
                "title": "how-someone-clueless-at-math-solved-it",
                "content": "If you want the best, most elegant solution, this isn\\'t the post for you... Here is how my brain wandered into a solution.\\n\\nFirst I simplified the problem into it core part. What it\\'s really asking is: if you have 3 H\\'s and 2 V\\'s, what is the k\\'th arrangement of them. As long as you go down twice and to the right 3 times, it doesn\\'t matter what order you do it in. I just decided to call H\\'s 1\\'s and V\\'s 0\\'s because that made more sense to me for some reason.\\n\\nFor reference here are the 10 possible arrangement for a 2 by 3 grid:\\n```\\n11100\\n11010\\n11001\\n10110\\n10101\\n10011\\n01110\\n01101\\n01011\\n00111\\n```\\n\\nI didn\\'t know where to start, so I figured I would just write a function that returned the count of orderings for a given number of ones and zeros. For example, f(ones=3, zeros=2) = 10.\\n\\nI reasoned the base case of that function was if there are only ones OR there are only zeros - in that case the answer is obviously 1. Then I figured the left more element could either by a 1 or a 0. So logically, the total count must be the sum of those two possiblities. if the left most element is 1, (3, 2) -> (2, 2). If the left most is a zero, (3, 2) -> (3, 1). After some testing, this logic seemed sound.\\n\\n```\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        return solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n    }\\n```\\n\\nI didn\\'t really know what to do from here but I vaguely had a sense that this logic was leading in the right direction. I noticed that if you assume the first digit is a one, you get solve(3 - 1, 2) = 6 possible options, which matches up with the actual numbers I wrote down. \\n\\nSo I knew that if k was <= solve(2, 2) = 6, the first digit must be a 1. Else it must be a zero. You can see this by looking at example arrangements. Okayyy... If we know the first digit is a 1, now what? Well it seems like we reduced the problem down to something simpler. Let say k = 3, now we just need to find the 3rd element for 2 0\\'s and 2 1\\'s since we already figured out the first element is a 1. Lets guess that the next element is also a 1. We get solve(1, 2) = 3, which is still <= 3. So we know the next digit is also a 1! Let\\'s guess one again the next element is a 1. We get solve(0, 2) = 1. Oops 3 > 1 so the next must be a zero. Okay again. solve(0, 1) = 1 < 3. so the next element must be a zero. Okay now we have no more zeros left so the last digit must be a 1. Done!\\n\\nNow lets try for k = 8. solve(2, 2) = 6 < 8. This means the first digit must be a 0. There are only 4 possible solutions where the first digit is 0. So what we are now looking for is the 2nd (8 - 6) solution where the first digit is 0. Let try solve(2, 1) = 3. 3 <= 3 so this time we know the next digit is a 1... And we continue this logic until we are out of digits to add. \\n\\nNow we just convert 1\\'s and 0\\'s into H\\'s and V\\'s and we are done!\\n\\nI got a time limit exceeded because the solve() function was very slow. So memoization (DP) fixed that and it was solved efficiently. The time complexity was the same as computing the memoized solve() function which was O(nm). \\n\\nIf you look closely, the solve() function actually creates pascal\\'s triangle which you might note is part of other\\'s solutions. So this is the same solution as other\\'s, just a different thought process.\\n\\nFinal code:\\n\\n```\\nvar kthSmallestPath = function(destination, k) {\\n    \\n    const cache = {};\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        const key = `${ones},${zeros}`;\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n        cache[key] = result;\\n        return result\\n    }\\n    \\n    let zeros = destination[0]\\n    let ones = destination[1]\\n    const size = zeros + ones;\\n    const digits = []\\n    while (digits.length < size) {\\n        if (ones === 0) {\\n            zeros--;\\n            digits.push(0)\\n            continue;\\n        } else if (zeros === 0) {\\n            ones--;\\n            digits.push(1)\\n            continue;\\n        } \\n        \\n        const res = solve(ones - 1, zeros);\\n        if (res >= k) {\\n            ones--\\n            digits.push(1)\\n        } else {\\n            zeros--\\n            digits.push(0)\\n            k -= (res)\\n        }\\n    }\\n    return digits\\n        .map(n => n === 1 ? \\'H\\' : \\'V\\')\\n        .join(\\'\\');\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n11100\\n11010\\n11001\\n10110\\n10101\\n10011\\n01110\\n01101\\n01011\\n00111\\n```\n```\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        return solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n    }\\n```\n```\\nvar kthSmallestPath = function(destination, k) {\\n    \\n    const cache = {};\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        const key = `${ones},${zeros}`;\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n        cache[key] = result;\\n        return result\\n    }\\n    \\n    let zeros = destination[0]\\n    let ones = destination[1]\\n    const size = zeros + ones;\\n    const digits = []\\n    while (digits.length < size) {\\n        if (ones === 0) {\\n            zeros--;\\n            digits.push(0)\\n            continue;\\n        } else if (zeros === 0) {\\n            ones--;\\n            digits.push(1)\\n            continue;\\n        } \\n        \\n        const res = solve(ones - 1, zeros);\\n        if (res >= k) {\\n            ones--\\n            digits.push(1)\\n        } else {\\n            zeros--\\n            digits.push(0)\\n            k -= (res)\\n        }\\n    }\\n    return digits\\n        .map(n => n === 1 ? \\'H\\' : \\'V\\')\\n        .join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295247,
                "title": "java-math-solution",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int hs = destination[1];\\n        int vs = destination[0];\\n        // the destination decided how many H and how many V should in the return string\\n        return find(hs, vs, k);\\n        \\n    }\\n    \\n    private String find(int h, int v, int k) {\\n        if (h == 0) {\\n            char[] chars = new char[v];\\n            Arrays.fill(chars, \\'V\\');\\n            return new String(chars);\\n        } else if (v == 0) {\\n            char[] chars = new char[h];\\n            Arrays.fill(chars, \\'H\\');\\n            return new String(chars);\\n        }\\n        // if return has no H or V, then we can directly return it. Should have better way to generate strings.   \\n        int total = h + v;\\n        int chance = ncr(total - 1, v);\\n\\t\\t// If we have 3 H and 2 V, totally we have ncr(5,2)=10 combinations, if first one is H, then all the combination has ncr(4, 2) = 6. So if K is bigger than it, means first one should be V. otherwise first letter is H.\\n\\t\\t\\n        if (k <= chance) {\\n            return \"H\" + find(h - 1, v, k);\\n\\t\\t\\t// if we ignore the first letter, then we have 2 H and 2 V left, run the function again to find it.\\n        } else {\\n            return \"V\" + find(h, v - 1, k - chance);\\n\\t\\t\\t// if first one is V, then we need remove the ncr(4, 2) combinations of k. Since we need find the other 4 letters order.\\n        }\\n    }\\n    \\n\\t//This funciton is used to find the ncr which mentioned in the question.\\n    private int ncr(int a, int b){\\n        int count = 1;\\n        int prod = 1;\\n        while (count <= b) {\\n            prod = prod * a / count;\\n            a--;\\n            count++;\\n        }\\n        return prod;\\n    }\\n}\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int hs = destination[1];\\n        int vs = destination[0];\\n        // the destination decided how many H and how many V should in the return string\\n        return find(hs, vs, k);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1129286,
                "title": "c-solution",
                "content": "```\\nint dp[35][25];\\n    int fnd(int n, int r)\\n    {\\n        if(n<r || r<0)\\n            return 0;\\n        if(n==1 || n==r || r==0)\\n            return 1;\\n        if(dp[n][r]!=-1)\\n            return dp[n][r];\\n        return dp[n][r]=fnd(n-1,r)+fnd(n-1,r-1);\\n    }\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        string ans;\\n        memset(dp,-1,sizeof(dp));\\n        int h=d[1],v=d[0],t=h+v;\\n        while(t>0)\\n        {\\n            long hf=h<=0?1:fnd(h+v-1,v);\\n            cout<<hf<<\" \";\\n            if(k>hf)\\n            {\\n                k-=hf;\\n                ans+=v>0?\\'V\\':\\'H\\';\\n                v--;\\n            }\\n            else\\n            {\\n                ans+=h>0?\\'H\\':\\'V\\';\\n                h--;\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint dp[35][25];\\n    int fnd(int n, int r)\\n    {\\n        if(n<r || r<0)\\n            return 0;\\n        if(n==1 || n==r || r==0)\\n            return 1;\\n        if(dp[n][r]!=-1)\\n            return dp[n][r];\\n        return dp[n][r]=fnd(n-1,r)+fnd(n-1,r-1);\\n    }\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        string ans;\\n        memset(dp,-1,sizeof(dp));\\n        int h=d[1],v=d[0],t=h+v;\\n        while(t>0)\\n        {\\n            long hf=h<=0?1:fnd(h+v-1,v);\\n            cout<<hf<<\" \";\\n            if(k>hf)\\n            {\\n                k-=hf;\\n                ans+=v>0?\\'V\\':\\'H\\';\\n                v--;\\n            }\\n            else\\n            {\\n                ans+=h>0?\\'H\\':\\'V\\';\\n                h--;\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1127528,
                "title": "c-simple-solution",
                "content": "destination[0] and destination[1] denote respectively the number of \"V\" `requiredV` and that of \"H\" `requiredH` contained in the final answer.\\n\\nLet `n` be the length of the whole string (`n = requiredV + requiredH`)\\n\\nWe determine bit by bit from left to right which (\"H\" or \"V\") should be there.\\nInitially we consider the 1st bit. If the 1st bit is \"V\", then the whole string would look like `V...`. There are `nCr(n - 1, requiredV)` many strings that are \"smaller\" than the string starting with a `V` in dictionary order.\\nTherefore, if `k > nCr(n - 1, requiredV)`, we should set the 1st bit as `V`. Otherwise we set the 1st bit as `H`.\\nThen we repeat this process until the whole string is determined.\\n```\\nclass Solution {\\nprivate:\\n    int choose(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int requiredV = destination[0], requiredH = destination[1];\\n        \\n        string ans = \"\";\\n        for(int i = 1; i <= destination[0] + destination[1]; i++){\\n            int combinations = choose(requiredV + requiredH - 1, requiredV);\\n            if(k > combinations) {\\n                k -= combinations;\\n                ans += \"V\";\\n                requiredV--;\\n            }else{\\n                ans += \"H\";\\n                requiredH--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int choose(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int requiredV = destination[0], requiredH = destination[1];\\n        \\n        string ans = \"\";\\n        for(int i = 1; i <= destination[0] + destination[1]; i++){\\n            int combinations = choose(requiredV + requiredH - 1, requiredV);\\n            if(k > combinations) {\\n                k -= combinations;\\n                ans += \"V\";\\n                requiredV--;\\n            }else{\\n                ans += \"H\";\\n                requiredH--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926698,
                "title": "c-o-row-col-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll dp[31][31];\\n    \\n    void helper(int n){\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i) dp[i][j] = 1;\\n                else dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod;\\n            }\\n        }\\n        return;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        memset(dp, 1, sizeof(dp));\\n        \\n        int h = dest[1];\\n        int v = dest[0];\\n        \\n        helper(h+v);\\n        \\n        int val = h+v;\\n        string res = \"\";\\n        \\n        for(int i = 0; i < val; i++){\\n            ll comb = dp[h+v][h];\\n            ll x = h*comb/(h+v);\\n            if(k <= h*comb/(h+v)){\\n                res += \"H\";\\n                h--;\\n            }\\n            else{\\n                res += \"V\";\\n                k -=  h*comb/(h+v);\\n                v--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll dp[31][31];\\n    \\n    void helper(int n){\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i) dp[i][j] = 1;\\n                else dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod;\\n            }\\n        }\\n        return;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        memset(dp, 1, sizeof(dp));\\n        \\n        int h = dest[1];\\n        int v = dest[0];\\n        \\n        helper(h+v);\\n        \\n        int val = h+v;\\n        string res = \"\";\\n        \\n        for(int i = 0; i < val; i++){\\n            ll comb = dp[h+v][h];\\n            ll x = h*comb/(h+v);\\n            if(k <= h*comb/(h+v)){\\n                res += \"H\";\\n                h--;\\n            }\\n            else{\\n                res += \"V\";\\n                k -=  h*comb/(h+v);\\n                v--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918954,
                "title": "java-iterative-math-solution-in-o-n-m",
                "content": "While we haven\\'t reached the destination we need to do the following:\\nIf moving right we will have enough number of combinations (`k <= number of combinations`), then we can go right, else go down\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int y = destination[0], x = destination[1];\\n        StringBuilder answer = new StringBuilder();\\n        \\n        while (x != 0 && y != 0) {\\n            int move = combinations(x + y - 1, y);\\n            \\n            if (k <= move) {\\n                answer.append(\\'H\\');\\n                x--;\\n            } else {\\n                answer.append(\\'V\\');\\n                k -= move;\\n                y--;\\n            }\\n        }\\n        \\n        while (x != 0) {\\n            answer.append(\\'H\\');\\n            x--;\\n        }\\n        \\n        while (y != 0) {\\n            answer.append(\\'V\\');\\n            y--;\\n        }\\n        \\n        return answer.toString();\\n    }\\n    \\n    private int combinations(int a, int b) {\\n        long top = 1;\\n        long bottom = 1;\\n        \\n        for (int i = b + 1; i <= a; i++) {\\n            top *= i;\\n        }\\n        \\n        for (int i = 1; i <= a - b; i++) {\\n            bottom *= i;\\n        }\\n        \\n        return (int) (top / bottom);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int y = destination[0], x = destination[1];\\n        StringBuilder answer = new StringBuilder();\\n        \\n        while (x != 0 && y != 0) {\\n            int move = combinations(x + y - 1, y);\\n            \\n            if (k <= move) {\\n                answer.append(\\'H\\');\\n                x--;\\n            } else {\\n                answer.append(\\'V\\');\\n                k -= move;\\n                y--;\\n            }\\n        }\\n        \\n        while (x != 0) {\\n            answer.append(\\'H\\');\\n            x--;\\n        }\\n        \\n        while (y != 0) {\\n            answer.append(\\'V\\');\\n            y--;\\n        }\\n        \\n        return answer.toString();\\n    }\\n    \\n    private int combinations(int a, int b) {\\n        long top = 1;\\n        long bottom = 1;\\n        \\n        for (int i = b + 1; i <= a; i++) {\\n            top *= i;\\n        }\\n        \\n        for (int i = 1; i <= a - b; i++) {\\n            bottom *= i;\\n        }\\n        \\n        return (int) (top / bottom);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918696,
                "title": "very-easy-c-dp-solution",
                "content": "First pass: calculate count of all path from (row, col) to destination\\nSecond pass: fill k-th trace using first pass calculations\\n\\n```\\n    public class Solution\\n    {\\n        private static readonly int[][] _dirs = new[]\\n        {\\n            new[] {0, 1},\\n            new[] {1, 0},\\n        };\\n\\n        private int CalculateCount(int?[,] count, int n, int m, int row, int col)\\n        {\\n            if (count[row, col].HasValue)\\n            {\\n                return count[row, col].Value;\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var d in _dirs)\\n            {\\n                int newRow = row + d[0];\\n                int newCol = col + d[1];\\n\\n                if (newRow < n && newCol < m)\\n                {\\n                    res += CalculateCount(count, n, m, newRow, newCol);\\n                }\\n            }\\n\\n            count[row, col] = res;\\n            return res;\\n        }\\n\\n        private void Helper(StringBuilder res, int row, int col, int?[,] counts, int k)\\n        {\\n            int n = counts.GetLength(0);\\n            int m = counts.GetLength(1);\\n\\n            if (row == n - 1 && col == m - 1)\\n            {\\n                return;\\n            }\\n\\n            var horRow = row + _dirs[0][0];\\n            var horCol = col + _dirs[0][1];\\n\\n            var vertRow = row + _dirs[1][0];\\n            var vertCol = col + _dirs[1][1];\\n\\n            if (horRow < n && horCol < m)\\n            {\\n                if (k < counts[horRow, horCol].Value)\\n                {\\n                    res.Append(\\'H\\');\\n                    Helper(res, horRow, horCol, counts, k);\\n                }\\n                else\\n                {\\n                    res.Append(\\'V\\');\\n                    Helper(res, vertRow, vertCol, counts, k - counts[horRow, horCol].Value);\\n                }\\n            }\\n            else\\n            {\\n                res.Append(\\'V\\');\\n                Helper(res, vertRow, vertCol, counts, k);\\n            }\\n        }\\n\\n        public string KthSmallestPath(int[] destination, int k)\\n        {\\n            int n = destination[0] + 1;\\n            int m = destination[1] + 1;\\n\\n            int?[,] count = new int?[n,m];\\n            count[destination[0], destination[1]] = 1;\\n            CalculateCount(count, n, m, 0, 0);\\n            StringBuilder res = new StringBuilder();\\n            Helper(res, 0,0,count, k-1);\\n            return res.ToString();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private static readonly int[][] _dirs = new[]\\n        {\\n            new[] {0, 1},\\n            new[] {1, 0},\\n        };\\n\\n        private int CalculateCount(int?[,] count, int n, int m, int row, int col)\\n        {\\n            if (count[row, col].HasValue)\\n            {\\n                return count[row, col].Value;\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var d in _dirs)\\n            {\\n                int newRow = row + d[0];\\n                int newCol = col + d[1];\\n\\n                if (newRow < n && newCol < m)\\n                {\\n                    res += CalculateCount(count, n, m, newRow, newCol);\\n                }\\n            }\\n\\n            count[row, col] = res;\\n            return res;\\n        }\\n\\n        private void Helper(StringBuilder res, int row, int col, int?[,] counts, int k)\\n        {\\n            int n = counts.GetLength(0);\\n            int m = counts.GetLength(1);\\n\\n            if (row == n - 1 && col == m - 1)\\n            {\\n                return;\\n            }\\n\\n            var horRow = row + _dirs[0][0];\\n            var horCol = col + _dirs[0][1];\\n\\n            var vertRow = row + _dirs[1][0];\\n            var vertCol = col + _dirs[1][1];\\n\\n            if (horRow < n && horCol < m)\\n            {\\n                if (k < counts[horRow, horCol].Value)\\n                {\\n                    res.Append(\\'H\\');\\n                    Helper(res, horRow, horCol, counts, k);\\n                }\\n                else\\n                {\\n                    res.Append(\\'V\\');\\n                    Helper(res, vertRow, vertCol, counts, k - counts[horRow, horCol].Value);\\n                }\\n            }\\n            else\\n            {\\n                res.Append(\\'V\\');\\n                Helper(res, vertRow, vertCol, counts, k);\\n            }\\n        }\\n\\n        public string KthSmallestPath(int[] destination, int k)\\n        {\\n            int n = destination[0] + 1;\\n            int m = destination[1] + 1;\\n\\n            int?[,] count = new int?[n,m];\\n            count[destination[0], destination[1]] = 1;\\n            CalculateCount(count, n, m, 0, 0);\\n            StringBuilder res = new StringBuilder();\\n            Helper(res, 0,0,count, k-1);\\n            return res.ToString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918676,
                "title": "easy-understandable-dp-solution-c-o-n-m",
                "content": "```\\nint n,m;\\nint cache[20][20];\\nstring res;\\nint dp(int x,int y){\\n    int &ans = cache[x][y];\\n    if(x > n or y > m)\\n        return ans = 0;\\n    if(x == n and y == m)\\n        return ans = 1;\\n    if(ans != -1)\\n        return ans;\\n    ans = dp(x,y+1) + dp(x+1,y); \\n    return ans;\\n}\\nvoid dp1(int x,int y,int k)\\n{\\n    if(x > n or y > m)\\n        return;\\n    if(x == n and y == m)\\n        return;\\n    int &ans = cache[x][y];\\n    int l = cache[x][y+1];\\n    if(l >= k){\\n        res += \\'H\\';\\n        dp1(x,y+1,k);\\n        return;\\n    }\\n    res += \\'V\\';\\n    dp1(x+1,y,k-l);\\n}\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0];\\n        m = d[1];\\n        memset(cache,-1,sizeof(cache));\\n        dp(0,0);\\n        res = \"\";\\n        dp1(0,0,k);\\n\\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/17c1bd4c-5eaa-4b5e-b9c8-4f356767daa9_1604311353.9740295.png)\\n\\n```\\n# Destinaton = [1,2]\\n\\n# If you oberved carefully how to filled *cache* table then you can see that the imediate left node of root_node(0,0) contain value 2 that indicate  from that pos(0,1) we have 2 valid way to reach  destination_node(1,2) and lexicographical order of those instruction will be 1 and 2.\\n\\n# The imediate right node of root_node(0,0) contain value 1 that indicate  from that pos(1,0) we have 1 valid way to reach  destination_node(1,2) and lexicographical order of this instruction will be 3(as already 2 valid instruction found in left node which lexicographically smaller than this instruction).\\n\\n# l >= k means kth lexicographically smallest instruction must be present in left subtree of that node so we need to move right or horizontally and append \\'H\\' to the res\\n# Otherwise we move right subtree of that node (i.e actually move vertically or down from that position) and append \\'V\\' to the res. \\n# when we move right subtree we decrease the value of k by l because we already found l number of instruction in left subtree which lexicograpically smaller then any instruction of right subtree.\\n# So we need to actually find (k-l)th smallest instruction in right subtree.\\n\\n# lets take an example row   = 1 and col = 2 and k = 2, so we passes dp1(x = 0, y = 0, k = 2) from main.\\n# 1st, l = cache[0][1] = 2 as l >= k we move left subtree i.e. dp1(0,1,2) and res = \\'H\\'.\\n# 2nd, l = cache[0][2] = 1 as l < k so we move right subtree i.e. dp1(1,1,1) and res = \"HV\"\\n# 3rd, l = cache[1][2] = 1 as l >= k so we move left subtree i.e. dp1(1,2,1) and res = \"HVH\"\\n# 4th, as x = row and y = col so simple return and resultant instruction will be \"HVH\".\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n,m;\\nint cache[20][20];\\nstring res;\\nint dp(int x,int y){\\n    int &ans = cache[x][y];\\n    if(x > n or y > m)\\n        return ans = 0;\\n    if(x == n and y == m)\\n        return ans = 1;\\n    if(ans != -1)\\n        return ans;\\n    ans = dp(x,y+1) + dp(x+1,y); \\n    return ans;\\n}\\nvoid dp1(int x,int y,int k)\\n{\\n    if(x > n or y > m)\\n        return;\\n    if(x == n and y == m)\\n        return;\\n    int &ans = cache[x][y];\\n    int l = cache[x][y+1];\\n    if(l >= k){\\n        res += \\'H\\';\\n        dp1(x,y+1,k);\\n        return;\\n    }\\n    res += \\'V\\';\\n    dp1(x+1,y,k-l);\\n}\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0];\\n        m = d[1];\\n        memset(cache,-1,sizeof(cache));\\n        dp(0,0);\\n        res = \"\";\\n        dp1(0,0,k);\\n\\n        return res;\\n    }\\n};\\n```\n```\\n# Destinaton = [1,2]\\n\\n# If you oberved carefully how to filled *cache* table then you can see that the imediate left node of root_node(0,0) contain value 2 that indicate  from that pos(0,1) we have 2 valid way to reach  destination_node(1,2) and lexicographical order of those instruction will be 1 and 2.\\n\\n# The imediate right node of root_node(0,0) contain value 1 that indicate  from that pos(1,0) we have 1 valid way to reach  destination_node(1,2) and lexicographical order of this instruction will be 3(as already 2 valid instruction found in left node which lexicographically smaller than this instruction).\\n\\n# l >= k means kth lexicographically smallest instruction must be present in left subtree of that node so we need to move right or horizontally and append \\'H\\' to the res\\n# Otherwise we move right subtree of that node (i.e actually move vertically or down from that position) and append \\'V\\' to the res. \\n# when we move right subtree we decrease the value of k by l because we already found l number of instruction in left subtree which lexicograpically smaller then any instruction of right subtree.\\n# So we need to actually find (k-l)th smallest instruction in right subtree.\\n\\n# lets take an example row   = 1 and col = 2 and k = 2, so we passes dp1(x = 0, y = 0, k = 2) from main.\\n# 1st, l = cache[0][1] = 2 as l >= k we move left subtree i.e. dp1(0,1,2) and res = \\'H\\'.\\n# 2nd, l = cache[0][2] = 1 as l < k so we move right subtree i.e. dp1(1,1,1) and res = \"HV\"\\n# 3rd, l = cache[1][2] = 1 as l >= k so we move left subtree i.e. dp1(1,2,1) and res = \"HVH\"\\n# 4th, as x = row and y = col so simple return and resultant instruction will be \"HVH\".\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918536,
                "title": "c-dp-binsearch-easy-to-understand",
                "content": "First build a dp array where **dp[v][h]** denotes the count of permutation given v **V**\\'s and h **H**\\'s.\\n\\nThen perform a \\'*binary search*\\'. We will decide from left to right the next char to push back into the answer. \\n\\nSuppose now we have h \\'**H** and v \\'**V**\\'\\'s. If next character is \\'**V**\\' then we are throwing away all the permutations that has \\'**H**\\' in the same location, the number of solutions is **dp[v][h-1]**. Therefore, if k is greater than **dp[v][h-1]** then the next char is **\\'V**\\', otherwise it is \\'**H**\\'.\\n\\nComlexity should be **O(V*H)** which is the cost to build the dp array.\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int v = destination[0];  // num of V\\n        int h = destination[1];  // H\\n        vector<vector<int>> p(v+1, vector<int>(h+1, 0));\\n        for (int i = 0; i <= h; ++i) {\\n            p[0][i] = 1;\\n        }\\n        for (int j = 0; j <= v; ++j) {\\n            p[j][0] = 1;\\n        }\\n        for (int i = 1; i <= v; ++i) {\\n            for (int j = 1; j <= h; ++j) {\\n                p[i][j] = p[i-1][j] + p[i][j-1];\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            // if next char is V we will throw away p[r][c-1] solutions\\n            if (v > 0 && k > p[v][h-1]) {\\n                k -= p[v][h-1];\\n                res.push_back(\\'V\\');\\n                --v;\\n            } else {\\n                res.push_back(\\'H\\');\\n                --h;\\n            }\\n            if (v == 0 && h != 0) {\\n                res += string(h, \\'H\\');\\n                return res;\\n            } else if (h == 0 && v != 0) {\\n                res += string(v, \\'V\\');\\n                return res;\\n            } else if (h == 0 && v == 0) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int v = destination[0];  // num of V\\n        int h = destination[1];  // H\\n        vector<vector<int>> p(v+1, vector<int>(h+1, 0));\\n        for (int i = 0; i <= h; ++i) {\\n            p[0][i] = 1;\\n        }\\n        for (int j = 0; j <= v; ++j) {\\n            p[j][0] = 1;\\n        }\\n        for (int i = 1; i <= v; ++i) {\\n            for (int j = 1; j <= h; ++j) {\\n                p[i][j] = p[i-1][j] + p[i][j-1];\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            // if next char is V we will throw away p[r][c-1] solutions\\n            if (v > 0 && k > p[v][h-1]) {\\n                k -= p[v][h-1];\\n                res.push_back(\\'V\\');\\n                --v;\\n            } else {\\n                res.push_back(\\'H\\');\\n                --h;\\n            }\\n            if (v == 0 && h != 0) {\\n                res += string(h, \\'H\\');\\n                return res;\\n            } else if (h == 0 && v != 0) {\\n                res += string(v, \\'V\\');\\n                return res;\\n            } else if (h == 0 && v == 0) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918478,
                "title": "c-count-dp-explained",
                "content": "Count possible routes from that point to end. Run dfs, if possible routes are less than `\\'K\\'` subtract routes from `\\'K\\'` and go back.\\n\\nCount matrix when destination is (2,3) :-\\n```\\n10 6 3 1\\n 4 3 2 1\\n 1 1 1 1\\n```\\nWhat this represent is that there are 10 routes from (0, 0) , 6 routes from (0, 1) and so on.\\nDuring dfs when visit a point where number of possible routes are less than required `\\'K\\'` routes, then we mark these route visited i.e subtract those route from `\\'K\\'` and go back.\\nFor exmaple when `K=4` and we start moving from (0,0). At (0, 0) possible routes are 10 i.e greater than `K` so we move right. Same for (0, 1) but when we reach (0, 2) possible routes are 3 i.e less than `K` therefore there is no way we can choose `Kth` path if we continue this. Now we mark these 3 routes visited and subtract them from `K` and go back to (0, 1). At this point, we have already visited right so we will go down. This process will conitnue till we reach the end. \\n```\\nclass Solution {\\npublic:\\n    int x, y;\\n    string res;\\n    bool q;\\n    int cnt[16][16];\\n    void dfs(int i, int j, int& k, string &s){\\n        if (q) return;\\n        if (k>cnt[i][j]){\\n            k-=cnt[i][j];\\n            return;\\n        }\\n        if (i==x && j==y){\\n                q=true;\\n                res=s;\\n        }\\n        if (j<y){\\n            s.push_back(\\'H\\');\\n            dfs(i, j+1, k, s);\\n            s.pop_back();\\n        }\\n        if (i<x){\\n            s.push_back(\\'V\\');\\n            dfs(i+1, j, k, s);\\n            s.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        x=destination[0], y=destination[1];\\n        int tmp;\\n        for (int i=x; i>-1; --i){\\n            for (int j=y; j>-1; --j){\\n                tmp=0;\\n                if (i<15) tmp+=cnt[i+1][j];\\n                if (j<15) tmp+=cnt[i][j+1];\\n                tmp=max(1, tmp);\\n                cnt[i][j]=tmp;\\n            }\\n        }\\n        \\n        \\n        string s=\"\";\\n        q=false;\\n        dfs(0, 0, k, s);\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\n10 6 3 1\\n 4 3 2 1\\n 1 1 1 1\\n```\n```\\nclass Solution {\\npublic:\\n    int x, y;\\n    string res;\\n    bool q;\\n    int cnt[16][16];\\n    void dfs(int i, int j, int& k, string &s){\\n        if (q) return;\\n        if (k>cnt[i][j]){\\n            k-=cnt[i][j];\\n            return;\\n        }\\n        if (i==x && j==y){\\n                q=true;\\n                res=s;\\n        }\\n        if (j<y){\\n            s.push_back(\\'H\\');\\n            dfs(i, j+1, k, s);\\n            s.pop_back();\\n        }\\n        if (i<x){\\n            s.push_back(\\'V\\');\\n            dfs(i+1, j, k, s);\\n            s.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        x=destination[0], y=destination[1];\\n        int tmp;\\n        for (int i=x; i>-1; --i){\\n            for (int j=y; j>-1; --j){\\n                tmp=0;\\n                if (i<15) tmp+=cnt[i+1][j];\\n                if (j<15) tmp+=cnt[i][j+1];\\n                tmp=max(1, tmp);\\n                cnt[i][j]=tmp;\\n            }\\n        }\\n        \\n        \\n        string s=\"\";\\n        q=false;\\n        dfs(0, 0, k, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007090,
                "title": "java-solution-100-faster-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount Total Possible Paths using concept from unique Paths problem.\\nNow to find Kth Instruction-\\nDivide the range in the range of number of left \"H\" and \"V\" counts\\nWherever k lies add that to answer\\n\\nEg-(2,3)==>Total paths=10 horizontal moves=3, Vertical moves=2;\\nk=4;\\nDividing 1 to 10 in ratio of 3:2\\nFirst 6 paths will start with \"H\" and then rest with \"V\"\\nk<=6 therfore ans.append(\"H\");\\nnew ratio 2:2 range 1 to 6\\nFirst 3 paths will start with \"H\" and then rest with \"V\"\\nk>3 therfore ans.append(\"V\");\\nnew ration 2:1 range 4 to 6\\nRecursively we will find next moves by modifying range with left over moves.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int m=d[0]+1;\\n        int n=d[1]+1;\\n        int dp[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n          for(int j=0;j<n;j++){\\n            if(i==0 && j==0) dp[i][j]=1;\\n            else if(i==0)dp[i][j]=dp[i][j-1];\\n            else if(j==0)dp[i][j]=dp[i-1][j];\\n            else dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n          }\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        int lo=1,hi=dp[m-1][n-1];\\n        int h=n-1,v=m-1;\\n        while(h!=0 && v!=0){\\n          int mid=(int)(h*(((hi-lo+1)*1.0)/(h+v)));\\n          if(k<=mid+lo-1){\\n            sb.append(\"H\");\\n            hi=mid+lo-1;\\n            h--;\\n          }\\n          else{\\n            sb.append(\"V\");\\n            lo=mid+lo;\\n            v--;\\n          }\\n        }\\n        while(v-->0)sb.append(\"V\");\\n        while(h-->0)sb.append(\"H\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int m=d[0]+1;\\n        int n=d[1]+1;\\n        int dp[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n          for(int j=0;j<n;j++){\\n            if(i==0 && j==0) dp[i][j]=1;\\n            else if(i==0)dp[i][j]=dp[i][j-1];\\n            else if(j==0)dp[i][j]=dp[i-1][j];\\n            else dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n          }\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        int lo=1,hi=dp[m-1][n-1];\\n        int h=n-1,v=m-1;\\n        while(h!=0 && v!=0){\\n          int mid=(int)(h*(((hi-lo+1)*1.0)/(h+v)));\\n          if(k<=mid+lo-1){\\n            sb.append(\"H\");\\n            hi=mid+lo-1;\\n            h--;\\n          }\\n          else{\\n            sb.append(\"V\");\\n            lo=mid+lo;\\n            v--;\\n          }\\n        }\\n        while(v-->0)sb.append(\"V\");\\n        while(h-->0)sb.append(\"H\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997949,
                "title": "commented-easiest",
                "content": "****Here\\'s a step-by-step explanation of what\\'s happening with k -= c;:**\\n**\\nk is initially the kth smallest path we want to find.\\n\\nc is the number of combinations if we pick \\'H\\' at the current position in the string.\\n\\n\\n\\n\\nIf k is less than or equal to c, it means that the kth smallest path must include an \\'H\\' at the current position. Therefore, we append \\'H\\' to the result string s, decrement h (the count of available horizontal moves), and move to the next position.\\n\\n\\n\\n\\nIf k is greater than c, it means that the kth smallest path does not include \\'H\\' at the current position. In this case, we subtract c from k to adjust k to represent the kth smallest path among the remaining possibilities. We then append \\'V\\' to the result string s, decrement v (the count of available vertical moves), and move to the next position.\\n\\n\\n\\nThe purpose of k -= c; is to adjust the value of k based on whether we choose \\'H\\' or \\'V\\' at the current position, ensuring that we correctly find the kth smallest path as we construct the string. This process continues until we have constructed the entire string.\\n\\n# Code\\n```\\n\\n// Time complexity analysis:\\n// The code uses a combination formula to determine the number of ways to choose \\'H\\' or \\'V\\'\\n// at each position in the resulting string. It iterates through the entire string and makes\\n// a decision at each step based on the value of \\'k\\'. The maximum length of the resulting\\n// string is \\'H + V\\'. So, the time complexity is O((H + V)^2).\\n\\n// Space complexity analysis:\\n// The code uses only a constant amount of extra space to store variables like \\'ans\\', \\'s\\', \\'h\\', \\'v\\',\\n// \\'N\\', \\'i\\', \\'c\\', and \\'k\\'. Therefore, the space complexity is O(1).\\n\\nclass Solution {\\n    // Function to calculate the combination of \\'n\\' choose \\'r\\'.\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    // Function to find the kth smallest path.\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // If we have H available to pick.\\n                int c = comb(h - 1 + v, v); // Calculate the number of combinations if we pick H at this position.\\n                if (k <= c) { // If k is covered within \\'c\\', pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // Otherwise, pick V and adjust k.\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } \\n            \\n            else { // If no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// Time complexity analysis:\\n// The code uses a combination formula to determine the number of ways to choose \\'H\\' or \\'V\\'\\n// at each position in the resulting string. It iterates through the entire string and makes\\n// a decision at each step based on the value of \\'k\\'. The maximum length of the resulting\\n// string is \\'H + V\\'. So, the time complexity is O((H + V)^2).\\n\\n// Space complexity analysis:\\n// The code uses only a constant amount of extra space to store variables like \\'ans\\', \\'s\\', \\'h\\', \\'v\\',\\n// \\'N\\', \\'i\\', \\'c\\', and \\'k\\'. Therefore, the space complexity is O(1).\\n\\nclass Solution {\\n    // Function to calculate the combination of \\'n\\' choose \\'r\\'.\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    // Function to find the kth smallest path.\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // If we have H available to pick.\\n                int c = comb(h - 1 + v, v); // Calculate the number of combinations if we pick H at this position.\\n                if (k <= c) { // If k is covered within \\'c\\', pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // Otherwise, pick V and adjust k.\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } \\n            \\n            else { // If no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974286,
                "title": "beats-100-users-simplest-o-15-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nat every index we need to check that can we place a H or V\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet say at ith index you place a \\'H\\' then calculate that how many permutations left, if its greater than k it means you can place \\'H\\' there else you will place \\'V\\' here and will reduce k \\nfor more calrity refer my code then you will get a better understanding\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(15)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(15)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long ncr(int h,int v,int k){\\n        if(h<1) return 1;\\n        long long ans=1;\\n        for(int i=h+v;i>max(h,v);i--) ans*=i;\\n        for(int i=min(h,v);i>0;i--) ans/=i;\\n        return ans;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ans;\\n        while(v+h>0){\\n            long long res=ncr(h-1,v,k);\\n            if(res>=k and h) ans+=\\'H\\',h--;\\n            else{\\n                ans+=\\'V\\';\\n                v--;\\n                k-=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long ncr(int h,int v,int k){\\n        if(h<1) return 1;\\n        long long ans=1;\\n        for(int i=h+v;i>max(h,v);i--) ans*=i;\\n        for(int i=min(h,v);i>0;i--) ans/=i;\\n        return ans;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ans;\\n        while(v+h>0){\\n            long long res=ncr(h-1,v,k);\\n            if(res>=k and h) ans+=\\'H\\',h--;\\n            else{\\n                ans+=\\'V\\';\\n                v--;\\n                k-=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864114,
                "title": "python-combinatorial-solution-beats-95-10-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython combinatorial search. Beats 97%. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive combinatorial search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(destination[0] + destination[1])\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(destination[0] + destination[1]) \\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def kthSmallestPath(self, destination: list[int], k: int) -> str:\\n        def choose(n, k):\\n            return math.factorial(n) / (math.factorial(n-k)*math.factorial(k))\\n        def helper(n, k, rank) -> str:\\n            if k == 0:\\n                return \\'H\\' * n\\n            elif n == k:\\n                return \\'V\\' * n\\n            if rank <= choose(n-1, k):\\n                # we know path must start with a 0 (\\'H\\')\\n                return \\'H\\' + helper(n-1, k, rank)\\n            else:\\n                # we know path must start with a 1 (\\'V\\')\\n                return \\'V\\' + helper(n-1, k-1, rank - choose(n-1, k))\\n        return helper(destination[0]+destination[1], destination[0], k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def kthSmallestPath(self, destination: list[int], k: int) -> str:\\n        def choose(n, k):\\n            return math.factorial(n) / (math.factorial(n-k)*math.factorial(k))\\n        def helper(n, k, rank) -> str:\\n            if k == 0:\\n                return \\'H\\' * n\\n            elif n == k:\\n                return \\'V\\' * n\\n            if rank <= choose(n-1, k):\\n                # we know path must start with a 0 (\\'H\\')\\n                return \\'H\\' + helper(n-1, k, rank)\\n            else:\\n                # we know path must start with a 1 (\\'V\\')\\n                return \\'V\\' + helper(n-1, k-1, rank - choose(n-1, k))\\n        return helper(destination[0]+destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853187,
                "title": "good-combinatorics-problem-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne of the best ways to solve a search space sometimes is to DFS. This is one of those times thanks to the fact that Bob is picky. Because Bob is picky, we can use that to prune the dfs space as we go along, thus providing a way to quickly and readily match up and eliminate possible dead ends quickly. \\n\\nThis is mainly due to the fact that Bob\\'s pickiness allows us to use a combinatorial calculation to determine WHEN we add a \\'V\\' to our path string, rather than trying to find WHERE in the graph we should do so; this reduces our search space complexity greatly at the cost of combinatorial calculations. Luckily, nice people out there have done n choose k for a quite large range, so calculating that is of less concern. \\n\\nWith that in hand, we merely need to stay in our bounded space of k, moves horizontal and moves vertical and we can get to an answer that uses up Bob\\'s exhaustive nature. Then we can simply concat the remaining in lexicographically smallest order and it\\'s solved. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReduce K by 1 for off by 1 indexing (annoying monopoly rule people) \\n\\nGet change in rows and change in columns as the value of destination unpacked \\n\\nSet an empty path string \\n\\n- While you have k, dr, and dc greater than 0 \\n    - get directional options - 1 choose horizontal options minus 1 \\n    - if this value is lte k\\n        - we can afford a V \\n        - So, add a V to the path string \\n        - reduce our number of vertical options \\n        - and reduce our value of k by the combinatorial value \\n    - otherwise, we can\\'t afford a V \\n        - add an H to the path string and reduce our number of horizontal options \\n\\nWhen done, bob still may not have arrived. \\nSo, to keep it lexicographically smallest \\n- If you still have dc options gt 0 \\n    - add H dc times to the path string \\n- If you still have dr options gt 0 \\n    - add V dr times to the path string \\n\\nNow we know Bob has made it, send him his path string that he\\'ll be OK with       \\n\\n\\n# Complexity\\n- Time complexity : O(N ^ 2)\\n    - O(N) for math combinations it turns out \\n    - Gotta do that at least N times as well to make up for search space at the worst (if Bob was not, in fact, actually that picky)\\n    - At worst O(N * N) or O(N^2), where N is size of grid space  \\n\\n- Space complexity : O(P) \\n    - O(P) have to store the path string of size P \\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str :\\n        # off by 1 indexing \\n        k-=1\\n        # get destination row and column \\n        dr, dc = destination\\n        # set up path string \\n        path_string = \"\" \\n        # while you still have moves to make, and have not reached the goal \\n        while k and dr and dc : \\n            # evaluates n choose k, in this case n is directional space of dr + dc - 1 \\n            # and k is choosing space of only dc - 1 \\n            # remember dc, change in cols, is horizontal! \\n            current_combination_value = math.comb(dr+dc - 1, dc - 1) \\n            # if the value produced is lte k \\n            if current_combination_value <= k : \\n                # we can afford a \\'V\\' here, which is a large value lexicographically \\n                path_string += \"V\"\\n                # we\\'ve used up a vertical directional movement, a change in rows \\n                dr -= 1 \\n                # so, we also need to lower k by this combination value\\n                # this is equivalent to cutting off any future V\\'s of at most this value as well \\n                k -= current_combination_value\\n            else : \\n                # otherwise, we should just add an h and decrement our horizontal option space\\n                path_string += \"H\" \\n                dc -= 1 \\n        # when done with above, path string still may not be fully built. To ensure it \\n        # if we have any horizontal components left \\n        if (dc > 0) :\\n            path_string = path_string + \"H\" * dc\\n        # then if we have any vertical components left \\n        if (dr > 0) : \\n            path_string = path_string + \"V\" * dr\\n        # now we\\'re all set \\n        return path_string\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str :\\n        # off by 1 indexing \\n        k-=1\\n        # get destination row and column \\n        dr, dc = destination\\n        # set up path string \\n        path_string = \"\" \\n        # while you still have moves to make, and have not reached the goal \\n        while k and dr and dc : \\n            # evaluates n choose k, in this case n is directional space of dr + dc - 1 \\n            # and k is choosing space of only dc - 1 \\n            # remember dc, change in cols, is horizontal! \\n            current_combination_value = math.comb(dr+dc - 1, dc - 1) \\n            # if the value produced is lte k \\n            if current_combination_value <= k : \\n                # we can afford a \\'V\\' here, which is a large value lexicographically \\n                path_string += \"V\"\\n                # we\\'ve used up a vertical directional movement, a change in rows \\n                dr -= 1 \\n                # so, we also need to lower k by this combination value\\n                # this is equivalent to cutting off any future V\\'s of at most this value as well \\n                k -= current_combination_value\\n            else : \\n                # otherwise, we should just add an h and decrement our horizontal option space\\n                path_string += \"H\" \\n                dc -= 1 \\n        # when done with above, path string still may not be fully built. To ensure it \\n        # if we have any horizontal components left \\n        if (dc > 0) :\\n            path_string = path_string + \"H\" * dc\\n        # then if we have any vertical components left \\n        if (dr > 0) : \\n            path_string = path_string + \"V\" * dr\\n        # now we\\'re all set \\n        return path_string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827669,
                "title": "c-beat-100",
                "content": "```\\npublic class Solution {\\n    int[,] nCr;\\n    public string KthSmallestPath(int[] destination, int k) {\\n        StringBuilder res=new StringBuilder();\\n        int n=destination[0];int m=destination[1];\\n        nCr=new int[n+m+1,n+1];\\n        \\n        int distance=destination[0]+destination[1];\\n        int[] curr_loc=new int[2]{0,0};\\n        \\n        for(int i=0;i<distance;i++){\\n            long c=C(distance-i-1,destination[0]-curr_loc[0]) ;   \\n            if(k>c){\\n                res.Append(\"V\");\\n                curr_loc[0]++;\\n                k=k-(int)c;\\n            }\\n            else{\\n                res.Append(\"H\");\\n                curr_loc[1]++;\\n            }\\n            \\n        }\\n        \\n        return res.ToString();\\n    }\\n    \\n    public int C(int n, int r){\\n        if(r==0 || r==n)\\n            return 1;\\n        \\n        if(r>n)\\n            return 0;\\n        if(nCr[n,r]>0)\\n            return nCr[n,r];\\n        \\n        nCr[n,r]= C(n-1,r)+C(n-1,r-1);\\n        return nCr[n,r];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\npublic class Solution {\\n    int[,] nCr;\\n    public string KthSmallestPath(int[] destination, int k) {\\n        StringBuilder res=new StringBuilder();\\n        int n=destination[0];int m=destination[1];\\n        nCr=new int[n+m+1,n+1];\\n        \\n        int distance=destination[0]+destination[1];\\n        int[] curr_loc=new int[2]{0,0};\\n        \\n        for(int i=0;i<distance;i++){\\n            long c=C(distance-i-1,destination[0]-curr_loc[0]) ;   \\n            if(k>c){\\n                res.Append(\"V\");\\n                curr_loc[0]++;\\n                k=k-(int)c;\\n            }\\n            else{\\n                res.Append(\"H\");\\n                curr_loc[1]++;\\n            }\\n            \\n        }\\n        \\n        return res.ToString();\\n    }\\n    \\n    public int C(int n, int r){\\n        if(r==0 || r==n)\\n            return 1;\\n        \\n        if(r>n)\\n            return 0;\\n        if(nCr[n,r]>0)\\n            return nCr[n,r];\\n        \\n        nCr[n,r]= C(n-1,r)+C(n-1,r-1);\\n        return nCr[n,r];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803332,
                "title": "swift-using-combinatorics-beat-100",
                "content": "My only proud in this awful code is that I managed to solve this problem without looking into any hints.\\n\\n# Code\\n```\\nclass Solution {\\n    func kthSmallestPath(_ destination: [Int], _ k: Int) -> String {\\n        var rows = destination[0] // V\\n        var columns = destination[1] // H\\n        var chars: [Character] = []\\n        var leftK = k\\n        while leftK >= 1, rows > 0, columns > 0 {\\n            let (shifts, newK) = shifts(rows, leftK)\\n            chars.append(contentsOf: Array(repeating: \"H\", count: columns-shifts))\\n            chars.append(\"V\")\\n            rows -= 1\\n            columns = shifts\\n            leftK = newK\\n        }\\n        chars.append(contentsOf: Array(repeating: \"H\", count: columns))\\n        chars.append(contentsOf: Array(repeating: \"V\", count: rows))\\n        return String(chars)\\n    }\\n    \\n    private func shifts(_ rows: Int, _ k: Int) -> (Int, Int) {\\n        if k == 1 { return (0, 0) }\\n        var shift = 0\\n        var totalLetters = rows\\n        var totalCombinations = 1\\n        var prevTotalCombinations = 1\\n        while k > totalCombinations {\\n            prevTotalCombinations = totalCombinations\\n            if totalLetters == rows {\\n                totalCombinations = 1\\n            } else {\\n                totalCombinations *= totalLetters // had to optimize the code to pass cases with large numbers\\n                totalCombinations /= (totalLetters-rows)\\n            }\\n            shift += 1\\n            totalLetters += 1\\n        }\\n        return (shift-1, k - prevTotalCombinations)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    func kthSmallestPath(_ destination: [Int], _ k: Int) -> String {\\n        var rows = destination[0] // V\\n        var columns = destination[1] // H\\n        var chars: [Character] = []\\n        var leftK = k\\n        while leftK >= 1, rows > 0, columns > 0 {\\n            let (shifts, newK) = shifts(rows, leftK)\\n            chars.append(contentsOf: Array(repeating: \"H\", count: columns-shifts))\\n            chars.append(\"V\")\\n            rows -= 1\\n            columns = shifts\\n            leftK = newK\\n        }\\n        chars.append(contentsOf: Array(repeating: \"H\", count: columns))\\n        chars.append(contentsOf: Array(repeating: \"V\", count: rows))\\n        return String(chars)\\n    }\\n    \\n    private func shifts(_ rows: Int, _ k: Int) -> (Int, Int) {\\n        if k == 1 { return (0, 0) }\\n        var shift = 0\\n        var totalLetters = rows\\n        var totalCombinations = 1\\n        var prevTotalCombinations = 1\\n        while k > totalCombinations {\\n            prevTotalCombinations = totalCombinations\\n            if totalLetters == rows {\\n                totalCombinations = 1\\n            } else {\\n                totalCombinations *= totalLetters // had to optimize the code to pass cases with large numbers\\n                totalCombinations /= (totalLetters-rows)\\n            }\\n            shift += 1\\n            totalLetters += 1\\n        }\\n        return (shift-1, k - prevTotalCombinations)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788838,
                "title": "is-k-small-enough-to-insert-symbol-h-at-the-end-of-the-string",
                "content": "# Intuition\\nWe iteratively add symbols from the the beggining of the string to its end. What we can do is to think of when the first symbol is \"H\" and when it is \\'V\\'. In fact if k is \"too large\" then it\\'s \\'V\\'. In fact too large means it\\'s larger then (n choose h-1) where n is the length of the string and h is the number of \"H\" in it. So if it\\'s smaller we return \\'H\\' + kthSmallestPath((v,h-1), k). otherwise we insert V and change k: k = k - (n choose h-1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import factorial\\nclass Solution:\\n    def perm(self, destination) -> int:\\n        return factorial(destination[1]+destination[0]) // factorial(destination[0]) // factorial(destination[1])\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        if k==0:\\n            return \\'H\\' * destination[1] + \\'V\\' * destination[0]\\n        if destination[1]==0:\\n            return \\'V\\' * destination[0]\\n        ans = \\'\\' \\n        while k-1>=self.perm((destination[0], destination[1]-1)) and destination[0]>0:\\n            k = k - self.perm((destination[0], destination[1]-1))\\n            destination = destination[0]-1, destination[1]\\n            ans = ans + \\'V\\'\\n        if destination[0]==0:\\n            return ans + \\'H\\' * destination[1]\\n        if k-1<self.perm((destination[0], destination[1]-1)):\\n            return ans + \\'H\\' + self.kthSmallestPath((destination[0], destination[1]-1), k)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import factorial\\nclass Solution:\\n    def perm(self, destination) -> int:\\n        return factorial(destination[1]+destination[0]) // factorial(destination[0]) // factorial(destination[1])\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        if k==0:\\n            return \\'H\\' * destination[1] + \\'V\\' * destination[0]\\n        if destination[1]==0:\\n            return \\'V\\' * destination[0]\\n        ans = \\'\\' \\n        while k-1>=self.perm((destination[0], destination[1]-1)) and destination[0]>0:\\n            k = k - self.perm((destination[0], destination[1]-1))\\n            destination = destination[0]-1, destination[1]\\n            ans = ans + \\'V\\'\\n        if destination[0]==0:\\n            return ans + \\'H\\' * destination[1]\\n        if k-1<self.perm((destination[0], destination[1]-1)):\\n            return ans + \\'H\\' + self.kthSmallestPath((destination[0], destination[1]-1), k)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725596,
                "title": "optimal-greedy-combinatorics-o-r-c-logmod-time",
                "content": "# Intuition\\n1. try to place \\'a\\' at i\\'th position, now there are (aCount - 1) and bCount characters can be put after i\\'th position, count all ways to do it. that is: (aCount + bCount - 1)! / [(aCount-1)*bCount]. The intution if after putting \\'a\\' if we are able to generate atleat k different strings then it is optimal to put \\'a\\'.\\n2. if it is >=k then we put \\'a\\' at i\\'th index\\n3. otherwise we put \\'b\\' and subract the ways from k.\\n\\n# Complexity\\n- Time complexity:\\nO((R+C)logMOD), MOD = 10^9 + 7\\n\\n- Space complexity:\\nO(R+C)\\n\\n# Code\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int a = destination[1];\\n        int b = destination[0];\\n        int sum = a + b;\\n        long[] fact = new long[sum+1];\\n        long[] invFact = new long[sum+1];\\n        fact[0] = invFact[0] = 1;\\n        for(int i=1;i<=sum;i++){\\n            fact[i] = i*fact[i-1];\\n            fact[i]%=mod;\\n            invFact[i] = _pow(fact[i],mod-2);\\n        }\\n    \\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<sum;i++){\\n            if(a == 0){\\n                ans.append(\\'V\\');\\n                b--;\\n                continue;\\n            }\\n            if(b == 0){\\n                ans.append(\\'H\\');\\n                a--;\\n                continue;\\n            }\\n            long next = ((fact[a+b-1] * invFact[a-1] % mod )*invFact[b]%mod);\\n            if(next >= k){\\n                ans.append(\\'H\\');\\n                a--;\\n            }else {\\n                ans.append(\\'V\\');\\n                k-=next;\\n                b--;\\n            }\\n        }\\n        return ans.toString();\\n\\n    }\\n    long mod = (int)1e9 + 7;\\n    private long _pow(long x, long n){\\n        long ans = 1;\\n        while(n > 0){\\n            if(n%2==1){\\n                ans *=x;\\n                n--;\\n            }else {\\n                x*=x;\\n                n>>=1;\\n            }\\n            x%=mod;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int a = destination[1];\\n        int b = destination[0];\\n        int sum = a + b;\\n        long[] fact = new long[sum+1];\\n        long[] invFact = new long[sum+1];\\n        fact[0] = invFact[0] = 1;\\n        for(int i=1;i<=sum;i++){\\n            fact[i] = i*fact[i-1];\\n            fact[i]%=mod;\\n            invFact[i] = _pow(fact[i],mod-2);\\n        }\\n    \\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<sum;i++){\\n            if(a == 0){\\n                ans.append(\\'V\\');\\n                b--;\\n                continue;\\n            }\\n            if(b == 0){\\n                ans.append(\\'H\\');\\n                a--;\\n                continue;\\n            }\\n            long next = ((fact[a+b-1] * invFact[a-1] % mod )*invFact[b]%mod);\\n            if(next >= k){\\n                ans.append(\\'H\\');\\n                a--;\\n            }else {\\n                ans.append(\\'V\\');\\n                k-=next;\\n                b--;\\n            }\\n        }\\n        return ans.toString();\\n\\n    }\\n    long mod = (int)1e9 + 7;\\n    private long _pow(long x, long n){\\n        long ans = 1;\\n        while(n > 0){\\n            if(n%2==1){\\n                ans *=x;\\n                n--;\\n            }else {\\n                x*=x;\\n                n>>=1;\\n            }\\n            x%=mod;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664146,
                "title": "runtime-only-1ms-and-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int comb(int n, int r) {\\n        int ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = ans * (n - i + 1) / i;\\n        }\\n        return ans;\\n    }\\n\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder ans = new StringBuilder();\\n        int y = destination[0];\\n        int x = destination[1];\\n        int n = x + y;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (x > 0) {\\n                int c = comb(x + y - 1, x - 1);\\n                if (k <= c) {\\n                    ans.append(\\'H\\');\\n                    x--;\\n                } else {\\n                    ans.append(\\'V\\');\\n                    y--;\\n                    k -= c;\\n                }\\n            } else {\\n                ans.append(\\'V\\');\\n                y--;\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int comb(int n, int r) {\\n        int ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = ans * (n - i + 1) / i;\\n        }\\n        return ans;\\n    }\\n\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder ans = new StringBuilder();\\n        int y = destination[0];\\n        int x = destination[1];\\n        int n = x + y;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (x > 0) {\\n                int c = comb(x + y - 1, x - 1);\\n                if (k <= c) {\\n                    ans.append(\\'H\\');\\n                    x--;\\n                } else {\\n                    ans.append(\\'V\\');\\n                    y--;\\n                    k -= c;\\n                }\\n            } else {\\n                ans.append(\\'V\\');\\n                y--;\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639684,
                "title": "o-n-2-time-complexity-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public static String kthSmallestPath(int[] destination, int k) {\\n        int rows = destination[0] + 1;\\n        int cols = destination[1] + 1;\\n\\n        int[][] dp = new int[rows][cols];\\n\\n        // Calculate the number of possible paths for each cell\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int remainingH = cols - 1;  // Number of remaining horizontal moves\\n        int remainingV = rows - 1;  // Number of remaining vertical moves\\n\\n        for (int i = 0; i < rows + cols - 2; i++) {\\n            if (remainingH > 0 && dp[remainingV][remainingH - 1] >= k) {\\n                sb.append(\"H\");\\n                remainingH--;\\n            } else {\\n                sb.append(\"V\");\\n                if (remainingH > 0) {\\n                    k -= dp[remainingV][remainingH - 1];\\n                }\\n                remainingV--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    \\n    }\\n    /*\\n    private static void backtrack(List<String> paths, String currentPath, int row, int col, int rows, int columns) {\\n        if (row == rows - 1 && col == columns - 1) {\\n            paths.add(currentPath);\\n            return;\\n        }\\n\\n        if (row < rows - 1) {\\n            backtrack(paths, currentPath + \"V\", row + 1, col, rows, columns);\\n        }\\n\\n        if (col < columns - 1) {\\n            backtrack(paths, currentPath + \"H\", row, col + 1, rows, columns);\\n        }\\n    }*/\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String kthSmallestPath(int[] destination, int k) {\\n        int rows = destination[0] + 1;\\n        int cols = destination[1] + 1;\\n\\n        int[][] dp = new int[rows][cols];\\n\\n        // Calculate the number of possible paths for each cell\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int remainingH = cols - 1;  // Number of remaining horizontal moves\\n        int remainingV = rows - 1;  // Number of remaining vertical moves\\n\\n        for (int i = 0; i < rows + cols - 2; i++) {\\n            if (remainingH > 0 && dp[remainingV][remainingH - 1] >= k) {\\n                sb.append(\"H\");\\n                remainingH--;\\n            } else {\\n                sb.append(\"V\");\\n                if (remainingH > 0) {\\n                    k -= dp[remainingV][remainingH - 1];\\n                }\\n                remainingV--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    \\n    }\\n    /*\\n    private static void backtrack(List<String> paths, String currentPath, int row, int col, int rows, int columns) {\\n        if (row == rows - 1 && col == columns - 1) {\\n            paths.add(currentPath);\\n            return;\\n        }\\n\\n        if (row < rows - 1) {\\n            backtrack(paths, currentPath + \"V\", row + 1, col, rows, columns);\\n        }\\n\\n        if (col < columns - 1) {\\n            backtrack(paths, currentPath + \"H\", row, col + 1, rows, columns);\\n        }\\n    }*/\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378929,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL combination(int n, int m)\\n    {        \\n        LL ret = 1;\\n        if(n == m || m == 0)\\n            return 1 ;\\n        for(int i = 0; i < m; i++){\\n            ret *= n - i;\\n            ret /= (i + 1);\\n        }\\n        return ret;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0] ;\\n        int H = destination[1] ;\\n        int n = V + H ;\\n        string ret ;\\n        for(int i = 0; i < n; i++){\\n            if(H == 0){\\n                while(V){\\n                    ret.push_back(\\'V\\') ;\\n                    V-- ;\\n                }\\n                break ;\\n            }    \\n            if(V == 0){\\n                while(H){\\n                    ret.push_back(\\'H\\') ;\\n                    H-- ;\\n                }\\n                break ;\\n            }\\n            LL sum = combination(H-1 + V, V) ;\\n            if(k <= sum){\\n                ret.push_back(\\'H\\') ;\\n                H-- ;\\n            }\\n            else{\\n                k -= sum;  //important \\n                ret.push_back(\\'V\\') ;\\n                V-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL combination(int n, int m)\\n    {        \\n        LL ret = 1;\\n        if(n == m || m == 0)\\n            return 1 ;\\n        for(int i = 0; i < m; i++){\\n            ret *= n - i;\\n            ret /= (i + 1);\\n        }\\n        return ret;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0] ;\\n        int H = destination[1] ;\\n        int n = V + H ;\\n        string ret ;\\n        for(int i = 0; i < n; i++){\\n            if(H == 0){\\n                while(V){\\n                    ret.push_back(\\'V\\') ;\\n                    V-- ;\\n                }\\n                break ;\\n            }    \\n            if(V == 0){\\n                while(H){\\n                    ret.push_back(\\'H\\') ;\\n                    H-- ;\\n                }\\n                break ;\\n            }\\n            LL sum = combination(H-1 + V, V) ;\\n            if(k <= sum){\\n                ret.push_back(\\'H\\') ;\\n                H-- ;\\n            }\\n            else{\\n                k -= sum;  //important \\n                ret.push_back(\\'V\\') ;\\n                V-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331607,
                "title": "c-simple-explanation",
                "content": "1. It\\'s like performing a binary search. Let\\'s represent V as 1 and H as 0. The number of values starting with 0 is C(4, 2), since there are four digits left and we need to choose two of them to be 1\\'s.\\nThere are 6 combinations ranging from 0**0011** to 0**1100**.\\n\\n            k     number \\n            1    0 0 0 1 1\\n            2    0 0 1 0 1\\n            3    0 0 1 1 0\\n            4    0 1 0 0 1\\n            5    0 1 0 1 0\\n            6    0 1 1 0 0\\n\\n            7    1 0 0 0 1\\n            8    1 0 0 1 0\\n            9    1 0 1 0 0\\n            10   1 1 0 0 0\\n2. If k is larger than 6, the first digit must be 1, otherwise, 0.\\n3. Determine whether each digit should be 0 or 1 from left to right.\\n3. If there are no 1s left, then the remaining digits should all be 0s.\\n4. If the number of remaining places minus one is less than the remaining 1s, then the remaining places should be all 1s because there is no place to set the leftmost digit to 0.\\n5. To Compute the combination count C(a, b), we can use the following method, and the result of each step is grantee to be an integer (evenly divisible):\\nanswer = 1\\nanswer = answer * (a - b + 1) / 1\\nanswer = answer * (a - b + 2) / 2\\n...\\nFor example: C(30, 15)\\nanswer = answer * 16 / 1\\nanswer = answer * 17 / 2\\n...\\nSimple proof:\\n    1. Combination count C(a, b) is always an integer (no proof is provided here).\\n    2. At each step, we are simply computing a subset combination count, which is grantee to be an integer.\\n        step1: C(16, 1) = 16 / 1!\\n        step2: C(17, 2) = 17 * 16 / 2!\\n        ...\\n        step15: C(30, 15) = 30 * 29 ... * 16 / 15!\\n        ```\\n        16 17 18 19 ... 30\\n        1  2  3  4 ...  15  \\n        ```\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public string KthSmallestPath(int[] destination, int k)\\n    {\\n        int vCount = destination[0];\\n        int hCount = destination[1];\\n        int totalCount = vCount + hCount;\\n        int indexCountNow = 0;\\n        int remainingVCount = vCount;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < totalCount; ++i)\\n        {\\n            if (remainingVCount <= 0)\\n            {\\n                int remainingHCount = totalCount - i;\\n                for (int whichH = 0; whichH < remainingHCount; ++whichH)\\n                {\\n                    sb.Append(\\'H\\');\\n                }\\n                break;\\n            }\\n\\n            int remainingN = totalCount - 1 - i;\\n            if (remainingN < remainingVCount)\\n            {\\n                for (int whilchV = 0; whilchV < remainingVCount; ++whilchV)\\n                {\\n                    sb.Append(\\'V\\');\\n                }\\n                break;\\n            }\\n\\n            int partitionCount = CombinationCount(remainingN, remainingVCount);\\n            indexCountNow += partitionCount;\\n\\n            if (k <= indexCountNow)\\n            {\\n                sb.Append(\\'H\\');\\n                indexCountNow -= partitionCount;\\n            }\\n            else\\n            {\\n                sb.Append(\\'V\\');\\n                --remainingVCount;\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private int CombinationCount(int a, int b)\\n    {\\n        long answer = 1;\\n\\n        for (int i = 1; i <= b; ++i)\\n        {\\n            answer *= (a - b + i);\\n            answer /= i;\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        16 17 18 19 ... 30\\n        1  2  3  4 ...  15  \\n        ```\n```\\npublic class Solution {\\n    public string KthSmallestPath(int[] destination, int k)\\n    {\\n        int vCount = destination[0];\\n        int hCount = destination[1];\\n        int totalCount = vCount + hCount;\\n        int indexCountNow = 0;\\n        int remainingVCount = vCount;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < totalCount; ++i)\\n        {\\n            if (remainingVCount <= 0)\\n            {\\n                int remainingHCount = totalCount - i;\\n                for (int whichH = 0; whichH < remainingHCount; ++whichH)\\n                {\\n                    sb.Append(\\'H\\');\\n                }\\n                break;\\n            }\\n\\n            int remainingN = totalCount - 1 - i;\\n            if (remainingN < remainingVCount)\\n            {\\n                for (int whilchV = 0; whilchV < remainingVCount; ++whilchV)\\n                {\\n                    sb.Append(\\'V\\');\\n                }\\n                break;\\n            }\\n\\n            int partitionCount = CombinationCount(remainingN, remainingVCount);\\n            indexCountNow += partitionCount;\\n\\n            if (k <= indexCountNow)\\n            {\\n                sb.Append(\\'H\\');\\n                indexCountNow -= partitionCount;\\n            }\\n            else\\n            {\\n                sb.Append(\\'V\\');\\n                --remainingVCount;\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private int CombinationCount(int a, int b)\\n    {\\n        long answer = 1;\\n\\n        for (int i = 1; i <= b; ++i)\\n        {\\n            answer *= (a - b + i);\\n            answer /= i;\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183406,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn c(n: usize, k: usize) -> usize {\\n            let mut ans = 1;\\n            for i in 0..k {\\n                ans = ans * (n - i) / (i + 1);\\n            }\\n            ans\\n        }\\n\\n        let (mut row, mut col) = (destination[0] as usize, destination[1] as usize);\\n        let mut k = k as usize;\\n        let mut ans = String::new();\\n        while row > 0 || col > 0 {\\n            if row == 0 {\\n                ans.push(\\'H\\');\\n                col -= 1;\\n            } else if col == 0 {\\n                ans.push(\\'V\\');\\n                row -= 1;\\n            } else {\\n                let n = c(row + col - 1, col - 1);\\n                if k <= n {\\n                    ans.push(\\'H\\');\\n                    col -= 1;\\n                } else {\\n                    ans.push(\\'V\\');\\n                    row -= 1;\\n                    k -= n;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn c(n: usize, k: usize) -> usize {\\n            let mut ans = 1;\\n            for i in 0..k {\\n                ans = ans * (n - i) / (i + 1);\\n            }\\n            ans\\n        }\\n\\n        let (mut row, mut col) = (destination[0] as usize, destination[1] as usize);\\n        let mut k = k as usize;\\n        let mut ans = String::new();\\n        while row > 0 || col > 0 {\\n            if row == 0 {\\n                ans.push(\\'H\\');\\n                col -= 1;\\n            } else if col == 0 {\\n                ans.push(\\'V\\');\\n                row -= 1;\\n            } else {\\n                let n = c(row + col - 1, col - 1);\\n                if k <= n {\\n                    ans.push(\\'H\\');\\n                    col -= 1;\\n                } else {\\n                    ans.push(\\'V\\');\\n                    row -= 1;\\n                    k -= n;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117171,
                "title": "tracing-path-from-2d-array",
                "content": "### Thought Process 1:Greedy  TLE\\n`Why not store all possible paths and return the k-1 th path`\\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        self.path = []\\n        def f(i,j,s):\\n            if i == row and j == col:\\n                # reached destination so store the path\\n                self.path.append(s)\\n            if i>row or j>col:return\\n            f(i,j+1,s+\"H\") # lets move right\\n            f(i+1,j,s+\"V\") # lets move down\\n        f(0,0,\"\")\\n        return self.path[k-1]\\n# Note to keep the path list sorted we need to move RIGHT first then DOWN\\n# If we move DOWN first and then RIGHT we need to sort them\\n```\\n### Improving Thought Process 1: Improved Greedy TLE\\n`\\nDo we really need to store all paths?\\n`\\n`We are finding paths in sorted manner.So cant we use this to our advantage?`\\n`So , basically we can return k-1th path and stop searching for next paths`\\n```\\n# We will store only the answer now. Not the complete list\\n# We will return once we reach k-1th path\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n\\n        self.k = k\\n        self.ans = \"\"\\n        @cache\\n        def f(i,j,s):\\n            if i == row and j == col: # reached destination\\n                self.k -= 1\\n                if self.k == 0:       # checking if its our k-1th path\\n                    self.ans = s\\n                    return True       # If yes, return True and store the answer\\n                return False\\n            if self.k == 0:           # This will stop seaching for next\\n                self.ans = s          # store the answer and return True\\n                return True\\n            if i>row or j>col:return False\\n            return f(i,j+1,s+\"H\") or f(i+1,j,s+\"V\")\\n        f(0,0,\"\")\\n        return self.ans # return answer\\n```\\n\\n### Issue With Recurion:\\n`As k value is very high` $^nC_r(row+col,row)$ `for this memory wont suffice`\\n`From above we are able to travel [0,0] to [r,c]`\\n`Cant we store the possible paths for each cell?`\\n```\\n    def f(i,j):\\n        if i == row and j == col: # reached destination\\n            return 1\\n        if i>row or j>col:\\n            return 0              # out of bound\\n        right = f(i,j+1)          # move right\\n        down = f(i+1,j)           # move down\\n        return right+down         # total paths\\n    f(0,0)\\n    # Equvalent Code in 2d array\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n```\\n```\\nfor [2,2]\\nnCr = (2+2,2) = 6 i.e total possible paths for [2,2]\\n\\no/p:\\n    6    3    1\\n    3    2    1\\n    1    1    1\\n\\neach cell denotes total paths current cell to [2,2]\\ncell [0,1] = 3 i.e from [0,1] to [2,2] we have 3 paths [HVV,VHV,VVH]\\ncell [1,0] = 3 i.e from [0,1] to [2,2] we have 3 paths [HHV,HVH,VHH]\\ncell [0,0] = 6 i.e from [0,0] to [2,2] we have 6 possible paths\\n```\\n### Whats Next?\\n`We have all possible paths in a 2D list`\\n`Now we need to extract the k-1th path from it`\\n\\n`To do so we need to follow 2 rules:`\\n```\\nwe are currently at [0,0]\\nSo,\\n should we move [0,1] i.e (i,j+1) - \"H\"\\n should we move [1,0] i.e (i+1,j) - \"V\"\\n\\nmove to (i,j+1) if dp[i][j+1] >=k -> (k remains same     j+=1  add \"H\")\\nmove to (i+1,j) if dp[i][j+1] < k -> (k = k - dp[i][j+1] i+=1  add \"V\")\\n\\nNow we would have reached one of the boundary (row or column)\\nif we have not reached end of row: add \"V\"\\nif we have not reached end of col: add \"H\"\\n```\\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        // Creating dp for all possible paths\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n        \\n\\n        i,j = 0,0 //stating point [0,0]\\n        s = \"\"    // answer\\n        while i<row and j<col: // iterate until we have hit one of boundary\\n            if dp[i][j+1]>=k:  // move horizontal\\n                j += 1\\n                s += \"H\"\\n            else:              // move vertical\\n                k -= dp[i][j+1]\\n                i +=1\\n                s += \"V\"\\n        while i<row: // we can move down as i<row so add \"V\"\\n            s += \"V\"\\n            i += 1\\n        while j<col: // we can move right as j<col so add \"H\"\\n            s += \"H\"\\n            j += 1\\n        return s\\n\\n```\\n\\n### Extra\\n`Exchange \"H\" and \"V\" and it will give lexicographically largest`\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        self.path = []\\n        def f(i,j,s):\\n            if i == row and j == col:\\n                # reached destination so store the path\\n                self.path.append(s)\\n            if i>row or j>col:return\\n            f(i,j+1,s+\"H\") # lets move right\\n            f(i+1,j,s+\"V\") # lets move down\\n        f(0,0,\"\")\\n        return self.path[k-1]\\n# Note to keep the path list sorted we need to move RIGHT first then DOWN\\n# If we move DOWN first and then RIGHT we need to sort them\\n```\n```\\n# We will store only the answer now. Not the complete list\\n# We will return once we reach k-1th path\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n\\n        self.k = k\\n        self.ans = \"\"\\n        @cache\\n        def f(i,j,s):\\n            if i == row and j == col: # reached destination\\n                self.k -= 1\\n                if self.k == 0:       # checking if its our k-1th path\\n                    self.ans = s\\n                    return True       # If yes, return True and store the answer\\n                return False\\n            if self.k == 0:           # This will stop seaching for next\\n                self.ans = s          # store the answer and return True\\n                return True\\n            if i>row or j>col:return False\\n            return f(i,j+1,s+\"H\") or f(i+1,j,s+\"V\")\\n        f(0,0,\"\")\\n        return self.ans # return answer\\n```\n```\\n    def f(i,j):\\n        if i == row and j == col: # reached destination\\n            return 1\\n        if i>row or j>col:\\n            return 0              # out of bound\\n        right = f(i,j+1)          # move right\\n        down = f(i+1,j)           # move down\\n        return right+down         # total paths\\n    f(0,0)\\n    # Equvalent Code in 2d array\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n```\n```\\nfor [2,2]\\nnCr = (2+2,2) = 6 i.e total possible paths for [2,2]\\n\\no/p:\\n    6    3    1\\n    3    2    1\\n    1    1    1\\n\\neach cell denotes total paths current cell to [2,2]\\ncell [0,1] = 3 i.e from [0,1] to [2,2] we have 3 paths [HVV,VHV,VVH]\\ncell [1,0] = 3 i.e from [0,1] to [2,2] we have 3 paths [HHV,HVH,VHH]\\ncell [0,0] = 6 i.e from [0,0] to [2,2] we have 6 possible paths\\n```\n```\\nwe are currently at [0,0]\\nSo,\\n should we move [0,1] i.e (i,j+1) - \"H\"\\n should we move [1,0] i.e (i+1,j) - \"V\"\\n\\nmove to (i,j+1) if dp[i][j+1] >=k -> (k remains same     j+=1  add \"H\")\\nmove to (i+1,j) if dp[i][j+1] < k -> (k = k - dp[i][j+1] i+=1  add \"V\")\\n\\nNow we would have reached one of the boundary (row or column)\\nif we have not reached end of row: add \"V\"\\nif we have not reached end of col: add \"H\"\\n```\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        // Creating dp for all possible paths\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n        \\n\\n        i,j = 0,0 //stating point [0,0]\\n        s = \"\"    // answer\\n        while i<row and j<col: // iterate until we have hit one of boundary\\n            if dp[i][j+1]>=k:  // move horizontal\\n                j += 1\\n                s += \"H\"\\n            else:              // move vertical\\n                k -= dp[i][j+1]\\n                i +=1\\n                s += \"V\"\\n        while i<row: // we can move down as i<row so add \"V\"\\n            s += \"V\"\\n            i += 1\\n        while j<col: // we can move right as j<col so add \"H\"\\n            s += \"H\"\\n            j += 1\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112807,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        i,j = destination\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k == 1:\\n                return \"H\"*j + \"V\"*i\\n            else:\\n                val = math.comb(i+j-1,j-1)\\n\\n                if k <= val:\\n                    return \"H\" + dfs(i,j-1,k)\\n                else:\\n                    return \"V\" + dfs(i-1,j,k-val)\\n\\n        return dfs(i,j,k)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        i,j = destination\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k == 1:\\n                return \"H\"*j + \"V\"*i\\n            else:\\n                val = math.comb(i+j-1,j-1)\\n\\n                if k <= val:\\n                    return \"H\" + dfs(i,j-1,k)\\n                else:\\n                    return \"V\" + dfs(i-1,j,k-val)\\n\\n        return dfs(i,j,k)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094957,
                "title": "scala",
                "content": "```scala\\nobject Solution {\\n    def kthSmallestPath(des: Array[Int], k: Int): String = {\\n        def mem[I, O](f: I => O) = new scala.collection.mutable.HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val comb: ((Int, Int)) => Int = mem {\\n            case (_, 0) | (0, _) => 1\\n            case (m, 1) => m\\n            case (m, n) if (n > m / 2) => comb(m, m - n)\\n            case (m, n) => comb(m - 1, n - 1) + comb(m - 1, n)\\n        }\\n        \\n        lazy val go: ((Int, Int, Int)) => String = {\\n            case (r, 0, _) => \"V\" * r\\n            case (r, c, k) if (k > comb(r + c - 1, r)) => \"V\" + go(r - 1, c, k - comb(r + c - 1, r))\\n            case (r, c, k) => \"H\" + go(r, c - 1, k)\\n        }\\n        \\n        go(des(0), des(1), k)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def kthSmallestPath(des: Array[Int], k: Int): String = {\\n        def mem[I, O](f: I => O) = new scala.collection.mutable.HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val comb: ((Int, Int)) => Int = mem {\\n            case (_, 0) | (0, _) => 1\\n            case (m, 1) => m\\n            case (m, n) if (n > m / 2) => comb(m, m - n)\\n            case (m, n) => comb(m - 1, n - 1) + comb(m - 1, n)\\n        }\\n        \\n        lazy val go: ((Int, Int, Int)) => String = {\\n            case (r, 0, _) => \"V\" * r\\n            case (r, c, k) if (k > comb(r + c - 1, r)) => \"V\" + go(r - 1, c, k - comb(r + c - 1, r))\\n            case (r, c, k) => \"H\" + go(r, c - 1, k)\\n        }\\n        \\n        go(des(0), des(1), k)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976648,
                "title": "python-java-walking-through-example-with-dp-approach-builds-on-lc-62-unique-paths",
                "content": "I recommend solving [unique-paths](https://leetcode.com/problems/unique-paths/) first (with a bottom-up dp approach). We will use it to create the dp table.\\n\\nSpecifically, we will build a dp table where $dp[i][j]$ denotes the number of unique paths to reach the bottom-right corner, starting from indexes i, j\\n\\nFor example, \\ndestination = [2, 3], k = 3\\nwill have the following dp table:\\n```\\n10  6   3   1\\n\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\n<pre>\\nLets look at dp[0][0],\\nThere are 10 unique paths\\n    if we move right, we then have 6 unique paths left\\n        [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\"]\\n    if we move down, we then have 4 unique paths left\\n        [\"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]\\n</pre>\\n\\nThe 6 paths on moving right are lexicographically smaller than the 4 paths on moving down\\n\\nWe want the 3rd smallest path(we are given k=3). So we choose to move right since the 3rd smallest path will be amongst the 6 smallest paths.\\n\\n```\\n10__6   3   1\\n    ^    \\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\nWe are now at dp[0][1] = 6, moving right will mean our path will be amongst the 3 smallest paths, so we move right.\\n```\\n10__6___3   1\\n        ^\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\nWe are now at dp[0][2] = 3, we don\\'t want to move right since then our path will be amongst the 1 smallest path(s), so we don\\'t do that(since k = 3, we want the 3rd smallest path).\\nWe move down instead.\\n\\nThere is one thing to note when moving down. \\nAgain, all the paths when moving right are lexicographically smaller than all the paths when moving down.\\nSo you could imagine that all the unique paths when moving down are all \"shifted\" in lex order by the number of paths on the right.\\n\\nYou could also view this as a subproblem where we are looking at the unique paths starting from indexes i, j\\n\\nWe can encode this into our implementation by subtracting our k value by dp[i][j+1] \\nso in this case:\\n```\\nk := k - dp[i][j+1]\\n   = k - dp[0][3]\\n   = 3 - 1 # so now k is 2\\n```\\n\\n\\n```  \\nk = 2\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        ^\\n1   1   1   1\\n```\\nWe are now at dp[1][2] = 2, k = 2, we don\\'t want to move right since then  path will be the 1st smallest path(inside the subproblem perspective).\\nSo we move down.\\n\\n```  \\nk = 1\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1   1\\n        ^\\n```\\nWe are now at dp[2][2] = 1, k = 1\\nOnce we reach the bottom row or right column, there is only one path we can choose.\\n\\nOur final path is:\\n```  \\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1___1\\n\"HHVVH\"\\n```\\nWhich is indeed the 3rd smallest path out of [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]\\n\\n# High-level Recap\\nWe build dp table of unique paths.\\nWe traverse the dp table starting at dp[0][0].\\nWe compare k with dp[i][j+1] to decide whether to move right or down.\\n\\n# Code\\n```python []\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination[0] + 1, destination[1] + 1\\n        dp = [[0] * n for i in range(m)]\\n        for i in range(m): dp[i][n-1] = 1\\n        for j in range(n): dp[m-1][j] = 1\\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        # ^ this is just LC #62. Unique Paths\\n\\n        sb = []\\n        i, j = 0, 0\\n        while i < m-1 and j < n-1: \\n            \"\"\" e.g dest = [2,3], k = 3\\n            10  6   3   1\\n            4   3   2   1   \\n            1   1   1   1\\n            \"\"\"\\n            # move right\\n            if k <= dp[i][j+1]:\\n                j += 1\\n                sb.append(\\'H\\')\\n            # move down\\n            else:\\n                k -= dp[i][j+1]\\n                i += 1\\n                sb.append(\\'V\\')\\n        # if we reach the bottom row or right column, there is only one path left\\n        sb.append(\\'V\\' * (m-1 - i) + \\'H\\' * (n-1 - j))\\n        # print(\\'\\\\n\\'.join([\\'\\\\t\\'.join([str(cell) for cell in row]) for row in dp]))\\n        return \\'\\'.join(sb)\\n```\\n```java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        } // ^ this is just LC #62. Unique Paths\\n\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            // e.g dest = [2,3], k = 3\\n            //    10  6   3   1\\n            //    4   3   2   1   \\n            //    1   1   1   1\\n\\n            // move right\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            // move down\\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        // if we reach the bottom row or right column, there is only one path left\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        //System.out.println(Arrays.deepToString(dp).replace(\"], \", \"]\\\\n\"));\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n10  6   3   1\\n\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\n10__6   3   1\\n    ^    \\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\n10__6___3   1\\n        ^\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\nk := k - dp[i][j+1]\\n   = k - dp[0][3]\\n   = 3 - 1 # so now k is 2\\n```\n```  \\nk = 2\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        ^\\n1   1   1   1\\n```\n```  \\nk = 1\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1   1\\n        ^\\n```\n```  \\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1___1\\n\"HHVVH\"\\n```\n```python []\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination[0] + 1, destination[1] + 1\\n        dp = [[0] * n for i in range(m)]\\n        for i in range(m): dp[i][n-1] = 1\\n        for j in range(n): dp[m-1][j] = 1\\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        # ^ this is just LC #62. Unique Paths\\n\\n        sb = []\\n        i, j = 0, 0\\n        while i < m-1 and j < n-1: \\n            \"\"\" e.g dest = [2,3], k = 3\\n            10  6   3   1\\n            4   3   2   1   \\n            1   1   1   1\\n            \"\"\"\\n            # move right\\n            if k <= dp[i][j+1]:\\n                j += 1\\n                sb.append(\\'H\\')\\n            # move down\\n            else:\\n                k -= dp[i][j+1]\\n                i += 1\\n                sb.append(\\'V\\')\\n        # if we reach the bottom row or right column, there is only one path left\\n        sb.append(\\'V\\' * (m-1 - i) + \\'H\\' * (n-1 - j))\\n        # print(\\'\\\\n\\'.join([\\'\\\\t\\'.join([str(cell) for cell in row]) for row in dp]))\\n        return \\'\\'.join(sb)\\n```\n```java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        } // ^ this is just LC #62. Unique Paths\\n\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            // e.g dest = [2,3], k = 3\\n            //    10  6   3   1\\n            //    4   3   2   1   \\n            //    1   1   1   1\\n\\n            // move right\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            // move down\\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        // if we reach the bottom row or right column, there is only one path left\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        //System.out.println(Arrays.deepToString(dp).replace(\"], \", \"]\\\\n\"));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969285,
                "title": "golang-solution-constant-time-space-with-the-given-constraints-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate a grid of m*n representing the number of possible paths from (x, y) to destination.\\n\\nAny cell in last colume(can only go down) or last row(can only go right) would be 1\\nFor the rest of the grid, c(x, y) = c(x+1, y) + c(x, y+1), combination of total paths from two cells: the one on the right, and the one beneath it.\\n\\nstarting from cell(0, 0), going right, i.e, moving to (0, 1) means appending an \"H\", and going down, i.e, moving to (1, 0) means appending a \"V\". Kth permutation must either falls into these two cases. If grid(0, 1) has larger or equal count than \"k\", the k-th path must be one of the paths via cell (0, 1).\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\nm = num of rows\\nn = num of cols\\n0 <= rows, cols <= 15\\n\\n- Space complexity:\\nO(m*n)\\nm = num of rows\\nn = num of cols\\n0 <= rows, cols <= 15\\n\\n# Code\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n    rows, cols := destination[0] + 1, destination[1] + 1\\n    c := make([][]int, rows)\\n    for i := 0; i < rows; i = i + 1 {\\n        c[i] = make([]int, cols)\\n    }\\n    // last row\\n    for i := 0; i < cols - 1; i = i + 1 {\\n        c[rows-1][i] = 1\\n    }\\n    // last col\\n    for i := 0; i < rows - 1; i = i + 1 {\\n        c[i][cols-1] = 1\\n    }\\n    for r := rows - 2; r >= 0; r = r - 1 {\\n        for cl := cols - 2; cl >= 0; cl = cl - 1 {\\n            c[r][cl] = c[r][cl+1] + c[r+1][cl]\\n        }\\n    }\\n    ret := \"\"\\n    row, col := 0, 0\\n    slen := destination[0] + destination[1]\\n    for len(ret) < destination[0] + destination[1] {\\n        if col == cols - 1 {\\n            // can only go down\\n            for len(ret) < slen {\\n                ret = ret + \"V\"\\n            }\\n            break\\n        }\\n        if row == rows - 1 {\\n            // can only go right\\n            for len(ret) < slen {\\n                ret = ret + \"H\"\\n            }\\n            break\\n        }\\n        if k <= c[row][col+1] {\\n            // go horizontal\\n            ret = ret + \"H\"\\n            col = col + 1\\n        } else {\\n            k -= c[row][col+1]\\n            row = row + 1\\n            ret = ret + \"V\"\\n        }\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n    rows, cols := destination[0] + 1, destination[1] + 1\\n    c := make([][]int, rows)\\n    for i := 0; i < rows; i = i + 1 {\\n        c[i] = make([]int, cols)\\n    }\\n    // last row\\n    for i := 0; i < cols - 1; i = i + 1 {\\n        c[rows-1][i] = 1\\n    }\\n    // last col\\n    for i := 0; i < rows - 1; i = i + 1 {\\n        c[i][cols-1] = 1\\n    }\\n    for r := rows - 2; r >= 0; r = r - 1 {\\n        for cl := cols - 2; cl >= 0; cl = cl - 1 {\\n            c[r][cl] = c[r][cl+1] + c[r+1][cl]\\n        }\\n    }\\n    ret := \"\"\\n    row, col := 0, 0\\n    slen := destination[0] + destination[1]\\n    for len(ret) < destination[0] + destination[1] {\\n        if col == cols - 1 {\\n            // can only go down\\n            for len(ret) < slen {\\n                ret = ret + \"V\"\\n            }\\n            break\\n        }\\n        if row == rows - 1 {\\n            // can only go right\\n            for len(ret) < slen {\\n                ret = ret + \"H\"\\n            }\\n            break\\n        }\\n        if k <= c[row][col+1] {\\n            // go horizontal\\n            ret = ret + \"H\"\\n            col = col + 1\\n        } else {\\n            k -= c[row][col+1]\\n            row = row + 1\\n            ret = ret + \"V\"\\n        }\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917301,
                "title": "simple-combination-beats-91-time-c-easy",
                "content": "# Intuition\\nSince, the path string can only have 2 characters : \\'H\\' and \\'V\\', We can incrementally try to build the path string. Also, the fact that, out of \\'total\\' possible strings, some \\'num\\' strings will start from \\'H\\', and remaining \\'total\\' - \\'num\\' will start from \\'V\\' can help us here.\\n\\n# Approach\\nNotice, that you can straightaway tell, that how many number of \\'H\\' (hNum) and how many number of \\'V\\' (vNum) will be in any path. Notice examples carefully for understanding this point.\\nNext,\\nStart building answer from index 0.\\nIf k is less than or equal to the number of strings that start with \\'H\\', then first character of our answer will be \\'H\\', otherwise it will be \\'V\\'.\\nAccordingly update the value of \\'hNum\\' and \\'vNum\\' and k. Repeat this process until \\'hNum\\' and \\'vNum\\' are both not 0.\\n\\nYou can understand how to calculate number of strings starting from \\'H\\' by observing the code.\\n\\n# Complexity\\n- Time complexity:\\nIn the while loop, either vNum is being decremented each time or hNum is being decremented each time. O(m+n) where m is vNum and n is hNum.\\nCombination function takes O(min(m,n)) in the worst case.\\nFinal Time Complexity : O((m+n)*min(m,n))\\n\\n- Space complexity:\\nNo additional space used, apart from few variables.\\nFinal Space Complexity : O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long combination(int n,int k) { // calculates (nCk)\\n        long long res = 1;\\n        if (k > n - k)\\n            k = n - k;\\n        for (int i = 0; i < k; ++i) {\\n            res *= (n - i);\\n            res /= (i + 1);\\n        }\\n        return res;\\n    }\\n\\n    int findStringsStartWithH(int hNum, int vNum) { // finds how many strings starts with \\'H\\' when no.(H) = hNum, no.(v) = vNum\\n        return combination(hNum+vNum,hNum) * hNum / (hNum+vNum) ;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int vNum = destination[0], hNum = destination[1];\\n        string path = \"\";\\n        while(hNum || vNum) {\\n            int HStrings = findStringsStartWithH(hNum,vNum);\\n           if(k<=HStrings) {\\n                path+=\\'H\\';\\n                hNum--;\\n            }\\n            else {\\n                path+=\\'V\\';\\n                vNum--;\\n                k -= HStrings;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long combination(int n,int k) { // calculates (nCk)\\n        long long res = 1;\\n        if (k > n - k)\\n            k = n - k;\\n        for (int i = 0; i < k; ++i) {\\n            res *= (n - i);\\n            res /= (i + 1);\\n        }\\n        return res;\\n    }\\n\\n    int findStringsStartWithH(int hNum, int vNum) { // finds how many strings starts with \\'H\\' when no.(H) = hNum, no.(v) = vNum\\n        return combination(hNum+vNum,hNum) * hNum / (hNum+vNum) ;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int vNum = destination[0], hNum = destination[1];\\n        string path = \"\";\\n        while(hNum || vNum) {\\n            int HStrings = findStringsStartWithH(hNum,vNum);\\n           if(k<=HStrings) {\\n                path+=\\'H\\';\\n                hNum--;\\n            }\\n            else {\\n                path+=\\'V\\';\\n                vNum--;\\n                k -= HStrings;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865635,
                "title": "python-combinatorics",
                "content": "# Intuition\\nWe need to print the k\\'th lexicographic manifestation of h H\\'s and v V\\'s.\\nThere are $${h+v \\\\choose h} = {h+v \\\\choose v}$$ of them, the first $${h+v-1 \\\\choose h-1} = {h+v-1 \\\\choose v-1}$$ of which start with a \"H\" and the second half start with a \"V\".\\nIf k is less than this value, return \"H\" + the k\\'th lexicographical manifestation of h-1 H\\'s and v V\\'s.\\nIf k is greater than this value, return \"V\" + the (k - threshold)\\'th lexicographical manifestation of h H\\'s and v-1 V\\'s.\\n\\n# Code\\n```\\nimport math \\nclass Solution:\\n\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        ret = []\\n        while True:\\n            if v == 0:\\n                ret.append(\"H\" * h)\\n                break\\n            if h == 0:\\n                ret.append(\"V\" * v)\\n                break\\n            # the number of versions that start with an H\\n            threshold = math.comb(h + v - 1, h - 1)\\n            if k <= threshold:\\n                ret.append(\"H\")\\n                h -= 1\\n            else:\\n                ret.append(\"V\")\\n                v -= 1\\n                k -= threshold\\n        return \"\".join(ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math \\nclass Solution:\\n\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        ret = []\\n        while True:\\n            if v == 0:\\n                ret.append(\"H\" * h)\\n                break\\n            if h == 0:\\n                ret.append(\"V\" * v)\\n                break\\n            # the number of versions that start with an H\\n            threshold = math.comb(h + v - 1, h - 1)\\n            if k <= threshold:\\n                ret.append(\"H\")\\n                h -= 1\\n            else:\\n                ret.append(\"V\")\\n                v -= 1\\n                k -= threshold\\n        return \"\".join(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843538,
                "title": "c-dp-calculate-lexicography-in-every-step-o-m-n",
                "content": "I solve this in 2 steps:\\n- Count possible ways to reach all i,j (i<n, j<m)\\n- Travel from (0,0), in each step, greedily decide if we should go right or down\\n\\t- If we go right, our rank stay the same, since \"H\" is the best choice lexicography\\n\\t- If we go left, our rank decrease, we choose \"V\" which essentially go down lexicography. Use precalculated array from previous step to determine how many rank do we go down\\n\\t- When we reach (n,m), answer is the path made from the traversal\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[1]+1;\\n        int m = destination[0]+1;\\n        vector<vector<int>> f(n, vector<int>(m,0));\\n        f[0][0] = 1;\\n        for(int i = 0;i<n;i++) {\\n            f[i][0] = 1;\\n        }\\n        for(int i = 0;i<m;i++) {\\n            f[0][i] = 1;\\n        }\\n        for(int i = 1;i<n;i++) {\\n            for(int j = 1;j<m;j++) {\\n                f[i][j] = f[i-1][j] + f[i][j-1];\\n            }\\n        }\\n        string ret = \"\";\\n        int i = 0;\\n        int j = 0;\\n        int rank = 1;\\n        while(i<n && j<m) {\\n            int dx = n-1-i;\\n            int dy = m-1-j;\\n            if(dx == 0 && dy == 0) {\\n                break;\\n            }\\n            if(dx == 0) {\\n                j++;\\n                ret += \"V\";\\n            } else if(dy == 0) {\\n                i++;\\n                ret += \"H\";\\n            } else {\\n                int deltaV = f[dx][dy] - f[dx][dy-1]; \\n                // if we go down, we go down deltaV in rank\\n                // if we go right, our rank stay the same\\n                if(rank + deltaV <= k) {\\n                    rank += deltaV;\\n                    j++;\\n                    ret += \"V\";\\n                } else {\\n                    i++;\\n                    ret += \"H\";\\n                }\\n            }\\n        }\\n        return ret;\\n        cout<<\"f: \"<<endl;\\n        for(int i = 0;i<n;i++) {\\n            for(int j = 0;j<m;j++) {\\n                cout<<f[i][j]<<\\' \\';\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[1]+1;\\n        int m = destination[0]+1;\\n        vector<vector<int>> f(n, vector<int>(m,0));\\n        f[0][0] = 1;\\n        for(int i = 0;i<n;i++) {\\n            f[i][0] = 1;\\n        }\\n        for(int i = 0;i<m;i++) {\\n            f[0][i] = 1;\\n        }\\n        for(int i = 1;i<n;i++) {\\n            for(int j = 1;j<m;j++) {\\n                f[i][j] = f[i-1][j] + f[i][j-1];\\n            }\\n        }\\n        string ret = \"\";\\n        int i = 0;\\n        int j = 0;\\n        int rank = 1;\\n        while(i<n && j<m) {\\n            int dx = n-1-i;\\n            int dy = m-1-j;\\n            if(dx == 0 && dy == 0) {\\n                break;\\n            }\\n            if(dx == 0) {\\n                j++;\\n                ret += \"V\";\\n            } else if(dy == 0) {\\n                i++;\\n                ret += \"H\";\\n            } else {\\n                int deltaV = f[dx][dy] - f[dx][dy-1]; \\n                // if we go down, we go down deltaV in rank\\n                // if we go right, our rank stay the same\\n                if(rank + deltaV <= k) {\\n                    rank += deltaV;\\n                    j++;\\n                    ret += \"V\";\\n                } else {\\n                    i++;\\n                    ret += \"H\";\\n                }\\n            }\\n        }\\n        return ret;\\n        cout<<\"f: \"<<endl;\\n        for(int i = 0;i<n;i++) {\\n            for(int j = 0;j<m;j++) {\\n                cout<<f[i][j]<<\\' \\';\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834322,
                "title": "easy-c-recursion",
                "content": "```\\nclass Solution {\\n    \\n    int combi(int n, int r) {\\n                \\n        int num = n;\\n        int den = min(n-r, r);\\n        \\n        int sm = 1;\\n        int i;\\n        \\n        for(i=1;i<=den;i++) {\\n            sm = (sm * num)/i;\\n            num--;\\n        }        \\n        return sm;\\n    }\\n    \\n    string solve(int h, int v, int k) {\\n        if(h==0) {\\n            return string(v,\\'V\\');\\n        }\\n        if(v==0) {\\n            return string(h, \\'H\\');\\n        }\\n        \\n        int c = combi(h+v-1,h-1);\\n        \\n        if(k>c) {\\n            return \\'V\\'+solve(h, v-1, k-c);\\n        } else {\\n            return \\'H\\'+solve(h-1, v, k);\\n        }\\n    }\\n    \\n    \\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        return solve(destination[1],destination[0],k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int combi(int n, int r) {\\n                \\n        int num = n;\\n        int den = min(n-r, r);\\n        \\n        int sm = 1;\\n        int i;\\n        \\n        for(i=1;i<=den;i++) {\\n            sm = (sm * num)/i;\\n            num--;\\n        }        \\n        return sm;\\n    }\\n    \\n    string solve(int h, int v, int k) {\\n        if(h==0) {\\n            return string(v,\\'V\\');\\n        }\\n        if(v==0) {\\n            return string(h, \\'H\\');\\n        }\\n        \\n        int c = combi(h+v-1,h-1);\\n        \\n        if(k>c) {\\n            return \\'V\\'+solve(h, v-1, k-c);\\n        } else {\\n            return \\'H\\'+solve(h-1, v, k);\\n        }\\n    }\\n    \\n    \\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        return solve(destination[1],destination[0],k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790385,
                "title": "python3-simple-recursive-approach-with-comments",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # Returns the Kth smallest string containing h H\\'s and v V\\'s.\\n        def recurse(h, v, k):\\n            # If k is 1, return the smallest lexicographical string.\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n            \\n            # The first character will be \\'V\\' if k exceed the number of\\n            # combinations starting with an \\'H\\'.\\n            hCombinations = comb(h + v - 1, v)\\n            if hCombinations < k:\\n                return \\'V\\' + recurse(h, v - 1, k - hCombinations)\\n            \\n\\t\\t\\t# If not, the next character will be an \\'H\\'.\\n            return \\'H\\' + recurse(h - 1, v, k)\\n        \\n        return recurse(destination[1], destination[0], k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # Returns the Kth smallest string containing h H\\'s and v V\\'s.\\n        def recurse(h, v, k):\\n            # If k is 1, return the smallest lexicographical string.\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n            \\n            # The first character will be \\'V\\' if k exceed the number of\\n            # combinations starting with an \\'H\\'.\\n            hCombinations = comb(h + v - 1, v)\\n            if hCombinations < k:\\n                return \\'V\\' + recurse(h, v - 1, k - hCombinations)\\n            \\n\\t\\t\\t# If not, the next character will be an \\'H\\'.\\n            return \\'H\\' + recurse(h - 1, v, k)\\n        \\n        return recurse(destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682554,
                "title": "eay-python-o-n-2",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.get all the combinations possible from every index\\n2.start from 0,0\\n3.check if the right index combination is less than or equal to our K,if yes ,move to right else move to left with k=k-right combo\\n4.repeat step 3 until u reach n-1,n-1 \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n**2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        x,y=destination\\n        arr=[[0 for i in range(y+1)] for j in range(x+1)]\\n        arr[x][y]=1\\n\\n        for i in range(x,-1,-1):\\n            for j in range(y,-1,-1):\\n                if i+1<=x:\\n                    arr[i][j]+=arr[i+1][j]\\n                if j+1<=y:\\n                    arr[i][j]+=arr[i][j+1]\\n       \\n        i,j=0,0\\n        r=\\'\\'\\n        for _ in range(x+y):\\n            if i<=x and j+1<=y and arr[i][j+1]>=k:\\n                r+=\\'H\\'\\n                j+=1\\n            else:\\n                r+=\\'V\\'\\n                k-=arr[i][j+1] if i<=x and j+1<=y else 0\\n                i+=1\\n        \\n        return r\\n                \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        x,y=destination\\n        arr=[[0 for i in range(y+1)] for j in range(x+1)]\\n        arr[x][y]=1\\n\\n        for i in range(x,-1,-1):\\n            for j in range(y,-1,-1):\\n                if i+1<=x:\\n                    arr[i][j]+=arr[i+1][j]\\n                if j+1<=y:\\n                    arr[i][j]+=arr[i][j+1]\\n       \\n        i,j=0,0\\n        r=\\'\\'\\n        for _ in range(x+y):\\n            if i<=x and j+1<=y and arr[i][j+1]>=k:\\n                r+=\\'H\\'\\n                j+=1\\n            else:\\n                r+=\\'V\\'\\n                k-=arr[i][j+1] if i<=x and j+1<=y else 0\\n                i+=1\\n        \\n        return r\\n                \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676330,
                "title": "python-with-only-one-combination-computation",
                "content": "Let\\'s start with the initial value `(v + h - 1) Combination (v)`\\n\\nWe know nCr is the number of positioning r `H` in n positions.\\nWhile decreasing n, if the combination got smaller than k, we can know the position of v.\\nDecreasing n can be done in `O(1)` using lastest combination computation.\\n\\nAfter finding the first position of `H`, by subtracting k by the \\'biggest combination less than k\\', which is the last combination, we can reuse same logic to the end.\\n\\nWhenever finding the position of `H`, we should decrease r. It can also be done in `O(1)` using latest combination computation.\\n\\n```\\nclass Combination:\\n    def __init__(self, n: int, r: int):\\n        self.n = n\\n        self.r = r\\n        self.val = math.comb(n, r)\\n        \\n    def reduce_r(self):\\n        if self.val:\\n            self.val = self.val * self.r // (self.n - self.r + 1)\\n        self.r -= 1\\n        \\n    def reduce_n(self):\\n        self.val = self.val * (self.n - self.r) // self.n\\n        self.n -= 1\\n\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        comb = Combination(destination[0] + destination[1] - 1, destination[0])\\n        \\n        arr = []\\n        \\n        while True:\\n            if comb.val < k:\\n                arr.append(\\'V\\')\\n                k -= comb.val\\n                comb.reduce_r()\\n                if comb.r == 0:\\n                    arr.extend(itertools.repeat(\\'H\\', destination[0] + destination[1] - len(arr)))\\n                    break\\n            else:\\n                arr.append(\\'H\\')\\n                    \\n            comb.reduce_n()\\n        \\n        return \\'\\'.join(arr)\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Combination:\\n    def __init__(self, n: int, r: int):\\n        self.n = n\\n        self.r = r\\n        self.val = math.comb(n, r)\\n        \\n    def reduce_r(self):\\n        if self.val:\\n            self.val = self.val * self.r // (self.n - self.r + 1)\\n        self.r -= 1\\n        \\n    def reduce_n(self):\\n        self.val = self.val * (self.n - self.r) // self.n\\n        self.n -= 1\\n\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        comb = Combination(destination[0] + destination[1] - 1, destination[0])\\n        \\n        arr = []\\n        \\n        while True:\\n            if comb.val < k:\\n                arr.append(\\'V\\')\\n                k -= comb.val\\n                comb.reduce_r()\\n                if comb.r == 0:\\n                    arr.extend(itertools.repeat(\\'H\\', destination[0] + destination[1] - len(arr)))\\n                    break\\n            else:\\n                arr.append(\\'H\\')\\n                    \\n            comb.reduce_n()\\n        \\n        return \\'\\'.join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650895,
                "title": "no-dp-required-simple-counting-problem-70-faster",
                "content": "Similar to [K-th Smallest in Lexicographical Order](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/)\\nDp is not required in this problem. You can just count to the required kth sequence.\\nFor current prefix count number of possible string with current prefix as the prefix. If rank of current prefix + nmuber of possible solutions are more than k then we need to append H which will half the possible number of strings and continue. If possibilitis are less then k then subtract the possibilities from k and switch up last element from H to V. If k becomes one then we extend the prefix to required string and return.\\n```\\nclass Solution {\\npublic:\\n    long long int count(string &s, int r, int c, int k){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        long long int num = 1;\\n        for(int i = r+c; i>max(r,c); i--){num *= i;}\\n        for(int i = min(r,c); i>=1; i--){num/=i;}\\n        return num;\\n    }\\n    string perp(string &s, int r , int c){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        for(int i = 0; i<c; i++)s += \"H\";\\n        for(int i = 0; i<r; i++)s += \"V\";\\n        return s;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int r = destination[0], c = destination[1];\\n        string pre = \"H\";\\n        while(k){\\n            if(k==1) return perp(pre, r,c);\\n            long long int  num = count(pre,r,c,k);\\n            if(num < k){\\n                k -=num;\\n                pre[pre.size()-1] = \\'V\\';\\n            }else{\\n                pre += \"H\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<c; i++)ans += \"H\";\\n        for(int i = 0; i<r; i++)ans += \"V\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int count(string &s, int r, int c, int k){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        long long int num = 1;\\n        for(int i = r+c; i>max(r,c); i--){num *= i;}\\n        for(int i = min(r,c); i>=1; i--){num/=i;}\\n        return num;\\n    }\\n    string perp(string &s, int r , int c){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        for(int i = 0; i<c; i++)s += \"H\";\\n        for(int i = 0; i<r; i++)s += \"V\";\\n        return s;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int r = destination[0], c = destination[1];\\n        string pre = \"H\";\\n        while(k){\\n            if(k==1) return perp(pre, r,c);\\n            long long int  num = count(pre,r,c,k);\\n            if(num < k){\\n                k -=num;\\n                pre[pre.size()-1] = \\'V\\';\\n            }else{\\n                pre += \"H\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<c; i++)ans += \"H\";\\n        for(int i = 0; i<r; i++)ans += \"V\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547391,
                "title": "python-combination-how-many-we-have-skipped-if-we-choose-v",
                "content": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # H > V\\n        # k start from 1\\n        # need destination[1] * H and destination[0] * V\\n        \\n        res = []\\n        k -= 1\\n        while k != 0:\\n            total = sum(destination) - 1\\n            H, V = destination[1] - 1, destination[0]\\n            # how many we have skipped if we choose V\\n            skipped = factorial(total) // (factorial(H) * factorial(V))\\n            if skipped <= k:\\n                k -= factorial(total) // (factorial(H) * factorial(V))\\n                res.append(\"V\")\\n                destination[0] -= 1\\n            else:\\n                res.append(\"H\")\\n                destination[1] -= 1\\n        \\n        res += [\"H\"] * destination[1]\\n        res += [\"V\"] * destination[0]\\n        return \"\".join(res)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # H > V\\n        # k start from 1\\n        # need destination[1] * H and destination[0] * V\\n        \\n        res = []\\n        k -= 1\\n        while k != 0:\\n            total = sum(destination) - 1\\n            H, V = destination[1] - 1, destination[0]\\n            # how many we have skipped if we choose V\\n            skipped = factorial(total) // (factorial(H) * factorial(V))\\n            if skipped <= k:\\n                k -= factorial(total) // (factorial(H) * factorial(V))\\n                res.append(\"V\")\\n                destination[0] -= 1\\n            else:\\n                res.append(\"H\")\\n                destination[1] -= 1\\n        \\n        res += [\"H\"] * destination[1]\\n        res += [\"V\"] * destination[0]\\n        return \"\".join(res)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544205,
                "title": "c-combinatorics",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fac[32];\\n    int mod=1000000007;\\n    void pre()\\n    {\\n        fac[0]=1;\\n        for(long long i=1;i<=30;++i)\\n        {\\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n    }\\n    long long power(long long a,int b)\\n    {\\n        if(b==0)return 1;\\n        long long p=power(a,b/2);\\n        p=(p*p)%mod;\\n        if(b&1)\\n        {\\n            p=(p*a)%mod;\\n        }\\n        return p;\\n    }\\n    long long modInverse(long long a)\\n    {\\n        return power(a,mod-2)%mod;\\n    }\\n    long long nCr(int n,int r)\\n    {\\n        if(n<r)return 0;\\n        if(r==0)return 1;\\n        \\n        return ((((fac[n]%mod)*(modInverse(fac[r]%mod)%mod))%mod)*(modInverse(fac[n-r]%mod)%mod))%mod;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        pre();\\n        int h=destination[0],w=destination[1];\\n        string res=\"\";\\n        while(h>0&&w>0)\\n        {\\n            long long pos=nCr(h+w-1,w-1);\\n            //cout<<pos<<\" \";\\n            if(pos<k)\\n            {\\n                k-=pos;\\n                res.push_back(\\'V\\');\\n                h--;\\n            }\\n            else\\n            {\\n                res.push_back(\\'H\\');\\n                w--;\\n            }\\n        }\\n        while(h>0)\\n        {\\n            res.push_back(\\'V\\');\\n            h--;\\n        }\\n        while(w>0)\\n        {\\n            res.push_back(\\'H\\');\\n            w--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fac[32];\\n    int mod=1000000007;\\n    void pre()\\n    {\\n        fac[0]=1;\\n        for(long long i=1;i<=30;++i)\\n        {\\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n    }\\n    long long power(long long a,int b)\\n    {\\n        if(b==0)return 1;\\n        long long p=power(a,b/2);\\n        p=(p*p)%mod;\\n        if(b&1)\\n        {\\n            p=(p*a)%mod;\\n        }\\n        return p;\\n    }\\n    long long modInverse(long long a)\\n    {\\n        return power(a,mod-2)%mod;\\n    }\\n    long long nCr(int n,int r)\\n    {\\n        if(n<r)return 0;\\n        if(r==0)return 1;\\n        \\n        return ((((fac[n]%mod)*(modInverse(fac[r]%mod)%mod))%mod)*(modInverse(fac[n-r]%mod)%mod))%mod;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        pre();\\n        int h=destination[0],w=destination[1];\\n        string res=\"\";\\n        while(h>0&&w>0)\\n        {\\n            long long pos=nCr(h+w-1,w-1);\\n            //cout<<pos<<\" \";\\n            if(pos<k)\\n            {\\n                k-=pos;\\n                res.push_back(\\'V\\');\\n                h--;\\n            }\\n            else\\n            {\\n                res.push_back(\\'H\\');\\n                w--;\\n            }\\n        }\\n        while(h>0)\\n        {\\n            res.push_back(\\'V\\');\\n            h--;\\n        }\\n        while(w>0)\\n        {\\n            res.push_back(\\'H\\');\\n            w--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2540479,
                "title": "70-faster-simple-greedy-solution",
                "content": "```\\nclass Solution {\\n    int ncr(int n,int r){\\n        long long int nom=1;\\n        long long int den=1;\\n        \\n        for(int i=r;i>0;i--){\\n            int newNom=n-(r-i);\\n            int newDen=i;\\n            \\n            nom*=newNom;\\n            den*=newDen;\\n        }\\n        \\n        return nom/den;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int zero=destination[1];\\n        int ones=destination[0];\\n        string ans=\"\";\\n        int tot=zero+ones;\\n        int len=tot;\\n        for(int i=0;i<len;i++){\\n           // can i place a  zero \\n            if(zero>0 && ones>0){\\n                int can = ncr(tot-1,zero-1);\\n                if(can>=k){\\n                    ans+=\\'H\\';\\n                    zero--;\\n                }\\n                else{\\n                    k-=can;\\n                    ans+=\\'V\\';\\n                    ones--;\\n                }\\n                \\n            }\\n            else if(zero==0) {\\n                ans+=\\'V\\';\\n                ones--;\\n            }\\n            else if(ones==0){\\n                ans+=\\'H\\';\\n                zero--;\\n            }\\n            \\n            tot--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ncr(int n,int r){\\n        long long int nom=1;\\n        long long int den=1;\\n        \\n        for(int i=r;i>0;i--){\\n            int newNom=n-(r-i);\\n            int newDen=i;\\n            \\n            nom*=newNom;\\n            den*=newDen;\\n        }\\n        \\n        return nom/den;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int zero=destination[1];\\n        int ones=destination[0];\\n        string ans=\"\";\\n        int tot=zero+ones;\\n        int len=tot;\\n        for(int i=0;i<len;i++){\\n           // can i place a  zero \\n            if(zero>0 && ones>0){\\n                int can = ncr(tot-1,zero-1);\\n                if(can>=k){\\n                    ans+=\\'H\\';\\n                    zero--;\\n                }\\n                else{\\n                    k-=can;\\n                    ans+=\\'V\\';\\n                    ones--;\\n                }\\n                \\n            }\\n            else if(zero==0) {\\n                ans+=\\'V\\';\\n                ones--;\\n            }\\n            else if(ones==0){\\n                ans+=\\'H\\';\\n                zero--;\\n            }\\n            \\n            tot--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531153,
                "title": "python-combinations-and-dp",
                "content": "Build string from left to right using combinations.\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        Vs = destination[0]\\n        Hs = destination[1]\\n        pathLengthLeft = Vs + Hs\\n        path = []\\n        \\n        # Calculating factorials takes time, so I cache the results from math.factorial\\n        factCache = {0: 1}\\n\\n        def cFactorial(n):\\n            if n not in factCache:\\n                factCache[n] = math.factorial(n)\\n            return factCache[n]\\n        \\n        # Pick k from n or return 0 for \"not possible\"\\n        def combinations(n, k):\\n            if n-k < 0:\\n                return 0\\n            return cFactorial(n) // (cFactorial(k) * cFactorial(n-k))\\n            \\n        # Build string from left to right.\\n        # If k is greater than the number of ways to place the V\\'s in a string\\n        # that\\'s one space shorter then the leftmost space must be a V, else it\\'s a H.\\n        # This gives us lexagraphical ordering.\\n        #\\n        # Reduce the pathLength by 1, and remove the V or H you just used, then repeat the above.\\n        while Vs or Hs:\\n            combinationsForSubString = combinations(pathLengthLeft-1, Vs)\\n            if k > combinationsForSubString:\\n                k -= combinationsForSubString\\n                path.append(\\'V\\')\\n                Vs -= 1\\n            else:\\n                path.append(\\'H\\')\\n                Hs -= 1\\n            pathLengthLeft -= 1\\n        return \\'\\'.join(path)\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        Vs = destination[0]\\n        Hs = destination[1]\\n        pathLengthLeft = Vs + Hs\\n        path = []\\n        \\n        # Calculating factorials takes time, so I cache the results from math.factorial\\n        factCache = {0: 1}",
                "codeTag": "Java"
            },
            {
                "id": 2515176,
                "title": "c-soln-using-combination-of-similar-objects",
                "content": "```\\nclass Solution {\\npublic:\\n    int nCr(int n, int r){\\n        if(r > n - r) r = n - r;\\n        long long ans = 1;\\n        int i;\\n        for(i = 1; i <= r; i++) {\\n            ans *= (n - r + i);\\n            ans /= i;\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int h=destination[1],v=destination[0];\\n        long long n=0;\\n        string ans=\"\";\\n        while(h && v){\\n            int x=nCr(h+v-1,h-1);\\n            if(x+n<k){\\n                v--;\\n                n+=x;\\n                ans.push_back(\\'V\\');\\n            }\\n            else{\\n                h--;\\n                ans.push_back(\\'H\\');\\n            }\\n        }\\n        if(v){\\n            for(int i=0;i<v;i++)    ans.push_back(\\'V\\');\\n        }\\n        if(h){\\n            for(int i=0;i<h;i++)    ans.push_back(\\'H\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nCr(int n, int r){\\n        if(r > n - r) r = n - r;\\n        long long ans = 1;\\n        int i;\\n        for(i = 1; i <= r; i++) {\\n            ans *= (n - r + i);\\n            ans /= i;\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int h=destination[1],v=destination[0];\\n        long long n=0;\\n        string ans=\"\";\\n        while(h && v){\\n            int x=nCr(h+v-1,h-1);\\n            if(x+n<k){\\n                v--;\\n                n+=x;\\n                ans.push_back(\\'V\\');\\n            }\\n            else{\\n                h--;\\n                ans.push_back(\\'H\\');\\n            }\\n        }\\n        if(v){\\n            for(int i=0;i<v;i++)    ans.push_back(\\'V\\');\\n        }\\n        if(h){\\n            for(int i=0;i<h;i++)    ans.push_back(\\'H\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303536,
                "title": "c-rust-recursive-combination",
                "content": "**C++ Code**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint comb(int n, int r){\\n\\t\\t\\tif(r>n)return 0;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=1;i<=r;i++)res=res*(n-i+1)/i;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tstring kthSmallestPath(vector<int>& destination, int k) {\\n\\t\\t\\tint V=destination[0];        \\n\\t\\t\\tint H=destination[1];\\n\\t\\t\\tif(V==0 || H==0 || k==1){\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<H;i++)s.push_back(\\'H\\');            \\n\\t\\t\\t\\tfor(int i=0;i<V;i++)s.push_back(\\'V\\');\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t\\tint count = comb(V+H-1,V);\\n\\t\\t\\tif (count >= k) {\\n\\t\\t\\t\\tdestination[1]-=1;\\n\\t\\t\\t\\treturn \"H\" + kthSmallestPath(destination,k);\\n\\t\\t\\t}\\n\\t\\t\\tdestination[0]-=1;\\n\\t\\t\\treturn \"V\" + kthSmallestPath(destination,k-count);\\n\\t\\t}\\n\\t};\\n\\n**Rust Code**\\n\\n\\timpl Solution {\\n\\t\\tfn comb(n: i32, r: i32) -> i32 {\\n\\t\\t\\tif r>n{return 0;}\\n\\t\\t\\t(1..=r).fold(1, |acc, i| acc*(n-i+1)/i)\\n\\t\\t}\\n\\t\\tpub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n\\t\\t\\tlet (V,H) = (destination[0], destination[1]);\\n\\t\\t\\tif V==0 || H==0 || k==1 {\\n\\t\\t\\t\\tlet mut s = String::with_capacity((H+V)as usize);\\n\\t\\t\\t\\tfor _  in 0..H {s.push(\\'H\\')};\\n\\t\\t\\t\\tfor _  in 0..V {s.push(\\'V\\')};\\n\\t\\t\\t\\treturn s\\n\\t\\t\\t}\\n\\t\\t\\tlet count = Self::comb(V+H-1, V);\\n\\t\\t\\tif k<= count {\\n\\t\\t\\t\\tlet destination: Vec<i32> = vec![V,H-1];\\n\\t\\t\\t\\treturn \"H\".to_string() + Self::kth_smallest_path(destination, k).as_str();\\n\\t\\t\\t}\\n\\t\\t\\tlet destination: Vec<i32> = vec![V-1,H];\\n\\t\\t\\t\"V\".to_string() + Self::kth_smallest_path(destination, k - count).as_str()\\n\\t\\t}\\n\\t}\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Rust"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint comb(int n, int r){\\n\\t\\t\\tif(r>n)return 0;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=1;i<=r;i++)res=res*(n-i+1)/i;\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2298988,
                "title": "easy-basic-maths-python-solution-faster-than-90",
                "content": "\\tclass Solution:\\n\\t\\tdef kthSmallestPath(self, dest: List[int], k: int) -> str:\\n\\t\\t\\tn = sum(dest)\\n\\t\\t\\tfact = [1]\\n\\t\\t\\tcurr = \"\"\\n\\t\\t\\tfor i in range(1, 31):\\n\\t\\t\\t\\tfact.append(i*fact[i-1])\\n\\t\\t\\ti = 1\\n\\t\\t\\twhile i <= n:\\n\\t\\t\\t\\tln = n-i\\n\\t\\t\\t\\tf1 = fact[ln]\\n\\t\\t\\t\\th = fact[dest[1]-1]\\n\\t\\t\\t\\tv = fact[dest[0]]\\n\\t\\t\\t\\tval = f1//(v*h)\\n\\t\\t\\t\\tif val >= k:\\n\\t\\t\\t\\t\\tdest[1] -= 1\\n\\t\\t\\t\\t\\tcurr = curr + \"H\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk = k - val\\n\\t\\t\\t\\t\\tcurr = curr + \"V\"\\n\\t\\t\\t\\t\\tdest[0] -= 1\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn curr\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kthSmallestPath(self, dest: List[int], k: int) -> str:\\n\\t\\t\\tn = sum(dest)\\n\\t\\t\\tfact = [1]\\n\\t\\t\\tcurr = \"\"\\n\\t\\t\\tfor i in range(1, 31):\\n\\t\\t\\t\\tfact.append(i*fact[i-1])\\n\\t\\t\\ti = 1\\n\\t\\t\\twhile i <= n:\\n\\t\\t\\t\\tln = n-i\\n\\t\\t\\t\\tf1 = fact[ln]\\n\\t\\t\\t\\th = fact[dest[1]-1]\\n\\t\\t\\t\\tv = fact[dest[0]]\\n\\t\\t\\t\\tval = f1//(v*h)\\n\\t\\t\\t\\tif val >= k:\\n\\t\\t\\t\\t\\tdest[1] -= 1\\n\\t\\t\\t\\t\\tcurr = curr + \"H\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk = k - val\\n\\t\\t\\t\\t\\tcurr = curr + \"V\"\\n\\t\\t\\t\\t\\tdest[0] -= 1\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn curr\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2284034,
                "title": "c-solution-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        long long dp[101][101];\\n        int r = d[0], c = d[1];\\n        for(int i = r; i >= 0; i--) {\\n            for(int j = c; j >= 0; j--) {\\n                if(i == r and j == c) dp[i][j] = 1;\\n                else dp[i][j] = (i+1 <= r?dp[i+1][j]:0)+(j+1 <= c?dp[i][j+1]:0);\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        long long t = k;\\n        string s;\\n        while(!(i == r and j == c)) {\\n            if(j+1 <= c and dp[i][j+1] >= t) s += \\'H\\', j++;\\n            else s += \\'V\\',  t -= ((j+1 <= c)? dp[i][j+1]:0), i++;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        long long dp[101][101];\\n        int r = d[0], c = d[1];\\n        for(int i = r; i >= 0; i--) {\\n            for(int j = c; j >= 0; j--) {\\n                if(i == r and j == c) dp[i][j] = 1;\\n                else dp[i][j] = (i+1 <= r?dp[i+1][j]:0)+(j+1 <= c?dp[i][j+1]:0);\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        long long t = k;\\n        string s;\\n        while(!(i == r and j == c)) {\\n            if(j+1 <= c and dp[i][j+1] >= t) s += \\'H\\', j++;\\n            else s += \\'V\\',  t -= ((j+1 <= c)? dp[i][j+1]:0), i++;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264515,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public String kthSmallestPath(int[] destination, int k) {\\n        \\n        int m = destination[0];\\n        int n = destination[1];\\n        \\n        int dp[][] = new int[m+1][n+1];\\n        //first we need to figer out how many possible way\\'s are there to reach the destination\\n        for(int i = m; i >= 0; i--)\\n        {\\n            for(int j = n; j >= 0 ; j--)\\n            {\\n                if(i == m && j == n ) dp[i][j] = 1;\\n                else if( i == m) dp[i][j] = dp[i][j+1];\\n                else if(j == n) dp[i][j] = dp[i+1][j];\\n                else dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //now one thing we have to note here that\\n        // k = 1 then there is fixed path\\n        //k = 2 then H(right direction) will reduce\\n        // k = destination then start with v\\n        //so why not we move such a way\\n        helper(0, 0, k, sb, dp);\\n        return sb.toString();\\n        \\n    }\\n    \\n    //In helper funtion what we are doing we just travelling according to dp see below\\n    public void helper(int i, int j, int k, StringBuilder sb, int dp[][]){\\n        \\n        \\n        //if we reach to the last row then we have only one option go to right\\n        if(i == dp.length-1){\\n            while(++j < dp[0].length) sb.append(\"H\");\\n            return;\\n        }\\n        //if we reach last column then we have only one direction go to down\\n        if(j == dp[0].length-1){\\n            while(++i < dp.length) sb.append(\"V\");\\n            return;\\n        }\\n        \\n        //In dp we have store that this i and j how many possible ways we can reach to destination\\n        //so we are checking like\\n        //if k is smaller then have come wrong place(down[V]) so we have to move right\\n        if(k <= dp[i][j+1]){\\n            sb.append(\"H\");\\n            helper(i, j+1, k, sb, dp);\\n        }else{\\n            //if our k is greater then we reach to specific index now we have to move down only to\\n            //reach the destination\\n            sb.append(\"V\");\\n            helper(i+1, j,k - dp[i][j+1], sb, dp);\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n   \\n}\\n```\\nI have seen this solution on discussion section just get to know and try to simplify here!!",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String kthSmallestPath(int[] destination, int k) {\\n        \\n        int m = destination[0];\\n        int n = destination[1];\\n        \\n        int dp[][] = new int[m+1][n+1];\\n        //first we need to figer out how many possible way\\'s are there to reach the destination\\n        for(int i = m; i >= 0; i--)\\n        {\\n            for(int j = n; j >= 0 ; j--)\\n            {\\n                if(i == m && j == n ) dp[i][j] = 1;\\n                else if( i == m) dp[i][j] = dp[i][j+1];\\n                else if(j == n) dp[i][j] = dp[i+1][j];\\n                else dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //now one thing we have to note here that\\n        // k = 1 then there is fixed path\\n        //k = 2 then H(right direction) will reduce\\n        // k = destination then start with v\\n        //so why not we move such a way\\n        helper(0, 0, k, sb, dp);\\n        return sb.toString();\\n        \\n    }\\n    \\n    //In helper funtion what we are doing we just travelling according to dp see below\\n    public void helper(int i, int j, int k, StringBuilder sb, int dp[][]){\\n        \\n        \\n        //if we reach to the last row then we have only one option go to right\\n        if(i == dp.length-1){\\n            while(++j < dp[0].length) sb.append(\"H\");\\n            return;\\n        }\\n        //if we reach last column then we have only one direction go to down\\n        if(j == dp[0].length-1){\\n            while(++i < dp.length) sb.append(\"V\");\\n            return;\\n        }\\n        \\n        //In dp we have store that this i and j how many possible ways we can reach to destination\\n        //so we are checking like\\n        //if k is smaller then have come wrong place(down[V]) so we have to move right\\n        if(k <= dp[i][j+1]){\\n            sb.append(\"H\");\\n            helper(i, j+1, k, sb, dp);\\n        }else{\\n            //if our k is greater then we reach to specific index now we have to move down only to\\n            //reach the destination\\n            sb.append(\"V\");\\n            helper(i+1, j,k - dp[i][j+1], sb, dp);\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163787,
                "title": "c-o-r-log-c-greedy-with-binary-search-beats-100-time-and-90-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //precomputed binomial coefficient table for O(1) lookups, this isn\\'t necessary if your language has a built in function for this\\n    static constexpr int pascals[30][16] = {\\n    {1},\\n    {1,1},\\n    {1,2,1},\\n    {1,3,3,1},\\n    {1,4,6,4,1},\\n    {1,5,10,10,5,1},\\n    {1,6,15,20,15,6,1},\\n    {1,7,21,35,35,21,7,1},\\n    {1,8,28,56,70,56,28,8,1},\\n    {1,9,36,84,126,126,84,36,9,1},\\n    {1,10,45,120,210,252,210,120,45,10,1},\\n    {1,11,55,165,330,462,462,330,165,55,11,1},\\n    {1,12,66,220,495,792,924,792,495,220,66,12,1},\\n    {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1},\\n    {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1},\\n    {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1},\\n    {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16},\\n    {1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136},\\n    {1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816},\\n    {1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876},\\n    {1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504},\\n    {1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264},\\n    {1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544},\\n    {1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314},\\n    {1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504},\\n    {1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760},\\n    {1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160},\\n    {1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860},\\n    {1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160},\\n    {1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760}};\\n    \\n    //since we\\'re dealing with lexicographically smallest string, index in this context will refer to the index when reading the string from right to left\\n    void binary_recurse(string &s, int n, int k, int previous){\\n        //if there are no more \\'V\\'s to place we\\'re done\\n        if (n == 0){\\n            return;\\n        }\\n        //there are n more \\'V\\'s left to place, so our lower bound will always start at n rather than at 0\\n        int lower = n;\\n        int upper = previous;\\n        //binary search over solution space for the index of the next \\'V\\' in the output\\n        while (lower < upper){\\n            int mid = (upper + lower)/2;\\n            //the number of paths that include all prior \\'V\\'s and a \\'V\\' at index mid \\n            int test = (pascals[mid][n-1] * (mid + 1 - n)) / n;\\n            if (test >= k){\\n                upper = mid;\\n            }\\n            else{\\n                lower = mid + 1;\\n            }\\n        }\\n        s[s.size() - upper] = \\'V\\';\\n        binary_recurse(s,n-1,k - (pascals[upper - 1][n-1] * (upper - n)) / n,upper);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0];\\n        int m = destination[1];\\n        string output = string(n+m,\\'H\\');\\n        binary_recurse(output,n,k,n + m);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //precomputed binomial coefficient table for O(1) lookups, this isn\\'t necessary if your language has a built in function for this\\n    static constexpr int pascals[30][16] = {\\n    {1},\\n    {1,1},\\n    {1,2,1},\\n    {1,3,3,1},\\n    {1,4,6,4,1},\\n    {1,5,10,10,5,1},\\n    {1,6,15,20,15,6,1},\\n    {1,7,21,35,35,21,7,1},\\n    {1,8,28,56,70,56,28,8,1},\\n    {1,9,36,84,126,126,84,36,9,1},\\n    {1,10,45,120,210,252,210,120,45,10,1},\\n    {1,11,55,165,330,462,462,330,165,55,11,1},\\n    {1,12,66,220,495,792,924,792,495,220,66,12,1},\\n    {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1},\\n    {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1},\\n    {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1},\\n    {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16},\\n    {1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136},\\n    {1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816},\\n    {1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876},\\n    {1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504},\\n    {1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264},\\n    {1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544},\\n    {1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314},\\n    {1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504},\\n    {1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760},\\n    {1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160},\\n    {1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860},\\n    {1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160},\\n    {1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760}};\\n    \\n    //since we\\'re dealing with lexicographically smallest string, index in this context will refer to the index when reading the string from right to left\\n    void binary_recurse(string &s, int n, int k, int previous){\\n        //if there are no more \\'V\\'s to place we\\'re done\\n        if (n == 0){\\n            return;\\n        }\\n        //there are n more \\'V\\'s left to place, so our lower bound will always start at n rather than at 0\\n        int lower = n;\\n        int upper = previous;\\n        //binary search over solution space for the index of the next \\'V\\' in the output\\n        while (lower < upper){\\n            int mid = (upper + lower)/2;\\n            //the number of paths that include all prior \\'V\\'s and a \\'V\\' at index mid \\n            int test = (pascals[mid][n-1] * (mid + 1 - n)) / n;\\n            if (test >= k){\\n                upper = mid;\\n            }\\n            else{\\n                lower = mid + 1;\\n            }\\n        }\\n        s[s.size() - upper] = \\'V\\';\\n        binary_recurse(s,n-1,k - (pascals[upper - 1][n-1] * (upper - n)) / n,upper);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0];\\n        int m = destination[1];\\n        string output = string(n+m,\\'H\\');\\n        binary_recurse(output,n,k,n + m);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109504,
                "title": "o-r-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll get(ll h,ll v)\\n    {\\n        ll ans=1,j=2,k=2;\\n        for(int i=h+v;i>=1;i--)\\n        {\\n            ans*=i;\\n            while(j<=h && ans%j==0) ans/=j,j++;\\n            while(k<=v && ans%k==0) ans/=k,k++;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& a, int k) \\n    {\\n        int v=a[0],h=a[1];\\n        string ans=\"\";\\n        for(int i=0;i<a[0]+a[1];i++)\\n        {\\n            ll c=get(h-1,v);\\n            if(c>=k && h) ans+=\\'H\\',h--;\\n            else  ans+=\\'V\\',v--,k-=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll get(ll h,ll v)\\n    {\\n        ll ans=1,j=2,k=2;\\n        for(int i=h+v;i>=1;i--)\\n        {\\n            ans*=i;\\n            while(j<=h && ans%j==0) ans/=j,j++;\\n            while(k<=v && ans%k==0) ans/=k,k++;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& a, int k) \\n    {\\n        int v=a[0],h=a[1];\\n        string ans=\"\";\\n        for(int i=0;i<a[0]+a[1];i++)\\n        {\\n            ll c=get(h-1,v);\\n            if(c>=k && h) ans+=\\'H\\',h--;\\n            else  ans+=\\'V\\',v--,k-=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105763,
                "title": "cpp-dynamic-programmming-pascal-triangle-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int pascalTri[31][32] = {};\\n        \\n    void presolve(){\\n        pascalTri[0][0] = pascalTri[1][0] = pascalTri[1][1] = 1;\\n        for(int i=2;i<31;i++){\\n            pascalTri[i][0] = 1;\\n            for(int j=1;j<=i;j++){\\n                pascalTri[i][j] = pascalTri[i-1][j] + pascalTri[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    string ans = \"\";\\n    \\n    void find(int numh, int numv, int k){\\n        if(numh + numv == 0) return;\\n        \\n        long long int tempk = pascalTri[numh + numv - 1][max(numh - 1, numv)];\\n        \\n        if(tempk >= k){\\n            ans.push_back(\\'H\\');\\n            find(numh - 1, numv, k);\\n        }\\n        else{\\n            k -= tempk;\\n            ans.push_back(\\'V\\');\\n            find(numh, numv - 1, k);\\n        }\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        presolve();\\n        int numH = destination[1];\\n        int numV = destination[0];\\n        \\n        find(numH, numV, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int pascalTri[31][32] = {};\\n        \\n    void presolve(){\\n        pascalTri[0][0] = pascalTri[1][0] = pascalTri[1][1] = 1;\\n        for(int i=2;i<31;i++){\\n            pascalTri[i][0] = 1;\\n            for(int j=1;j<=i;j++){\\n                pascalTri[i][j] = pascalTri[i-1][j] + pascalTri[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    string ans = \"\";\\n    \\n    void find(int numh, int numv, int k){\\n        if(numh + numv == 0) return;\\n        \\n        long long int tempk = pascalTri[numh + numv - 1][max(numh - 1, numv)];\\n        \\n        if(tempk >= k){\\n            ans.push_back(\\'H\\');\\n            find(numh - 1, numv, k);\\n        }\\n        else{\\n            k -= tempk;\\n            ans.push_back(\\'V\\');\\n            find(numh, numv - 1, k);\\n        }\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        presolve();\\n        int numH = destination[1];\\n        int numV = destination[0];\\n        \\n        find(numH, numV, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083572,
                "title": "go-beats-100",
                "content": "This is a go implementation based on suggested solutions from dicussion. The two solutions I came up were exceeding time limit. \\n\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tdx, dy := destination[0], destination[1]\\n\\n\\tm := make([][]int, dx+1)\\n\\tfor i := 0; i < dx+1; i++ {\\n\\t\\tm[i] = make([]int, dy+1)\\n\\t}\\n\\n\\tfor i := 0; i <= dx; i++ {\\n\\t\\tfor j := 0; j <= dy; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tm[i][j] = 1\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1]\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i-1][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1] + m[i-1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult := \"\"\\n\\n\\tfor dx > 0 && dy > 0 {\\n \\t\\tif m[dx][dy-1] >= k {\\n\\t\\t\\tdy--\\n\\t\\t\\tresult += \"H\"\\n\\t\\t} else {\\n\\t\\t\\tk -= m[dx][dy-1]\\n\\t\\t\\tdx--\\n\\t\\t\\tresult += \"V\"\\n\\t\\t}\\n\\t}\\n\\n\\tfor dx > 0 {\\n\\t\\tdx--\\n\\t\\tresult += \"V\"\\n\\t}\\n\\tfor dy > 0 {\\n\\t\\tdy--\\n\\t\\tresult += \"H\"\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tdx, dy := destination[0], destination[1]\\n\\n\\tm := make([][]int, dx+1)\\n\\tfor i := 0; i < dx+1; i++ {\\n\\t\\tm[i] = make([]int, dy+1)\\n\\t}\\n\\n\\tfor i := 0; i <= dx; i++ {\\n\\t\\tfor j := 0; j <= dy; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tm[i][j] = 1\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1]\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i-1][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1] + m[i-1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult := \"\"\\n\\n\\tfor dx > 0 && dy > 0 {\\n \\t\\tif m[dx][dy-1] >= k {\\n\\t\\t\\tdy--\\n\\t\\t\\tresult += \"H\"\\n\\t\\t} else {\\n\\t\\t\\tk -= m[dx][dy-1]\\n\\t\\t\\tdx--\\n\\t\\t\\tresult += \"V\"\\n\\t\\t}\\n\\t}\\n\\n\\tfor dx > 0 {\\n\\t\\tdx--\\n\\t\\tresult += \"V\"\\n\\t}\\n\\tfor dy > 0 {\\n\\t\\tdy--\\n\\t\\tresult += \"H\"\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006845,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // number of combinations\\n                if (k <= c) s.push_back(\\'H\\'), h--; // pick H as k in within range\\n                else s.push_back(\\'V\\'), v--, k -= c; // otherwise pick V\\n            } else s.push_back(\\'V\\');\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "class Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1965604,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        result=[]\\n        r=destination[0]\\n        c=destination[1]\\n        down=r\\n        for i in range(r+c):\\n            total=r+c-(i+1)\\n            step=comb(total,down)\\n            if step>=k:\\n                result.append(\\'H\\')\\n            else:\\n                down-=1\\n                result.append(\\'V\\')\\n                k-=step\\n        return \\'\\'.join(result)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        result=[]\\n        r=destination[0]\\n        c=destination[1]\\n        down=r\\n        for i in range(r+c):\\n            total=r+c-(i+1)\\n            step=comb(total,down)\\n            if step>=k:\\n                result.append(\\'H\\')\\n            else:\\n                down-=1\\n                result.append(\\'V\\')\\n                k-=step\\n        return \\'\\'.join(result)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906056,
                "title": "10-lines-simpe-recursion-solution-python",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        vcnt,hcnt = destination\\n        if k==1 or vcnt==0 or hcnt==0:\\n            return \"\".join([\"H\"]*hcnt+[\"V\"]*vcnt)\\n        smallerCnt = math.comb(hcnt+vcnt-1,vcnt)\\n        if smallerCnt>=k:\\n            return \"H\"+self.kthSmallestPath([vcnt,hcnt-1],k)\\n        return \"V\"+self.kthSmallestPath([vcnt-1,hcnt],k-smallerCnt)\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        vcnt,hcnt = destination\\n        if k==1 or vcnt==0 or hcnt==0:\\n            return \"\".join([\"H\"]*hcnt+[\"V\"]*vcnt)\\n        smallerCnt = math.comb(hcnt+vcnt-1,vcnt)\\n        if smallerCnt>=k:\\n            return \"H\"+self.kthSmallestPath([vcnt,hcnt-1],k)\\n        return \"V\"+self.kthSmallestPath([vcnt-1,hcnt],k-smallerCnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882587,
                "title": "python-narrowing-down-search-simple-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        row, col = destination\\n        currow, curcol = 0, 0\\n        res = []\\n        while curcol < col and currow < row:\\n            cnt = comb(row-currow+col-curcol-1, row-currow)\\n            if cnt >= k:\\n                curcol += 1\\n                res.append(\"H\")\\n            else:\\n                currow += 1\\n                k -= cnt\\n                res.append(\"V\")\\n        res.extend([\"H\"]*(col-curcol))\\n        res.extend([\"V\"]*(row-currow))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        row, col = destination\\n        currow, curcol = 0, 0\\n        res = []\\n        while curcol < col and currow < row:\\n            cnt = comb(row-currow+col-curcol-1, row-currow)\\n            if cnt >= k:\\n                curcol += 1\\n                res.append(\"H\")\\n            else:\\n                currow += 1\\n                k -= cnt\\n                res.append(\"V\")\\n        res.extend([\"H\"]*(col-curcol))\\n        res.extend([\"V\"]*(row-currow))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817760,
                "title": "c",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Kth Smallest Instructions.\\nMemory Usage: 15.4 MB, less than 55.15% of C++ online submissions for Kth Smallest Instructions.\\n\\nI think we should change to  int cnt[16][16]; \\n\\n```\\nclass Solution {\\npublic:\\n\\n    string res;\\n    int cnt[16][16];\\n    string kthSmallestPath(vector<int>& des, int k) {\\n          int m=des[0]+1,n=des[1]+1; //1-indexed\\n          //dp\\n          //ask: destination is null?  \\n          //ask: k is always greater than 0?\\n          //ask: destination contains only x1, y1? destination.length == 2\\n          //ask: destination is always valid? or could be (0,0)?\\n          //ask: is the maze a matrix? how about [[2,3][2]]\\n          //H come before V \\n          for(int x = m-1; x>=0; x--){\\n              for(int y = n-1; y>=0; y--){\\n                  if(x==m-1 || y==n-1){\\n                      cnt[x][y] = 1; \\n                      continue;\\n                  }\\n                  cnt[x][y] = cnt[x][y+1] + cnt[x+1][y];\\n              }\\n          }\\n          int i = 0, j = 0;\\n          while(i<m-1 && j<n-1){\\n              if(k<=cnt[i][j+1]){\\n                  res+=\"H\";j++;\\n              }else{\\n                  k=k-cnt[i][j+1];\\n                  res+=\"V\";i++;\\n              }\\n          }\\n        \\n          while(j++<n-1) res+=\"H\";\\n          while(i++<m-1) res+=\"V\";\\n          \\n              \\n         return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string res;\\n    int cnt[16][16];\\n    string kthSmallestPath(vector<int>& des, int k) {\\n          int m=des[0]+1,n=des[1]+1; //1-indexed\\n          //dp\\n          //ask: destination is null?  \\n          //ask: k is always greater than 0?\\n          //ask: destination contains only x1, y1? destination.length == 2\\n          //ask: destination is always valid? or could be (0,0)?\\n          //ask: is the maze a matrix? how about [[2,3][2]]\\n          //H come before V \\n          for(int x = m-1; x>=0; x--){\\n              for(int y = n-1; y>=0; y--){\\n                  if(x==m-1 || y==n-1){\\n                      cnt[x][y] = 1; \\n                      continue;\\n                  }\\n                  cnt[x][y] = cnt[x][y+1] + cnt[x+1][y];\\n              }\\n          }\\n          int i = 0, j = 0;\\n          while(i<m-1 && j<n-1){\\n              if(k<=cnt[i][j+1]){\\n                  res+=\"H\";j++;\\n              }else{\\n                  k=k-cnt[i][j+1];\\n                  res+=\"V\";i++;\\n              }\\n          }\\n        \\n          while(j++<n-1) res+=\"H\";\\n          while(i++<m-1) res+=\"V\";\\n          \\n              \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779475,
                "title": "python-o-m-n-min-m-n-solution-with-explanation-beats-100",
                "content": "We just choose chars one by one.\\nSay there are c_h \\'H\\' and c_v \\'V\\' could be chose, and the rank is k-th (0-index).\\nObviously the length of string is c_h + c_v.\\nThen which one should we choose?\\nIf there is not any \\'H\\' could be chose, we just select \\'V\\', and decrement c_v by 1.\\nIf there are still some \\'H\\', we just calculate the ways of the string with leading \\'H\\' cnt = nCr(c_h + c_v - 1, c_v), which means choos c_v locations from c_h + c_v - 1 positions to locate \\'V\\'.\\nIf k < cnt, then the char must be \\'H\\', decreament c_h by 1;\\notherwise, the char must be \\'V\\', and the rank will be k - cnt, decreament c_v by 1.\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def select(m, n):\\n            n = min(n, m - n)\\n            den, num = 1, 1\\n            for t in range(n):\\n                num *= m - t\\n                den *= n - t\\n            return num // den\\n\\n        cnt_v, cnt_h = destination\\n        size = cnt_v + cnt_h\\n        k -= 1\\n        ans = []\\n        for i in range(size):\\n            if cnt_h == 0:\\n                ans.append(\\'V\\')\\n                cnt_v -= 1\\n            else:\\n                cnt = select(size - i - 1, cnt_v)\\n                if k < cnt:\\n                    ans.append(\\'H\\')\\n                    cnt_h -= 1\\n                else:\\n                    ans.append(\\'V\\')\\n                    cnt_v -= 1\\n                    k -= cnt\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def select(m, n):\\n            n = min(n, m - n)\\n            den, num = 1, 1\\n            for t in range(n):\\n                num *= m - t\\n                den *= n - t\\n            return num // den\\n\\n        cnt_v, cnt_h = destination\\n        size = cnt_v + cnt_h\\n        k -= 1\\n        ans = []\\n        for i in range(size):\\n            if cnt_h == 0:\\n                ans.append(\\'V\\')\\n                cnt_v -= 1\\n            else:\\n                cnt = select(size - i - 1, cnt_v)\\n                if k < cnt:\\n                    ans.append(\\'H\\')\\n                    cnt_h -= 1\\n                else:\\n                    ans.append(\\'V\\')\\n                    cnt_v -= 1\\n                    k -= cnt\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748036,
                "title": "python-no-dp-no-recursion-no-comb-only-loops",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n      h,w = destination\\n      \\n      index = 0\\n      res = [\\'H\\']*(h+w)\\n      \\n      while index < h:\\n        curs = 1 # sum of cur, C(h-1,h-1) + C(h,h-1) + C(h+1,h-1)...\\n        cur = 1 # cur, C(h-1,h-1) , C(h,h-1) , C(h+1,h-1)...\\n        up = h - index\\n        down = 1\\n        prev = 0\\n        while curs < k:\\n          prev = curs\\n          cur= cur * up // down\\n          up,down = up + 1,down + 1\\n          curs += cur\\n\\n        k -= prev\\n        res[-up] = \\'V\\'\\n        index += 1\\n        \\n      return \\'\\'.join(res)\\n```\\nIdea is simple to explain in an interview.\\nFirst we have h elements to set in h+w blanks, then we loop h times to set them.\\nInside each loop, subtract the number of combinations less than kth combination from k, and set the position of the left most element.\\n\\n",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n      h,w = destination\\n      \\n      index = 0\\n      res = [\\'H\\']*(h+w)\\n      \\n      while index < h:\\n        curs = 1 # sum of cur, C(h-1,h-1) + C(h,h-1) + C(h+1,h-1)...\\n        cur = 1 # cur, C(h-1,h-1) , C(h,h-1) , C(h+1,h-1)...\\n        up = h - index\\n        down = 1\\n        prev = 0\\n        while curs < k:\\n          prev = curs\\n          cur= cur * up // down\\n          up,down = up + 1,down + 1\\n          curs += cur\\n\\n        k -= prev\\n        res[-up] = \\'V\\'\\n        index += 1\\n        \\n      return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734399,
                "title": "python-28-ms-14-lines-of-code-beats-98-py-solutions",
                "content": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tl = destination[0]\\n\\tn = destination[0] + destination[1]\\n\\tperm = [\\'H\\'] * n\\n\\twhile True and n >= l and k > 0:\\n\\t\\tif k == 1:\\n\\t\\t\\tperm[0:l] = [\\'V\\'] * l\\n\\t\\t\\tbreak\\n\\t\\tlower = comb(n-1, l) + 1\\n\\t\\tif k >= lower:\\n\\t\\t\\tperm[n-1] = \\'V\\'\\n\\t\\t\\tl-= 1\\n\\t\\t\\tk = k - lower + 1\\n\\t\\tn -= 1\\n\\treturn \"\".join(perm[::-1])\\n\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tl = destination[0]\\n\\tn = destination[0] + destination[1]\\n\\tperm = [\\'H\\'] * n\\n\\twhile True and n >= l and k > 0:\\n\\t\\tif k == 1:\\n\\t\\t\\tperm[0:l] = [\\'V\\'] * l\\n\\t\\t\\tbreak\\n\\t\\tlower = comb(n-1, l) + 1\\n\\t\\tif k >= lower:\\n\\t\\t\\tperm[n-1] = \\'V\\'\\n\\t\\t\\tl-= 1\\n\\t\\t\\tk = k - lower + 1\\n\\t\\tn -= 1\\n\\treturn \"\".join(perm[::-1])\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1609523,
                "title": "c-concise-and-efficient-solution-explained-using-maths",
                "content": "There are `nCk(m + n, m) = nCk(m + n, n)` solutions to go from `(0, 0)` to `(m, n)` because we have to perform `m` moves down and `n` moves right, regardless of the order. So the idea is to check step by step how many paths start with `H` given a certain position. To do that, just compute `nCk(m + (n - 1), m)` because it is the number of such solutions if we go right (decrease `n`). Then there are two possibilities : \\n* `k <= nCk(m + (n - 1), m)` which means that the next letter has to be `H`\\n* `k > nCk(m + (n - 1), m)` which means that next letter is `V`. From that point, we decrease `k` by those result and proceed recursively from the next position updated.\\n\\n(The `nCr` function uses sucessive fractions of `n / k` in order not to have to compute too large factorials that not fit a 32 bits integer)\\n\\n```\\nclass Solution {\\n   public:\\n    string kthSmallestPath(vector<int>& destination, int k) {      \\n        int m = destination[0], n = destination[1];     \\n        string ans = \"\";   \\n        while(m + n) {   \\n            int byH = n_choose_k(m + n - 1, m);        \\n            if(k <= byH) {\\n                ans += \"H\"; n--;\\n            } else { \\n                ans += \"V\"; m--; k -= byH;\\n            }\\n        }   \\n        return ans;\\n    }\\n    \\n    int n_choose_k(int n, int k) {\\n        double ans = 1.0;\\n        while(k > 0) \\n            ans *= ((double) n-- / k--);\\n        return round(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    string kthSmallestPath(vector<int>& destination, int k) {      \\n        int m = destination[0], n = destination[1];     \\n        string ans = \"\";   \\n        while(m + n) {   \\n            int byH = n_choose_k(m + n - 1, m);        \\n            if(k <= byH) {\\n                ans += \"H\"; n--;\\n            } else { \\n                ans += \"V\"; m--; k -= byH;\\n            }\\n        }   \\n        return ans;\\n    }\\n    \\n    int n_choose_k(int n, int k) {\\n        double ans = 1.0;\\n        while(k > 0) \\n            ans *= ((double) n-- / k--);\\n        return round(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570425,
                "title": "java-100-95-o-r-c-min-r-c-with-explanation",
                "content": "According to combinatorics, the number of ways to choose v identical objects from n total is (n choose v) = n! / [v! (n-v)!].  In this problem, interpret n as the sum of the horizontal and vertical steps (the sum of the values of the given destination array), and v as the number of vertical steps (destination[0]).\\n\\nThe key observation for this problem is that when all of the (n choose v) possible combinations are laid out in lexicographical order, the first (n - 1 choose v) of them begin with H, and the remaining ones begin with V.  Therefore, we can compare k to (n-1 choose v) to determine whether the first character is H or V.  Then, we reduce the problem to finding v or v-1 V\\'s within n-1 remaining positions.  To set up for the next iteration, if we found a V, reduce k by (n-1 choose v), and decrement v.  Regardless, reduce n by 1.  Repeat this process until all remaining characters are either H (v == 0) or V (v == n).\\n\\nFor example, suppose destination = [2,3] and k = 8.  Here, n = 2+3 = 5 and v = 2.  The (n choose v) = 5!/(2! 3!) = 10 possible arrangements of H and V, in lexicographical order, are:\\nHHHVV\\nHHVHV\\nHHVVH\\nHVHHV\\nHVHVH\\nHVVHH\\nVHHHV\\nVHHVH\\nVHVHH\\nVVHHH\\n\\nStart with n = 5, v = 2, k = 8.\\n* For the first character, calculate (n-1 choose v), which is 4!/(2! 2!) = 6.  In this case, k = 8 is larger than 6, so the first letter must be V.  Decrement n to 4 and v to 1, and reduce k by 6 to 2.  In other words, among the strings that start with V, we want to find the 2nd (kth) string.  There are 4 characters remaining, and only 1 V left to be found.\\n* For the second character, calculate (n-1 choose v), which is 3!/(1! 2!) = 3.  In this case, k = 2 is less than or equal to 3, so the second letter must be H.  Decrement n to 3.\\n* For the third character, calculate (n-1 choose v), which is 2!/(1! 1!) = 2.  In this case, k = 2 is less than or equal to 2, so the third letter must be H.  Decrement n to 2.\\n* For the fourth character, calculate (n-1 choose v), which is 1!/(1! 0!) = 1.  In this case, k = 2 is greater than 1, so the fourth letter must be V.  Decrement n to 1, v to 0, and reduce k by 1 to 1.\\n* Now v == 0, so there are no more Vs left to find.  The last character must be an H.\\n* Return the answer, VHHVH.\\n\\nTC = O((r+c) * min(r,c)), because there are r+c iterations (i.e. the number of steps to reach the destination), and computation of n choose k on each iteration requires looping for the smaller of the remaining horizontal and vertical steps.\\nSC = O(1)\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int v = destination[0];  // number of Vs left to find\\n        int n = v + destination[1];  // number of digits left to find\\n        while (true) {\\n            int range = choose(--n, v);\\n            if (k <= range) sb.append(\\'H\\');\\n            else {\\n                sb.append(\\'V\\');\\n                v--;\\n                k -= range;\\n            }\\n\\n            // Check to see whether we are done\\n            if (v == 0) {\\n                // All remaining directions are H\\n                for (int i = 1; i <= n; i++) sb.append(\\'H\\');\\n                break;\\n            } else if (v == n) {\\n                // All remaining directions are V\\n                for (int i = 1; i <= v; i++) sb.append(\\'V\\');\\n                break;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int choose(int n, int k) {\\n        if (n-k < k) k = n-k;\\n        int answer = 1;\\n        for (int i = 1; i <= k; i++) answer = answer * (n+1 - i) / i;\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int v = destination[0];  // number of Vs left to find\\n        int n = v + destination[1];  // number of digits left to find\\n        while (true) {\\n            int range = choose(--n, v);\\n            if (k <= range) sb.append(\\'H\\');\\n            else {\\n                sb.append(\\'V\\');\\n                v--;\\n                k -= range;\\n            }\\n\\n            // Check to see whether we are done\\n            if (v == 0) {\\n                // All remaining directions are H\\n                for (int i = 1; i <= n; i++) sb.append(\\'H\\');\\n                break;\\n            } else if (v == n) {\\n                // All remaining directions are V\\n                for (int i = 1; i <= v; i++) sb.append(\\'V\\');\\n                break;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int choose(int n, int k) {\\n        if (n-k < k) k = n-k;\\n        int answer = 1;\\n        for (int i = 1; i <= k; i++) answer = answer * (n+1 - i) / i;\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538840,
                "title": "javascript-solution-faster-than-100-takes-up-less-memory-than-100",
                "content": "```\\nvar kthSmallestPath = function(destination, k, r, c) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    function helper( H,  V,  k, result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        let combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH,result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n  function combination( M,  N){\\n        let result = 1;\\n        for(let i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\nvar kthSmallestPath = function(destination, k, r, c) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    function helper( H,  V,  k, result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        let combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH,result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n  function combination( M,  N){\\n        let result = 1;\\n        for(let i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1494127,
                "title": "simple-elimination-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        \\n        int m=destination[0]+1, n=destination[1]+1;\\n        vector<vector<int> > dp(m, vector<int>(n, 1));\\n        \\n        for(int i=m;i--;){\\n            for(int j=n;j--;){\\n                int sum=0;\\n                if(i+1<m){\\n                    sum+=dp[i+1][j];\\n                }\\n                if(j+1<n){\\n                    sum+=dp[i][j+1];\\n                }\\n                dp[i][j]=max(1, sum);\\n                \\n            }\\n        }\\n        \\n        string ans(\"\");\\n        \\n        int i=0, j=0;\\n        \\n        while(i<m && j<n){\\n            if(dp[i][j]==k){\\n                if(m-i>1){\\n                    ans=ans+string(m-i-1, \\'V\\');\\n                }\\n                ans=ans+string(n-j-1, \\'H\\');\\n                return ans;\\n            }\\n            if(dp[i][j+1]<k){\\n                ans.push_back(\\'V\\');\\n                k-=dp[i][j+1];\\n                ++i;\\n            }\\n            else{\\n                ans.push_back(\\'H\\');\\n                ++j;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        \\n        int m=destination[0]+1, n=destination[1]+1;\\n        vector<vector<int> > dp(m, vector<int>(n, 1));\\n        \\n        for(int i=m;i--;){\\n            for(int j=n;j--;){\\n                int sum=0;\\n                if(i+1<m){\\n                    sum+=dp[i+1][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1436912,
                "title": "python-linear-solution-with-explanation-and-how-to-behave-when-being-asked-during-interview",
                "content": "### Construction\\nIf you familiar with standard dynamic programming problem of number of path to right bottom of grid, then you can get the idea that the path is combination of *n* chioces of going right, and *m* choice of going down. Then the number of path starting from left top to right bottom is the *nCr(m + n, m)*. \\nThen the naive solution is that we can get all of combinations and return the *k* th in the sorted order, which definitely not the accepted solution.\\nYou might come up with the solution for *find next smallest permutation* problem, so starting with the minimum path, such as `HHHHVVVV`, we find the next smallest combination using the solution at *k* times, which denotes **O(k\\\\*(m + n))** complexity. \\nIs there a better way? If we know the number of choices for respective *V* and *H*, then we can know how many path based on the fact we learned from the dp problem. Then we can iterate each position in the path, and try with *H* first to see how many choices of path we have for the rest of *V* and *H*. If the number is greater than *k*, then we must put *H*, otherwise we should put *V*. At the same time, we update *k* correspondingly. It makes *O(m + n)* complexity.\\n```python\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\t[count_v, count_h] = destination\\n    path = [0] * (count_h + count_v) \\n        \\n    for i in range(len(path)):\\n\\t\\ttry_h = comb(count_h - 1 + count_v, count_v)\\n        if try_h >= k:\\n\\t\\t\\tpath[i] = \\'H\\'\\n            count_h -= 1\\n\\t\\telse:\\n\\t\\t\\tpath[i] = \\'V\\' \\n            k = k - try_h\\n            count_v -= 1\\n\\treturn \\'\\'.join(path)\\n```\\n\\n*Time Complexity* = **O(m + n)**\\n*Space Complexity*= **O(1)**",
                "solutionTags": [],
                "code": "```python\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\t[count_v, count_h] = destination\\n    path = [0] * (count_h + count_v) \\n        \\n    for i in range(len(path)):\\n\\t\\ttry_h = comb(count_h - 1 + count_v, count_v)\\n        if try_h >= k:\\n\\t\\t\\tpath[i] = \\'H\\'\\n            count_h -= 1\\n\\t\\telse:\\n\\t\\t\\tpath[i] = \\'V\\' \\n            k = k - try_h\\n            count_v -= 1\\n\\treturn \\'\\'.join(path)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1420459,
                "title": "a-few-lines-of-python",
                "content": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def C(A,N):\\n            if A <= N: return 1\\n            return factorial(A)/factorial(A-N)/factorial(N)  \\n        \\n        def Assemble(H,V,K):\\n            if H == 0 or V == 0: return \\'H\\' * H + \\'V\\' * V\\n            total = C(H+V,V)\\n            if total <= K: return \\'V\\' * V + \\'H\\' * H\\n            else:\\n                lower = C(H+V-1,V)\\n                if lower >= K:\\n                    return \\'H\\' + Assemble(H-1,V, K)\\n                else:\\n                    return \\'V\\' + Assemble(H, V-1, K-lower)\\n            \\n        return Assemble(destination[1], destination[0], k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def C(A,N):\\n            if A <= N: return 1\\n            return factorial(A)/factorial(A-N)/factorial(N)  \\n        \\n        def Assemble(H,V,K):\\n            if H == 0 or V == 0: return \\'H\\' * H + \\'V\\' * V\\n            total = C(H+V,V)\\n            if total <= K: return \\'V\\' * V + \\'H\\' * H\\n            else:\\n                lower = C(H+V-1,V)\\n                if lower >= K:\\n                    return \\'H\\' + Assemble(H-1,V, K)\\n                else:\\n                    return \\'V\\' + Assemble(H, V-1, K-lower)\\n            \\n        return Assemble(destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379331,
                "title": "c-easy-dp-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\n    vector<vector<int>>mat;\\n\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0]+1;\\n        m = d[1]+1;\\n        mat.resize(n+5,vector<int>(m+5,0));\\n        for(int i = 0;i<n;i++){\\n            mat[i][m-1] = 1;\\n        }\\n        for(int j = 0;j<m;j++){\\n            mat[n-1][j] = 1;\\n        }\\n        mat[n-1][m-1] = 0;\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = m-2;j>=0;j--){\\n                mat[i][j]+=mat[i+1][j];\\n                mat[i][j]+=mat[i][j+1];\\n            }\\n        }\\n        string res = \"\";\\n        int i = 0;\\n        int j = 0;\\n        while(i<=n-1&&j<=m-1){\\n            while(mat[i][j]>=k){\\n                j++;\\n                res+=\\'H\\';\\n            }\\n            res.pop_back();\\n            j--;\\n            if(j>=m-1) break;\\n            k-=mat[i][j+1];\\n            i++;\\n            if(i>=n) break;\\n            res+=\\'V\\';\\n        }\\n        while(j<m-1){\\n            j++;\\n            res+=\\'H\\';\\n        }\\n        while(i<n-1){\\n            i++;\\n            res+=\\'V\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\n    vector<vector<int>>mat;\\n\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0]+1;\\n        m = d[1]+1;\\n        mat.resize(n+5,vector<int>(m+5,0));\\n        for(int i = 0;i<n;i++){\\n            mat[i][m-1] = 1;\\n        }\\n        for(int j = 0;j<m;j++){\\n            mat[n-1][j] = 1;\\n        }\\n        mat[n-1][m-1] = 0;\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = m-2;j>=0;j--){\\n                mat[i][j]+=mat[i+1][j];\\n                mat[i][j]+=mat[i][j+1];\\n            }\\n        }\\n        string res = \"\";\\n        int i = 0;\\n        int j = 0;\\n        while(i<=n-1&&j<=m-1){\\n            while(mat[i][j]>=k){\\n                j++;\\n                res+=\\'H\\';\\n            }\\n            res.pop_back();\\n            j--;\\n            if(j>=m-1) break;\\n            k-=mat[i][j+1];\\n            i++;\\n            if(i>=n) break;\\n            res+=\\'V\\';\\n        }\\n        while(j<m-1){\\n            j++;\\n            res+=\\'H\\';\\n        }\\n        while(i<n-1){\\n            i++;\\n            res+=\\'V\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365035,
                "title": "similar-to-binary-search",
                "content": "- Try putting \\'H\\' at a location and check what is the maximum rank we can achieve with this. If max rank >= k, then append \\'H\\'\\n- Else, append \\'V\\' and increment current rank by that number if \\'H\\' would have been at that position as `H < V`\\n- So, two search space. either check by putting H, if k is still greater than max rank, append V and increment current rank by nCr\\n```\\nclass Solution {\\npublic:\\n    \\n    int nCr(int n, int r) {\\n        if(r > n-r) {\\n            r = n-r;\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= (n-i);\\n            ans /= i+1;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        string ans = \"\";\\n        int count = 0, V = m, H = n;\\n        for(int i = 0; i < m+n; i++) {\\n            int x = nCr(H+V-1, V);\\n            if(H > 0 && count + x >= k) {\\n                ans += \\'H\\';\\n                H--;\\n            }\\n            else{\\n                ans += \\'V\\';\\n                count += x;\\n                V--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int nCr(int n, int r) {\\n        if(r > n-r) {\\n            r = n-r;\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= (n-i);\\n            ans /= i+1;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        string ans = \"\";\\n        int count = 0, V = m, H = n;\\n        for(int i = 0; i < m+n; i++) {\\n            int x = nCr(H+V-1, V);\\n            if(H > 0 && count + x >= k) {\\n                ans += \\'H\\';\\n                H--;\\n            }\\n            else{\\n                ans += \\'V\\';\\n                count += x;\\n                V--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299549,
                "title": "python3-recursive-with-memoization",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        mem = {}\\n        def get_mx_cnt(h_cnt, v_cnt):\\n            if h_cnt == 0 or v_cnt == 0:\\n                return 1\\n            if (h_cnt, v_cnt) in mem:\\n                return mem[(h_cnt, v_cnt)]\\n\\n            mem[(h_cnt, v_cnt)] = get_mx_cnt(h_cnt - 1, v_cnt) + get_mx_cnt(h_cnt, v_cnt - 1)\\n            return mem[(h_cnt, v_cnt)]\\n \\n        def get_kth(h_cnt, v_cnt, k):\\n            if k == 1 or v_cnt == 0 or h_cnt == 0:\\n                return [\"H\"] * h_cnt + [\"V\"] * v_cnt, 1\\n\\n            mx_htop_cnt = get_mx_cnt(h_cnt - 1, v_cnt)\\n            if mx_htop_cnt >= k:\\n                # H top\\n                sub_res, nh_cnt = get_kth(h_cnt - 1, v_cnt, k) \\n                return [\"H\"] + sub_res, nh_cnt\\n            else:\\n                # V top\\n                sub_res, nv_cnt = get_kth(h_cnt, v_cnt - 1, k - mx_htop_cnt)\\n                return [\"V\"] + sub_res, nv_cnt + mx_htop_cnt\\n\\n        res, _ = get_kth(destination[1], destination[0], k)\\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        mem = {}\\n        def get_mx_cnt(h_cnt, v_cnt):\\n            if h_cnt == 0 or v_cnt == 0:\\n                return 1\\n            if (h_cnt, v_cnt) in mem:\\n                return mem[(h_cnt, v_cnt)]\\n\\n            mem[(h_cnt, v_cnt)] = get_mx_cnt(h_cnt - 1, v_cnt) + get_mx_cnt(h_cnt, v_cnt - 1)\\n            return mem[(h_cnt, v_cnt)]\\n \\n        def get_kth(h_cnt, v_cnt, k):\\n            if k == 1 or v_cnt == 0 or h_cnt == 0:\\n                return [\"H\"] * h_cnt + [\"V\"] * v_cnt, 1\\n\\n            mx_htop_cnt = get_mx_cnt(h_cnt - 1, v_cnt)\\n            if mx_htop_cnt >= k:\\n                # H top\\n                sub_res, nh_cnt = get_kth(h_cnt - 1, v_cnt, k) \\n                return [\"H\"] + sub_res, nh_cnt\\n            else:\\n                # V top\\n                sub_res, nv_cnt = get_kth(h_cnt, v_cnt - 1, k - mx_htop_cnt)\\n                return [\"V\"] + sub_res, nv_cnt + mx_htop_cnt\\n\\n        res, _ = get_kth(destination[1], destination[0], k)\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276376,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int r=destination[0],c=destination[1];\\n        int dp[][]=new int[r+2][c+2];\\n        dp[r][c]=1;\\n        for(int i=r;i>=0;i--)\\n            for(int j=c;j>=0;j--)\\n                dp[i][j]=dp[i][j]+dp[i+1][j]+dp[i][j+1];\\n        StringBuilder ans=new StringBuilder();\\n        int i=0,j=0,p=k;\\n        while(i<r || j<c)\\n        {\\n            if(dp[i][j+1]>=p)\\n            {\\n                ans.append(\"H\");\\n                j++;\\n            }\\n            else\\n            {\\n                p=p-dp[i][j+1];\\n                ans.append(\"V\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int r=destination[0],c=destination[1];\\n        int dp[][]=new int[r+2][c+2];\\n        dp[r][c]=1;\\n        for(int i=r;i>=0;i--)\\n            for(int j=c;j>=0;j--)\\n                dp[i][j]=dp[i][j]+dp[i+1][j]+dp[i][j+1];\\n        StringBuilder ans=new StringBuilder();\\n        int i=0,j=0,p=k;\\n        while(i<r || j<c)\\n        {\\n            if(dp[i][j+1]>=p)\\n            {\\n                ans.append(\"H\");\\n                j++;\\n            }\\n            else\\n            {\\n                p=p-dp[i][j+1];\\n                ans.append(\"V\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250929,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int h = d[1], v = d[0];\\n        int[][] dp = new int[h+v+1][v+1];\\n        dp[0][0] = 1;\\n        for(int i = 1 ; i < dp.length ; i++){\\n            dp[i][0] = 1;\\n            for(int j = 1 ; j <= v ; j++){\\n                dp[i][j] += dp[i-1][j] + dp[i-1][j-1];\\n            }\\n        }\\n        char[] ret = new char[h+v];\\n        int vt = v;\\n        int idx = h+v;\\n        while(idx > 0 && k > 0 && vt > 0){\\n            while(idx >= 0  && dp[idx-1][vt] >= k){\\n                idx--;\\n            }\\n            if(k == dp[idx][vt]){\\n                while(idx > 0 && vt > 0){\\n                    ret[h+v-idx] = \\'V\\';\\n                    idx--;\\n                    vt--;\\n                }\\n                break;\\n            }else{\\n                k -= dp[idx-1][vt];\\n                ret[h+v-idx]=\\'V\\';\\n                vt--;\\n            }\\n        }\\n        for(int i = 0 ; i < ret.length ; i++){\\n            if(ret[i] != \\'V\\'){\\n                ret[i] = \\'H\\';\\n            }\\n        }\\n        return new String(ret);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int h = d[1], v = d[0];\\n        int[][] dp = new int[h+v+1][v+1];\\n        dp[0][0] = 1;\\n        for(int i = 1 ; i < dp.length ; i++){\\n            dp[i][0] = 1;\\n            for(int j = 1 ; j <= v ; j++){\\n                dp[i][j] += dp[i-1][j] + dp[i-1][j-1];\\n            }\\n        }\\n        char[] ret = new char[h+v];\\n        int vt = v;\\n        int idx = h+v;\\n        while(idx > 0 && k > 0 && vt > 0){\\n            while(idx >= 0  && dp[idx-1][vt] >= k){\\n                idx--;\\n            }\\n            if(k == dp[idx][vt]){\\n                while(idx > 0 && vt > 0){\\n                    ret[h+v-idx] = \\'V\\';\\n                    idx--;\\n                    vt--;\\n                }\\n                break;\\n            }else{\\n                k -= dp[idx-1][vt];\\n                ret[h+v-idx]=\\'V\\';\\n                vt--;\\n            }\\n        }\\n        for(int i = 0 ; i < ret.length ; i++){\\n            if(ret[i] != \\'V\\'){\\n                ret[i] = \\'H\\';\\n            }\\n        }\\n        return new String(ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230350,
                "title": "python3-count-how-many-v-and-h-top-down-memoization",
                "content": "We want to start with patterns with V behind H. The basic problem is this:\\n\\nSuppose you have a number of `v` vertical moves, and `h` horizontal moves, how many total paths are there?\\n\\nSuppose v + h = n, You can quickly figure out this is Comb(n, v), basically choose v places out of n positions. So we can start counting (by increasing i from v to n) until we have Comb(i, v) >= k. When this happens, we know during this iteration, the first V appears after (n - i) H; and after the first V, we have (v-1) V left, and (h-n+i) H left, and we want to figure out the new position corresponding to the new k. \\n\\nFor example, we want v=2, h=3, and k =4. n = v+h = 5. Starting from i = 2 to 5, we can see:\\n* Comb(2, 2) = 1 < k, meaning \\'VV\\' is the only combination if we have length i = 2.\\n* Comb(3, 2) = 3 < k, meaning we have 3 combinations (\\'VVH\\', \\'VHV\\', \\'VVH\\').\\n* Comb(4, 2) = 6 >= k = 4. So we know the final pattern will be \\'HVxxx\\'. We need to look for length 4 pattern \\'Vxxx\\'. Now the new k becomes k = 4 - 3 = 1 -> we are looking for the 1st combination of length 4 (\\'Vxxx\\'), given that there are 3 length 3 combinations. Also, since we have used 1 H and 1 V in \\'HVxxx\\', we know we will need to check helper(v-1, h - 1, new_k).\\n\\nSee the program for details.\\n\\n```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        @lru_cache(None)\\n        def helper(v, h, k):\\n            n = v + h\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n\\n            last = 0\\n            for i in range(v, n+1):\\n                cur = factorial(i) // (factorial(v) * factorial(i-v))\\n                if last < k <= cur:\\n                    k -= last\\n                    break\\n                last = cur\\n            return \\'H\\' * (n - i) + \\'V\\' + helper(v-1, h - n + i, k)\\n    \\n        v, h = destination\\n        return helper(v, h, k)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        @lru_cache(None)\\n        def helper(v, h, k):\\n            n = v + h\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n\\n            last = 0\\n            for i in range(v, n+1):\\n                cur = factorial(i) // (factorial(v) * factorial(i-v))\\n                if last < k <= cur:\\n                    k -= last\\n                    break\\n                last = cur\\n            return \\'H\\' * (n - i) + \\'V\\' + helper(v-1, h - n + i, k)\\n    \\n        v, h = destination\\n        return helper(v, h, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121137,
                "title": "o-m-n-solution-with-precomputation-of-ncr-explained",
                "content": "Let\\'s say we have a function `placeV(n, r, k int) => string` to generate the k-th seqeunce of string of length `n`, with `r` \"V\"s and `n-r` \"H\".\\n\\nAssume that we place a \"H\" as the first character, the remaining string of length `n-1` will need to have `r` \"V\"s, there are `nCr[n-1][r]` of such combinations.\\n- If `nCr[n-1][r] < k` we will know that the k-th sequence will not have the first character as \"H\", so the solution will be `\"V\" + placeV(n-1, r-1, k-nCr[n-1][r])`\\n- otherwise the solution must have \"H\" as first character, i.e. `\"H\" + placeV(n-1, r, k)`\\n\\nBelow is a non-recursive implementation of this idea in golang.\\n```\\nvar ncr [][]int\\nfunc kthSmallestPath(d []int, k int) string {\\n  if ncr == nil {\\n    ncr = make([][]int, 31)\\n    for i := 0; i <= 30; i++ {\\n      ncr[i] = make([]int, 31)\\n      for j := 0; j <= i; j++ {\\n        if j == 0 {\\n          ncr[i][j] = 1\\n          continue\\n        }\\n        ncr[i][j] = ncr[i-1][j-1] + ncr[i-1][j]\\n      }\\n    }\\n  }\\n  \\n  s := \"\"\\n  n, r := d[0]+d[1], d[0]\\n  for n > 0 {\\n    if ncr[n-1][r] < k {\\n      s += \"V\"\\n      k -= ncr[n-1][r]\\n      r--\\n    } else {\\n      s += \"H\"\\n    }\\n    n--\\n  }\\n  return s\\n}\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nvar ncr [][]int\\nfunc kthSmallestPath(d []int, k int) string {\\n  if ncr == nil {\\n    ncr = make([][]int, 31)\\n    for i := 0; i <= 30; i++ {\\n      ncr[i] = make([]int, 31)\\n      for j := 0; j <= i; j++ {\\n        if j == 0 {\\n          ncr[i][j] = 1\\n          continue\\n        }\\n        ncr[i][j] = ncr[i-1][j-1] + ncr[i-1][j]\\n      }\\n    }\\n  }\\n  \\n  s := \"\"\\n  n, r := d[0]+d[1], d[0]\\n  for n > 0 {\\n    if ncr[n-1][r] < k {\\n      s += \"V\"\\n      k -= ncr[n-1][r]\\n      r--\\n    } else {\\n      s += \"H\"\\n    }\\n    n--\\n  }\\n  return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102004,
                "title": "java-fastest-solution-11ms-with-biginteger",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return find(\"\", destination[0], destination[1], k);\\n    }\\n    \\n    private String find(String current, int v, int h, long k) {\\n        if (v == 0 && h == 0) return current;\\n        BigInteger totalCombs = combinations(v+h, h);\\n        BigInteger hCombs = combinations(v+h-1, h-1);\\n        if (v > 0 && (BigInteger.valueOf(k).compareTo(hCombs) > 0 || h == 0)) {\\n            return find(current + \\'V\\', v-1, h, k - hCombs.longValue());\\n        }\\n        else {\\n            return find(current + \\'H\\', v, h-1, k);\\n        }\\n    }\\n        \\n    private BigInteger factorial(int n) {\\n        BigInteger result = BigInteger.ONE;\\n        for (int i = 2; i <= n; i++)\\n            result = result.multiply(BigInteger.valueOf(i));\\n        return result;\\n    }\\n    \\n    private BigInteger combinations(int total, int rows) {\\n        return (factorial(total)).divide(((factorial(rows)).multiply((factorial(total-rows)))));\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return find(\"\", destination[0], destination[1], k);\\n    }\\n    \\n    private String find(String current, int v, int h, long k) {\\n        if (v == 0 && h == 0) return current;\\n        BigInteger totalCombs = combinations(v+h, h);\\n        BigInteger hCombs = combinations(v+h-1, h-1);\\n        if (v > 0 && (BigInteger.valueOf(k).compareTo(hCombs) > 0 || h == 0)) {\\n            return find(current + \\'V\\', v-1, h, k - hCombs.longValue());\\n        }\\n        else {\\n            return find(current + \\'H\\', v, h-1, k);\\n        }\\n    }\\n        \\n    private BigInteger factorial(int n) {\\n        BigInteger result = BigInteger.ONE;\\n        for (int i = 2; i <= n; i++)\\n            result = result.multiply(BigInteger.valueOf(i));\\n        return result;\\n    }\\n    \\n    private BigInteger combinations(int total, int rows) {\\n        return (factorial(total)).divide(((factorial(rows)).multiply((factorial(total-rows)))));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081532,
                "title": "python-combination-beats-85",
                "content": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tv, h = destination\\n\\tn = v + h\\n\\tprefix = \"\"\\n\\taccu = 0\\n\\tfor i in range(n):\\n\\t\\thCand = math.comb(v+h-1, v)\\n\\t\\tif k == accu + hCand:\\n\\t\\t\\tprefix += \"H\" + \"V\" * v + \"H\" * (h - 1)\\n\\t\\t\\tbreak\\n\\t\\telif k > accu + hCand:\\n\\t\\t\\tprefix += \"V\"\\n\\t\\t\\taccu += hCand\\n\\t\\t\\tv -= 1\\n\\t\\telse:\\n\\t\\t\\tprefix += \"H\"\\n\\t\\t\\th -= 1\\n\\treturn prefix",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tv, h = destination\\n\\tn = v + h\\n\\tprefix = \"\"\\n\\taccu = 0\\n\\tfor i in range(n):\\n\\t\\thCand = math.comb(v+h-1, v)\\n\\t\\tif k == accu + hCand:\\n\\t\\t\\tprefix += \"H\" + \"V\" * v + \"H\" * (h - 1)\\n\\t\\t\\tbreak\\n\\t\\telif k > accu + hCand:\\n\\t\\t\\tprefix += \"V\"\\n\\t\\t\\taccu += hCand\\n\\t\\t\\tv -= 1\\n\\t\\telse:\\n\\t\\t\\tprefix += \"H\"\\n\\t\\t\\th -= 1\\n\\treturn prefix",
                "codeTag": "Python3"
            },
            {
                "id": 1076943,
                "title": "python-recursively-calculate-combinations-and-rank",
                "content": "```\\ndef combination(a, b):\\n    product = 1\\n    for i in range(a, a-b,-1):\\n        product *= i\\n    \\n    for i in range(1, b+1):\\n        product //= i\\n        \\n    return product\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # print(combination(3,0))\\n        \\n        def help(m, n, k):\\n            # print(m, n, k)\\n            if n == 0 and m == 0:\\n                return \"\"\\n            elif n == 0:\\n                return m * \\'H\\'\\n            elif m == 0:\\n                return n * \\'V\\'\\n            else:\\n                #chose \\'H\\' as the first number\\n                firstNum = combination(m+n-1,m-1)\\n                if k == firstNum:\\n                    return \\'H\\'+ n*\\'V\\' + (m-1)*\\'H\\'\\n                elif k < firstNum:\\n                    return \\'H\\' + help(m-1, n, k)\\n                else:\\n                    return \\'V\\' + help(m, n-1, k-firstNum)\\n            \\n        numV = destination[0]\\n        numH = destination[1]\\n        \\n        return help(numH, numV, k)\\n```",
                "solutionTags": [],
                "code": "```\\ndef combination(a, b):\\n    product = 1\\n    for i in range(a, a-b,-1):\\n        product *= i\\n    \\n    for i in range(1, b+1):\\n        product //= i\\n        \\n    return product\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # print(combination(3,0))\\n        \\n        def help(m, n, k):\\n            # print(m, n, k)\\n            if n == 0 and m == 0:\\n                return \"\"\\n            elif n == 0:\\n                return m * \\'H\\'\\n            elif m == 0:\\n                return n * \\'V\\'\\n            else:\\n                #chose \\'H\\' as the first number\\n                firstNum = combination(m+n-1,m-1)\\n                if k == firstNum:\\n                    return \\'H\\'+ n*\\'V\\' + (m-1)*\\'H\\'\\n                elif k < firstNum:\\n                    return \\'H\\' + help(m-1, n, k)\\n                else:\\n                    return \\'V\\' + help(m, n-1, k-firstNum)\\n            \\n        numV = destination[0]\\n        numH = destination[1]\\n        \\n        return help(numH, numV, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070550,
                "title": "python-dp-o-m-n-2-explained",
                "content": "`dp[x][y]` means the number of ways to from `(0,0)` to `(x,y)`.\\nif we stand on point `(xp, yp)`, then from there the possible ways to `(x,y)` is `dp[x-xp][y-yp]` (equals to from `(0,0)` to point `(x-xp, y-yp)`. Then we had two option, \\u201CH\\u201D and \\u201CV\\u201D. If `k <= dp[x-xp][y-(yp+1)]` then it means the next step is \\'H\\' since all path started with \\'H\\' has smaller index thatn path started with \\'V\\'. if `k > dp[x-xp][y-(yp+1)]`, then it means the next step is \\'V\\' and we should update `k` by subtract `dp[x-xp][y-(yp+1)]` since the next two options index after `V` need to consider adding this part.\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        dp = [[1]*16 for _ in range(16)]\\n        for i in range(1,16):\\n            for j in range(1,16):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        x, y = destination\\n        xp, yp = 0, 0\\n        res = \"\"\\n        while xp < x and yp < y:\\n            if dp[x-xp][y-yp-1] >= k:\\n                yp += 1\\n                res += \"H\"\\n            else:\\n                k -= dp[x-xp][y-yp-1]\\n                xp += 1\\n                res += \"V\"\\n        while xp < x:\\n            xp += 1\\n            res += \"V\"\\n        while yp < y:\\n            yp += 1\\n            res += \"H\"\\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        dp = [[1]*16 for _ in range(16)]\\n        for i in range(1,16):\\n            for j in range(1,16):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        x, y = destination\\n        xp, yp = 0, 0\\n        res = \"\"\\n        while xp < x and yp < y:\\n            if dp[x-xp][y-yp-1] >= k:\\n                yp += 1\\n                res += \"H\"\\n            else:\\n                k -= dp[x-xp][y-yp-1]\\n                xp += 1\\n                res += \"V\"\\n        while xp < x:\\n            xp += 1\\n            res += \"V\"\\n        while yp < y:\\n            yp += 1\\n            res += \"H\"\\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1051674,
                "title": "java-1ms-dp-solution-time-o-row-col-space-o-row-col",
                "content": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        int[][] grid = new int[16][16];\\n        int desRow = destination[0];\\n        int desCol = destination[1];\\n        for (int i = desRow; i >= 0; i--) {\\n             grid[i][desCol] = 1;\\n        }\\n        for (int j = desCol; j >= 0; j--) {\\n             grid[desRow][j] = 1;\\n        }\\n        for (int i = desRow - 1; i >= 0; i--) {\\n             for (int j = desCol - 1; j >= 0; j--) {\\n                  grid[i][j] = grid[i + 1][j] + grid[i][j + 1];\\n             }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (row < desRow && col < desCol) {\\n        \\n            if (grid[row][col + 1] >= k) {\\n                builder.append(\"H\");\\n                col++;\\n            } else {\\n                k -= grid[row][col + 1];\\n                builder.append(\"V\");\\n                row++;\\n            }\\n        }\\n        while (col < desCol) {\\n            builder.append(\"H\");\\n            col++;\\n        }\\n        while (row < desRow) {\\n            builder.append(\"V\");\\n            row++;\\n        }\\n        return builder.toString();\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        int[][] grid = new int[16][16];\\n        int desRow = destination[0];\\n        int desCol = destination[1];\\n        for (int i = desRow; i >= 0; i--) {\\n             grid[i][desCol] = 1;\\n        }\\n        for (int j = desCol; j >= 0; j--) {\\n             grid[desRow][j] = 1;\\n        }\\n        for (int i = desRow - 1; i >= 0; i--) {\\n             for (int j = desCol - 1; j >= 0; j--) {\\n                  grid[i][j] = grid[i + 1][j] + grid[i][j + 1];\\n             }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (row < desRow && col < desCol) {\\n        \\n            if (grid[row][col + 1] >= k) {\\n                builder.append(\"H\");\\n                col++;\\n            } else {\\n                k -= grid[row][col + 1];\\n                builder.append(\"V\");\\n                row++;\\n            }\\n        }\\n        while (col < desCol) {\\n            builder.append(\"H\");\\n            col++;\\n        }\\n        while (row < desRow) {\\n            builder.append(\"V\");\\n            row++;\\n        }\\n        return builder.toString();\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044044,
                "title": "c-combination",
                "content": "```\\nclass Combination{\\npublic:\\n    using ll=long long;\\n    Combination(int size) : factorial(size) {\\n        factorial[0] = 1;\\n        for(int i=1; i<size; i++) factorial[i] = i * factorial[i-1] % mod;\\n    }\\n    \\n    ll power(ll a, ll b){ \\n        ll x = 1, y = a % mod; \\n        while (b > 0){ \\n            if (b%2) x = x * y % mod; \\n            y = y * y % mod; \\n            b /= 2; \\n        } \\n        return x % mod; \\n    }\\t \\n \\n    ll modular_inverse(ll n){ \\n        return power(n, mod-2); \\n    } \\n\\n    ll nCr(ll n, ll k){ \\n        if(k<0) return 0;\\n        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;\\n    } \\n    \\n    vector<ll> factorial;\\n    static constexpr ll mod = 1e9+7;\\n};\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[1], m = dest[0], q = n+m;\\n        Combination comb(30);\\n        string res;\\n        while(q--){\\n            if(comb.nCr(n+m-1, n-1) < k){\\n                k -= comb.nCr(n+m-1, n-1);\\n                res += \\'V\\';\\n                m--;\\n            }\\n            else{\\n                n--;\\n                res += \\'H\\';\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[1], m = dest[0], q = n+m;\\n        Combination comb(30);\\n        string res;\\n        while(q--){\\n            if(comb.nCr(n+m-1, n-1) < k){\\n                k -= comb.nCr(n+m-1, n-1);\\n                res += \\'V\\';\\n                m--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1025752,
                "title": "python-only-math-dhruv-vavliya",
                "content": "```\\n# written by :Dhruv vavliya\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        h = destination[1]\\n        v = destination[0]\\n        ans = \\'\\'\\n\\n        while h>0 and v>0:\\n            temp = comb(h+v-1 ,v)\\n\\n            if k <= temp:\\n                ans+=\\'H\\'\\n                h-=1\\n            else:\\n                ans+=\\'V\\'\\n                v-=1\\n                k-=temp\\n\\n        if h==0:\\n            ans += \\'V\\'*v\\n        if v==0:\\n            ans += \\'H\\'*h\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# written by :Dhruv vavliya\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        h = destination[1]\\n        v = destination[0]\\n        ans = \\'\\'\\n\\n        while h>0 and v>0:\\n            temp = comb(h+v-1 ,v)\\n\\n            if k <= temp:\\n                ans+=\\'H\\'\\n                h-=1\\n            else:\\n                ans+=\\'V\\'\\n                v-=1\\n                k-=temp\\n\\n        if h==0:\\n            ans += \\'V\\'*v\\n        if v==0:\\n            ans += \\'H\\'*h\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020886,
                "title": "go-0ms-solution",
                "content": "```\\nfunc factorialRange(n, end uint64) uint64 {\\n\\tif n < end {\\n\\t\\treturn 1\\n\\t}\\n\\treturn n * factorialRange(n-1, end)\\n}\\n\\nfunc nCr(n, r uint64) int {\\n\\t// To avoid overflow\\n\\treturn int(factorialRange(n, n-r+1) / factorialRange(r, 2))\\n}\\n\\nfunc duplicateChar(c string, n int) string {\\n\\tstr := \"\"\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstr += c\\n\\t}\\n\\n\\treturn str\\n}\\n\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tv, h := destination[0], destination[1]\\n\\tif v == 0 {\\n\\t\\treturn duplicateChar(\"H\", h)\\n\\t}\\n\\tif h == 0 {\\n\\t\\treturn duplicateChar(\"V\", v)\\n\\t}\\n\\n\\tfor i := h; ; i-- {\\n\\t\\tcombinations := nCr(uint64(h+v-i-1), uint64(v-1))\\n\\t\\tif k-combinations <= 0 || i == 0 {\\n\\t\\t\\treturn duplicateChar(\"H\", i) + \"V\" + kthSmallestPath([]int{v - 1, h - i}, k)\\n\\t\\t}\\n\\n\\t\\tk -= combinations\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc factorialRange(n, end uint64) uint64 {\\n\\tif n < end {\\n\\t\\treturn 1\\n\\t}\\n\\treturn n * factorialRange(n-1, end)\\n}\\n\\nfunc nCr(n, r uint64) int {\\n\\t// To avoid overflow\\n\\treturn int(factorialRange(n, n-r+1) / factorialRange(r, 2))\\n}\\n\\nfunc duplicateChar(c string, n int) string {\\n\\tstr := \"\"\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstr += c\\n\\t}\\n\\n\\treturn str\\n}\\n\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tv, h := destination[0], destination[1]\\n\\tif v == 0 {\\n\\t\\treturn duplicateChar(\"H\", h)\\n\\t}\\n\\tif h == 0 {\\n\\t\\treturn duplicateChar(\"V\", v)\\n\\t}\\n\\n\\tfor i := h; ; i-- {\\n\\t\\tcombinations := nCr(uint64(h+v-i-1), uint64(v-1))\\n\\t\\tif k-combinations <= 0 || i == 0 {\\n\\t\\t\\treturn duplicateChar(\"H\", i) + \"V\" + kthSmallestPath([]int{v - 1, h - i}, k)\\n\\t\\t}\\n\\n\\t\\tk -= combinations\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998278,
                "title": "p23-5",
                "content": "ncr = calculate using formula of taking and not taking\\nMath dp",
                "solutionTags": [],
                "code": "ncr = calculate using formula of taking and not taking\\nMath dp",
                "codeTag": "Unknown"
            },
            {
                "id": 974380,
                "title": "python-very-easy",
                "content": "```\\nfrom math import factorial as fac\\nclass Solution:\\n    def kthSmallestPath(self, z: List[int], k: int) -> str:\\n        def f(h,v):\\n            if h==-1:return 0\\n            return fac(v+h)//(fac(v)*fac(h))\\n        v,h=z\\n        res=\\'\\'\\n        while 1:\\n            if h==0 or v==0:\\n                res+= \\'H\\'*h+ \\'V\\'*v\\n                break\\n            a=f(h-1,v)\\n            if k<=a:\\n                res+=\\'H\\'   \\n                h-=1\\n            else:\\n                res+=\\'V\\'\\n                k-=a\\n                v-=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as fac\\nclass Solution:\\n    def kthSmallestPath(self, z: List[int], k: int) -> str:\\n        def f(h,v):\\n            if h==-1:return 0\\n            return fac(v+h)//(fac(v)*fac(h))\\n        v,h=z\\n        res=\\'\\'\\n        while 1:\\n            if h==0 or v==0:\\n                res+= \\'H\\'*h+ \\'V\\'*v\\n                break\\n            a=f(h-1,v)\\n            if k<=a:\\n                res+=\\'H\\'   \\n                h-=1\\n            else:\\n                res+=\\'V\\'\\n                k-=a\\n                v-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971943,
                "title": "c-0ms-choose-n-from-m-and-switch-accordingly",
                "content": "```\\nclass Solution {\\n    static int dp[31][31];\\npublic:\\n    // choose j items from i items\\n    int get(int i, int j) {\\n        if(i < j) return 0;\\n        if(i == j) return 1;\\n        if(j == 0) return 1;\\n        if(j == 1) return i;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = get(i - 1, j) + get(i - 1, j - 1);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int x = dest[1], y = dest[0];\\n        string res;\\n        for(int i = x + y; i > 0; i--)\\n        {\\n            if(get(i-1, y) >= k) {\\n                res.push_back(\\'H\\');\\n                x--;\\n            }\\n            else{\\n                res.push_back(\\'V\\');\\n                k -= get(i-1, y);\\n                y--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nint Solution::dp[31][31]{};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int dp[31][31];\\npublic:\\n    // choose j items from i items\\n    int get(int i, int j) {\\n        if(i < j) return 0;\\n        if(i == j) return 1;\\n        if(j == 0) return 1;\\n        if(j == 1) return i;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = get(i - 1, j) + get(i - 1, j - 1);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int x = dest[1], y = dest[0];\\n        string res;\\n        for(int i = x + y; i > 0; i--)\\n        {\\n            if(get(i-1, y) >= k) {\\n                res.push_back(\\'H\\');\\n                x--;\\n            }\\n            else{\\n                res.push_back(\\'V\\');\\n                k -= get(i-1, y);\\n                y--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nint Solution::dp[31][31]{};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969107,
                "title": "c-4ms-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        c[0][0] = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            c[i][0] = 1;\\n            for (int j = 1; j <= 31; j++) {\\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\\n            }\\n        }\\n        int v = destination[0], h = destination[1];\\n        return solve(h, v, k);\\n    }\\nprivate:\\n    int c[32][32];\\n    string solve(int h, int v, int k) {\\n        int p = v;\\n        int sum = 0;\\n        while (true) {\\n            if (sum + c[p - 1][v - 1] < k) {\\n                sum += c[p - 1][v - 1];\\n                p++;\\n            } else if (sum + c[p - 1][v - 1] == k) {\\n                return string(h + v - p, \\'H\\') + string(v, \\'V\\') + string(p - v, \\'H\\');\\n            } else {\\n                return string(h + v - p, \\'H\\') + string(1, \\'V\\') + solve(p - v, v - 1, k - sum);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        c[0][0] = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            c[i][0] = 1;\\n            for (int j = 1; j <= 31; j++) {\\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\\n            }\\n        }\\n        int v = destination[0], h = destination[1];\\n        return solve(h, v, k);\\n    }\\nprivate:\\n    int c[32][32];\\n    string solve(int h, int v, int k) {\\n        int p = v;\\n        int sum = 0;\\n        while (true) {\\n            if (sum + c[p - 1][v - 1] < k) {\\n                sum += c[p - 1][v - 1];\\n                p++;\\n            } else if (sum + c[p - 1][v - 1] == k) {\\n                return string(h + v - p, \\'H\\') + string(v, \\'V\\') + string(p - v, \\'H\\');\\n            } else {\\n                return string(h + v - p, \\'H\\') + string(1, \\'V\\') + solve(p - v, v - 1, k - sum);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961836,
                "title": "c-math",
                "content": "```\\npublic class Solution\\n{\\n  public string KthSmallestPath(int[] destination, int k)\\n  {\\n    var maxX = destination[0];\\n    var maxY = destination[1];\\n\\n    var point = (x: 0, y: 0);\\n    var target = (x: destination[0], y: destination[1]);\\n    var range = (start: 1, end: Cr(maxX + maxY, maxX));\\n\\n    var sb = new StringBuilder();\\n\\n    while (point != target)\\n    {\\n      if (point.x == target.x)\\n      {\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n        continue;\\n      }\\n\\n      if (point.y == target.y)\\n      {\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n        continue;\\n      }\\n\\n      var lpoint = (x: point.x, y: point.y + 1);\\n      var dpoint = (x: point.x + 1, y: point.y);\\n\\n      var lCr = Cr(maxY - lpoint.y + maxX - lpoint.x, maxX - lpoint.x);\\n      var dCr = Cr(maxY - dpoint.y + maxX - dpoint.x, maxX - dpoint.x);\\n\\n      var hRange = (start: range.start, end: range.start + lCr - 1);\\n      var vRange = (start: range.end - dCr + 1, end: range.end);\\n\\n      if (hRange.start <= k && k <= hRange.end)\\n      {\\n        range = hRange;\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n      }\\n      else\\n      {\\n        range = vRange;\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n      }\\n    }\\n\\n    return sb.ToString();\\n  }\\n\\n  public int Cr(int n, int r) \\n    => (int)(Fact(n) / (Fact(r) * Fact(n - r)));\\n\\n  public BigInteger Fact(int n) \\n    => Enumerable.Range(1, n).Aggregate(BigInteger.One, (p, item) => BigInteger.Multiply(p, new BigInteger(item)));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public string KthSmallestPath(int[] destination, int k)\\n  {\\n    var maxX = destination[0];\\n    var maxY = destination[1];\\n\\n    var point = (x: 0, y: 0);\\n    var target = (x: destination[0], y: destination[1]);\\n    var range = (start: 1, end: Cr(maxX + maxY, maxX));\\n\\n    var sb = new StringBuilder();\\n\\n    while (point != target)\\n    {\\n      if (point.x == target.x)\\n      {\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n        continue;\\n      }\\n\\n      if (point.y == target.y)\\n      {\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n        continue;\\n      }\\n\\n      var lpoint = (x: point.x, y: point.y + 1);\\n      var dpoint = (x: point.x + 1, y: point.y);\\n\\n      var lCr = Cr(maxY - lpoint.y + maxX - lpoint.x, maxX - lpoint.x);\\n      var dCr = Cr(maxY - dpoint.y + maxX - dpoint.x, maxX - dpoint.x);\\n\\n      var hRange = (start: range.start, end: range.start + lCr - 1);\\n      var vRange = (start: range.end - dCr + 1, end: range.end);\\n\\n      if (hRange.start <= k && k <= hRange.end)\\n      {\\n        range = hRange;\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n      }\\n      else\\n      {\\n        range = vRange;\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n      }\\n    }\\n\\n    return sb.ToString();\\n  }\\n\\n  public int Cr(int n, int r) \\n    => (int)(Fact(n) / (Fact(r) * Fact(n - r)));\\n\\n  public BigInteger Fact(int n) \\n    => Enumerable.Range(1, n).Aggregate(BigInteger.One, (p, item) => BigInteger.Multiply(p, new BigInteger(item)));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957826,
                "title": "c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& cnt, int m, int n, int r, string& res)\\n    {\\n        if(n == 0 || m == 0)\\n        {\\n            int s = m + n;\\n            char c = m > 0 ? \\'H\\' : \\'V\\';\\n            res += string(s, c);\\n            return;\\n        }\\n        \\n        int a = cnt[m - 1][n];\\n        int b = cnt[m][n - 1];\\n        \\n        if(r <= a) {\\n            res.push_back(\\'H\\');\\n            dfs(cnt, m-1, n, r, res);\\n        } else {\\n            res.push_back(\\'V\\');\\n            dfs(cnt, m, n - 1, r - a, res);\\n        }\\n        \\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) \\n    {\\n        int n = destination.front(), m = destination.back();\\n        vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 1));\\n        for (int i = 1; i <= m; i ++)\\n            for (int j = 1; j <= n; j++)\\n                cnt[i][j] = cnt[i - 1][j] + cnt[i][j - 1];\\n\\n        string res;\\n        dfs(cnt, m, n, k, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& cnt, int m, int n, int r, string& res)\\n    {\\n        if(n == 0 || m == 0)\\n        {\\n            int s = m + n;\\n            char c = m > 0 ? \\'H\\' : \\'V\\';\\n            res += string(s, c);\\n            return;\\n        }\\n        \\n        int a = cnt[m - 1][n];\\n        int b = cnt[m][n - 1];\\n        \\n        if(r <= a) {\\n            res.push_back(\\'H\\');\\n            dfs(cnt, m-1, n, r, res);\\n        } else {\\n            res.push_back(\\'V\\');\\n            dfs(cnt, m, n - 1, r - a, res);\\n        }\\n        \\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) \\n    {\\n        int n = destination.front(), m = destination.back();\\n        vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 1));\\n        for (int i = 1; i <= m; i ++)\\n            for (int j = 1; j <= n; j++)\\n                cnt[i][j] = cnt[i - 1][j] + cnt[i][j - 1];\\n\\n        string res;\\n        dfs(cnt, m, n, k, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957608,
                "title": "can-anyone-write-me-a-brute-force-dfs-without-dp-pls",
                "content": "No DP, no memo, pure brute force DFS\\nNo combo\\nBetter in Java pls",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 929041,
                "title": "rust-dp-o-v-h-2",
                "content": "I build up a DP, where `DP[i][j]` is defined as the index of the item where `i is defined as the number of vertical moves` and `j is defined as the position of  the leading v` the first time it reaches that position.\\n\\nEg:\\n\\n```\\n\"H....HHHHVHHH....HHVVV...VVV\"  == > i = count(\"v\")\\n          ^ j\\n```\\n\\nUsing this map we can rebuild by finding indexes smaller or equal to k. And placing `\"V\"s` as we go.\\n\\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        let h = destination[1];\\n        let v = destination[0];\\n        \\n        let mut dp: Vec<Vec<i32>> = vec![];\\n        for i in 0..=v {\\n            dp.push(vec![-1; (h+v) as usize]);\\n        }\\n        for i in 1..=v {\\n            dp[i as usize][(i-1) as usize] = 0;\\n            for j in i..v+h {\\n                dp[i as usize][j as usize] = 1;\\n                for k in 0..i {\\n                    dp[i as usize][j as usize] += dp[(i-k) as usize][(j-k-1) as usize];   \\n                }\\n            }\\n        }\\n        \\n        let mut real_k = k - 1;\\n        let mut highest = v+h-1;\\n        let mut answer = String::new();\\n        for i in 0..v {\\n            let p = v - i;\\n            while dp[p as usize][highest as usize] > real_k {\\n                answer.push(\\'H\\');\\n                highest -= 1;\\n                \\n            }\\n            answer.push(\\'V\\');\\n            real_k -= dp[p as usize][highest as usize];\\n            highest -= 1;\\n        }\\n        for _ in 0..=highest {\\n            answer.push(\\'H\\');\\n        }\\n\\n       answer\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\"H....HHHHVHHH....HHVVV...VVV\"  == > i = count(\"v\")\\n          ^ j\\n```\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        let h = destination[1];\\n        let v = destination[0];\\n        \\n        let mut dp: Vec<Vec<i32>> = vec![];\\n        for i in 0..=v {\\n            dp.push(vec![-1; (h+v) as usize]);\\n        }\\n        for i in 1..=v {\\n            dp[i as usize][(i-1) as usize] = 0;\\n            for j in i..v+h {\\n                dp[i as usize][j as usize] = 1;\\n                for k in 0..i {\\n                    dp[i as usize][j as usize] += dp[(i-k) as usize][(j-k-1) as usize];   \\n                }\\n            }\\n        }\\n        \\n        let mut real_k = k - 1;\\n        let mut highest = v+h-1;\\n        let mut answer = String::new();\\n        for i in 0..v {\\n            let p = v - i;\\n            while dp[p as usize][highest as usize] > real_k {\\n                answer.push(\\'H\\');\\n                highest -= 1;\\n                \\n            }\\n            answer.push(\\'V\\');\\n            real_k -= dp[p as usize][highest as usize];\\n            highest -= 1;\\n        }\\n        for _ in 0..=highest {\\n            answer.push(\\'H\\');\\n        }\\n\\n       answer\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927483,
                "title": "java-1ms-o-row-col-if-computation-of-combination-is-o-1",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder b = new StringBuilder();\\n        helper(destination[0], destination[1], k, b);\\n        return b.toString();\\n    }\\n    \\n    void helper(int row, int col, int k, StringBuilder b) {\\n        if(k == 1 || row == 0 || col == 0) {\\n            for(int i = 0; i < col; i++) {\\n                b.append(\\'H\\');\\n            }\\n            for(int i = 0; i < row; i++) {\\n                b.append(\\'V\\');\\n            }\\n            return;\\n        }\\n        int add = C(row + col - 1, row);\\n        if(k <= add) {\\n            b.append(\\'H\\');\\n            helper(row, col - 1, k, b);\\n        }\\n        else {\\n            b.append(\\'V\\');\\n            helper(row - 1, col, k - add, b);\\n        }\\n    }\\n    \\n    int C(int n, int k) {\\n        double res = 1;\\n        for (int i = 1; i <= k; ++i)\\n            res = res * (n - k + i) / i;\\n        return (int)(res + 0.01);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder b = new StringBuilder();\\n        helper(destination[0], destination[1], k, b);\\n        return b.toString();\\n    }\\n    \\n    void helper(int row, int col, int k, StringBuilder b) {\\n        if(k == 1 || row == 0 || col == 0) {\\n            for(int i = 0; i < col; i++) {\\n                b.append(\\'H\\');\\n            }\\n            for(int i = 0; i < row; i++) {\\n                b.append(\\'V\\');\\n            }\\n            return;\\n        }\\n        int add = C(row + col - 1, row);\\n        if(k <= add) {\\n            b.append(\\'H\\');\\n            helper(row, col - 1, k, b);\\n        }\\n        else {\\n            b.append(\\'V\\');\\n            helper(row - 1, col, k - add, b);\\n        }\\n    }\\n    \\n    int C(int n, int k) {\\n        double res = 1;\\n        for (int i = 1; i <= k; ++i)\\n            res = res * (n - k + i) / i;\\n        return (int)(res + 0.01);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925290,
                "title": "simple-java-solution",
                "content": "```\\npublic String kthSmallestPath(int[] dest, int k) {\\n\\tfinal int MX = 33;\\n\\tint comb[][] = new int[MX][MX];\\n\\tfor (int n = 1; n < MX; n++) {\\n\\t\\tcomb[n][1] = n;\\n\\t\\tcomb[n][n] = 1;\\n\\t}\\n\\tfor (int n = 2; n < MX; n++)\\n\\t\\tfor (int r = 2; r < n; r++)\\n\\t\\t\\tcomb[n][r] = comb[n - 1][r] + comb[n - 1][r - 1];\\n\\n\\tint t = dest[0] + dest[1];\\n\\tint rem = dest[0];\\n\\n\\tStringBuilder builder = new StringBuilder();\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tif (comb[t - i - 1][rem] < k && rem > 0) {\\n\\t\\t\\tbuilder.append(\"V\");\\n\\t\\t\\tk -= comb[t - i - 1][rem];\\n\\t\\t\\trem--;\\n\\t\\t} else\\n\\t\\t\\tbuilder.append(\"H\");\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] dest, int k) {\\n\\tfinal int MX = 33;\\n\\tint comb[][] = new int[MX][MX];\\n\\tfor (int n = 1; n < MX; n++) {\\n\\t\\tcomb[n][1] = n;\\n\\t\\tcomb[n][n] = 1;\\n\\t}\\n\\tfor (int n = 2; n < MX; n++)\\n\\t\\tfor (int r = 2; r < n; r++)\\n\\t\\t\\tcomb[n][r] = comb[n - 1][r] + comb[n - 1][r - 1];\\n\\n\\tint t = dest[0] + dest[1];\\n\\tint rem = dest[0];\\n\\n\\tStringBuilder builder = new StringBuilder();\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tif (comb[t - i - 1][rem] < k && rem > 0) {\\n\\t\\t\\tbuilder.append(\"V\");\\n\\t\\t\\tk -= comb[t - i - 1][rem];\\n\\t\\t\\trem--;\\n\\t\\t} else\\n\\t\\t\\tbuilder.append(\"H\");\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 923115,
                "title": "c-o-n-m-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring kthSmallestPath(vector<int>& arr, int k) {\\n\\t\\tconst int n = arr[0], m = arr[1];\\n\\t\\tlong long x = m;\\n\\t\\tfor(int i = m + 1; i <= n + m; i++)\\n\\t\\t\\tx = x * i / (i - m);\\n\\t\\tstring ans(n + m, \\'V\\');\\n\\t\\tfor(int i = 0, a = m, b = n; i < n + m; i++) {\\n\\t\\t\\tx /= a + b;\\n\\t\\t\\tif(a && k <= x)\\n\\t\\t\\t\\tans[i] = \\'H\\', x *= --a;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk -= x, x *= b--;\\n\\t\\t}\\n\\t\\treturn move(ans);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring kthSmallestPath(vector<int>& arr, int k) {\\n\\t\\tconst int n = arr[0], m = arr[1];\\n\\t\\tlong long x = m;\\n\\t\\tfor(int i = m + 1; i <= n + m; i++)\\n\\t\\t\\tx = x * i / (i - m);\\n\\t\\tstring ans(n + m, \\'V\\');\\n\\t\\tfor(int i = 0, a = m, b = n; i < n + m; i++) {\\n\\t\\t\\tx /= a + b;\\n\\t\\t\\tif(a && k <= x)\\n\\t\\t\\t\\tans[i] = \\'H\\', x *= --a;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk -= x, x *= b--;\\n\\t\\t}\\n\\t\\treturn move(ans);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922025,
                "title": "java-very-short-code-beats-100-with-explanation",
                "content": "Here as \\'V\\'>\\'H\\', placement of \\'V\\' determines the lexicographical rank.\\n\\nEx: V=3,H=3,k=18.Now we have 6 places and 3V\\'s to arrange in 6C3 ways=20 ways.\\nSo rank can range from 1 to 20. 1 being lexicographically smallest .\\n\\n**[ I ]recur(3 H,3 V,rank 18)**\\nif first V is placed at index=3,\\n_ _ _V _ _  , rank=1, because remaining 2 V\\'s will be placed in 2 blanks to left\\nif first V is placed at index=2,\\n_ _ V _ _ _,then we have 3 blanks, and 2 V\\'s to arrange.Rank will range from 2 to 4 (1+3C2 )\\nif first V is placed at index 1,\\n_V_ _ _ _, then we have 4 blanks anf 2 V\\'s to arrange. Rank will range from 5 to 10 (4+4C2)\\nif first V is placed at index 0,\\nV _ _ _ _ _, then we have 5 blanks and 2 V\\'s to arrange. Rank will range from 11 to 20 (10+5C2).\\n\\nTo get rank  k=18,we need to place V at index 0. Now we have 5 blanks, 2 V\\'s and we need to get rank=18-10=8. So we  do recursive call to dfs(3 H ,2 V, rank 8)\\n\\n**[ II ]recur(3 H,2 V,rank 8)**\\nHere rank can range from 1 to 5C2=1 to 10.\\nif first V is placed at index=3,\\n_ _ _ V _ , rank=1 beacuse remaining 1 V will be placed at blank at left.\\nif first V placed at index=2,\\n_ _ V _ _, then we have 2 blanks, and 1 V to arrange.Rank will range from 2 to 3 (1+2C1 )\\nif first V is placed at index 1,\\n_V_ _ _, then we have 3 blanks anf 1 V\\'s to arrange. Rank will range from 4 to 6 (4+3C1)\\nif first V is placed at index 0,\\nV _ _ _ _, then we have 4 blanks and 1 V\\'s to arrange. Rank will range from 7 to 10 (7+4C1).\\n\\nTo get rank=8, we need to put V at index 0. Now we have 4 blanks 1 V and rank=8-6=2.\\n\\n**[III] recur( 3 H, 1 V, rank=2)**\\nAs we are left with 1 V, rank is directly determined by index of V. To get rank=2, we need to place V at before last index  _ _ V _.\\n\\nSo we place V at index=0,1,4 and rest are \\'H\\'. To get rank 18.\\n\\n**Base conditions,**\\n1.if only 1 V left, then place it accordingly to required rank.\\n2.If rank 1 is required ,then arrange all V\\'s from last index.\\n\\nHere combination array is used to compute nCr. as nCr= n-1Cr-1 * n/n-r. \\n```\\nclass Solution {\\n    char[] ch;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int H=destination[1],V=destination[0];\\n        ch=new char[H+V];Arrays.fill(ch,\\'H\\');\\n        recur(H,V,k);\\n        return new String(ch);\\n    }\\n    private void recur(int H,int V,int k){\\n        //Combination array from r-1Cr-1 to n-1Cr-1\\n        if(V==1) ch[ch.length-k]=\\'V\\';\\n        else if(k==1) while(V-->0) ch[ch.length-1-V]=\\'V\\';\\n        else{\\n            int len=(H+V)-(V-1),r=V-1;\\n            int[] comb=new int[len];\\n            comb[0]=1;\\n            for(int i=1;i<len;i++) comb[i]=(comb[i-1]*(r+i))/i;\\n            for(int i=1;i<len;i++) comb[i]+=comb[i-1];\\n            for(int i=0;i<len;i++){\\n                if(k<=comb[i]){\\n                    ch[ch.length-(i+r+1)]=\\'V\\';\\n                    recur(H,V-1,k-comb[i-1]);\\n                    break;\\n                }\\n            }\\n        }        \\n    }\\n}\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] ch;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int H=destination[1],V=destination[0];\\n        ch=new char[H+V];Arrays.fill(ch,\\'H\\');\\n        recur(H,V,k);\\n        return new String(ch);\\n    }\\n    private void recur(int H,int V,int k){\\n        //Combination array from r-1Cr-1 to n-1Cr-1\\n        if(V==1) ch[ch.length-k]=\\'V\\';\\n        else if(k==1) while(V-->0) ch[ch.length-1-V]=\\'V\\';\\n        else{\\n            int len=(H+V)-(V-1),r=V-1;\\n            int[] comb=new int[len];\\n            comb[0]=1;\\n            for(int i=1;i<len;i++) comb[i]=(comb[i-1]*(r+i))/i;\\n            for(int i=1;i<len;i++) comb[i]+=comb[i-1];\\n            for(int i=0;i<len;i++){\\n                if(k<=comb[i]){\\n                    ch[ch.length-(i+r+1)]=\\'V\\';\\n                    recur(H,V-1,k-comb[i-1]);\\n                    break;\\n                }\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921421,
                "title": "python-sub-problem-s-o-comb-r-c-r",
                "content": "Divide to sub problems.\\nif math.comb(R + C - 1, R) >= k, get \"H\",\\nelse, get \"V\",\\n\\ngo to sub problem.\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        ans = \"\"\\n        R, C = destination\\n\\n        while R + C > 0:\\n            child_cnt = math.comb(R + C - 1, R)\\n            if child_cnt >= k :\\n                ans += \"H\"\\n                C -= 1\\n            else:\\n                ans += \"V\"\\n                R -= 1\\n                k -= child_cnt\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        ans = \"\"\\n        R, C = destination\\n\\n        while R + C > 0:\\n            child_cnt = math.comb(R + C - 1, R)\\n            if child_cnt >= k :\\n                ans += \"H\"\\n                C -= 1\\n            else:\\n                ans += \"V\"\\n                R -= 1\\n                k -= child_cnt\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921116,
                "title": "dynamic-programming-solution-in-c-with-explanation",
                "content": "```\\nchar* kthSmallestPath(int* destination, int destinationSize, int k) {\\n  const int m = destination[0];\\n  const int n = destination[1];\\n\\n  // First compute the total number of paths to all destinations.\\n  int total[m + 1][n + 1];\\n  for (int i = 0; i < m + 1; ++i) {\\n    for (int j = 0; j < n + 1; ++j) {\\n      if (i == 0 || j == 0) {\\n        // Only one way to reach a destination in the 0th row or col.\\n        total[i][j] = 1;\\n      } else {\\n        // Number of paths to this destination is the sum of the number of paths\\n        // to one above and one left.\\n        total[i][j] = total[i - 1][j] + total[i][j - 1];\\n      }\\n    }\\n  }\\n\\n  // We will always take exactly m+n steps. The +1 is for the null terminator.\\n  char* result = malloc(m + n + 1);\\n  int i = 0, j = 0;\\n  for (int index = 0; index < m + n; ++index) {\\n    if (i == m) {\\n      // Must move right.\\n      result[index] = \\'H\\';\\n      continue;\\n    }\\n\\n    if (j == n) {\\n      // Must move down.\\n      result[index] = \\'V\\';\\n      continue;\\n    }\\n\\n    // Number of ways to get to destination if we move right.\\n    const int n_right = total[m - i][n - j - 1];\\n\\n    // All right movements sort before all down movements. If we can move right\\n    // and still have k way to get to the destination, then that is what we\\n    // should do.\\n    //\\n    // Otherwise, we will move down, thus skipping n_right number of paths (and\\n    // subtracting that from k).\\n    if (n_right >= k) {\\n      ++j;\\n      result[index] = \\'H\\';\\n    } else {\\n      ++i;\\n      result[index] = \\'V\\';\\n      k -= n_right;\\n    }\\n  }\\n\\n  result[m + n] = \\'\\\\0\\';\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nchar* kthSmallestPath(int* destination, int destinationSize, int k) {\\n  const int m = destination[0];\\n  const int n = destination[1];\\n\\n  // First compute the total number of paths to all destinations.\\n  int total[m + 1][n + 1];\\n  for (int i = 0; i < m + 1; ++i) {\\n    for (int j = 0; j < n + 1; ++j) {\\n      if (i == 0 || j == 0) {\\n        // Only one way to reach a destination in the 0th row or col.\\n        total[i][j] = 1;\\n      } else {\\n        // Number of paths to this destination is the sum of the number of paths\\n        // to one above and one left.\\n        total[i][j] = total[i - 1][j] + total[i][j - 1];\\n      }\\n    }\\n  }\\n\\n  // We will always take exactly m+n steps. The +1 is for the null terminator.\\n  char* result = malloc(m + n + 1);\\n  int i = 0, j = 0;\\n  for (int index = 0; index < m + n; ++index) {\\n    if (i == m) {\\n      // Must move right.\\n      result[index] = \\'H\\';\\n      continue;\\n    }\\n\\n    if (j == n) {\\n      // Must move down.\\n      result[index] = \\'V\\';\\n      continue;\\n    }\\n\\n    // Number of ways to get to destination if we move right.\\n    const int n_right = total[m - i][n - j - 1];\\n\\n    // All right movements sort before all down movements. If we can move right\\n    // and still have k way to get to the destination, then that is what we\\n    // should do.\\n    //\\n    // Otherwise, we will move down, thus skipping n_right number of paths (and\\n    // subtracting that from k).\\n    if (n_right >= k) {\\n      ++j;\\n      result[index] = \\'H\\';\\n    } else {\\n      ++i;\\n      result[index] = \\'V\\';\\n      k -= n_right;\\n    }\\n  }\\n\\n  result[m + n] = \\'\\\\0\\';\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921115,
                "title": "python-intuitive-recursive-solution",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # start from HHH...VVV, we then iteratively put V forward and \\n        # check if the number of combinations would exceed k\\n        \\n        V, H = destination\\n        \\n        def cal_num_comb(V, H):\\n            ans1, ans2 = 1, 1\\n            for i in range(V):\\n                ans1 *= (H+V-i)\\n                ans2 *= (V-i)\\n            return ans1 / ans2\\n        \\n        def helper(V, H, k):\\n            if k == 1: return \\'H\\'*H + \\'V\\'*V\\n            k -= 1\\n            for i in range(1, H+1):\\n                num_comb = cal_num_comb(V-1, i)\\n                if num_comb < k:\\n                    k -= num_comb\\n                else:\\n                    return \\'H\\'*(H-i)+\\'V\\' + helper(V-1, i, k)\\n        \\n        return helper(V, H, k)\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # start from HHH...VVV, we then iteratively put V forward and \\n        # check if the number of combinations would exceed k\\n        \\n        V, H = destination\\n        \\n        def cal_num_comb(V, H):\\n            ans1, ans2 = 1, 1\\n            for i in range(V):\\n                ans1 *= (H+V-i)\\n                ans2 *= (V-i)\\n            return ans1 / ans2\\n        \\n        def helper(V, H, k):\\n            if k == 1: return \\'H\\'*H + \\'V\\'*V\\n            k -= 1\\n            for i in range(1, H+1):\\n                num_comb = cal_num_comb(V-1, i)\\n                if num_comb < k:\\n                    k -= num_comb\\n                else:\\n                    return \\'H\\'*(H-i)+\\'V\\' + helper(V-1, i, k)\\n        \\n        return helper(V, H, k)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920664,
                "title": "c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll C(ll n, ll k) {\\n        double res = 1;\\n        for (ll i = 1; i <= k; ++i)\\n            res=res*(n-k+i)/i;\\n        return (ll)(res+0.01);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        ll H=destination[1], V=destination[0];\\n        string ans=\"\";\\n        while(k>0 && H>0 && V>0){\\n            ll tmp=C(H+V-1, V);\\n            if(k<=tmp){\\n                ans+=\\'H\\';\\n                H--;\\n            }\\n            else{\\n                k-=tmp;\\n                ans+=\\'V\\';\\n                V--;\\n            }\\n        }\\n        while(H>0){\\n            ans+=\\'H\\';\\n            H--;\\n        }\\n        while(V>0){\\n            ans+=\"V\";\\n            V--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll C(ll n, ll k) {\\n        double res = 1;\\n        for (ll i = 1; i <= k; ++i)\\n            res=res*(n-k+i)/i;\\n        return (ll)(res+0.01);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        ll H=destination[1], V=destination[0];\\n        string ans=\"\";\\n        while(k>0 && H>0 && V>0){\\n            ll tmp=C(H+V-1, V);\\n            if(k<=tmp){\\n                ans+=\\'H\\';\\n                H--;\\n            }\\n            else{\\n                k-=tmp;\\n                ans+=\\'V\\';\\n                V--;\\n            }\\n        }\\n        while(H>0){\\n            ans+=\\'H\\';\\n            H--;\\n        }\\n        while(V>0){\\n            ans+=\"V\";\\n            V--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920485,
                "title": "java-90-breaking-into-steps",
                "content": "First some key points:\\n\\n- Notice that `H` is the least lexicographical step always.\\n- Notice that when `V` is chosen over `H`, we skip over all paths ending with prefix `...H`.\\n\\t- E.g. Path= `HH`, if we choose `V` over `H` we skip over all path combinations starting with prefix `HHH`.\\n\\nThis now becomes a simpler problem of:\\n- Building a DP array of `numberOfPaths` to `destination`.\\n- Choose `H` whenever `numberOfPaths` from choosing `H` is >= `k`. \\n\\t- kth path is within.\\n- Choose `V` otherwise, removing `numberOfPaths` from choosing `H` from `k`.\\n\\t- Remove numberOfPath combinations from k.\\n\\n```java\\npublic String kthSmallestPath(int[] destination, int k) {\\n\\tint height = destination[0] + 1;\\n\\tint width = destination[1] + 1;\\n\\n\\tint[][] dp = new int[height][width];\\n\\tkthSmallestPath(destination, 0, 0, dp);\\n\\n\\tStringBuilder sb = new StringBuilder(width + height);\\n\\tint y = 0;\\n\\tint x = 0;\\n\\twhile (y < destination[0] && x < destination[1]) {\\n\\t\\tif (isWithin(dp, y, x+1)) {\\n\\t\\t\\tint possibilitiesH = dp[y][x+1];\\n\\t\\t\\tif (possibilitiesH >= k) {\\n\\t\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= dp[y][x+1];\\n\\t\\t}\\n\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (y < destination[0]) {\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (x < destination[1]) {\\n\\t\\tsb.append(\\'H\\');\\n\\t\\tx++;\\n\\t}\\n\\treturn sb.toString();\\n}\\n\\nprivate int kthSmallestPath(int[] destination, int y, int x, int[][] dp) {\\n\\tif (!isWithin(dp, y, x)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (y == destination[0] && x == destination[1]) {\\n\\t\\tdp[y][x] = 1;\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tif (dp[y][x] != 0) {\\n\\t\\treturn dp[y][x];\\n\\t}\\n\\n\\tdp[y][x] = kthSmallestPath(destination, y, x+1, dp) + kthSmallestPath(destination, y+1, x, dp);\\n\\treturn dp[y][x];\\n}\\n\\nprivate boolean isWithin(int[][] dp, int y, int x) {\\n\\treturn y >= 0 && y < dp.length && x >= 0 && x < dp[y].length;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic String kthSmallestPath(int[] destination, int k) {\\n\\tint height = destination[0] + 1;\\n\\tint width = destination[1] + 1;\\n\\n\\tint[][] dp = new int[height][width];\\n\\tkthSmallestPath(destination, 0, 0, dp);\\n\\n\\tStringBuilder sb = new StringBuilder(width + height);\\n\\tint y = 0;\\n\\tint x = 0;\\n\\twhile (y < destination[0] && x < destination[1]) {\\n\\t\\tif (isWithin(dp, y, x+1)) {\\n\\t\\t\\tint possibilitiesH = dp[y][x+1];\\n\\t\\t\\tif (possibilitiesH >= k) {\\n\\t\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= dp[y][x+1];\\n\\t\\t}\\n\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (y < destination[0]) {\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (x < destination[1]) {\\n\\t\\tsb.append(\\'H\\');\\n\\t\\tx++;\\n\\t}\\n\\treturn sb.toString();\\n}\\n\\nprivate int kthSmallestPath(int[] destination, int y, int x, int[][] dp) {\\n\\tif (!isWithin(dp, y, x)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (y == destination[0] && x == destination[1]) {\\n\\t\\tdp[y][x] = 1;\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tif (dp[y][x] != 0) {\\n\\t\\treturn dp[y][x];\\n\\t}\\n\\n\\tdp[y][x] = kthSmallestPath(destination, y, x+1, dp) + kthSmallestPath(destination, y+1, x, dp);\\n\\treturn dp[y][x];\\n}\\n\\nprivate boolean isWithin(int[][] dp, int y, int x) {\\n\\treturn y >= 0 && y < dp.length && x >= 0 && x < dp[y].length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920467,
                "title": "rust-translated-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn helper(dp: &Vec<Vec<i32>>, mut i: usize, mut j: usize, k: usize, ans: &mut String) {\\n            if i == dp.len() - 1 {\\n                loop {\\n                    j += 1;\\n                    if j < dp[0].len() {\\n                        ans.push(\\'H\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if j == dp[0].len() - 1 {\\n                loop {\\n                    i += 1;\\n                    if i < dp.len() {\\n                        ans.push(\\'V\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if dp[i][j + 1] >= k as i32 {\\n                ans.push(\\'H\\');\\n                helper(dp, i, j + 1, k, ans);\\n            } else {\\n                ans.push(\\'V\\');\\n                helper(dp, i + 1, j, k - dp[i][j + 1] as usize, ans);\\n            }\\n        }\\n\\n        let m = destination[0] as usize;\\n        let n = destination[1] as usize;\\n        let mut dp = vec![vec![0; n + 1]; m + 1];\\n        for i in (0..m + 1).rev() {\\n            for j in (0..n + 1).rev() {\\n                if i == m && j == n {\\n                    dp[i][j] = 1;\\n                } else if i == m {\\n                    dp[i][j] = dp[i][j + 1];\\n                } else if j == n {\\n                    dp[i][j] = dp[i + 1][j];\\n                } else {\\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\\n                }\\n            }\\n        }\\n        let mut ans = String::new();\\n        helper(&dp, 0, 0, k as usize, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_kth_smallest_path() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 1),\\n            \"HHHVV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_02() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 2),\\n            \"HHVHV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_03() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 3),\\n            \"HHVVH\".to_owned()\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn helper(dp: &Vec<Vec<i32>>, mut i: usize, mut j: usize, k: usize, ans: &mut String) {\\n            if i == dp.len() - 1 {\\n                loop {\\n                    j += 1;\\n                    if j < dp[0].len() {\\n                        ans.push(\\'H\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if j == dp[0].len() - 1 {\\n                loop {\\n                    i += 1;\\n                    if i < dp.len() {\\n                        ans.push(\\'V\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if dp[i][j + 1] >= k as i32 {\\n                ans.push(\\'H\\');\\n                helper(dp, i, j + 1, k, ans);\\n            } else {\\n                ans.push(\\'V\\');\\n                helper(dp, i + 1, j, k - dp[i][j + 1] as usize, ans);\\n            }\\n        }\\n\\n        let m = destination[0] as usize;\\n        let n = destination[1] as usize;\\n        let mut dp = vec![vec![0; n + 1]; m + 1];\\n        for i in (0..m + 1).rev() {\\n            for j in (0..n + 1).rev() {\\n                if i == m && j == n {\\n                    dp[i][j] = 1;\\n                } else if i == m {\\n                    dp[i][j] = dp[i][j + 1];\\n                } else if j == n {\\n                    dp[i][j] = dp[i + 1][j];\\n                } else {\\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\\n                }\\n            }\\n        }\\n        let mut ans = String::new();\\n        helper(&dp, 0, 0, k as usize, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_kth_smallest_path() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 1),\\n            \"HHHVV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_02() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 2),\\n            \"HHVHV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_03() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 3),\\n            \"HHVVH\".to_owned()\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920395,
                "title": "java-combinatorics-math",
                "content": "```java\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int c = destination[1];\\n        int r = destination[0];\\n        \\n        StringBuilder res = new StringBuilder();\\n        while (r > 0 || c > 0) {\\n            if (r == 0) {\\n                res.append(\\'H\\');\\n                c--;\\n                continue;\\n            }\\n            if (c == 0) {\\n                res.append(\\'V\\');\\n                r--;\\n                continue;\\n            }\\n            double total = nCr(r, c - 1);\\n            if (k > total) {\\n                k -= total;\\n                res.append(\\'V\\');\\n                r--;\\n            } else {\\n                res.append(\\'H\\');\\n                c--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n    \\n    double nCr(int m, int n) {\\n        if (m > n) return nCr(n, m);\\n        double res = 1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            res = res * (m + n - i);\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            res /= i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int c = destination[1];\\n        int r = destination[0];\\n        \\n        StringBuilder res = new StringBuilder();\\n        while (r > 0 || c > 0) {\\n            if (r == 0) {\\n                res.append(\\'H\\');\\n                c--;\\n                continue;\\n            }\\n            if (c == 0) {\\n                res.append(\\'V\\');\\n                r--;\\n                continue;\\n            }\\n            double total = nCr(r, c - 1);\\n            if (k > total) {\\n                k -= total;\\n                res.append(\\'V\\');\\n                r--;\\n            } else {\\n                res.append(\\'H\\');\\n                c--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n    \\n    double nCr(int m, int n) {\\n        if (m > n) return nCr(n, m);\\n        double res = 1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            res = res * (m + n - i);\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            res /= i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920380,
                "title": "java-solution-bst-searching",
                "content": "1. build a 2D matrix to record number of path from point (x,y), e.g. for [2,3]\\n---------\\n10 6 3 1\\n 4  3 2 1\\n 1  1 1 1\\npoint (0, 1) has 6 paths 1st-6th\\npoint (1, 0) has 4 paths 7th-10th\\n\\nif k is 1-6, then should go right\\nif k is 7-10, then should go down, if going down, need to minus the right side point, and the problem converted to pick up the k-dp[i][j+1] from point (i+1, j)\\nJust like BST searching.\\n\\n```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    void f(int i, int j, int row, int col){\\n        if(i>=row || j>=col || dp[i][j]!=0) return;\\n        f(i+1, j, row, col);\\n        f(i, j+1, row, col);\\n        dp[i][j]=dp[i+1][j]+dp[i][j+1];\\n    }\\n\\n    public String kthSmallestPath(int[] d, int k) {\\n        \\n        int row = d[0]+1;\\n        int col = d[1]+1;\\n        dp = new int[row+1][col+1];\\n        dp[row-1][col-1]=1;\\n\\n        f(0, 0, row, col);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0, j=0; ;){\\n            if(i==row-1 && j==col-1) break;\\n            if(dp[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }  else {\\n                sb.append(\\'V\\');\\n                k-=dp[i++][j+1];\\n            }\\n        }\\n\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    void f(int i, int j, int row, int col){\\n        if(i>=row || j>=col || dp[i][j]!=0) return;\\n        f(i+1, j, row, col);\\n        f(i, j+1, row, col);\\n        dp[i][j]=dp[i+1][j]+dp[i][j+1];\\n    }\\n\\n    public String kthSmallestPath(int[] d, int k) {\\n        \\n        int row = d[0]+1;\\n        int col = d[1]+1;\\n        dp = new int[row+1][col+1];\\n        dp[row-1][col-1]=1;\\n\\n        f(0, 0, row, col);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0, j=0; ;){\\n            if(i==row-1 && j==col-1) break;\\n            if(dp[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }  else {\\n                sb.append(\\'V\\');\\n                k-=dp[i++][j+1];\\n            }\\n        }\\n\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920155,
                "title": "python-dp-solution-o-m-n",
                "content": "while choose V or H for each choice:\\neg: for first step choose, group order is like: ```[h...] < [v...] ```\\n=>we want to know which group the kth is in: first group or second group.\\nif numH<k,mean should choose [v...] group,k-=numH\\nso we want to pre-calculate numbers of group with prefix [...]. \\nif use combination formula to get C(m,n) for each m,n, cost O(n) to calculate (m*..*m-n+1)/n!,which will cost O(n*m*n) in total.\\ndp[m][n] is numbers of steps with m row and n cols.\\njust use dp[m][n]=dp[m][n-1]+dp[m-1][n], which cost O(m*n) in total to dp array.\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, des, k):\\n        V,H=des[0],des[1]\\n        dp=[[1]*(H+1) for _ in range(V+1)]\\n        for i in range(1,V+1):\\n            for j in range(1,H+1):\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]\\n        res=[]\\n        while V>0 and H>0:#go until there is only one kind of move. \\n            if dp[V][H-1]<k:\\n                k-=dp[V][H-1]\\n                res.append(\\'V\\')\\n                V-=1\\n            else:\\n                res.append(\\'H\\')\\n                H-=1\\n        for _ in range(V):\\n            res.append(\\'V\\')\\n        for _ in range(H):\\n            res.append(\\'H\\')\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "```[h...] < [v...] ```",
                "codeTag": "Unknown"
            },
            {
                "id": 919988,
                "title": "c-faster-than-100",
                "content": "The main idea is that at every timestep, we need to calculate how many paths we have after we choose \"H\" .\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int CombinationNum(int dx, int dy)\\n    {\\n        int all_step = dx + dy, product = 1;\\n        int start = max(dx, dy), m = min(dx, dy);\\n        for(int i=start+1, j=1; i<=all_step, j<= m; i++, j++)\\n        {\\n            product = product * i / j;\\n        }\\n        return product;\\n    }\\n    string traverse(vector<int> &destination, int k, int x, int y)\\n    {\\n        if(x == destination[0] && y == destination[1]) return \"\";\\n        \\n        int num = CombinationNum(destination[0] - x , destination[1] - y - 1);\\n        if(num >= k && y < destination[1])\\n            return traverse(destination, k, x, y+1) + \"H\";\\n        else\\n            return traverse(destination, k-num, x+1, y) + \"V\";\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ret = traverse(destination, k, 0, 0);\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int CombinationNum(int dx, int dy)\\n    {\\n        int all_step = dx + dy, product = 1;\\n        int start = max(dx, dy), m = min(dx, dy);\\n        for(int i=start+1, j=1; i<=all_step, j<= m; i++, j++)\\n        {\\n            product = product * i / j;\\n        }\\n        return product;\\n    }\\n    string traverse(vector<int> &destination, int k, int x, int y)\\n    {\\n        if(x == destination[0] && y == destination[1]) return \"\";\\n        \\n        int num = CombinationNum(destination[0] - x , destination[1] - y - 1);\\n        if(num >= k && y < destination[1])\\n            return traverse(destination, k, x, y+1) + \"H\";\\n        else\\n            return traverse(destination, k-num, x+1, y) + \"V\";\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ret = traverse(destination, k, 0, 0);\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919957,
                "title": "simple-javascript-combination-solution",
                "content": "if prefix of s is \\'V\\', the rank is at least \"combination of s with prefix \\'H\\' \"\\n```\\nlet kthSmallestPath = function(destination, k) {\\n\\tconst [V, H] = destination\\n\\tconst N = V + H\\n\\tlet s = \\'\\', n = N, v = V, h = H\\n\\twhile (s.length < N) {\\n\\t\\tlet c = p(n - 1, v)\\n\\t\\tif (h > 0 && c >= k) {\\n\\t\\t\\ts += \\'H\\'\\n\\t\\t\\th--\\n\\t\\t\\tn--\\n\\t\\t}else {\\n\\t\\t\\ts += \\'V\\'\\n\\t\\t\\tk -= c\\n\\t\\t\\tv--\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nfunction p(n, r) {\\n\\tlet base = 1\\n\\tfor (let i = r + 1; i <= n; i++) {\\n\\t\\tbase *= i\\n\\t}\\n\\tfor (let i = 1; i <= n - r; i++) {\\n\\t\\tbase /= i\\n\\t}\\n\\treturn base\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Combinatorics"
                ],
                "code": "```\\nlet kthSmallestPath = function(destination, k) {\\n\\tconst [V, H] = destination\\n\\tconst N = V + H\\n\\tlet s = \\'\\', n = N, v = V, h = H\\n\\twhile (s.length < N) {\\n\\t\\tlet c = p(n - 1, v)\\n\\t\\tif (h > 0 && c >= k) {\\n\\t\\t\\ts += \\'H\\'\\n\\t\\t\\th--\\n\\t\\t\\tn--\\n\\t\\t}else {\\n\\t\\t\\ts += \\'V\\'\\n\\t\\t\\tk -= c\\n\\t\\t\\tv--\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nfunction p(n, r) {\\n\\tlet base = 1\\n\\tfor (let i = r + 1; i <= n; i++) {\\n\\t\\tbase *= i\\n\\t}\\n\\tfor (let i = 1; i <= n - r; i++) {\\n\\t\\tbase /= i\\n\\t}\\n\\treturn base\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919926,
                "title": "c-combination-easy-to-understand",
                "content": "To get to the **destination(row, col)**, we can only take down step or right step. \\n**The total step is (row + col) with row \"V\" steps and col \"V\" steps;**  \\nIn those (row + col) oprations, we have to chose row\\'s operation to take down steps and the left are all right steps; \\nThe total possibale methods is nCr(row + col, row); We have to find kth smallest. \\n\\nObviously, the smallest must start with \"H\", the largerst must start with \"V\";\\nFor example with destination (2, 3), 2hen the first character is H, H**** represent  smallest nCr(2+3-1,2) combination. \\nwhen k <nCr(2+3-1,2), the first character must be \"H\" otherwise it is \"V\";\\nwe can iterative fill the string;\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int row = des[0], col = des[1];\\n        vector<vector<int>> comb(31, vector<int>(31, 0));\\n        comb[0][0] = comb[1][0] = comb[1][1] = 1;\\n        for(int i=2; i<=30;i++)  \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0||j==i)\\n                    comb[i][j] =1;\\n                else\\n                    comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\\n            }\\n        return fill(row, col, comb, k);\\n    }\\n    string fill(int row, int col, vector<vector<int>>&comb, int k)\\n    {\\n\\n        if(k==1||row==0||col==0)\\n            return string(col,\\'H\\') + string(row, \\'V\\');\\n        if(k==comb[row+col][row])\\n            return string(row, \\'V\\') + string(col, \\'H\\');\\n        if(k<=comb[row+col-1][row])\\n            return \"H\" + fill(row, col-1,comb, k);\\n        else\\n            return \"V\" + fill(row-1, col, comb, k-comb[row+col-1][row]);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int row = des[0], col = des[1];\\n        vector<vector<int>> comb(31, vector<int>(31, 0));\\n        comb[0][0] = comb[1][0] = comb[1][1] = 1;\\n        for(int i=2; i<=30;i++)  \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0||j==i)\\n                    comb[i][j] =1;\\n                else\\n                    comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\\n            }\\n        return fill(row, col, comb, k);\\n    }\\n    string fill(int row, int col, vector<vector<int>>&comb, int k)\\n    {\\n\\n        if(k==1||row==0||col==0)\\n            return string(col,\\'H\\') + string(row, \\'V\\');\\n        if(k==comb[row+col][row])\\n            return string(row, \\'V\\') + string(col, \\'H\\');\\n        if(k<=comb[row+col-1][row])\\n            return \"H\" + fill(row, col-1,comb, k);\\n        else\\n            return \"V\" + fill(row-1, col, comb, k-comb[row+col-1][row]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919843,
                "title": "simple-c-using-combination-table-4ms-beat-100",
                "content": "```\\nstring kthSmallestPath_(int left, int k, vector<vector<int>>& comTable, const int& tot) {\\n\\n\\tif (left == 0) return string(tot, \\'H\\');\\n\\n\\tint pos = tot - left;\\n\\n\\tstring res;\\n\\n\\tfor (; pos >= 0; --pos) {\\n\\n\\t\\tif (comTable[tot - pos - 1][left - 1] >= k) {\\n\\t\\t\\tres = kthSmallestPath_(left - 1, k, comTable, tot);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tk -= comTable[tot - pos - 1][left - 1];\\n\\n\\t}\\n\\n\\tres[pos] = \\'V\\';\\n\\n\\treturn res;\\n}\\n\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n\\n\\tint tot = destination[0] + destination[1];\\n\\tvector<vector<int>> comTable(tot + 1, vector<int>(tot + 1, 0));\\n\\n\\n\\tfor (int i = 0; i <= tot; ++i) {\\n\\t\\tcomTable[i][0] = 1;\\n\\t\\tcomTable[i][i] = 1;\\n\\t\\tfor (int j = 1; j < i; ++j) {\\n\\t\\t\\tcomTable[i][j] = comTable[i - 1][j - 1] + comTable[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn kthSmallestPath_(destination[0], k, comTable, tot);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring kthSmallestPath_(int left, int k, vector<vector<int>>& comTable, const int& tot) {\\n\\n\\tif (left == 0) return string(tot, \\'H\\');\\n\\n\\tint pos = tot - left;\\n\\n\\tstring res;\\n\\n\\tfor (; pos >= 0; --pos) {\\n\\n\\t\\tif (comTable[tot - pos - 1][left - 1] >= k) {\\n\\t\\t\\tres = kthSmallestPath_(left - 1, k, comTable, tot);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tk -= comTable[tot - pos - 1][left - 1];\\n\\n\\t}\\n\\n\\tres[pos] = \\'V\\';\\n\\n\\treturn res;\\n}\\n\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n\\n\\tint tot = destination[0] + destination[1];\\n\\tvector<vector<int>> comTable(tot + 1, vector<int>(tot + 1, 0));\\n\\n\\n\\tfor (int i = 0; i <= tot; ++i) {\\n\\t\\tcomTable[i][0] = 1;\\n\\t\\tcomTable[i][i] = 1;\\n\\t\\tfor (int j = 1; j < i; ++j) {\\n\\t\\t\\tcomTable[i][j] = comTable[i - 1][j - 1] + comTable[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn kthSmallestPath_(destination[0], k, comTable, tot);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919797,
                "title": "c-o-r-c-solution-max-of-r-c-30",
                "content": "binomialCombination taken from G F G. Apologies.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int binomialCoeff(int n, int k)\\n    {\\n        dp.resize(n+1, vector<int>(k+1, 0));\\n        int i, j;\\n        for (i = 0; i <= n; i++)\\n        {\\n            for (j = 0; j <= min(i, k); j++)\\n            {\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n\\n                else\\n                    dp[i][j] = dp[i - 1][j - 1] +\\n                              dp[i - 1][j];\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        binomialCoeff(30, 15);\\n        int nH = dest[1]-0;\\n        int nV = dest[0]-0;\\n        string ans = \"\";\\n        while (nH!=0 && nV!=0){\\n            if (dp[nH+nV-1][nV]>=k){\\n                nH--;\\n                ans+=\"H\";\\n            }\\n            else{\\n                k-=dp[nH+nV-1][nV];\\n                nV--;\\n                ans+=\"V\";\\n            }\\n            if (dp[nH+nV][nV]==k){\\n                while (nV){\\n                    ans+=\"V\"; nV--;\\n                }\\n        \\n                while (nH){\\n                    ans+=\"H\"; nH--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        while (nH){\\n            ans+=\"H\"; nH--;\\n        }\\n        \\n        while (nV){\\n            ans+=\"V\"; nV--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int binomialCoeff(int n, int k)\\n    {\\n        dp.resize(n+1, vector<int>(k+1, 0));\\n        int i, j;\\n        for (i = 0; i <= n; i++)\\n        {\\n            for (j = 0; j <= min(i, k); j++)\\n            {\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n\\n                else\\n                    dp[i][j] = dp[i - 1][j - 1] +\\n                              dp[i - 1][j];\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        binomialCoeff(30, 15);\\n        int nH = dest[1]-0;\\n        int nV = dest[0]-0;\\n        string ans = \"\";\\n        while (nH!=0 && nV!=0){\\n            if (dp[nH+nV-1][nV]>=k){\\n                nH--;\\n                ans+=\"H\";\\n            }\\n            else{\\n                k-=dp[nH+nV-1][nV];\\n                nV--;\\n                ans+=\"V\";\\n            }\\n            if (dp[nH+nV][nV]==k){\\n                while (nV){\\n                    ans+=\"V\"; nV--;\\n                }\\n        \\n                while (nH){\\n                    ans+=\"H\"; nH--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        while (nH){\\n            ans+=\"H\"; nH--;\\n        }\\n        \\n        while (nV){\\n            ans+=\"V\"; nV--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919573,
                "title": "java-greedy-path-construction-faster-than-100",
                "content": "We need to arrange `numH` H\\'s and `numV` V\\'s into a single string named `path`.\\n\\nIt must be lexicographically later than `k - 1` such strings. (That is, we should skip `k - 1` prior strings as we construct `path`.)\\n\\nWe will construct `path` left-to-right through sequence of `numH + numV` choices.\\n\\n**Key Ideas:** \\n1. Each time we choose a V for the next position, we *skip* all the lexicographically prior `path`\\'s with an H in that position. \\n2.  There are `skips = binom(numH + numV - 1, numH - 1)` such `path`\\'s.\\n3.  So each choice of V reduces the number of remaining skips to `k - 1 -  skips`.\\n4.  The conclusion is that we should choose a V iff `skips <= k - 1`; equivalently, `skips < k` or `!(skips >= k)`.\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int vsLeft = d[0], hsLeft = d[1];\\n        int allLeft = vsLeft + hsLeft;\\n        \\n        var path = new StringBuilder();\\n        while (allLeft > 0) {\\n            if (hsLeft > 0 && k <= binom[allLeft - 1][hsLeft - 1]) {\\n                path.append(\\'H\\');\\n                hsLeft--;\\n            } else {\\n                path.append(\\'V\\');\\n                if (hsLeft > 0) {\\n                    k -= binom[allLeft - 1][hsLeft - 1];\\n                }\\n                vsLeft--;\\n            }\\n            allLeft--;\\n        }\\n        return path.toString();\\n    }\\n    \\n    private static int[][] binom = new int[31][31];\\n    \\n    static {\\n        for (int i = 0; i <= 30; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    binom[i][j] = 1;\\n                } else {\\n                    binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int vsLeft = d[0], hsLeft = d[1];\\n        int allLeft = vsLeft + hsLeft;\\n        \\n        var path = new StringBuilder();\\n        while (allLeft > 0) {\\n            if (hsLeft > 0 && k <= binom[allLeft - 1][hsLeft - 1]) {\\n                path.append(\\'H\\');\\n                hsLeft--;\\n            } else {\\n                path.append(\\'V\\');\\n                if (hsLeft > 0) {\\n                    k -= binom[allLeft - 1][hsLeft - 1];\\n                }\\n                vsLeft--;\\n            }\\n            allLeft--;\\n        }\\n        return path.toString();\\n    }\\n    \\n    private static int[][] binom = new int[31][31];\\n    \\n    static {\\n        for (int i = 0; i <= 30; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    binom[i][j] = 1;\\n                } else {\\n                    binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919547,
                "title": "python3-very-simple-recursion",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        nV, nH = destination\\n        \\n        if nV == 0:\\n            return \"H\" * nH\\n        if nH == 0:\\n            return \"V\" * nV\\n        \\n        n_begin_with_H = comb(nH - 1 + nV,nV) \\n        \\n        if k <= n_begin_with_H:\\n            return \"H\" + self.kthSmallestPath([nV,nH-1],k)\\n        else:\\n            return \"V\" + self.kthSmallestPath([nV-1,nH],k - n_begin_with_H)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        nV, nH = destination\\n        \\n        if nV == 0:\\n            return \"H\" * nH\\n        if nH == 0:\\n            return \"V\" * nV\\n        \\n        n_begin_with_H = comb(nH - 1 + nV,nV) \\n        \\n        if k <= n_begin_with_H:\\n            return \"H\" + self.kthSmallestPath([nV,nH-1],k)\\n        else:\\n            return \"V\" + self.kthSmallestPath([nV-1,nH],k - n_begin_with_H)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919465,
                "title": "python-greedy-math-recursion-o-mn-o-1-thoughts-beats-100-100",
                "content": "**Analysis :** \\n\\n1. When I first get this question, `kth + LexiOrder` gives me the idea of `greedy + dfs (Greedily add H as priority)` . However, this will be brute force and can go up to O(2**mn) time complexity which is not acceptable.\\n\\n2. Then the next thing jumped into my mind is see whether I can use `DFS + Memo` to lower down the time complexity. So I have to write down several examples to see if I can find a `pattern (Transition equation)`\\n\\n\\n**Thoughts :** \\n\\nFor DP, naturally you will try to find pattern, then I start to write :  `(2, 3)` as example\\n\\n`[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].`\\n\\nWith letters it might not be so obvious, `but It looks very similar to binary string`\\n\\n`11100, 11010. 11001, 10101, 10011, 01110.... so on so forth.`\\n\\n**Pattern**\\n\\nThen we find the pattern. \\nIt is using greedy thinking to put all `1` or `H` as early as possible and whole question can be translate into \\n\\n`Find Kth largest number that made up with 0 and 1`.\\n\\nSo we can using recursion to solve it easily. \\n\\n1. We can divide a big problem into a tree structure sub problems\\n\\n ```\\n     xxxxx\\n1xxxx + 0xxxx\\n....................\\n```\\n\\n\\n2. The total combination of subproblem `(1xxxx) = count Factorial of current `H` and `V` left (Math)`\\n3. if K is larger than the all combination started with `H` , then the current index should use `V` \\nso on so forth.\\n\\n\\n\\n**Full Answer**\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        Hcount, Vcount = destination[1], destination[0]\\n        self.res = \\'\\'\\n        self.calculate(Hcount, Vcount, k)\\n        return self.res\\n    \\n    def calculate(self, Hcount, Vcount, k):\\n        \\n        if Hcount == 0:\\n            self.res = self.res + Vcount*\"V\"\\n            return\\n        elif Vcount == 0:\\n            self.res = self.res + Hcount*\"H\"\\n            return \\n        \\n        comboStartWithH = self.countFactorial(Hcount-1+Vcount)/(self.countFactorial(Hcount-1)*self.countFactorial(Vcount))\\n        if comboStartWithH >= k:\\n            self.res += \\'H\\'\\n            self.calculate(Hcount-1, Vcount, k)\\n        else:\\n            self.res += \\'V\\'\\n            self.calculate(Hcount, Vcount-1, k-comboStartWithH)\\n            \\n    \\n    def countFactorial(self, num):\\n        res = 1\\n        for i in range(1, num + 1):\\n            res = res * i\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n     xxxxx\\n1xxxx + 0xxxx\\n....................\\n```\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        Hcount, Vcount = destination[1], destination[0]\\n        self.res = \\'\\'\\n        self.calculate(Hcount, Vcount, k)\\n        return self.res\\n    \\n    def calculate(self, Hcount, Vcount, k):\\n        \\n        if Hcount == 0:\\n            self.res = self.res + Vcount*\"V\"\\n            return\\n        elif Vcount == 0:\\n            self.res = self.res + Hcount*\"H\"\\n            return \\n        \\n        comboStartWithH = self.countFactorial(Hcount-1+Vcount)/(self.countFactorial(Hcount-1)*self.countFactorial(Vcount))\\n        if comboStartWithH >= k:\\n            self.res += \\'H\\'\\n            self.calculate(Hcount-1, Vcount, k)\\n        else:\\n            self.res += \\'V\\'\\n            self.calculate(Hcount, Vcount-1, k-comboStartWithH)\\n            \\n    \\n    def countFactorial(self, num):\\n        res = 1\\n        for i in range(1, num + 1):\\n            res = res * i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919305,
                "title": "c-after-thinking-about-the-combinatorics-method-i-finnaly-get-the-idea",
                "content": "```\\nlong long nCr(vector<long long>& factorial, int n, int k) {\\n    if (n <= 20) return factorial[n] / (factorial[k] * factorial[n - k]);\\n    else {\\n        long long numerator = 1;\\n        for (int i = max(k, n - k) + 1; i <= n ; i++) numerator *= i;\\n        return numerator / factorial[min(k, n - k)];\\n    }\\n}\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n    int v = destination[0], h = destination[1], cur = k;\\n    vector<long long> factorial(min(20, h + v + 1) + 1, 1);  // factorial[n] = n!\\n    string res = \"\";\\n    for (int i = 1; i <= min(20, h + v + 1); i++) factorial[i] = i * factorial[i - 1];\\n    while (h > 0 || v > 0) {\\n        if (!v || !h) {\\n            res += string(h, \\'H\\') + string(v, \\'V\\');\\n            break;\\n        }\\n        if (cur > nCr(factorial, h + v - 1, h - 1)) {\\n            cur -= nCr(factorial, h + v - 1, h - 1);\\n            res += \\'V\\';\\n            v--;\\n        }\\n        else {\\n            res += \\'H\\';\\n            h--;\\n        }\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "```\\nlong long nCr(vector<long long>& factorial, int n, int k) {\\n    if (n <= 20) return factorial[n] / (factorial[k] * factorial[n - k]);\\n    else {\\n        long long numerator = 1;\\n        for (int i = max(k, n - k) + 1; i <= n ; i++) numerator *= i;\\n        return numerator / factorial[min(k, n - k)];\\n    }\\n}\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n    int v = destination[0], h = destination[1], cur = k;\\n    vector<long long> factorial(min(20, h + v + 1) + 1, 1);  // factorial[n] = n!\\n    string res = \"\";\\n    for (int i = 1; i <= min(20, h + v + 1); i++) factorial[i] = i * factorial[i - 1];\\n    while (h > 0 || v > 0) {\\n        if (!v || !h) {\\n            res += string(h, \\'H\\') + string(v, \\'V\\');\\n            break;\\n        }\\n        if (cur > nCr(factorial, h + v - 1, h - 1)) {\\n            cur -= nCr(factorial, h + v - 1, h - 1);\\n            res += \\'V\\';\\n            v--;\\n        }\\n        else {\\n            res += \\'H\\';\\n            h--;\\n        }\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 919265,
                "title": "why-is-the-following-simple-code-throwing-me-a-run-time-error",
                "content": "#define ll int\\n#define pb push_back\\nll dx[2]={0, 1};\\nll dy[2]={1, 0};\\nclass Solution {\\npublic:\\n    \\n    void  update(string str, ll sx, ll sy, ll ex, ll ey,vector<string>& arr , vector<vector<bool>> vis)\\n    {\\n        \\n        \\n        if(sx==ex && sy==ey)\\n        {\\n            arr.pb(str);\\n            return ;\\n          \\n        }\\n        vis[sx][sy]=1;\\n        for(ll i=0;i<2;i++)\\n        {\\n            \\n            ll nx=sx+dx[i];\\n            ll ny=sy+dy[i];\\n            \\n            if(nx>ex || ny>ey || vis[nx][ny])\\n                continue;\\n            \\n            if(i==0)\\n            {\\n              update(str+\"H\", nx, ny, ex, ey, arr, vis);  \\n            }\\n            else\\n            {\\n               update(str+\"V\", nx, ny, ex, ey, arr, vis); \\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        ll ex=destination[0];\\n        ll ey=destination[1];\\n        \\n        ll sx=0, sy=0;\\n        \\n        vector<string> arr;\\n        \\n        string str=\"\";\\n        \\n        vector<vector<bool>>vis(ex, vector<bool>(ey, 0));\\n        \\n        update(str, sx, sy, ex, ey, arr, vis);\\n        \\n        \\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        return arr[k-1];\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void  update(string str, ll sx, ll sy, ll ex, ll ey,vector<string>& arr , vector<vector<bool>> vis)\\n    {\\n        \\n        \\n        if(sx==ex && sy==ey)\\n        {\\n            arr.pb(str);\\n            return ;\\n          \\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2038121,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            },
            {
                "id": 1949680,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            },
            {
                "id": 1766594,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            }
        ]
    }
]