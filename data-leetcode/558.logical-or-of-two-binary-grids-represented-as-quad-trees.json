[
    {
        "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
        "question_content": "A Binary Matrix is a matrix in which all the elements are either 0 or 1.\nGiven quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix.\nReturn a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2.\nNotice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\n\tval: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n\tisLeaf: True if the node is leaf node on the tree or False if the node has the four children.\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\n\tIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\n\tIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\n\tRecurse for each of the children with the proper sub-grid.\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nThe input/output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\n&nbsp;\nExample 1:\n \nInput: quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nOutput: [[0,0],[1,1],[1,1],[1,1],[1,0]]\nExplanation: quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree.\nIf we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree.\nNotice that the binary matrices shown are only for illustration, you don't have to construct the binary matrix to get the result tree.\n\nExample 2:\n\nInput: quadTree1 = [[1,0]], quadTree2 = [[1,0]]\nOutput: [[1,0]]\nExplanation: Each tree represents a binary matrix of size 1*1. Each matrix contains only zero.\nThe resulting matrix is of size 1*1 with also zero.\n\n&nbsp;\nConstraints:\n\n\tquadTree1 and quadTree2 are both valid Quad-Trees each representing a n * n grid.\n\tn == 2x where 0 <= x <= 9.",
        "solutions": [
            {
                "id": 151802,
                "title": "python-simple-short-readable-ac-solution",
                "content": "```\\nclass Solution:\\n    def intersect(self, q1, q2):\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersect(self, q1, q2):\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152730,
                "title": "c-10-line-beat-100",
                "content": "```\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf && quadTree1->val) return quadTree1;\\n        if(quadTree2->isLeaf && quadTree2->val) return quadTree2;\\n        if(quadTree1->isLeaf && !quadTree1->val) return quadTree2;\\n        if(quadTree2->isLeaf && !quadTree2->val) return quadTree1;     \\n        \\n        auto tl = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        auto tr = intersect(quadTree1->topRight, quadTree2->topRight);\\n        auto bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        auto br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if(tl->val == tr->val && tl->val == bl->val && tl->val == br->val && tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf)\\n            return new Node(tl->val, true, nullptr, nullptr, nullptr, nullptr);\\n        else         \\n            return new Node(false, false, tl, tr, bl, br);\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf && quadTree1->val) return quadTree1;\\n        if(quadTree2->isLeaf && quadTree2->val) return quadTree2;\\n        if(quadTree1->isLeaf && !quadTree1->val) return quadTree2;\\n        if(quadTree2->isLeaf && !quadTree2->val) return quadTree1;     \\n        \\n        auto tl = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        auto tr = intersect(quadTree1->topRight, quadTree2->topRight);\\n        auto bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        auto br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if(tl->val == tr->val && tl->val == bl->val && tl->val == br->val && tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf)\\n            return new Node(tl->val, true, nullptr, nullptr, nullptr, nullptr);\\n        else         \\n            return new Node(false, false, tl, tr, bl, br);\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 153964,
                "title": "python-solution-to-a-badly-worded-question",
                "content": "Information required but not in problem description: the val attribute for a non-leaf node is False.\\n\\nCombine two leaves according the logical OR of their values.\\nIf one node is a leaf then return it if it is True, else return the other node.\\nIf neither are leaves, intersect each of the 4 subtree children and return a leaf if they are all leaves with the same value, or else return a non-leaf with value of False.\\n\\n```\\n    def intersect(self, quadTree1, quadTree2):\\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n\\n        children = [topLeft, topRight, bottomLeft, bottomRight]\\n        values = [child.val for child in children]\\n        leaves = [child.isLeaf for child in children]\\n\\n        if all(leaves) and (sum(values) == 0 or sum(values) == 4):\\n            return Node(topLeft.val, True, None, None, None, None)\\n\\n        # non-leaf must have False val\\n        return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\\n```",
                "solutionTags": [],
                "code": "```\\n    def intersect(self, quadTree1, quadTree2):\\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n\\n        children = [topLeft, topRight, bottomLeft, bottomRight]\\n        values = [child.val for child in children]\\n        leaves = [child.isLeaf for child in children]\\n\\n        if all(leaves) and (sum(values) == 0 or sum(values) == 4):\\n            return Node(topLeft.val, True, None, None, None, None)\\n\\n        # non-leaf must have False val\\n        return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 157532,
                "title": "java-concise-code-beat-100",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if (q1.isLeaf) {\\n            return q1.val ? q1 : q2;\\n        }\\n        if (q2.isLeaf) {\\n            return q2.val ? q2 : q1;\\n        }\\n        \\n        q1.topLeft = intersect(q1.topLeft, q2.topLeft);\\n        q1.topRight = intersect(q1.topRight, q2.topRight);\\n        q1.bottomLeft = intersect(q1.bottomLeft, q2.bottomLeft);\\n        q1.bottomRight = intersect(q1.bottomRight, q2.bottomRight);\\n        \\n        if (q1.topLeft.isLeaf && q1.topRight.isLeaf \\n            && q1.bottomLeft.isLeaf && q1.bottomRight.isLeaf\\n            && q1.topLeft.val == q1.topRight.val \\n            && q1.topRight.val == q1.bottomLeft.val \\n            && q1.bottomLeft.val == q1.bottomRight.val) {\\n            q1.isLeaf = true;\\n            q1.val = q1.topLeft.val;\\n        }\\n        return q1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if (q1.isLeaf) {\\n            return q1.val ? q1 : q2;\\n        }\\n        if (q2.isLeaf) {\\n            return q2.val ? q2 : q1;\\n        }\\n        \\n        q1.topLeft = intersect(q1.topLeft, q2.topLeft);\\n        q1.topRight = intersect(q1.topRight, q2.topRight);\\n        q1.bottomLeft = intersect(q1.bottomLeft, q2.bottomLeft);\\n        q1.bottomRight = intersect(q1.bottomRight, q2.bottomRight);\\n        \\n        if (q1.topLeft.isLeaf && q1.topRight.isLeaf \\n            && q1.bottomLeft.isLeaf && q1.bottomRight.isLeaf\\n            && q1.topLeft.val == q1.topRight.val \\n            && q1.topRight.val == q1.bottomLeft.val \\n            && q1.bottomLeft.val == q1.bottomRight.val) {\\n            q1.isLeaf = true;\\n            q1.val = q1.topLeft.val;\\n        }\\n        return q1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249072,
                "title": "readable-java-beats-100",
                "content": "```\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        // Terminal condition, when any of two is leaf.\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n        // Recurse in all 4 directions.\\n        Node tl = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr = intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        // Detect a merger state when all 4 leaves have same value.\\n        if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && tl.val == tr.val && bl.val == br.val && tl.val == bl.val) {\\n            return new Node(tl.val, true, null, null, null, null);\\n        } else {\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        // Terminal condition, when any of two is leaf.\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n        // Recurse in all 4 directions.\\n        Node tl = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr = intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        // Detect a merger state when all 4 leaves have same value.\\n        if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && tl.val == tr.val && bl.val == br.val && tl.val == bl.val) {\\n            return new Node(tl.val, true, null, null, null, null);\\n        } else {\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328437,
                "title": "python-stupid-approach-beats-97-with-more-examples-and-explanation",
                "content": "```py\\n\"\"\"\\n1st approach: recursive dfs\\n- my intuitive approach is just to dfs the trees BUT we need to consider 2 corner cases:\\n\\t- e.g.2 a false leaf BUT its counterpart is a QTree\\n\\t- e.g.3 all children have the same values\\n- actually i am not sure what \\'val\\' should i return if it is not a leaf, therefore i put None and leetcode ACCEPTED it lol\\n\\n\\ne.g. 1\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       | F | F |  |       |       |\\n|   T   |   T   |  |   T   +---+---+  |   T   |   T   |\\n|       |       |  |       | T | T |  |       |       |\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |       |       |\\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\\n|       |       |  |       |       |  |       |       |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\ne.g.2\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       | F | F |  |       | F | F |\\n|   T   |   F   |  |   T   +---+---+  |   T   |---+---+ \\n|       |       |  |       | T | T |  |       | T | T |\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |       |       |\\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\\n|       |       |  |       |       |  |       |       |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\ne.g.3\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |               |\\n|   T   |   T   |  |   T   |   T   |  |               |\\n|       |       |  |       |       |  |               |\\n+-------+-------+  +-------+---+---+  +       T       |\\n|       |       |  |       |       |  |               |\\n|   F   |   T   |  |   T   |   T   |  |               |\\n|       |       |  |       |       |  |               |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\nTime    O(m+n) <= we just need to visit all nodes at most once\\nSpace   O(m+n) <= the new QTree\\n220 ms, faster than 97.22%\\n\"\"\"\\n\\n\\nclass Solution(object):\\n    def intersect(self, t1, t2):\\n        if t1.isLeaf and t2.isLeaf:\\n            return Node(t1.val or t2.val, True, None, None, None, None)\\n        elif t1.isLeaf:\\n            if t1.val == True:\\n                return Node(True, True, None, None, None, None) # e.g.1\\n            else:\\n                return t2 # e.g.2\\n        elif t2.isLeaf:\\n            if t2.val == True:\\n                return Node(True, True, None, None, None, None) # e.g.1\\n            else:\\n                return t1 # e.g.2\\n        else:\\n            a = self.intersect(t1.topLeft, t2.topLeft)\\n            b = self.intersect(t1.topRight, t2.topRight)\\n            c = self.intersect(t1.bottomLeft, t2.bottomLeft)\\n            d = self.intersect(t1.bottomRight, t2.bottomRight)\\n            # e.g.3 if all children have the same value, merge them into one node\\n            if a.isLeaf and b.isLeaf and c.isLeaf and d.isLeaf:\\n                total = a.val + b.val + c.val + d.val # in python2.x, boolean is a subclass of integer\\n                if total == 4:\\n                    return Node(True, True, None, None, None, None)\\n                elif total == 0:\\n                    return Node(False, True, None, None, None, None)\\n            # else, keep 4 children\\n            return Node(None, False, a, b, c, d)\\n\\n    def dfs(self, t):\\n        if t == None:\\n            return False\\n        if t.isLeaf:\\n            return t.val\\n        return self.dfs(t.topLeft) or\\\\\\n            self.dfs(t.topRight) or\\\\\\n            self.dfs(t.bottomLeft) or\\\\\\n            self.dfs(t.bottomRight)\\n```",
                "solutionTags": [],
                "code": "```py\\n\"\"\"\\n1st approach: recursive dfs\\n- my intuitive approach is just to dfs the trees BUT we need to consider 2 corner cases:\\n\\t- e.g.2 a false leaf BUT its counterpart is a QTree\\n\\t- e.g.3 all children have the same values\\n- actually i am not sure what \\'val\\' should i return if it is not a leaf, therefore i put None and leetcode ACCEPTED it lol\\n\\n\\ne.g. 1\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       | F | F |  |       |       |\\n|   T   |   T   |  |   T   +---+---+  |   T   |   T   |\\n|       |       |  |       | T | T |  |       |       |\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |       |       |\\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\\n|       |       |  |       |       |  |       |       |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\ne.g.2\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       | F | F |  |       | F | F |\\n|   T   |   F   |  |   T   +---+---+  |   T   |---+---+ \\n|       |       |  |       | T | T |  |       | T | T |\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |       |       |\\n|   F   |   F   |  |   T   |   F   |  |   T   |   F   |\\n|       |       |  |       |       |  |       |       |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\ne.g.3\\nA:                 B:                 C (A or B):\\n+-------+-------+  +-------+---+---+  +-------+-------+\\n|       |       |  |       |       |  |               |\\n|   T   |   T   |  |   T   |   T   |  |               |\\n|       |       |  |       |       |  |               |\\n+-------+-------+  +-------+---+---+  +       T       |\\n|       |       |  |       |       |  |               |\\n|   F   |   T   |  |   T   |   T   |  |               |\\n|       |       |  |       |       |  |               |\\n+-------+-------+  +-------+-------+  +-------+-------+\\n\\nTime    O(m+n) <= we just need to visit all nodes at most once\\nSpace   O(m+n) <= the new QTree\\n220 ms, faster than 97.22%\\n\"\"\"\\n\\n\\nclass Solution(object):\\n    def intersect(self, t1, t2):\\n        if t1.isLeaf and t2.isLeaf:\\n            return Node(t1.val or t2.val, True, None, None, None, None)\\n        elif t1.isLeaf:\\n            if t1.val == True:\\n                return Node(True, True, None, None, None, None) # e.g.1\\n            else:\\n                return t2 # e.g.2\\n        elif t2.isLeaf:\\n            if t2.val == True:\\n                return Node(True, True, None, None, None, None) # e.g.1\\n            else:\\n                return t1 # e.g.2\\n        else:\\n            a = self.intersect(t1.topLeft, t2.topLeft)\\n            b = self.intersect(t1.topRight, t2.topRight)\\n            c = self.intersect(t1.bottomLeft, t2.bottomLeft)\\n            d = self.intersect(t1.bottomRight, t2.bottomRight)\\n            # e.g.3 if all children have the same value, merge them into one node\\n            if a.isLeaf and b.isLeaf and c.isLeaf and d.isLeaf:\\n                total = a.val + b.val + c.val + d.val # in python2.x, boolean is a subclass of integer\\n                if total == 4:\\n                    return Node(True, True, None, None, None, None)\\n                elif total == 0:\\n                    return Node(False, True, None, None, None, None)\\n            # else, keep 4 children\\n            return Node(None, False, a, b, c, d)\\n\\n    def dfs(self, t):\\n        if t == None:\\n            return False\\n        if t.isLeaf:\\n            return t.val\\n        return self.dfs(t.topLeft) or\\\\\\n            self.dfs(t.topRight) or\\\\\\n            self.dfs(t.bottomLeft) or\\\\\\n            self.dfs(t.bottomRight)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148732,
                "title": "fixed-incorrect-test-cases",
                "content": "For example\\n```\\n A =\\n {\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"val\":false\\n}\\nB = \\n{\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"val\":false\\n}\\n\\nExpected =\\n{\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"val\":true\\n}\\n```\\n\\nSurely the answer should be a single, true, leaf node?",
                "solutionTags": [],
                "code": "```\\n A =\\n {\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"val\":false\\n}\\nB = \\n{\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"val\":false\\n}\\n\\nExpected =\\n{\\n  \"$id\":\"1\",\\n  \"bottomLeft\":{\"$id\":\"4\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"bottomRight\":{\"$id\":\"5\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":false},\\n  \"isLeaf\":false,\\n  \"topLeft\":{\"$id\":\"2\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"topRight\":{\"$id\":\"3\",\"bottomLeft\":null,\"bottomRight\":null,\"isLeaf\":true,\"topLeft\":null,\"topRight\":null,\"val\":true},\\n  \"val\":true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298769,
                "title": "558-time-99-4-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if either quadTree1 or quadTree2 is a leaf node. If quadTree1 is a leaf node, return quadTree1 if its value is True, else return quadTree2. If quadTree2 is a leaf node, return quadTree2 if its value is True, else return quadTree1.\\n2. Recursively check the intersection of each child node of quadTree1 and quadTree2 by calling the intersect function on each of them. Store the return values in variables tl (top-left), tr (top-right), bl (bottom-left), and br (bottom-right).\\n3. Check if all four child nodes (tl, tr, bl, br) are leaves and have the same value. If yes, create a new leaf node with the same value and return it.\\n4. If any of the child nodes have a different value or are not leaf nodes, create a new internal node with the four child nodes as its children and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        # If either of the trees is a leaf node, return the appropriate tree\\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n        \\n        # Recursively check the intersection of each child node\\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        # If all four child nodes are leaves with the same value, return a new leaf node\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n            return Node(tl.val, True, None, None, None, None)\\n        \\n        # Otherwise, return a new internal node with the four child nodes as children\\n        return Node(None, False, tl, tr, bl, br)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        # If either of the trees is a leaf node, return the appropriate tree\\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n        \\n        # Recursively check the intersection of each child node\\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        # If all four child nodes are leaves with the same value, return a new leaf node\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n            return Node(tl.val, True, None, None, None, None)\\n        \\n        # Otherwise, return a new internal node with the four child nodes as children\\n        return Node(None, False, tl, tr, bl, br)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508954,
                "title": "c-simple-intuitive-approach-100-faster-explanation",
                "content": "First things first... What is Bitwise OR of 2 digits?\\n `0 OR 0 -> 0`\\n `0 OR 1 -> 1`\\n `1 OR 0 -> 1`\\n `1 OR 1 -> 1`\\nWow, we can see that if any one of our LeafNode has value 1 then our BITWISE OR is gonna be 1 for that Grid.\\n\\nOkay this is cool if both QuadNodes are LeafNode... But what if a QuadNode is a leafNode but the other one is not?\\nLet us assume  `q1` be the LeafNode and `q2` is not a LeafNode\\n\\nPossible Cases:\\n\\t1. `q1` node has value `1` - Hurray we know that if any grid has value 1 then our resulant grid Node is also gonna have value 1\\n\\t2. `q1` node has value `0` - Well in this case we know that, `0 OR Something` is always going to be that `Something`. Therefore we are safe to say that, our resultant grid Node will always be same as `q2` QuadNode.\\n\\nTherefore, by keeping these points in mind we recursively break down the Quad Trees until we have atlease one LeafNode. And based on that LeafNode we build up our Quad BITWISE OR tree.\\n\\nHere\\'s the code for your help\\n\\n```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n            return new Node(quadTree1->val || quadTree2->val, true);\\n        }\\n        if (quadTree1->isLeaf) {\\n            if (quadTree1->val) return quadTree1;\\n            return quadTree2;\\n        } \\n        if (quadTree2->isLeaf) {\\n            if (quadTree2->val) return quadTree2;\\n            return quadTree1;\\n        }\\n        \\n        Node *topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        Node *topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        Node *bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        Node *bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        Node *newnode = new Node();\\n        \\n        if (topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf && topLeft->val == topRight->val && bottomLeft->val == bottomRight->val && topLeft->val == bottomRight->val) {\\n            newnode->isLeaf = true;\\n            newnode->val = topLeft->val;\\n        } else {\\n            newnode->topLeft = topLeft;\\n            newnode->topRight = topRight;\\n            newnode->bottomLeft = bottomLeft;\\n            newnode->bottomRight = bottomRight;\\n        }\\n        \\n        return newnode;\\n    }\\n};\\n```\\n\\nAnd as mentioned in the Header, here\\'s the proof \\n![image](https://assets.leetcode.com/users/images/6c66a0cb-149a-4df8-bde7-b1bea129f9f2_1633627455.1166697.png)\\n\\nMake sure to give a vote to this post if you liked it!\\n\\nThank You \\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n            return new Node(quadTree1->val || quadTree2->val, true);\\n        }\\n        if (quadTree1->isLeaf) {\\n            if (quadTree1->val) return quadTree1;\\n            return quadTree2;\\n        } \\n        if (quadTree2->isLeaf) {\\n            if (quadTree2->val) return quadTree2;\\n            return quadTree1;\\n        }\\n        \\n        Node *topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        Node *topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        Node *bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        Node *bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        Node *newnode = new Node();\\n        \\n        if (topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf && topLeft->val == topRight->val && bottomLeft->val == bottomRight->val && topLeft->val == bottomRight->val) {\\n            newnode->isLeaf = true;\\n            newnode->val = topLeft->val;\\n        } else {\\n            newnode->topLeft = topLeft;\\n            newnode->topRight = topRight;\\n            newnode->bottomLeft = bottomLeft;\\n            newnode->bottomRight = bottomRight;\\n        }\\n        \\n        return newnode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156156,
                "title": "java-recursive-solution",
                "content": "I do realize now there was no need to take it out to a helper method, but whatever.\\n```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        return constructIntTree(quadTree1, quadTree2);\\n    }\\n    \\n    // Return the intersection between the trees rooted by curQ1 and curQ2.\\n    public Node constructIntTree(Node curQ1, Node curQ2) {\\n        if (curQ1 == null)\\n            return curQ2;\\n        if (curQ2 == null)\\n            return curQ1;\\n        \\n        if (curQ1.isLeaf && curQ1.val)\\n            return curQ1;\\n        if (curQ2.isLeaf && curQ2.val)\\n            return curQ2;\\n        \\n        // Neither one has a \"dominating\" true value\\n        \\n        // If they\\'re both false, return a false!\\n        if (curQ1.isLeaf && !curQ1.val && curQ2.isLeaf && !curQ2.val) {\\n            return curQ1;\\n        }\\n        \\n        // If one is non-false, return that one.\\n        if (curQ1.isLeaf && !curQ1.val)\\n            return curQ2;\\n        if (curQ2.isLeaf && !curQ2.val)\\n            return curQ1;\\n        \\n        \\n        // At this point, we have two nodes each with four children and we need to intersect them\\n        Node result = new Node();\\n        result.topLeft = constructIntTree(curQ1.topLeft, curQ2.topLeft);\\n        result.topRight = constructIntTree(curQ1.topRight, curQ2.topRight);\\n        result.bottomLeft = constructIntTree(curQ1.bottomLeft, curQ2.bottomLeft);\\n        result.bottomRight = constructIntTree(curQ1.bottomRight, curQ2.bottomRight);\\n        \\n        if (result.topLeft.isLeaf && result.topRight.isLeaf && result.bottomLeft.isLeaf && result.bottomRight.isLeaf\\n           && result.topLeft.val == result.topRight.val && result.topRight.val == result.bottomLeft.val && result.bottomLeft.val == result.bottomRight.val) {\\n            // We\\'re just a leaf!\\n            result.isLeaf = true;\\n            result.val = result.topLeft.val;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        return constructIntTree(quadTree1, quadTree2);\\n    }\\n    \\n    // Return the intersection between the trees rooted by curQ1 and curQ2.\\n    public Node constructIntTree(Node curQ1, Node curQ2) {\\n        if (curQ1 == null)\\n            return curQ2;\\n        if (curQ2 == null)\\n            return curQ1;\\n        \\n        if (curQ1.isLeaf && curQ1.val)\\n            return curQ1;\\n        if (curQ2.isLeaf && curQ2.val)\\n            return curQ2;\\n        \\n        // Neither one has a \"dominating\" true value\\n        \\n        // If they\\'re both false, return a false!\\n        if (curQ1.isLeaf && !curQ1.val && curQ2.isLeaf && !curQ2.val) {\\n            return curQ1;\\n        }\\n        \\n        // If one is non-false, return that one.\\n        if (curQ1.isLeaf && !curQ1.val)\\n            return curQ2;\\n        if (curQ2.isLeaf && !curQ2.val)\\n            return curQ1;\\n        \\n        \\n        // At this point, we have two nodes each with four children and we need to intersect them\\n        Node result = new Node();\\n        result.topLeft = constructIntTree(curQ1.topLeft, curQ2.topLeft);\\n        result.topRight = constructIntTree(curQ1.topRight, curQ2.topRight);\\n        result.bottomLeft = constructIntTree(curQ1.bottomLeft, curQ2.bottomLeft);\\n        result.bottomRight = constructIntTree(curQ1.bottomRight, curQ2.bottomRight);\\n        \\n        if (result.topLeft.isLeaf && result.topRight.isLeaf && result.bottomLeft.isLeaf && result.bottomRight.isLeaf\\n           && result.topLeft.val == result.topRight.val && result.topRight.val == result.bottomLeft.val && result.bottomLeft.val == result.bottomRight.val) {\\n            // We\\'re just a leaf!\\n            result.isLeaf = true;\\n            result.val = result.topLeft.val;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884082,
                "title": "python3-9-line-recursive-64ms-93-33",
                "content": "\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition \\n        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: \\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(None, False, tl, tr, bl, br)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition \\n        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: \\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(None, False, tl, tr, bl, br)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386346,
                "title": "c-220-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public Node Intersect(Node quadTree1, Node quadTree2)\\n        {\\n            if (quadTree1.isLeaf && quadTree2.isLeaf)\\n            {\\n                return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n            }\\n\\n            var topLeft1 = quadTree1.isLeaf ? quadTree1 : quadTree1.topLeft;\\n            var topRight1 = quadTree1.isLeaf ? quadTree1 : quadTree1.topRight;\\n            var bottomLeft1 = quadTree1.isLeaf ? quadTree1 : quadTree1.bottomLeft;\\n            var bottomRight1 = quadTree1.isLeaf ? quadTree1 : quadTree1.bottomRight;\\n\\n            var topLeft2 = quadTree2.isLeaf ? quadTree2 : quadTree2.topLeft;\\n            var topRight2 = quadTree2.isLeaf ? quadTree2 : quadTree2.topRight;\\n            var bottomLeft2 = quadTree2.isLeaf ? quadTree2 : quadTree2.bottomLeft;\\n            var bottomRight2 = quadTree2.isLeaf ? quadTree2 : quadTree2.bottomRight;\\n\\n            var topLeft = Intersect(topLeft1, topLeft2);\\n            var topRight = Intersect(topRight1, topRight2);\\n            var bottomLeft = Intersect(bottomLeft1, bottomLeft2);\\n            var bottomRight = Intersect(bottomRight1, bottomRight2);\\n\\n            if (topLeft.isLeaf && topRight.isLeaf &&\\n                bottomLeft.isLeaf && bottomRight.isLeaf &&\\n                topLeft.val == topRight.val &&\\n                topLeft.val == bottomLeft.val &&\\n                topLeft.val == bottomRight.val)\\n            {\\n                return new Node(topLeft.val, true, null, null, null, null);\\n            }\\n\\n            return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public Node Intersect(Node quadTree1, Node quadTree2)\\n        {\\n            if (quadTree1.isLeaf && quadTree2.isLeaf)\\n            {\\n                return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 306764,
                "title": "python-short-recursion-132ms",
                "content": "\\tdef intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':        \\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        elif quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n        else:\\n            tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            \\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n                    return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(tl.val, False, tl, tr, bl, br)\\n\\'\\'\\'\\n\\nThe trick is to realize that:\\nX or 0 = X\\nX or 1 = 1\\n\\nWhenever we encounter a leaf node and a non leaf node, we never have to partition the leaf node into 4 quadrants, because a) if the leaf node is all ones, the resulting node will also be all ones, b) if the leaf node is all zeros, the resulting node will be equal to the other non leaf node.\\n\\nSo the only interesting case is when both nodes are non leafs, in this case we recusively call the function 4 times and put the results together.",
                "solutionTags": [],
                "code": "\\tdef intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':        \\n        if quadTree1.isLeaf:\\n            return quadTree1 if quadTree1.val else quadTree2\\n        elif quadTree2.isLeaf:\\n            return quadTree2 if quadTree2.val else quadTree1\\n        else:\\n            tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            \\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n                    return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(tl.val, False, tl, tr, bl, br)\\n\\'\\'\\'\\n\\nThe trick is to realize that:\\nX or 0 = X\\nX or 1 = 1\\n\\nWhenever we encounter a leaf node and a non leaf node, we never have to partition the leaf node into 4 quadrants, because a) if the leaf node is all ones, the resulting node will also be all ones, b) if the leaf node is all zeros, the resulting node will be equal to the other non leaf node.\\n\\nSo the only interesting case is when both nodes are non leafs, in this case we recusively call the function 4 times and put the results together.",
                "codeTag": "Python3"
            },
            {
                "id": 300703,
                "title": "json-error",
                "content": "When run the test code, it reports\\n```json.hpp:1321:23: runtime error: load of value 190, which is not a valid value for type \\'bool\\'```",
                "solutionTags": [],
                "code": "```json.hpp:1321:23: runtime error: load of value 190, which is not a valid value for type \\'bool\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 156511,
                "title": "c-100-w-o-extra-space-hate-the-input-format-life-is-so-hard",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr) {\\n            return quadTree2;\\n        }\\n        if (quadTree2 == nullptr) {\\n            return quadTree1;\\n        }\\n        if (quadTree1->isLeaf && quadTree1->val) {\\n            return quadTree1;\\n        }\\n        if (quadTree2->isLeaf && quadTree2->val) {\\n            return quadTree2;\\n        }\\n        if (quadTree1->isLeaf) {\\n            return quadTree2;\\n        }\\n        if (quadTree2->isLeaf) {\\n            return quadTree1;\\n        }\\n\\n        quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        quadTree1->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n\\n        if (quadTree1->topLeft->isLeaf && quadTree1->topRight->isLeaf && quadTree1->bottomLeft->isLeaf && quadTree1->bottomRight->isLeaf) {\\n            if (quadTree1->topLeft->val && quadTree1->topRight->val && quadTree1->bottomLeft->val && quadTree1->bottomRight->val) {\\n                quadTree1->isLeaf = true;\\n                quadTree1->val = true;\\n                quadTree1->topLeft = nullptr;\\n                quadTree1->topRight = nullptr;\\n                quadTree1->bottomLeft = nullptr;\\n                quadTree1->bottomRight = nullptr;\\n            } else if (!quadTree1->topLeft->val && !quadTree1->topRight->val && !quadTree1->bottomLeft->val && !quadTree1->bottomRight->val) {\\n                quadTree1->isLeaf = true;\\n                quadTree1->val = false;\\n                quadTree1->topLeft = nullptr;\\n                quadTree1->topRight = nullptr;\\n                quadTree1->bottomLeft = nullptr;\\n                quadTree1->bottomRight = nullptr;\\n            }\\n        } else {\\n            quadTree1->isLeaf = false;\\n            quadTree1->val = false;\\n        }\\n\\n        return quadTree1;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr) {\\n            return quadTree2;\\n        }\\n        if (quadTree2 == nullptr) {\\n            return quadTree1;\\n        }\\n        if (quadTree1->isLeaf && quadTree1->val) {\\n            return quadTree1;\\n        }\\n        if (quadTree2->isLeaf && quadTree2->val) {\\n            return quadTree2;\\n        }\\n        if (quadTree1->isLeaf) {\\n            return quadTree2;\\n        }\\n        if (quadTree2->isLeaf) {\\n            return quadTree1;\\n        }\\n\\n        quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        quadTree1->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n\\n        if (quadTree1->topLeft->isLeaf && quadTree1->topRight->isLeaf && quadTree1->bottomLeft->isLeaf && quadTree1->bottomRight->isLeaf) {\\n            if (quadTree1->topLeft->val && quadTree1->topRight->val && quadTree1->bottomLeft->val && quadTree1->bottomRight->val) {\\n                quadTree1->isLeaf = true;\\n                quadTree1->val = true;\\n                quadTree1->topLeft = nullptr;\\n                quadTree1->topRight = nullptr;\\n                quadTree1->bottomLeft = nullptr;\\n                quadTree1->bottomRight = nullptr;\\n            } else if (!quadTree1->topLeft->val && !quadTree1->topRight->val && !quadTree1->bottomLeft->val && !quadTree1->bottomRight->val) {\\n                quadTree1->isLeaf = true;\\n                quadTree1->val = false;\\n                quadTree1->topLeft = nullptr;\\n                quadTree1->topRight = nullptr;\\n                quadTree1->bottomLeft = nullptr;\\n                quadTree1->bottomRight = nullptr;\\n            }\\n        } else {\\n            quadTree1->isLeaf = false;\\n            quadTree1->val = false;\\n        }\\n\\n        return quadTree1;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458898,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 -> isLeaf)\\n        {\\n            if(quadTree1 -> val == 1) return quadTree1;\\n            return quadTree2;\\n        }\\n        if(quadTree2 -> isLeaf)\\n        {\\n            if(quadTree2 -> val == 1) return quadTree2;\\n            return quadTree1;\\n        }\\n        vector<Node*> arr;\\n        arr.push_back(intersect(quadTree1 -> topLeft, quadTree2 -> topLeft));\\n        arr.push_back(intersect(quadTree1 -> topRight, quadTree2 -> topRight));\\n        arr.push_back(intersect(quadTree1 -> bottomLeft, quadTree2 -> bottomLeft));\\n        arr.push_back(intersect(quadTree1 -> bottomRight, quadTree2 -> bottomRight));\\n        for(Node* node : arr)\\n        {\\n            if(!node -> isLeaf)\\n            {\\n                return new Node(\\n                    true, false,\\n                    arr[0], arr[1], arr[2], arr[3]\\n                );\\n            }\\n        }\\n        for(Node *node : arr)\\n        {\\n            if(!node -> val) return new Node(\\n                true, false,\\n                arr[0], arr[1], arr[2], arr[3]\\n            );\\n        }\\n        return new Node(true, true);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```\\n\\n```Java []\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n        return a;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 -> isLeaf)\\n        {\\n            if(quadTree1 -> val == 1) return quadTree1;\\n            return quadTree2;\\n        }\\n        if(quadTree2 -> isLeaf)\\n        {\\n            if(quadTree2 -> val == 1) return quadTree2;\\n            return quadTree1;\\n        }\\n        vector<Node*> arr;\\n        arr.push_back(intersect(quadTree1 -> topLeft, quadTree2 -> topLeft));\\n        arr.push_back(intersect(quadTree1 -> topRight, quadTree2 -> topRight));\\n        arr.push_back(intersect(quadTree1 -> bottomLeft, quadTree2 -> bottomLeft));\\n        arr.push_back(intersect(quadTree1 -> bottomRight, quadTree2 -> bottomRight));\\n        for(Node* node : arr)\\n        {\\n            if(!node -> isLeaf)\\n            {\\n                return new Node(\\n                    true, false,\\n                    arr[0], arr[1], arr[2], arr[3]\\n                );\\n            }\\n        }\\n        for(Node *node : arr)\\n        {\\n            if(!node -> val) return new Node(\\n                true, false,\\n                arr[0], arr[1], arr[2], arr[3]\\n            );\\n        }\\n        return new Node(true, true);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```\n```Java []\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463218,
                "title": "python-simple-dfs",
                "content": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf:\\n            return Node(True, True) if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return Node(True, True) if quadTree2.val else quadTree1\\n        temp = Node(False, False)\\n        temp.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        temp.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        temp.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        temp.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if (temp.topLeft.isLeaf and temp.topLeft.val) and (temp.topRight.isLeaf and temp.topRight.val) and (temp.bottomLeft.isLeaf and temp.bottomLeft.val) and (temp.bottomRight.isLeaf and temp.bottomRight.val):\\n            return Node(True, True)\\n        return temp\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf:\\n            return Node(True, True) if quadTree1.val else quadTree2\\n        if quadTree2.isLeaf:\\n            return Node(True, True) if quadTree2.val else quadTree1\\n        temp = Node(False, False)\\n        temp.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        temp.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        temp.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        temp.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if (temp.topLeft.isLeaf and temp.topLeft.val) and (temp.topRight.isLeaf and temp.topRight.val) and (temp.bottomLeft.isLeaf and temp.bottomLeft.val) and (temp.bottomRight.isLeaf and temp.bottomRight.val):\\n            return Node(True, True)\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234383,
                "title": "javascript-recursive-100ms-44-2mb",
                "content": "Reuse nodes as many as possible without mutation on original ones.\\n\\n```js\\nvar intersect = function(quadTree1, quadTree2) {\\n    if (!quadTree1.isLeaf && !quadTree2.isLeaf) {\\n        const tl = intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        const tr = intersect(quadTree1.topRight, quadTree2.topRight)\\n        const bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        const br = intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if (\\n            tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf &&\\n            tl.val === tr.val && tr.val === bl.val && bl.val === br.val\\n        ) {\\n            return tl\\n        } else {\\n            return new Node(true, false, tl, tr, bl, br)   \\n        }\\n    } else if (\\n        (quadTree2.isLeaf && quadTree2.val) ||\\n        (quadTree1.isLeaf && !quadTree1.val)\\n    ) {\\n        return quadTree2\\n    } else if (\\n        (quadTree1.isLeaf && quadTree1.val) ||\\n        (quadTree2.isLeaf && !quadTree2.val)\\n    ) {\\n        return quadTree1\\n    }\\n    throw new Error(\\'it\\\\\\'s not possible\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar intersect = function(quadTree1, quadTree2) {\\n    if (!quadTree1.isLeaf && !quadTree2.isLeaf) {\\n        const tl = intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        const tr = intersect(quadTree1.topRight, quadTree2.topRight)\\n        const bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        const br = intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if (\\n            tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf &&\\n            tl.val === tr.val && tr.val === bl.val && bl.val === br.val\\n        ) {\\n            return tl\\n        } else {\\n            return new Node(true, false, tl, tr, bl, br)   \\n        }\\n    } else if (\\n        (quadTree2.isLeaf && quadTree2.val) ||\\n        (quadTree1.isLeaf && !quadTree1.val)\\n    ) {\\n        return quadTree2\\n    } else if (\\n        (quadTree1.isLeaf && quadTree1.val) ||\\n        (quadTree2.isLeaf && !quadTree2.val)\\n    ) {\\n        return quadTree1\\n    }\\n    throw new Error(\\'it\\\\\\'s not possible\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750614,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (!quadTree1 && !quadTree2) return NULL;\\n        if (!quadTree2) return quadTree1;\\n        if (!quadTree1) return quadTree2;\\n        \\n        if (quadTree1->isLeaf && quadTree1->val) return quadTree1;\\n        if (quadTree2->isLeaf && quadTree2->val) return quadTree2;\\n        if (quadTree1->isLeaf && !quadTree1->val) return quadTree2;\\n        if (quadTree1->isLeaf && !quadTree1->val) return quadTree1;\\n        \\n        auto tl = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        auto tr = intersect(quadTree1->topRight, quadTree2->topRight);\\n        auto bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        auto br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if(tl->val == tr->val && tl->val == bl->val && tl->val == br->val &&\\n                    tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf) {\\n            return new Node(tr->val, true, NULL, NULL, NULL, NULL);\\n        } else {\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (!quadTree1 && !quadTree2) return NULL;\\n        if (!quadTree2) return quadTree1;\\n        if (!quadTree1) return quadTree2;\\n        \\n        if (quadTree1->isLeaf && quadTree1->val) return quadTree1;\\n        if (quadTree2->isLeaf && quadTree2->val) return quadTree2;\\n        if (quadTree1->isLeaf && !quadTree1->val) return quadTree2;\\n        if (quadTree1->isLeaf && !quadTree1->val) return quadTree1;\\n        \\n        auto tl = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        auto tr = intersect(quadTree1->topRight, quadTree2->topRight);\\n        auto bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        auto br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if(tl->val == tr->val && tl->val == bl->val && tl->val == br->val &&\\n                    tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf) {\\n            return new Node(tr->val, true, NULL, NULL, NULL, NULL);\\n        } else {\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523777,
                "title": "clean-code-beats-100",
                "content": "```\\n\\tpublic Node intersect(Node n1, Node n2) {\\n        if (n1.isLeaf) {\\n            return n1.val? n1 : n2;\\n        }\\n        if (n2.isLeaf) {\\n            return n2.val? n2 : n1;\\n        }\\n\\t\\t\\n        Node out = new Node();\\n        Node tl, tr, bl, br;\\n\\t\\t\\n        tl = intersect(n1.topLeft, n2.topLeft);\\n        tr = intersect(n1.topRight, n2.topRight);\\n        bl = intersect(n1.bottomLeft, n2.bottomLeft);\\n        br = intersect(n1.bottomRight, n2.bottomRight);\\n\\n        if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && (tl.val == tr.val) && (tr.val == bl.val) && (br.val == bl.val)) {\\n            out.isLeaf = true;\\n            out.val = tl.val;\\n        } else {\\n            out.topLeft = tl;\\n            out.topRight = tr;\\n            out.bottomLeft = bl;\\n            out.bottomRight = br;\\n        }\\n        return out;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic Node intersect(Node n1, Node n2) {\\n        if (n1.isLeaf) {\\n            return n1.val? n1 : n2;\\n        }\\n        if (n2.isLeaf) {\\n            return n2.val? n2 : n1;\\n        }\\n\\t\\t\\n        Node out = new Node();\\n        Node tl, tr, bl, br;\\n\\t\\t\\n        tl = intersect(n1.topLeft, n2.topLeft);\\n        tr = intersect(n1.topRight, n2.topRight);\\n        bl = intersect(n1.bottomLeft, n2.bottomLeft);\\n        br = intersect(n1.bottomRight, n2.bottomRight);\\n\\n        if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && (tl.val == tr.val) && (tr.val == bl.val) && (br.val == bl.val)) {\\n            out.isLeaf = true;\\n            out.val = tl.val;\\n        } else {\\n            out.topLeft = tl;\\n            out.topRight = tr;\\n            out.bottomLeft = bl;\\n            out.bottomRight = br;\\n        }\\n        return out;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 493351,
                "title": "clean-java-solution-0-ms",
                "content": "class Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n        if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n        \\n        Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n            \\n        boolean isLeaf = topLeft.isLeaf && topRight.isLeaf\\n            && bottomLeft.isLeaf && bottomRight.isLeaf\\n            && topLeft.val == topRight.val && topRight.val == bottomLeft.val\\n            && bottomLeft.val == bottomRight.val;\\n        \\n        if (isLeaf) {\\n            return new Node(topLeft.val, true, null, null, null, null);\\n        }\\n        \\n        return new Node(\\n            quadTree1.val || quadTree2.val,\\n            quadTree1.isLeaf && quadTree2.isLeaf,\\n            topLeft,\\n            topRight,\\n            bottomLeft,\\n            bottomRight);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 457761,
                "title": "straightforward-python",
                "content": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        falseTree = Node(False, True, None, None, None, None)\\n        if quadTree1.isLeaf and quadTree1.val or quadTree2.isLeaf and quadTree2.val:\\n            return Node(True, True, None, None, None, None)\\n        elif quadTree1.isLeaf and not quadTree1.val and quadTree2.isLeaf and not quadTree2.val:\\n            return Node(False, True, None, None, None, None)\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf and not quadTree2.val:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree1.topLeft, falseTree)\\n            union.topRight = self.intersect(quadTree1.topRight, falseTree)\\n            union.bottomLeft = self.intersect(quadTree1.bottomLeft, falseTree)\\n            union.bottomRight = self.intersect(quadTree1.bottomRight, falseTree)\\n            return union\\n        elif not quadTree2.isLeaf and quadTree1.isLeaf and not quadTree1.val:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree2.topLeft, falseTree)\\n            union.topRight = self.intersect(quadTree2.topRight, falseTree)\\n            union.bottomLeft = self.intersect(quadTree2.bottomLeft, falseTree)\\n            union.bottomRight = self.intersect(quadTree2.bottomRight, falseTree)\\n            return union\\n        elif not quadTree1.isLeaf and not quadTree2.isLeaf:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            union.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            union.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            union.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            if union.topLeft.isLeaf and union.topRight.isLeaf and union.bottomLeft.isLeaf and union.bottomRight.isLeaf and len(set([union.topLeft.val, union.topRight.val, union.bottomLeft.val, union.bottomRight.val])) == 1:\\n                union = Node(union.topLeft.val, True, None, None, None, None)\\n            return union\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        falseTree = Node(False, True, None, None, None, None)\\n        if quadTree1.isLeaf and quadTree1.val or quadTree2.isLeaf and quadTree2.val:\\n            return Node(True, True, None, None, None, None)\\n        elif quadTree1.isLeaf and not quadTree1.val and quadTree2.isLeaf and not quadTree2.val:\\n            return Node(False, True, None, None, None, None)\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf and not quadTree2.val:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree1.topLeft, falseTree)\\n            union.topRight = self.intersect(quadTree1.topRight, falseTree)\\n            union.bottomLeft = self.intersect(quadTree1.bottomLeft, falseTree)\\n            union.bottomRight = self.intersect(quadTree1.bottomRight, falseTree)\\n            return union\\n        elif not quadTree2.isLeaf and quadTree1.isLeaf and not quadTree1.val:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree2.topLeft, falseTree)\\n            union.topRight = self.intersect(quadTree2.topRight, falseTree)\\n            union.bottomLeft = self.intersect(quadTree2.bottomLeft, falseTree)\\n            union.bottomRight = self.intersect(quadTree2.bottomRight, falseTree)\\n            return union\\n        elif not quadTree1.isLeaf and not quadTree2.isLeaf:\\n            union = Node(False, False, None, None, None, None)\\n            union.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            union.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            union.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            union.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            if union.topLeft.isLeaf and union.topRight.isLeaf and union.bottomLeft.isLeaf and union.bottomRight.isLeaf and len(set([union.topLeft.val, union.topRight.val, union.bottomLeft.val, union.bottomRight.val])) == 1:\\n                union = Node(union.topLeft.val, True, None, None, None, None)\\n            return union\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374038,
                "title": "straightforward-recursive-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr || quadTree2 == nullptr)\\n            return nullptr;\\n        else if (quadTree1->isLeaf && quadTree1->val == true)\\n            return quadTree1;\\n        else if (quadTree2->isLeaf && quadTree2->val == true)\\n            return quadTree2;\\n        else if (quadTree1->isLeaf && quadTree2->isLeaf) //Then both leaves are have value false\\n            return quadTree1; //Could also return quadTree2;\\n        else if (quadTree1->isLeaf) //Then quadTree1 has value false and since (false || X == X), we return quadTree2\\n            return quadTree2;\\n        else if (quadTree2->isLeaf)\\n            return quadTree1;\\n        //Neither quadTree1 or quadTree2 are leaves.\\n        Node * ret = new Node();\\n        ret->isLeaf = false;\\n        ret->val = false;\\n        ret->topLeft     = intersect(quadTree1->topLeft,     quadTree2->topLeft);\\n        ret->topRight    = intersect(quadTree1->topRight,    quadTree2->topRight);\\n        ret->bottomLeft  = intersect(quadTree1->bottomLeft,  quadTree2->bottomLeft);\\n        ret->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        //If all 4 quadrants are leafs having the same value then make ret into a leaf of that value.\\n        if (ret->topLeft->isLeaf && ret->topRight->isLeaf && ret->bottomLeft->isLeaf && ret->bottomRight->isLeaf) {\\n            if ((ret->topLeft->val && ret->topRight->val && ret->bottomLeft->val && ret->bottomRight->val)\\n                || (!ret->topLeft->val && !ret->topRight->val && !ret->bottomLeft->val && !ret->bottomRight->val)) {\\n                ret->isLeaf = true;\\n                ret->val = ret->topLeft->val;\\n                ret->topLeft = nullptr;\\n                ret->topRight = nullptr;\\n                ret->bottomLeft = nullptr;\\n                ret->bottomRight = nullptr;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr || quadTree2 == nullptr)\\n            return nullptr;\\n        else if (quadTree1->isLeaf && quadTree1->val == true)\\n            return quadTree1;\\n        else if (quadTree2->isLeaf && quadTree2->val == true)\\n            return quadTree2;\\n        else if (quadTree1->isLeaf && quadTree2->isLeaf) //Then both leaves are have value false\\n            return quadTree1; //Could also return quadTree2;\\n        else if (quadTree1->isLeaf) //Then quadTree1 has value false and since (false || X == X), we return quadTree2\\n            return quadTree2;\\n        else if (quadTree2->isLeaf)\\n            return quadTree1;\\n        //Neither quadTree1 or quadTree2 are leaves.\\n        Node * ret = new Node();\\n        ret->isLeaf = false;\\n        ret->val = false;\\n        ret->topLeft     = intersect(quadTree1->topLeft,     quadTree2->topLeft);\\n        ret->topRight    = intersect(quadTree1->topRight,    quadTree2->topRight);\\n        ret->bottomLeft  = intersect(quadTree1->bottomLeft,  quadTree2->bottomLeft);\\n        ret->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        //If all 4 quadrants are leafs having the same value then make ret into a leaf of that value.\\n        if (ret->topLeft->isLeaf && ret->topRight->isLeaf && ret->bottomLeft->isLeaf && ret->bottomRight->isLeaf) {\\n            if ((ret->topLeft->val && ret->topRight->val && ret->bottomLeft->val && ret->bottomRight->val)\\n                || (!ret->topLeft->val && !ret->topRight->val && !ret->bottomLeft->val && !ret->bottomRight->val)) {\\n                ret->isLeaf = true;\\n                ret->val = ret->topLeft->val;\\n                ret->topLeft = nullptr;\\n                ret->topRight = nullptr;\\n                ret->bottomLeft = nullptr;\\n                ret->bottomRight = nullptr;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353218,
                "title": "a-simple-java-solution-faster-than-100-00-accepted-runtime-0-ms",
                "content": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n        if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n        Node ret = new Node();\\n        ret.val = true;\\n        ret.isLeaf = false;\\n        ret.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        ret.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        ret.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        ret.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n        if (ret.topLeft.isLeaf && ret.topRight.isLeaf && ret.bottomLeft.isLeaf && ret.bottomRight.isLeaf &&\\n                (ret.topLeft.val == ret.topRight.val\\n                        && ret.bottomLeft.val == ret.bottomRight.val\\n                        && ret.topLeft.val == ret.bottomRight.val)) {\\n            ret.isLeaf = true;\\n            ret.val = ret.topLeft.val;\\n            ret.topLeft = null;\\n            ret.topRight = null;\\n            ret.bottomLeft = null;\\n            ret.bottomRight = null;\\n        }\\n        return ret;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n        if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n        Node ret = new Node();\\n        ret.val = true;\\n        ret.isLeaf = false;\\n        ret.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        ret.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        ret.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        ret.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n        if (ret.topLeft.isLeaf && ret.topRight.isLeaf && ret.bottomLeft.isLeaf && ret.bottomRight.isLeaf &&\\n                (ret.topLeft.val == ret.topRight.val\\n                        && ret.bottomLeft.val == ret.bottomRight.val\\n                        && ret.topLeft.val == ret.bottomRight.val)) {\\n            ret.isLeaf = true;\\n            ret.val = ret.topLeft.val;\\n            ret.topLeft = null;\\n            ret.topRight = null;\\n            ret.bottomLeft = null;\\n            ret.bottomRight = null;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344454,
                "title": "clean-java-solution-and-i-think-this-should-be-marked-as-medium",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1 == null || quadTree2 == null) return null;\\n        \\n        if(quadTree1.isLeaf && quadTree2.isLeaf) {\\n            return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n        } else if(quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if(quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        } else {\\n            Node nTL = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node nTR = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node nBL = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node nBR = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n            \\n            if(nTL.isLeaf && nTR.isLeaf && nBL.isLeaf && nBR.isLeaf) {\\n                if(nTL.val == nTR.val && nTR.val == nBL.val && nBL.val == nBR.val) {\\n                    return new Node(nTL.val, true, null, null, null, null);\\n                }\\n            }\\n            return new Node(false, false, nTL, nTR, nBL, nBR);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1 == null || quadTree2 == null) return null;\\n        \\n        if(quadTree1.isLeaf && quadTree2.isLeaf) {\\n            return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n        } else if(quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if(quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        } else {\\n            Node nTL = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node nTR = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node nBL = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node nBR = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n            \\n            if(nTL.isLeaf && nTR.isLeaf && nBL.isLeaf && nBR.isLeaf) {\\n                if(nTL.val == nTR.val && nTR.val == nBL.val && nBL.val == nBR.val) {\\n                    return new Node(nTL.val, true, null, null, null, null);\\n                }\\n            }\\n            return new Node(false, false, nTL, nTR, nBL, nBR);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294321,
                "title": "create-new-space-to-store-new-quadtree",
                "content": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n\\n    Node() {}\\n\\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 == nullptr){\\n            return copyNode(quadTree2);\\n        }else if(quadTree2 == nullptr){\\n            return copyNode(quadTree1);\\n        }else if(quadTree1->isLeaf){\\n            if(quadTree1->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else\\n                return copyNode(quadTree2);\\n        }else if(quadTree2->isLeaf){\\n            if(quadTree2->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else\\n                return copyNode(quadTree1);\\n        }\\n        \\n        Node *topLeft = intersect(quadTree1->topLeft,quadTree2->topLeft);\\n        Node *topRight = intersect(quadTree1->topRight,quadTree2->topRight);\\n        Node *bottomLeft = intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n        Node *bottomRight = intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        \\n        if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf){\\n            if(topLeft->val && topRight->val && bottomLeft->val && bottomRight->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else if(topLeft->val == false && topRight->val == false  \\n                    && bottomLeft->val == false  && bottomRight->val == false )\\n                return new Node(false,true,nullptr,nullptr,nullptr,nullptr);\\n            else return new Node(false,false,topLeft,topRight,bottomLeft,bottomRight);\\n        }\\n        return new Node(false,false,topLeft,topRight,bottomLeft,bottomRight);\\n    }\\n    \\n    Node* copyNode(Node* tree){\\n        if(tree == nullptr) return nullptr;\\n        Node* node = new Node(tree->val,tree->isLeaf);\\n        node->topLeft = copyNode(tree->topLeft);\\n        node->topRight = copyNode(tree->topRight);\\n        node->bottomLeft = copyNode(tree->bottomLeft);\\n        node->bottomRight = copyNode(tree->bottomRight);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n\\n    Node() {}\\n\\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 == nullptr){\\n            return copyNode(quadTree2);\\n        }else if(quadTree2 == nullptr){\\n            return copyNode(quadTree1);\\n        }else if(quadTree1->isLeaf){\\n            if(quadTree1->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else\\n                return copyNode(quadTree2);\\n        }else if(quadTree2->isLeaf){\\n            if(quadTree2->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else\\n                return copyNode(quadTree1);\\n        }\\n        \\n        Node *topLeft = intersect(quadTree1->topLeft,quadTree2->topLeft);\\n        Node *topRight = intersect(quadTree1->topRight,quadTree2->topRight);\\n        Node *bottomLeft = intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n        Node *bottomRight = intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        \\n        if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf){\\n            if(topLeft->val && topRight->val && bottomLeft->val && bottomRight->val)\\n                return new Node(true,true,nullptr,nullptr,nullptr,nullptr);\\n            else if(topLeft->val == false && topRight->val == false  \\n                    && bottomLeft->val == false  && bottomRight->val == false )\\n                return new Node(false,true,nullptr,nullptr,nullptr,nullptr);\\n            else return new Node(false,false,topLeft,topRight,bottomLeft,bottomRight);\\n        }\\n        return new Node(false,false,topLeft,topRight,bottomLeft,bottomRight);\\n    }\\n    \\n    Node* copyNode(Node* tree){\\n        if(tree == nullptr) return nullptr;\\n        Node* node = new Node(tree->val,tree->isLeaf);\\n        node->topLeft = copyNode(tree->topLeft);\\n        node->topRight = copyNode(tree->topRight);\\n        node->bottomLeft = copyNode(tree->bottomLeft);\\n        node->bottomRight = copyNode(tree->bottomRight);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241491,
                "title": "python-non-recurrent",
                "content": "```\\n\"\"\"\\n# Definition for a QuadTree node.\\nclass Node:\\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\"\"\"\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if not quadTree1 or not quadTree2:\\n            return None\\n        st = [[quadTree1, quadTree2]]\\n        while st:\\n            tree1, tree2 = st.pop()\\n            if tree2:\\n                if tree1.isLeaf:\\n                    if tree2.isLeaf:\\n                        tree1.isLeaf = True\\n                        tree1.val = tree1.val or tree2.val\\n                    elif not tree1.val:\\n                        tree1.isLeaf = False\\n                        tree1.topLeft = tree2.topLeft\\n                        tree1.topRight = tree2.topRight\\n                        tree1.bottomLeft = tree2.bottomLeft\\n                        tree1.bottomRight = tree2.bottomRight\\n                elif tree2.isLeaf:\\n                    if tree2.val:\\n                        tree1.isLeaf = True\\n                        tree1.val = True\\n                        tree1.topLeft = None\\n                        tree1.topRight = None\\n                        tree1.bottomLeft = None\\n                        tree1.bottomRight = None\\n                else:\\n                    st.append([tree1, None])   # for merging sub nodes\\n                    st.append([tree1.topLeft, tree2.topLeft])\\n                    st.append([tree1.topRight, tree2.topRight])\\n                    st.append([tree1.bottomLeft, tree2.bottomLeft])\\n                    st.append([tree1.bottomRight, tree2.bottomRight])\\n            else: # merge sub nodes\\n                if tree1.topLeft.isLeaf and tree1.topRight.isLeaf and tree1.bottomLeft.isLeaf and tree1.bottomRight.isLeaf:\\n                    if tree1.topLeft.val == tree1.topRight.val == tree1.bottomLeft.val == tree1.bottomRight.val:\\n                        tree1.isLeaf = True\\n                        tree1.val = tree1.topLeft.val\\n                        tree1.topLeft = None\\n                        tree1.topRight = None\\n                        tree1.bottomLeft = None\\n                        tree1.bottomRight = None\\n        return quadTree1\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a QuadTree node.\\nclass Node:\\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\"\"\"\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if not quadTree1 or not quadTree2:\\n            return None\\n        st = [[quadTree1, quadTree2]]\\n        while st:\\n            tree1, tree2 = st.pop()\\n            if tree2:\\n                if tree1.isLeaf:\\n                    if tree2.isLeaf:\\n                        tree1.isLeaf = True\\n                        tree1.val = tree1.val or tree2.val\\n                    elif not tree1.val:\\n                        tree1.isLeaf = False\\n                        tree1.topLeft = tree2.topLeft\\n                        tree1.topRight = tree2.topRight\\n                        tree1.bottomLeft = tree2.bottomLeft\\n                        tree1.bottomRight = tree2.bottomRight\\n                elif tree2.isLeaf:\\n                    if tree2.val:\\n                        tree1.isLeaf = True\\n                        tree1.val = True\\n                        tree1.topLeft = None\\n                        tree1.topRight = None\\n                        tree1.bottomLeft = None\\n                        tree1.bottomRight = None\\n                else:\\n                    st.append([tree1, None])   # for merging sub nodes\\n                    st.append([tree1.topLeft, tree2.topLeft])\\n                    st.append([tree1.topRight, tree2.topRight])\\n                    st.append([tree1.bottomLeft, tree2.bottomLeft])\\n                    st.append([tree1.bottomRight, tree2.bottomRight])\\n            else: # merge sub nodes\\n                if tree1.topLeft.isLeaf and tree1.topRight.isLeaf and tree1.bottomLeft.isLeaf and tree1.bottomRight.isLeaf:\\n                    if tree1.topLeft.val == tree1.topRight.val == tree1.bottomLeft.val == tree1.bottomRight.val:\\n                        tree1.isLeaf = True\\n                        tree1.val = tree1.topLeft.val\\n                        tree1.topLeft = None\\n                        tree1.topRight = None\\n                        tree1.bottomLeft = None\\n                        tree1.bottomRight = None\\n        return quadTree1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181363,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if(quadTree1.isLeaf ) return quadTree1.val ?quadTree1:quadTree2 ;\\n        if(quadTree2.isLeaf ) return quadTree2.val ?quadTree2:quadTree1 ;\\n        \\n        Node root = new Node();\\n        Node topLeft = intersect(quadTree1.topLeft,quadTree2.topLeft);\\n        Node topRight = intersect(quadTree1.topRight,quadTree2.topRight);\\n        Node bottomLeft = intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n        Node bottomRight = intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n        if(topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf ) {\\n            if(topLeft.val && topRight.val && bottomLeft.val && bottomRight.val) { \\n                root.isLeaf = true;\\n                root.val = true;\\n                return root;\\n            }else if(!topLeft.val && !topRight.val && !bottomLeft.val && !bottomRight.val) {\\n                root.isLeaf = true;\\n                root.val = false;\\n                return root;\\n            }\\n        }\\n        root.topLeft = topLeft;\\n        root.topRight = topRight;\\n        root.bottomLeft = bottomLeft;\\n        root.bottomRight = bottomRight;\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if(quadTree1.isLeaf ) return quadTree1.val ?quadTree1:quadTree2 ;\\n        if(quadTree2.isLeaf ) return quadTree2.val ?quadTree2:quadTree1 ;\\n        \\n        Node root = new Node();\\n        Node topLeft = intersect(quadTree1.topLeft,quadTree2.topLeft);\\n        Node topRight = intersect(quadTree1.topRight,quadTree2.topRight);\\n        Node bottomLeft = intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n        Node bottomRight = intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n        if(topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf ) {\\n            if(topLeft.val && topRight.val && bottomLeft.val && bottomRight.val) { \\n                root.isLeaf = true;\\n                root.val = true;\\n                return root;\\n            }else if(!topLeft.val && !topRight.val && !bottomLeft.val && !bottomRight.val) {\\n                root.isLeaf = true;\\n                root.val = false;\\n                return root;\\n            }\\n        }\\n        root.topLeft = topLeft;\\n        root.topRight = topRight;\\n        root.bottomLeft = bottomLeft;\\n        root.bottomRight = bottomRight;\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176142,
                "title": "absolute-garbage-user-experience",
                "content": "I should\\'ve paid attention to the upvote/downvote ratio, shame on me...\\n\\nWhile the intent of the problem is good, the gnarly JSON input structure and nesting makes it difficult to debug and test meaningfully.  It\\'s not even human parseable with 1-2 levels of depth!  I don\\'t like how I had to use outside tools just to prettify/change/compare the inputs/outputs.  I wasted a bunch of time on nothing to do with the problem at hand.\\n\\nI wish more thought would\\'ve went into a more readable input structure.  The purpose of the problem is NOT to waste ones time making sense of dodgy JSON.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 160224,
                "title": "simple-recursion",
                "content": "Just be careful when all children nodes are leaves and their values are same, in which case you should merge all children.\\n```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) \\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        if (quadTree2.isLeaf)\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        Node node = new Node(false, false, \\n                            intersect(quadTree1.topLeft, quadTree2.topLeft),\\n                            intersect(quadTree1.topRight, quadTree2.topRight),\\n                            intersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n                            intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n                            );\\n        if (node.topLeft.isLeaf && node.topRight.isLeaf && node.bottomLeft.isLeaf && node.bottomRight.isLeaf &&\\n            node.topLeft.val == node.topRight.val && node.bottomLeft.val == node.bottomRight.val &&\\n            node.topRight.val == node.bottomLeft.val) {\\n            node.isLeaf = true;\\n            node.val = node.topRight.val;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) \\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        if (quadTree2.isLeaf)\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        Node node = new Node(false, false, \\n                            intersect(quadTree1.topLeft, quadTree2.topLeft),\\n                            intersect(quadTree1.topRight, quadTree2.topRight),\\n                            intersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n                            intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n                            );\\n        if (node.topLeft.isLeaf && node.topRight.isLeaf && node.bottomLeft.isLeaf && node.bottomRight.isLeaf &&\\n            node.topLeft.val == node.topRight.val && node.bottomLeft.val == node.bottomRight.val &&\\n            node.topRight.val == node.bottomLeft.val) {\\n            node.isLeaf = true;\\n            node.val = node.topRight.val;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151886,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        } else {\\n            Node root = new Node();\\n            Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n            \\n            if (topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val && \\n                topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf) {\\n                root.val = topLeft.val;\\n                root.isLeaf = true;\\n            } else {\\n                root.topLeft = topLeft;\\n                root.topRight = topRight;\\n                root.bottomLeft = bottomLeft;\\n                root.bottomRight = bottomRight;\\n            }\\n            \\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        } else if (quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        } else {\\n            Node root = new Node();\\n            Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n            \\n            if (topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val && \\n                topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf) {\\n                root.val = topLeft.val;\\n                root.isLeaf = true;\\n            } else {\\n                root.topLeft = topLeft;\\n                root.topRight = topRight;\\n                root.bottomLeft = bottomLeft;\\n                root.bottomRight = bottomRight;\\n            }\\n            \\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876079,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```java []\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n        return a;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 -> isLeaf)\\n        {\\n            if(quadTree1 -> val == 1) return quadTree1;\\n            return quadTree2;\\n        }\\n        if(quadTree2 -> isLeaf)\\n        {\\n            if(quadTree2 -> val == 1) return quadTree2;\\n            return quadTree1;\\n        }\\n        vector<Node*> arr;\\n        arr.push_back(intersect(quadTree1 -> topLeft, quadTree2 -> topLeft));\\n        arr.push_back(intersect(quadTree1 -> topRight, quadTree2 -> topRight));\\n        arr.push_back(intersect(quadTree1 -> bottomLeft, quadTree2 -> bottomLeft));\\n        arr.push_back(intersect(quadTree1 -> bottomRight, quadTree2 -> bottomRight));\\n        for(Node* node : arr)\\n        {\\n            if(!node -> isLeaf)\\n            {\\n                return new Node(\\n                    true, false,\\n                    arr[0], arr[1], arr[2], arr[3]\\n                );\\n            }\\n        }\\n        for(Node *node : arr)\\n        {\\n            if(!node -> val) return new Node(\\n                true, false,\\n                arr[0], arr[1], arr[2], arr[3]\\n            );\\n        }\\n        return new Node(true, true);\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n        return a;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1 -> isLeaf)\\n        {\\n            if(quadTree1 -> val == 1) return quadTree1;\\n            return quadTree2;\\n        }\\n        if(quadTree2 -> isLeaf)\\n        {\\n            if(quadTree2 -> val == 1) return quadTree2;\\n            return quadTree1;\\n        }\\n        vector<Node*> arr;\\n        arr.push_back(intersect(quadTree1 -> topLeft, quadTree2 -> topLeft));\\n        arr.push_back(intersect(quadTree1 -> topRight, quadTree2 -> topRight));\\n        arr.push_back(intersect(quadTree1 -> bottomLeft, quadTree2 -> bottomLeft));\\n        arr.push_back(intersect(quadTree1 -> bottomRight, quadTree2 -> bottomRight));\\n        for(Node* node : arr)\\n        {\\n            if(!node -> isLeaf)\\n            {\\n                return new Node(\\n                    true, false,\\n                    arr[0], arr[1], arr[2], arr[3]\\n                );\\n            }\\n        }\\n        for(Node *node : arr)\\n        {\\n            if(!node -> val) return new Node(\\n                true, false,\\n                arr[0], arr[1], arr[2], arr[3]\\n            );\\n        }\\n        return new Node(true, true);\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        if q1.isLeaf:\\n            return q1.val and q1 or q2\\n        elif q2.isLeaf:\\n            return q2.val and q2 or q1\\n        else:\\n            tLeft = self.intersect(q1.topLeft, q2.topLeft)\\n            tRight = self.intersect(q1.topRight, q2.topRight)\\n            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)\\n            bRight = self.intersect(q1.bottomRight, q2.bottomRight)\\n            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:\\n                node = Node(tLeft.val, True, None, None, None, None) \\n            else:\\n                node = Node(False, False, tLeft, tRight, bLeft, bRight)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394741,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public Node Intersect(Node quadTree1, Node quadTree2)\\n    {\\n        if (quadTree1.isLeaf)\\n        {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n\\n        if (quadTree2.isLeaf)\\n        {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n\\n        var children = new[]\\n        {\\n            Intersect(quadTree1.topLeft, quadTree2.topLeft),\\n            Intersect(quadTree1.topRight, quadTree2.topRight),\\n            Intersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n            Intersect(quadTree1.bottomRight, quadTree2.bottomRight),\\n        };\\n\\n        var val = children.First().val;\\n        var isLeaf = children.All(child => child.isLeaf && child.val == val);\\n\\n        return new Node(val, isLeaf)\\n        {\\n            topLeft = isLeaf ? null : children[0],\\n            topRight = isLeaf ? null : children[1],\\n            bottomLeft = isLeaf ? null : children[2],\\n            bottomRight = isLeaf ? null : children[3],\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public Node Intersect(Node quadTree1, Node quadTree2)\\n    {\\n        if (quadTree1.isLeaf)\\n        {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n\\n        if (quadTree2.isLeaf)\\n        {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n\\n        var children = new[]\\n        {\\n            Intersect(quadTree1.topLeft, quadTree2.topLeft),\\n            Intersect(quadTree1.topRight, quadTree2.topRight),\\n            Intersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n            Intersect(quadTree1.bottomRight, quadTree2.bottomRight),\\n        };\\n\\n        var val = children.First().val;\\n        var isLeaf = children.All(child => child.isLeaf && child.val == val);\\n\\n        return new Node(val, isLeaf)\\n        {\\n            topLeft = isLeaf ? null : children[0],\\n            topRight = isLeaf ? null : children[1],\\n            bottomLeft = isLeaf ? null : children[2],\\n            bottomRight = isLeaf ? null : children[3],\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384018,
                "title": "java-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need discuss the following cases when we do the q1 OR q2.\\na. q1.isLeaf is true and if q1.val is true, the OR will return q1 else it will return q2.\\nb. q2.isLeaf is true and if q2.val is true, the OR will return q2 else it will return q1.\\nc. both q1 and q2 are not isLeaf, in this case, we will create a new node to save the OR result and return. In this case, all the four children of q1 and q2 are not null  because above step a and step b have taken care of the situation when there will be null child. In other words, if one node has null child and the one node has child, in this case, the result will be either the one node with val 1  as LeafNode or the other node with child.\\nd. last step we need update the current node isLeaf and val because if from step c, all the children are isLeaf and they share the same value, then current node will be changed to a isLeaf node and the value will be the same as one of the children\\'s value and all children should be set to null\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursively apply the q1 OR q2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nworst case we need visit all of the children nodes from both q1 and q2\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n\\n        if( quadTree1.isLeaf )\\n           if (quadTree1.val) return quadTree1;\\n           else return quadTree2;\\n        if (quadTree2.isLeaf)\\n            if(quadTree2.val) return quadTree2;\\n            else return quadTree1;\\n        \\n        // now discuss both are false isLeaf\\n        Node ret = new Node(true, false, null, null, null, null);\\n        ret.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        ret.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        ret.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        ret.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n        // at the end, we need ensure that the final tree become a isLeaf\\n    \\n        if(ret.topLeft.isLeaf && ret.topRight.isLeaf &&  ret.bottomLeft.isLeaf && ret.bottomRight.isLeaf)\\n         {\\n            if(ret.topLeft.val == ret.topRight.val && ret.topLeft.val == ret.bottomLeft.val && ret.topLeft.val == ret.bottomRight.val)\\n            {\\n                return new Node(ret.topLeft.val, true, null, null, null, null);\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n\\n        if( quadTree1.isLeaf )\\n           if (quadTree1.val) return quadTree1;\\n           else return quadTree2;\\n        if (quadTree2.isLeaf)\\n            if(quadTree2.val) return quadTree2;\\n            else return quadTree1;\\n        \\n        // now discuss both are false isLeaf\\n        Node ret = new Node(true, false, null, null, null, null);\\n        ret.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        ret.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        ret.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        ret.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n        // at the end, we need ensure that the final tree become a isLeaf\\n    \\n        if(ret.topLeft.isLeaf && ret.topRight.isLeaf &&  ret.bottomLeft.isLeaf && ret.bottomRight.isLeaf)\\n         {\\n            if(ret.topLeft.val == ret.topRight.val && ret.topLeft.val == ret.bottomLeft.val && ret.topLeft.val == ret.bottomRight.val)\\n            {\\n                return new Node(ret.topLeft.val, true, null, null, null, null);\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361988,
                "title": "python-solution-for-quadtree-intersection-problem",
                "content": "# Intuition\\nThe problem statement asks to find the intersection of two quadtrees. A quadtree is a tree data structure in which each internal node has exactly four children: top left, top right, bottom left, and bottom right. Each leaf node represents a square region and has a boolean value. The quadtree is a recursive data structure, and hence we can use a recursive approach to solve this problem.\\n# Approach\\nWe can start by checking if either of the quad trees is empty, in which case we can simply return the other one. If both the quad trees are leaves, we merge them into a new node with the logical OR of their values. If one of the quad trees is a leaf and its value is True, we return it. We divide the quad trees into four sub-trees and recursively call the intersect function on these sub-trees. If all the sub-trees are leaves and have the same value, we merge them into a single node. Finally, we return the quad tree with the four sub-trees.\\n\\n\\n# Complexity\\n- Time complexity:\\nSince we are visiting each node of the quad tree once, the time complexity of the algorithm is O(n), where n is the number of nodes in the quad tree.\\n- Space complexity:\\nThe space complexity of the algorithm is O(logn), where n is the number of nodes in the quad tree, because the maximum depth of the recursive call stack is logn.\\n# Code\\n```\\n# Definition for a QuadTree node.\\n# class Node:\\n#     def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n#         self.val = val\\n#         self.isLeaf = isLeaf\\n#         self.topLeft = topLeft\\n#         self.topRight = topRight\\n#         self.bottomLeft = bottomLeft\\n#         self.bottomRight = bottomRight\\n\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        # If either quad tree is empty, return the other one\\n        if not quadTree1:\\n            return quadTree2\\n        if not quadTree2:\\n            return quadTree1\\n        \\n        # If both quad trees are leaves, merge them\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            return Node(quadTree1.val or quadTree2.val, True, None, None, None, None)\\n        \\n        # If one of the quad trees is a leaf, and it\\'s True, return it\\n        if quadTree1.isLeaf and quadTree1.val:\\n            return quadTree1\\n        if quadTree2.isLeaf and quadTree2.val:\\n            return quadTree2\\n        \\n        # Divide the quad trees into four sub-trees\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        # If all sub-trees are leaves and they have same values, merge them\\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and \\\\\\n            topLeft.val == topRight.val == bottomLeft.val == bottomRight.val:\\n            return Node(topLeft.val, True, None, None, None, None)\\n        \\n        # Return the quad tree with the four sub-trees\\n        return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a QuadTree node.\\n# class Node:\\n#     def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n#         self.val = val\\n#         self.isLeaf = isLeaf\\n#         self.topLeft = topLeft\\n#         self.topRight = topRight\\n#         self.bottomLeft = bottomLeft\\n#         self.bottomRight = bottomRight\\n\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        # If either quad tree is empty, return the other one\\n        if not quadTree1:\\n            return quadTree2\\n        if not quadTree2:\\n            return quadTree1\\n        \\n        # If both quad trees are leaves, merge them\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            return Node(quadTree1.val or quadTree2.val, True, None, None, None, None)\\n        \\n        # If one of the quad trees is a leaf, and it\\'s True, return it\\n        if quadTree1.isLeaf and quadTree1.val:\\n            return quadTree1\\n        if quadTree2.isLeaf and quadTree2.val:\\n            return quadTree2\\n        \\n        # Divide the quad trees into four sub-trees\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        # If all sub-trees are leaves and they have same values, merge them\\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and \\\\\\n            topLeft.val == topRight.val == bottomLeft.val == bottomRight.val:\\n            return Node(topLeft.val, True, None, None, None, None)\\n        \\n        # Return the quad tree with the four sub-trees\\n        return Node(False, False, topLeft, topRight, bottomLeft, bottomRight)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317542,
                "title": "go-simple-solution",
                "content": "```\\nfunc intersect(q1 *Node, q2 *Node) *Node {\\n    if q1.IsLeaf { if q1.Val { return q1 } else { return q2 } }\\n    if q2.IsLeaf { if q2.Val { return q2 } else { return q1 } }\\n\\n    tl := intersect(q1.TopLeft, q2.TopLeft)\\n    tr := intersect(q1.TopRight, q2.TopRight)\\n    bl := intersect(q1.BottomLeft, q2.BottomLeft)\\n    br := intersect(q1.BottomRight, q2.BottomRight)\\n    a, e := tl.IsLeaf, tl.Val\\n    b, f := tr.IsLeaf, tr.Val\\n    c, g := bl.IsLeaf, bl.Val\\n    d, h := br.IsLeaf, br.Val\\n\\n    if a && b && c && d && (e == f && f == g && g == h) {\\n        return &Node{a, e, nil, nil, nil, nil}\\n    }\\n\\n    return &Node{false, false, tl, tr, bl, br}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc intersect(q1 *Node, q2 *Node) *Node {\\n    if q1.IsLeaf { if q1.Val { return q1 } else { return q2 } }\\n    if q2.IsLeaf { if q2.Val { return q2 } else { return q1 } }\\n\\n    tl := intersect(q1.TopLeft, q2.TopLeft)\\n    tr := intersect(q1.TopRight, q2.TopRight)\\n    bl := intersect(q1.BottomLeft, q2.BottomLeft)\\n    br := intersect(q1.BottomRight, q2.BottomRight)\\n    a, e := tl.IsLeaf, tl.Val\\n    b, f := tr.IsLeaf, tr.Val\\n    c, g := bl.IsLeaf, bl.Val\\n    d, h := br.IsLeaf, br.Val\\n\\n    if a && b && c && d && (e == f && f == g && g == h) {\\n        return &Node{a, e, nil, nil, nil, nil}\\n    }\\n\\n    return &Node{false, false, tl, tr, bl, br}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281787,
                "title": "python-3-10-match",
                "content": "# Approach\\nRecursion\\n\\n# Code\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        match (quadTree1,quadTree2):\\n            case (None,_)|(_,Node(isLeaf=1,val=1)):\\n                return quadTree2\\n            case (Node(isLeaf=1,val=1),_)|(_,None)|(Node(isLeaf=1),Node(isLeaf=1)):\\n                return quadTree1\\n            case _:\\n                topLeft = self.intersect(quadTree1.topLeft,quadTree2.topLeft)\\n                topRight = self.intersect(quadTree1.topRight,quadTree2.topRight)\\n                bottomLeft = self.intersect(quadTree1.bottomLeft,quadTree2.bottomLeft)\\n                bottomRight = self.intersect(quadTree1.bottomRight,quadTree2.bottomRight)\\n                if all([(n.isLeaf,n.val) == (1,topLeft.val) for n in [topLeft, topRight, bottomLeft, bottomRight]]):\\n                    return Node(1,topLeft.val)\\n                else:\\n                    return Node(1,0,topLeft, topRight, bottomLeft, bottomRight)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        match (quadTree1,quadTree2):\\n            case (None,_)|(_,Node(isLeaf=1,val=1)):\\n                return quadTree2\\n            case (Node(isLeaf=1,val=1),_)|(_,None)|(Node(isLeaf=1),Node(isLeaf=1)):\\n                return quadTree1\\n            case _:\\n                topLeft = self.intersect(quadTree1.topLeft,quadTree2.topLeft)\\n                topRight = self.intersect(quadTree1.topRight,quadTree2.topRight)\\n                bottomLeft = self.intersect(quadTree1.bottomLeft,quadTree2.bottomLeft)\\n                bottomRight = self.intersect(quadTree1.bottomRight,quadTree2.bottomRight)\\n                if all([(n.isLeaf,n.val) == (1,topLeft.val) for n in [topLeft, topRight, bottomLeft, bottomRight]]):\\n                    return Node(1,topLeft.val)\\n                else:\\n                    return Node(1,0,topLeft, topRight, bottomLeft, bottomRight)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264112,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf)\\n            return quadTree1->val ? quadTree1 : quadTree2 ;\\n        if(quadTree2->isLeaf)\\n            return quadTree2->val ? quadTree2 : quadTree1 ;\\n        \\n        Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft) ;\\n        Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight) ;\\n        Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft) ;\\n        Node* bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight) ;\\n        \\n        if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf &&\\\\\\n          topLeft->val == topRight->val && topLeft->val == bottomLeft->val && topLeft->val == bottomRight->val)\\n            return new Node(topLeft->val, true);\\n        \\n        else \\n            return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight) ;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf)\\n            return quadTree1->val ? quadTree1 : quadTree2 ;\\n        if(quadTree2->isLeaf)\\n            return quadTree2->val ? quadTree2 : quadTree1 ;\\n        \\n        Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft) ;\\n        Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight) ;\\n        Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft) ;\\n        Node* bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight) ;\\n        \\n        if(topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf &&\\\\\\n          topLeft->val == topRight->val && topLeft->val == bottomLeft->val && topLeft->val == bottomRight->val)\\n            return new Node(topLeft->val, true);\\n        \\n        else \\n            return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight) ;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237510,
                "title": "swift-clean-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard var node1 = quadTree1, var node2 = quadTree2 else { return nil }\\n\\n        // If both nodes are leaf nodes, merge and quit\\n        if node1.isLeaf, node2.isLeaf {\\n            node1.val = node1.val || node2.val\\n            \\n            return node1\\n        }\\n\\n        // Since at least one of the nodes is not a leaf node,\\n        // split the nodes if needed.\\n        split(node1)\\n        split(node2)\\n\\n        node1.topLeft = intersect(node1.topLeft, node2.topLeft)\\n        node1.topRight = intersect(node1.topRight, node2.topRight)\\n        node1.bottomLeft = intersect(node1.bottomLeft, node2.bottomLeft)\\n        node1.bottomRight = intersect(node1.bottomRight, node2.bottomRight)\\n\\n        // Merge the children if they\\'re all leaf nodes\\n        // with the same value.\\n        mergeChildren(of: node1)\\n\\n        return node1\\n    }\\n\\n    private func split(_ node: Node) {\\n        guard node.isLeaf else { return }\\n\\n        node.isLeaf = false\\n        node.topLeft = Node(node.val, true)\\n        node.topRight = Node(node.val, true)\\n        node.bottomLeft = Node(node.val, true)\\n        node.bottomRight = Node(node.val, true)\\n    }\\n\\n    private func mergeChildren(of node: Node) {\\n        guard !node.isLeaf else { return }\\n\\n        guard \\n            let topLeft = node.topLeft, \\n            let topRight = node.topRight, \\n            let bottomLeft = node.bottomLeft, \\n            let bottomRight = node.bottomRight \\n        else { return }\\n\\n        let allChildrenAreLeaf = \\n            topLeft.isLeaf \\n            && topRight.isLeaf \\n            && bottomLeft.isLeaf \\n            && bottomRight.isLeaf\\n\\n        guard allChildrenAreLeaf else { return }\\n        \\n        let childrenHaveSameValue = \\n            topLeft.val == topRight.val\\n            && topLeft.val == bottomLeft.val\\n            && topLeft.val == bottomRight.val\\n\\n        guard childrenHaveSameValue else { return }\\n\\n        node.val = topLeft.val\\n        node.isLeaf = true\\n\\n        node.topLeft = nil\\n        node.topRight = nil\\n        node.bottomLeft = nil\\n        node.bottomRight = nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard var node1 = quadTree1, var node2 = quadTree2 else { return nil }\\n\\n        // If both nodes are leaf nodes, merge and quit\\n        if node1.isLeaf, node2.isLeaf {\\n            node1.val = node1.val || node2.val\\n            \\n            return node1\\n        }\\n\\n        // Since at least one of the nodes is not a leaf node,\\n        // split the nodes if needed.\\n        split(node1)\\n        split(node2)\\n\\n        node1.topLeft = intersect(node1.topLeft, node2.topLeft)\\n        node1.topRight = intersect(node1.topRight, node2.topRight)\\n        node1.bottomLeft = intersect(node1.bottomLeft, node2.bottomLeft)\\n        node1.bottomRight = intersect(node1.bottomRight, node2.bottomRight)\\n\\n        // Merge the children if they\\'re all leaf nodes\\n        // with the same value.\\n        mergeChildren(of: node1)\\n\\n        return node1\\n    }\\n\\n    private func split(_ node: Node) {\\n        guard node.isLeaf else { return }\\n\\n        node.isLeaf = false\\n        node.topLeft = Node(node.val, true)\\n        node.topRight = Node(node.val, true)\\n        node.bottomLeft = Node(node.val, true)\\n        node.bottomRight = Node(node.val, true)\\n    }\\n\\n    private func mergeChildren(of node: Node) {\\n        guard !node.isLeaf else { return }\\n\\n        guard \\n            let topLeft = node.topLeft, \\n            let topRight = node.topRight, \\n            let bottomLeft = node.bottomLeft, \\n            let bottomRight = node.bottomRight \\n        else { return }\\n\\n        let allChildrenAreLeaf = \\n            topLeft.isLeaf \\n            && topRight.isLeaf \\n            && bottomLeft.isLeaf \\n            && bottomRight.isLeaf\\n\\n        guard allChildrenAreLeaf else { return }\\n        \\n        let childrenHaveSameValue = \\n            topLeft.val == topRight.val\\n            && topLeft.val == bottomLeft.val\\n            && topLeft.val == bottomRight.val\\n\\n        guard childrenHaveSameValue else { return }\\n\\n        node.val = topLeft.val\\n        node.isLeaf = true\\n\\n        node.topLeft = nil\\n        node.topRight = nil\\n        node.bottomLeft = nil\\n        node.bottomRight = nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237435,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe recursive operation is to find the OR for given two QuadTree Nodes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen performing the OR operation for two quadTrees, we have multiple cases, we need to handle them each individually and thus implement the intersect function.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf==true && quadTree2->isLeaf==true) {\\n            return new Node(quadTree1->val || quadTree2->val, true);\\n        }\\n        else if(quadTree1->isLeaf==true) {\\n            if(quadTree1->val==true) {\\n                return new Node(true, true);\\n            }\\n            else {\\n                return quadTree2;\\n            }\\n        } \\n        else if(quadTree2->isLeaf==true) {\\n            if(quadTree2->val==true) {\\n                return new Node(true, true);\\n            }\\n            else {\\n                return quadTree1;\\n            }\\n        }\\n        else {\\n            \\n            Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            Node* bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            \\n            bool all_are_leaves = topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf;\\n            bool same_vals = topLeft->val==topRight->val && topRight->val==bottomLeft->val && bottomLeft->val==bottomRight->val;\\n            \\n            if(all_are_leaves && same_vals) {\\n                bool val=topLeft->val;\\n                delete topLeft;\\n                delete topRight;\\n                delete bottomLeft;\\n                delete bottomRight;\\n                return new Node(val, true);\\n            }\\n            else {\\n                return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\\n            }\\n        }\\n\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf==true && quadTree2->isLeaf==true) {\\n            return new Node(quadTree1->val || quadTree2->val, true);\\n        }\\n        else if(quadTree1->isLeaf==true) {\\n            if(quadTree1->val==true) {\\n                return new Node(true, true);\\n            }\\n            else {\\n                return quadTree2;\\n            }\\n        } \\n        else if(quadTree2->isLeaf==true) {\\n            if(quadTree2->val==true) {\\n                return new Node(true, true);\\n            }\\n            else {\\n                return quadTree1;\\n            }\\n        }\\n        else {\\n            \\n            Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            Node* bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            \\n            bool all_are_leaves = topLeft->isLeaf && topRight->isLeaf && bottomLeft->isLeaf && bottomRight->isLeaf;\\n            bool same_vals = topLeft->val==topRight->val && topRight->val==bottomLeft->val && bottomLeft->val==bottomRight->val;\\n            \\n            if(all_are_leaves && same_vals) {\\n                bool val=topLeft->val;\\n                delete topLeft;\\n                delete topRight;\\n                delete bottomLeft;\\n                delete bottomRight;\\n                return new Node(val, true);\\n            }\\n            else {\\n                return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\\n            }\\n        }\\n\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237256,
                "title": "intuitive-java-solution-beats-100",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if(q1.isLeaf && q1.val) return q1;\\n        if(q2.isLeaf && q2.val) return q2;\\n        if(q2.isLeaf && !q2.val) return q1;\\n        if(q1.isLeaf && !q1.val) return q2;\\n\\n        Node ret= new  Node(false,false,intersect(q1.topLeft,q2.topLeft),intersect(q1.topRight,q2.topRight),\\n        intersect(q1.bottomLeft,q2.bottomLeft),intersect(q1.bottomRight,q2.bottomRight));\\n\\n        if(allSameValue(ret))\\n         return ret.bottomLeft;\\n        \\n        return ret;\\n\\n    }\\n    public boolean allSameValue(Node q)\\n    {\\n        return q.bottomLeft.isLeaf &&q.topLeft.isLeaf\\n         &&q.topRight.isLeaf &&q.bottomRight.isLeaf && \\n         q.bottomLeft.val==q.bottomRight.val &&\\n         q.bottomRight.val==q.topRight.val &&\\n         q.topRight.val==q.topLeft.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if(q1.isLeaf && q1.val) return q1;\\n        if(q2.isLeaf && q2.val) return q2;\\n        if(q2.isLeaf && !q2.val) return q1;\\n        if(q1.isLeaf && !q1.val) return q2;\\n\\n        Node ret= new  Node(false,false,intersect(q1.topLeft,q2.topLeft),intersect(q1.topRight,q2.topRight),\\n        intersect(q1.bottomLeft,q2.bottomLeft),intersect(q1.bottomRight,q2.bottomRight));\\n\\n        if(allSameValue(ret))\\n         return ret.bottomLeft;\\n        \\n        return ret;\\n\\n    }\\n    public boolean allSameValue(Node q)\\n    {\\n        return q.bottomLeft.isLeaf &&q.topLeft.isLeaf\\n         &&q.topRight.isLeaf &&q.bottomRight.isLeaf && \\n         q.bottomLeft.val==q.bottomRight.val &&\\n         q.bottomRight.val==q.topRight.val &&\\n         q.topRight.val==q.topLeft.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236160,
                "title": "c-divide-and-conquer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// Node* f(vector<vector<int>>& grid,int n,int i,int j){\\n//     if(n==1) return new Node(grid[i][j],true);\\n//     Node* root=new Node();\\n//     int s=n/2;\\n//     Node* tl=f(grid,s,i,j);\\n//     Node* tr=f(grid,s,i,j+s);\\n//     Node* dl=f(grid,s,i+s,j);\\n//     Node* dr=f(grid,s,i+s,j+s);\\n//     if(tl->isLeaf &&  tr->isLeaf &&  dl->isLeaf &&  dr->isLeaf && tl->val==tr->val && dl->val==tr->val && dr->val==tl->val){\\n//         root->val=tl->val;\\n//         root->isLeaf=true;\\n//     }\\n//     else{\\n//        root->topLeft=tl;\\n//        root->topRight=tr; \\n//        root->bottomLeft=dl;\\n//        root->bottomRight=dr;\\n//     }\\n//     return root;\\n\\n// }\\n\\n    Node* intersect(Node* q1, Node* q2) {\\n        if(q1->isLeaf && q2->isLeaf){\\n            if(q1->val==q2->val) return q1;\\n            else return new Node(1,1);\\n        }\\n        if(q1->isLeaf || q2->isLeaf){\\n            if(q1->isLeaf){\\n                if(q1->val==1) return q1;\\n                else return q2;\\n            }\\n            if(q2->isLeaf){\\n                if(q2->val==1) return q2;\\n                else return q1;\\n            }\\n        }\\n        Node* root=new Node();\\n        Node* tl=intersect(q1->topLeft,q2->topLeft);\\n        Node* tr=intersect(q1->topRight,q2->topRight);\\n        Node* dl=intersect(q1->bottomLeft,q2->bottomLeft);\\n        Node* dr=intersect(q1->bottomRight,q2->bottomRight);\\n        if(tl->isLeaf &&  tr->isLeaf &&  dl->isLeaf &&  dr->isLeaf && tl->val==tr->val && dl->val==tr->val && dr->val==tl->val){\\n            root->val=tl->val;\\n            root->isLeaf=true;\\n        }\\n        else{\\n        root->topLeft=tl;\\n        root->topRight=tr; \\n        root->bottomLeft=dl;\\n        root->bottomRight=dr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// Node* f(vector<vector<int>>& grid,int n,int i,int j){\\n//     if(n==1) return new Node(grid[i][j],true);\\n//     Node* root=new Node();\\n//     int s=n/2;\\n//     Node* tl=f(grid,s,i,j);\\n//     Node* tr=f(grid,s,i,j+s);\\n//     Node* dl=f(grid,s,i+s,j);\\n//     Node* dr=f(grid,s,i+s,j+s);\\n//     if(tl->isLeaf &&  tr->isLeaf &&  dl->isLeaf &&  dr->isLeaf && tl->val==tr->val && dl->val==tr->val && dr->val==tl->val){\\n//         root->val=tl->val;\\n//         root->isLeaf=true;\\n//     }\\n//     else{\\n//        root->topLeft=tl;\\n//        root->topRight=tr; \\n//        root->bottomLeft=dl;\\n//        root->bottomRight=dr;\\n//     }\\n//     return root;\\n\\n// }\\n\\n    Node* intersect(Node* q1, Node* q2) {\\n        if(q1->isLeaf && q2->isLeaf){\\n            if(q1->val==q2->val) return q1;\\n            else return new Node(1,1);\\n        }\\n        if(q1->isLeaf || q2->isLeaf){\\n            if(q1->isLeaf){\\n                if(q1->val==1) return q1;\\n                else return q2;\\n            }\\n            if(q2->isLeaf){\\n                if(q2->val==1) return q2;\\n                else return q1;\\n            }\\n        }\\n        Node* root=new Node();\\n        Node* tl=intersect(q1->topLeft,q2->topLeft);\\n        Node* tr=intersect(q1->topRight,q2->topRight);\\n        Node* dl=intersect(q1->bottomLeft,q2->bottomLeft);\\n        Node* dr=intersect(q1->bottomRight,q2->bottomRight);\\n        if(tl->isLeaf &&  tr->isLeaf &&  dl->isLeaf &&  dr->isLeaf && tl->val==tr->val && dl->val==tr->val && dr->val==tl->val){\\n            root->val=tl->val;\\n            root->isLeaf=true;\\n        }\\n        else{\\n        root->topLeft=tl;\\n        root->topRight=tr; \\n        root->bottomLeft=dl;\\n        root->bottomRight=dr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234891,
                "title": "java-100-faster",
                "content": "# Approach\\nFirst, we have to find the size of the grid. We do this by finding the depth ```d``` of the tree. Then the size of the grid is ```2^2d```.\\n\\nWe then initialize 2 grids of the same size and fill them up by recursing through the tree.\\n\\nIf we find a leaf node, we fill up the grid squares that it represents with the appropritate value.\\n\\nIf it is not a leaf, we recurse into its children until we find a leaf.\\n\\nThe base case is when we are down to a single cell.\\n\\nWe then initialize a third grid and calculate the OR values for each cell.\\n\\nFinally, we build a new quad tree representing the result grid. The logic for that is explained here: https://leetcode.com/problems/construct-quad-tree/solutions/3234856/java-100-faster/\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int [][] g;\\n    \\n    public Node intersect(Node quadTree1, Node quadTree2)\\n    {\\n        int n = (int)Math.pow(2,Math.max(calc(quadTree1),calc(quadTree2)));\\n\\n        int [][] a = new int[n][n];\\n        int [][] b = new int[n][n];\\n\\n        fill(a,quadTree1,0,0,n-1,n-1);\\n        fill(b,quadTree2,0,0,n-1,n-1);\\n\\n        g = new int[n][n];\\n\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                g[i][j] = (a[i][j]+b[i][j] > 0 ? 1 : 0);\\n\\n        return make(0,0,g.length-1,g.length-1);\\n    }\\n\\n    private int calc(Node n)\\n    {\\n        return 1 + (n.isLeaf ? 0 :\\n                            Math.max(calc(n.topLeft),\\n                                Math.max(calc(n.topRight),\\n                                    Math.max(calc(n.bottomLeft),calc(n.bottomRight)))));\\n    }\\n\\n    private void fill(int [][] a, Node n, int x1, int y1, int x2, int y2)\\n    {\\n        int v = n.val ? 1 : 0;\\n        \\n        if(x1==x2)\\n            a[x1][y1] = v;\\n        \\n        else if(n.isLeaf)\\n        {\\n            for(int i=x1; i<=x2; i++)\\n                for(int j=y1; j<=y2; j++)\\n                    a[i][j] = v;\\n        }\\n\\n        else\\n        {\\n            fill(a,n.topLeft,x1,y1,(x1+x2)/2,(y1+y2)/2);\\n            fill(a,n.topRight,x1,1+(y1+y2)/2,(x1+x2)/2,y2);\\n            fill(a,n.bottomLeft,1+(x1+x2)/2,y1,x2,(y1+y2)/2);\\n            fill(a,n.bottomRight,1+(x1+x2)/2,1+(y1+y2)/2,x2,y2);\\n        }\\n    }\\n\\n    private Node make(int x1, int y1, int x2, int y2)\\n    {\\n        if(x1==x2)\\n            return new Node(g[x1][y1]==1, true);\\n        \\n        int r = g[x1][y1];\\n        boolean l = true;\\n\\n        for(int i=x1; i<=x2 && l; i++)\\n            for(int j=y1; j<=y2 && l; j++)\\n                if(g[i][j]!=r)\\n                    l = false;\\n\\n        return  l ? new Node(r==1, true) : new Node(r==1,false,\\n                        make(x1,y1,(x1+x2)/2,(y1+y2)/2),\\n                        make(x1,1+(y1+y2)/2,(x1+x2)/2,y2),\\n                        make(1+(x1+x2)/2,y1,x2,(y1+y2)/2),\\n                        make(1+(x1+x2)/2,1+(y1+y2)/2,x2,y2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```d```\n```2^2d```\n```\\nclass Solution\\n{\\n    int [][] g;\\n    \\n    public Node intersect(Node quadTree1, Node quadTree2)\\n    {\\n        int n = (int)Math.pow(2,Math.max(calc(quadTree1),calc(quadTree2)));\\n\\n        int [][] a = new int[n][n];\\n        int [][] b = new int[n][n];\\n\\n        fill(a,quadTree1,0,0,n-1,n-1);\\n        fill(b,quadTree2,0,0,n-1,n-1);\\n\\n        g = new int[n][n];\\n\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                g[i][j] = (a[i][j]+b[i][j] > 0 ? 1 : 0);\\n\\n        return make(0,0,g.length-1,g.length-1);\\n    }\\n\\n    private int calc(Node n)\\n    {\\n        return 1 + (n.isLeaf ? 0 :\\n                            Math.max(calc(n.topLeft),\\n                                Math.max(calc(n.topRight),\\n                                    Math.max(calc(n.bottomLeft),calc(n.bottomRight)))));\\n    }\\n\\n    private void fill(int [][] a, Node n, int x1, int y1, int x2, int y2)\\n    {\\n        int v = n.val ? 1 : 0;\\n        \\n        if(x1==x2)\\n            a[x1][y1] = v;\\n        \\n        else if(n.isLeaf)\\n        {\\n            for(int i=x1; i<=x2; i++)\\n                for(int j=y1; j<=y2; j++)\\n                    a[i][j] = v;\\n        }\\n\\n        else\\n        {\\n            fill(a,n.topLeft,x1,y1,(x1+x2)/2,(y1+y2)/2);\\n            fill(a,n.topRight,x1,1+(y1+y2)/2,(x1+x2)/2,y2);\\n            fill(a,n.bottomLeft,1+(x1+x2)/2,y1,x2,(y1+y2)/2);\\n            fill(a,n.bottomRight,1+(x1+x2)/2,1+(y1+y2)/2,x2,y2);\\n        }\\n    }\\n\\n    private Node make(int x1, int y1, int x2, int y2)\\n    {\\n        if(x1==x2)\\n            return new Node(g[x1][y1]==1, true);\\n        \\n        int r = g[x1][y1];\\n        boolean l = true;\\n\\n        for(int i=x1; i<=x2 && l; i++)\\n            for(int j=y1; j<=y2 && l; j++)\\n                if(g[i][j]!=r)\\n                    l = false;\\n\\n        return  l ? new Node(r==1, true) : new Node(r==1,false,\\n                        make(x1,y1,(x1+x2)/2,(y1+y2)/2),\\n                        make(x1,1+(y1+y2)/2,(x1+x2)/2,y2),\\n                        make(1+(x1+x2)/2,y1,x2,(y1+y2)/2),\\n                        make(1+(x1+x2)/2,1+(y1+y2)/2,x2,y2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234538,
                "title": "python-recursion-explained",
                "content": "We can recursively traverse each branch of the two trees.\\n\\nSince we are solving bitwise OR of the two trees, there are some special handling when we build a new node based on the return nodes from the children:\\n(1) if this node is a leaf node, we can directly return this node if its value is 1 or the other node is its value is 0.\\n(2) After we get the four children, if they all are leaf nodes and they all have the same value, we can create a new leaf node with the value.\\n(3) If the four children are not leaf nodes, just build a new node and return it.\\n\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1 is None:\\n            return quadTree2\\n        \\n        if quadTree2 is None:\\n            return quadTree1\\n        \\n        root = self.buildTree(quadTree1, quadTree2)\\n        \\n        return root\\n    \\n    def buildTree(self, t1, t2):\\n        if t1.isLeaf:\\n            if t1.val:\\n                return t1\\n            else:\\n                return t2\\n            \\n        if t2.isLeaf:\\n            if t2.val:\\n                return t2\\n            else:\\n                return t1\\n            \\n        # both nodes are not leaf\\n        tl = self.buildTree(t1.topLeft, t2.topLeft)\\n        tr = self.buildTree(t1.topRight, t2.topRight)\\n        bl = self.buildTree(t1.bottomLeft, t2.bottomLeft)\\n        br = self.buildTree(t1.bottomRight, t2.bottomRight)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n        \\n        return new_node\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1 is None:\\n            return quadTree2\\n        \\n        if quadTree2 is None:\\n            return quadTree1\\n        \\n        root = self.buildTree(quadTree1, quadTree2)\\n        \\n        return root\\n    \\n    def buildTree(self, t1, t2):\\n        if t1.isLeaf:\\n            if t1.val:\\n                return t1\\n            else:\\n                return t2\\n            \\n        if t2.isLeaf:\\n            if t2.val:\\n                return t2\\n            else:\\n                return t1\\n            \\n        # both nodes are not leaf\\n        tl = self.buildTree(t1.topLeft, t2.topLeft)\\n        tr = self.buildTree(t1.topRight, t2.topRight)\\n        bl = self.buildTree(t1.bottomLeft, t2.bottomLeft)\\n        br = self.buildTree(t1.bottomRight, t2.bottomRight)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n        \\n        return new_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130454,
                "title": "python3-combine-in-place-then-reconcile",
                "content": "# Intuition\\nThis problem was more tedious than hard - child nodes should be in an array.  Although, I did fail to simplify the output during the initial runthrough.\\n\\n# Code\\n```\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        def rec(n1, n2):\\n            if n1.isLeaf and n2.isLeaf:\\n                n1.val = n1.val or n2.val\\n            elif (not n1.isLeaf) and not (n2.isLeaf):\\n                rec(n1.topLeft, n2.topLeft)\\n                rec(n1.topRight, n2.topRight)\\n                rec(n1.bottomLeft, n2.bottomLeft)\\n                rec(n1.bottomRight, n2.bottomRight)\\n            elif n1.isLeaf and n1.val or n2.isLeaf and n2.val:\\n                n1.isLeaf = True\\n                n1.val = True\\n                n1.topLeft = None\\n                n1.topRight = None\\n                n1.bottomLeft = None\\n                n1.bottomRight = None\\n            elif n1.isLeaf:\\n                n1.isLeaf = n2.isLeaf\\n                n1.val = n2.val\\n                n1.topLeft = n2.topLeft\\n                n1.topRight = n2.topRight\\n                n1.bottomLeft = n2.bottomLeft\\n                n1.bottomRight = n2.bottomRight\\n\\n        rec(q1, q2)\\n\\n        def color(n1):\\n            if n1.isLeaf:\\n                return n1.val\\n            items = set([color(n1.topLeft), color(n1.topRight), color(n1.bottomLeft), color(n1.bottomRight)])\\n            if len(items) > 1:\\n                return None\\n            item = items.pop()\\n            if item is None:\\n                return None\\n            n1.isLeaf = True\\n            n1.val = item\\n            n1.topLeft = None\\n            n1.topRight = None\\n            n1.bottomLeft = None\\n            n1.bottomRight = None\\n\\n            return item\\n            \\n        color(q1)\\n        return q1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, q1: \\'Node\\', q2: \\'Node\\') -> \\'Node\\':\\n        def rec(n1, n2):\\n            if n1.isLeaf and n2.isLeaf:\\n                n1.val = n1.val or n2.val\\n            elif (not n1.isLeaf) and not (n2.isLeaf):\\n                rec(n1.topLeft, n2.topLeft)\\n                rec(n1.topRight, n2.topRight)\\n                rec(n1.bottomLeft, n2.bottomLeft)\\n                rec(n1.bottomRight, n2.bottomRight)\\n            elif n1.isLeaf and n1.val or n2.isLeaf and n2.val:\\n                n1.isLeaf = True\\n                n1.val = True\\n                n1.topLeft = None\\n                n1.topRight = None\\n                n1.bottomLeft = None\\n                n1.bottomRight = None\\n            elif n1.isLeaf:\\n                n1.isLeaf = n2.isLeaf\\n                n1.val = n2.val\\n                n1.topLeft = n2.topLeft\\n                n1.topRight = n2.topRight\\n                n1.bottomLeft = n2.bottomLeft\\n                n1.bottomRight = n2.bottomRight\\n\\n        rec(q1, q2)\\n\\n        def color(n1):\\n            if n1.isLeaf:\\n                return n1.val\\n            items = set([color(n1.topLeft), color(n1.topRight), color(n1.bottomLeft), color(n1.bottomRight)])\\n            if len(items) > 1:\\n                return None\\n            item = items.pop()\\n            if item is None:\\n                return None\\n            n1.isLeaf = True\\n            n1.val = item\\n            n1.topLeft = None\\n            n1.topRight = None\\n            n1.bottomLeft = None\\n            n1.bottomRight = None\\n\\n            return item\\n            \\n        color(q1)\\n        return q1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023259,
                "title": "java-simple-solution-recursion-100-beats",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node a, Node b) {\\n        if(a.isLeaf){\\n            return a.val ? a : b;\\n        }\\n        if(b.isLeaf){\\n            return b.val ? b : a;\\n        }\\n\\n        a.topLeft = intersect(a.topLeft,b.topLeft);\\n        a.topRight = intersect(a.topRight,b.topRight);\\n        a.bottomLeft = intersect(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = intersect(a.bottomRight,b.bottomRight);\\n\\n        if (a.topLeft.isLeaf && a.topRight.isLeaf \\n            && a.bottomLeft.isLeaf && a.bottomRight.isLeaf\\n            && a.topLeft.val == a.topRight.val \\n            && a.topRight.val == a.bottomLeft.val \\n            && a.bottomLeft.val == a.bottomRight.val) {\\n            return new Node(true,a.topLeft.val);\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966806,
                "title": "ruby-123-ms",
                "content": "```ruby\\ndef intersect a, b\\n\\tif a.isLeaf; a.val ? a : b\\n    elsif b.isLeaf; b.val ? b : a\\n    else\\n        c = [intersect(a.topLeft, b.topLeft), intersect(a.topRight, b.topRight),\\n             intersect(a.bottomLeft, b.bottomLeft), intersect(a.bottomRight, b.bottomRight)]\\n        c.count(&:isLeaf) == 4 && c.map(&:val).uniq.size == 1 ?\\n            Node.new(c.first.val, true) : Node.new(false, false, *c)\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef intersect a, b\\n\\tif a.isLeaf; a.val ? a : b\\n    elsif b.isLeaf; b.val ? b : a\\n    else\\n        c = [intersect(a.topLeft, b.topLeft), intersect(a.topRight, b.topRight),\\n             intersect(a.bottomLeft, b.bottomLeft), intersect(a.bottomRight, b.bottomRight)]\\n        c.count(&:isLeaf) == 4 && c.map(&:val).uniq.size == 1 ?\\n            Node.new(c.first.val, true) : Node.new(false, false, *c)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2925613,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition \\n        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: \\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(None, False, tl, tr, bl, br)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition \\n        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: \\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(None, False, tl, tr, bl, br)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891656,
                "title": "python-solution",
                "content": "# Approach\\nThis problem is different from many other problems here. In reality we need to traverse both trees in parallel and construct the result tree. \\nThe approach is defined as checking different cases:\\n1. Two empty trees give an empty tree as the result (``None``)\\n2. If one of the trees is empty - then result is a clone of the other tree\\n3. If both trees are leaves - just perform logical ``or`` on their values and construct another leave node as the output\\n4. If one of the trees is a leaf which is ``True``, then the other tree doesn\\'t matter and we return a ``True`` leaf node\\n5. Otherwise we deal with the general case and the recursion - joining each child subtree. A tricky thing here is that we could end up with all subtrees having ``True`` values - in this case we compress current node into a ``True`` leaf node. This will also be propagated bottom-up in the result tree.\\n\\n# Code\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n\\n        if not quadTree1 and not quadTree2:\\n            return None\\n\\n        if not quadTree1:\\n            return copy.deepcopy(quadTree2)\\n\\n        if not quadTree2:\\n            return copy.deepcopy(quadTree1)\\n\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            return Node(quadTree1.val or quadTree2.val, True, None, None, None, None)\\n        elif quadTree1.isLeaf and quadTree1.val or quadTree2.isLeaf and quadTree2.val:\\n            return Node(True, True, None, None, None, None)\\n\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n\\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and \\\\\\n           topLeft.val and topRight.val and bottomLeft.val and bottomRight.val:\\n            return Node(True, True, None, None, None, None)\\n\\n        result = Node(False, False,\\n                      topLeft,\\n                      topRight,\\n                      bottomLeft,\\n                      bottomRight)\\n\\n        return result\\n```\\n\\n\\nShall you have any questions or concerns please ask here, and upvote if you like the approach!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n\\n        if not quadTree1 and not quadTree2:\\n            return None\\n\\n        if not quadTree1:\\n            return copy.deepcopy(quadTree2)\\n\\n        if not quadTree2:\\n            return copy.deepcopy(quadTree1)\\n\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            return Node(quadTree1.val or quadTree2.val, True, None, None, None, None)\\n        elif quadTree1.isLeaf and quadTree1.val or quadTree2.isLeaf and quadTree2.val:\\n            return Node(True, True, None, None, None, None)\\n\\n        topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n        topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n\\n        if topLeft.isLeaf and topRight.isLeaf and bottomLeft.isLeaf and bottomRight.isLeaf and \\\\\\n           topLeft.val and topRight.val and bottomLeft.val and bottomRight.val:\\n            return Node(True, True, None, None, None, None)\\n\\n        result = Node(False, False,\\n                      topLeft,\\n                      topRight,\\n                      bottomLeft,\\n                      bottomRight)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880536,
                "title": "go-dfs",
                "content": "```\\nfunc intersect(quadTree1 *Node, quadTree2 *Node) *Node {\\n\\tvar dfs func(r1 *Node, r2 *Node) *Node\\n\\tdfs = func(r1 *Node, r2 *Node) *Node {\\n\\t\\tif r1.IsLeaf {\\n\\t\\t\\tif !r1.Val {\\n\\t\\t\\t\\treturn r2\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif r2.IsLeaf {\\n\\t\\t\\tif !r2.Val {\\n\\t\\t\\t\\treturn r1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttl := dfs(r1.TopLeft, r2.TopLeft)\\n\\t\\ttr := dfs(r1.TopRight, r2.TopRight)\\n\\t\\tbl := dfs(r1.BottomLeft, r2.BottomLeft)\\n\\t\\tbr := dfs(r1.BottomRight, r2.BottomRight)\\n\\t\\tif tl.Val == tr.Val && bl.Val == br.Val && tr.Val == br.Val && br.Val && tl.IsLeaf && tr.IsLeaf && bl.IsLeaf && br.IsLeaf {\\n\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t}\\n\\t\\tif tl.Val || bl.Val || tr.Val || br.Val {\\n\\t\\t\\treturn &Node{Val: true, IsLeaf: false, TopLeft: tl, TopRight: tr, BottomLeft: bl, BottomRight: br}\\n\\t\\t}\\n\\t\\treturn &Node{Val: false, IsLeaf: false, TopLeft: tl, TopRight: tr, BottomLeft: bl, BottomRight: br}\\n\\t}\\n\\treturn dfs(quadTree1, quadTree2)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc intersect(quadTree1 *Node, quadTree2 *Node) *Node {\\n\\tvar dfs func(r1 *Node, r2 *Node) *Node\\n\\tdfs = func(r1 *Node, r2 *Node) *Node {\\n\\t\\tif r1.IsLeaf {\\n\\t\\t\\tif !r1.Val {\\n\\t\\t\\t\\treturn r2\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif r2.IsLeaf {\\n\\t\\t\\tif !r2.Val {\\n\\t\\t\\t\\treturn r1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttl := dfs(r1.TopLeft, r2.TopLeft)\\n\\t\\ttr := dfs(r1.TopRight, r2.TopRight)\\n\\t\\tbl := dfs(r1.BottomLeft, r2.BottomLeft)\\n\\t\\tbr := dfs(r1.BottomRight, r2.BottomRight)\\n\\t\\tif tl.Val == tr.Val && bl.Val == br.Val && tr.Val == br.Val && br.Val && tl.IsLeaf && tr.IsLeaf && bl.IsLeaf && br.IsLeaf {\\n\\t\\t\\treturn &Node{Val: true, IsLeaf: true}\\n\\t\\t}\\n\\t\\tif tl.Val || bl.Val || tr.Val || br.Val {\\n\\t\\t\\treturn &Node{Val: true, IsLeaf: false, TopLeft: tl, TopRight: tr, BottomLeft: bl, BottomRight: br}\\n\\t\\t}\\n\\t\\treturn &Node{Val: false, IsLeaf: false, TopLeft: tl, TopRight: tr, BottomLeft: bl, BottomRight: br}\\n\\t}\\n\\treturn dfs(quadTree1, quadTree2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869062,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n#![allow(dead_code)]\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\n#[derive(Debug, Clone, PartialEq, Eq)]\\npub enum Node {\\n    Leaf(bool),\\n    Node {\\n        val: bool,\\n        top_left: Option<Rc<RefCell<Node>>>,\\n        top_right: Option<Rc<RefCell<Node>>>,\\n        bottom_left: Option<Rc<RefCell<Node>>>,\\n        bottom_right: Option<Rc<RefCell<Node>>>,\\n    },\\n}\\n\\nimpl Node {\\n    pub fn new(\\n        is_leaf: bool,\\n        val: bool,\\n        top_left: Option<Rc<RefCell<Node>>>,\\n        top_right: Option<Rc<RefCell<Node>>>,\\n        bottom_left: Option<Rc<RefCell<Node>>>,\\n        bottom_right: Option<Rc<RefCell<Node>>>,\\n    ) -> Self {\\n        if is_leaf {\\n            assert!(top_left.is_none());\\n            assert!(top_right.is_none());\\n            assert!(bottom_left.is_none());\\n            assert!(bottom_right.is_none());\\n            Node::Leaf(val)\\n        } else {\\n            Node::Node {\\n                val,\\n                top_left,\\n                top_right,\\n                bottom_left,\\n                bottom_right,\\n            }\\n        }\\n    }\\n\\n    pub fn is_leaf(&self) -> bool {\\n        match self {\\n            Node::Leaf(_) => true,\\n            Node::Node { .. } => false,\\n        }\\n    }\\n\\n    pub fn val(&self) -> bool {\\n        match self {\\n            Node::Leaf(val) => *val,\\n            Node::Node { val, .. } => *val,\\n        }\\n    }\\n\\n    pub fn top_left(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left,\\n                top_right: _,\\n                bottom_left: _,\\n                bottom_right: _,\\n            } => top_left.clone(),\\n        }\\n    }\\n\\n    pub fn top_right(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right,\\n                bottom_left: _,\\n                bottom_right: _,\\n            } => top_right.clone(),\\n        }\\n    }\\n\\n    pub fn bottom_left(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right: _,\\n                bottom_left,\\n                bottom_right: _,\\n            } => bottom_left.clone(),\\n        }\\n    }\\n\\n    pub fn bottom_right(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right: _,\\n                bottom_left: _,\\n                bottom_right,\\n            } => bottom_right.clone(),\\n        }\\n    }\\n}\\n\\nimpl std::fmt::Display for Node {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        match self {\\n            Node::Leaf(val) => write!(f, \"Leaf(val = {})\", val),\\n            Node::Node {\\n                val,\\n                top_left,\\n                top_right,\\n                bottom_left,\\n                bottom_right,\\n            } => write!(\\n                f,\\n                \"Node(val = {}, {}, {}, {}, {})\",\\n                val,\\n                top_left\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                top_right\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                bottom_left\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                bottom_right\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n            ),\\n        }\\n    }\\n}\\n\\nstruct Solution;\\n\\n//use std::cell::RefCell;\\n//use std::rc::Rc;\\nimpl Solution {\\n    pub fn intersect(\\n        quad_tree1: Option<Rc<RefCell<Node>>>,\\n        quad_tree2: Option<Rc<RefCell<Node>>>,\\n    ) -> Option<Rc<RefCell<Node>>> {\\n        if quad_tree1.is_none() {\\n            return quad_tree2;\\n        }\\n        if quad_tree2.is_none() {\\n            return quad_tree1;\\n        }\\n        if quad_tree1.as_ref().unwrap().borrow().is_leaf() {\\n            return if quad_tree1.as_ref().unwrap().borrow().val() {\\n                quad_tree1\\n            } else {\\n                quad_tree2\\n            };\\n        }\\n        if quad_tree2.as_ref().unwrap().borrow().is_leaf() {\\n            return if quad_tree2.as_ref().unwrap().borrow().val() {\\n                quad_tree2\\n            } else {\\n                quad_tree1\\n            };\\n        }\\n        let tl = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().top_left(),\\n            quad_tree2.as_ref().unwrap().borrow().top_left(),\\n        );\\n        let tr = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().top_right(),\\n            quad_tree2.as_ref().unwrap().borrow().top_right(),\\n        );\\n        let bl = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().bottom_left(),\\n            quad_tree2.as_ref().unwrap().borrow().bottom_left(),\\n        );\\n        let br = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().bottom_right(),\\n            quad_tree2.as_ref().unwrap().borrow().bottom_right(),\\n        );\\n        if tl.is_some()\\n            && tr.is_some()\\n            && bl.is_some()\\n            && br.is_some()\\n            && tl.as_ref().unwrap().borrow().is_leaf()\\n            && tr.as_ref().unwrap().borrow().is_leaf()\\n            && bl.as_ref().unwrap().borrow().is_leaf()\\n            && br.as_ref().unwrap().borrow().is_leaf()\\n            && tl.as_ref().unwrap().borrow().val() == tr.as_ref().unwrap().borrow().val()\\n            && tl.as_ref().unwrap().borrow().val() == bl.as_ref().unwrap().borrow().val()\\n            && tl.as_ref().unwrap().borrow().val() == br.as_ref().unwrap().borrow().val()\\n        {\\n            Some(Rc::new(RefCell::new(Node::new(\\n                true,\\n                tl.as_ref().unwrap().borrow().val(),\\n                None,\\n                None,\\n                None,\\n                None,\\n            ))))\\n        } else {\\n            Some(Rc::new(RefCell::new(Node::new(false, false, tl, tr, bl, br))))\\n        }\\n    }\\n}\\n\\n#[test]\\nfn test() {\\n    let leaf_false = Some(Rc::new(RefCell::new(Node::new(true, false,  None, None, None, None))));\\n    let leaf_true = Some(Rc::new(RefCell::new(Node::new(true, true, None, None, None, None))));\\n\\n    let quad_tree1 = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        true,\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n        leaf_false.clone(),\\n    ))));\\n\\n    let quad_tree2_tr = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        false,\\n        leaf_false.clone(),\\n        leaf_false.clone(),\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n    ))));\\n\\n    let quad_tree2 = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        true,\\n        leaf_true.clone(),\\n        quad_tree2_tr,\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n    ))));\\n\\n    let res = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        false,\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n    ))));\\n    assert_eq!(Solution::intersect(quad_tree1, quad_tree2), res);\\n\\n    let quad_tree1 = leaf_false.clone();\\n    let quad_tree2 = leaf_false.clone();\\n    let res = leaf_false.clone();\\n    assert_eq!(Solution::intersect(quad_tree1, quad_tree2), res);\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n#![allow(dead_code)]\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\n#[derive(Debug, Clone, PartialEq, Eq)]\\npub enum Node {\\n    Leaf(bool),\\n    Node {\\n        val: bool,\\n        top_left: Option<Rc<RefCell<Node>>>,\\n        top_right: Option<Rc<RefCell<Node>>>,\\n        bottom_left: Option<Rc<RefCell<Node>>>,\\n        bottom_right: Option<Rc<RefCell<Node>>>,\\n    },\\n}\\n\\nimpl Node {\\n    pub fn new(\\n        is_leaf: bool,\\n        val: bool,\\n        top_left: Option<Rc<RefCell<Node>>>,\\n        top_right: Option<Rc<RefCell<Node>>>,\\n        bottom_left: Option<Rc<RefCell<Node>>>,\\n        bottom_right: Option<Rc<RefCell<Node>>>,\\n    ) -> Self {\\n        if is_leaf {\\n            assert!(top_left.is_none());\\n            assert!(top_right.is_none());\\n            assert!(bottom_left.is_none());\\n            assert!(bottom_right.is_none());\\n            Node::Leaf(val)\\n        } else {\\n            Node::Node {\\n                val,\\n                top_left,\\n                top_right,\\n                bottom_left,\\n                bottom_right,\\n            }\\n        }\\n    }\\n\\n    pub fn is_leaf(&self) -> bool {\\n        match self {\\n            Node::Leaf(_) => true,\\n            Node::Node { .. } => false,\\n        }\\n    }\\n\\n    pub fn val(&self) -> bool {\\n        match self {\\n            Node::Leaf(val) => *val,\\n            Node::Node { val, .. } => *val,\\n        }\\n    }\\n\\n    pub fn top_left(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left,\\n                top_right: _,\\n                bottom_left: _,\\n                bottom_right: _,\\n            } => top_left.clone(),\\n        }\\n    }\\n\\n    pub fn top_right(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right,\\n                bottom_left: _,\\n                bottom_right: _,\\n            } => top_right.clone(),\\n        }\\n    }\\n\\n    pub fn bottom_left(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right: _,\\n                bottom_left,\\n                bottom_right: _,\\n            } => bottom_left.clone(),\\n        }\\n    }\\n\\n    pub fn bottom_right(&self) -> Option<Rc<RefCell<Node>>> {\\n        match self {\\n            Node::Leaf(_) => None,\\n            Node::Node {\\n                val: _,\\n                top_left: _,\\n                top_right: _,\\n                bottom_left: _,\\n                bottom_right,\\n            } => bottom_right.clone(),\\n        }\\n    }\\n}\\n\\nimpl std::fmt::Display for Node {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        match self {\\n            Node::Leaf(val) => write!(f, \"Leaf(val = {})\", val),\\n            Node::Node {\\n                val,\\n                top_left,\\n                top_right,\\n                bottom_left,\\n                bottom_right,\\n            } => write!(\\n                f,\\n                \"Node(val = {}, {}, {}, {}, {})\",\\n                val,\\n                top_left\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                top_right\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                bottom_left\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n                bottom_right\\n                    .as_ref()\\n                    .map(|node| node.borrow().to_string())\\n                    .unwrap_or_else(|| \"null\".to_string()),\\n            ),\\n        }\\n    }\\n}\\n\\nstruct Solution;\\n\\n//use std::cell::RefCell;\\n//use std::rc::Rc;\\nimpl Solution {\\n    pub fn intersect(\\n        quad_tree1: Option<Rc<RefCell<Node>>>,\\n        quad_tree2: Option<Rc<RefCell<Node>>>,\\n    ) -> Option<Rc<RefCell<Node>>> {\\n        if quad_tree1.is_none() {\\n            return quad_tree2;\\n        }\\n        if quad_tree2.is_none() {\\n            return quad_tree1;\\n        }\\n        if quad_tree1.as_ref().unwrap().borrow().is_leaf() {\\n            return if quad_tree1.as_ref().unwrap().borrow().val() {\\n                quad_tree1\\n            } else {\\n                quad_tree2\\n            };\\n        }\\n        if quad_tree2.as_ref().unwrap().borrow().is_leaf() {\\n            return if quad_tree2.as_ref().unwrap().borrow().val() {\\n                quad_tree2\\n            } else {\\n                quad_tree1\\n            };\\n        }\\n        let tl = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().top_left(),\\n            quad_tree2.as_ref().unwrap().borrow().top_left(),\\n        );\\n        let tr = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().top_right(),\\n            quad_tree2.as_ref().unwrap().borrow().top_right(),\\n        );\\n        let bl = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().bottom_left(),\\n            quad_tree2.as_ref().unwrap().borrow().bottom_left(),\\n        );\\n        let br = Solution::intersect(\\n            quad_tree1.as_ref().unwrap().borrow().bottom_right(),\\n            quad_tree2.as_ref().unwrap().borrow().bottom_right(),\\n        );\\n        if tl.is_some()\\n            && tr.is_some()\\n            && bl.is_some()\\n            && br.is_some()\\n            && tl.as_ref().unwrap().borrow().is_leaf()\\n            && tr.as_ref().unwrap().borrow().is_leaf()\\n            && bl.as_ref().unwrap().borrow().is_leaf()\\n            && br.as_ref().unwrap().borrow().is_leaf()\\n            && tl.as_ref().unwrap().borrow().val() == tr.as_ref().unwrap().borrow().val()\\n            && tl.as_ref().unwrap().borrow().val() == bl.as_ref().unwrap().borrow().val()\\n            && tl.as_ref().unwrap().borrow().val() == br.as_ref().unwrap().borrow().val()\\n        {\\n            Some(Rc::new(RefCell::new(Node::new(\\n                true,\\n                tl.as_ref().unwrap().borrow().val(),\\n                None,\\n                None,\\n                None,\\n                None,\\n            ))))\\n        } else {\\n            Some(Rc::new(RefCell::new(Node::new(false, false, tl, tr, bl, br))))\\n        }\\n    }\\n}\\n\\n#[test]\\nfn test() {\\n    let leaf_false = Some(Rc::new(RefCell::new(Node::new(true, false,  None, None, None, None))));\\n    let leaf_true = Some(Rc::new(RefCell::new(Node::new(true, true, None, None, None, None))));\\n\\n    let quad_tree1 = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        true,\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n        leaf_false.clone(),\\n    ))));\\n\\n    let quad_tree2_tr = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        false,\\n        leaf_false.clone(),\\n        leaf_false.clone(),\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n    ))));\\n\\n    let quad_tree2 = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        true,\\n        leaf_true.clone(),\\n        quad_tree2_tr,\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n    ))));\\n\\n    let res = Some(Rc::new(RefCell::new(Node::new(\\n        false,\\n        false,\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_true.clone(),\\n        leaf_false.clone(),\\n    ))));\\n    assert_eq!(Solution::intersect(quad_tree1, quad_tree2), res);\\n\\n    let quad_tree1 = leaf_false.clone();\\n    let quad_tree2 = leaf_false.clone();\\n    let res = leaf_false.clone();\\n    assert_eq!(Solution::intersect(quad_tree1, quad_tree2), res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2865310,
                "title": "java-solution-time-complexity-o-min-fn-sn-space-complexity-o-min-fd-sd",
                "content": "# Intuition\\n    Please refer the comment in the code section.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    - O(min(firstQuadTree node number, secondQuadTree node number))\\n\\n- Space complexity:\\n    - O(min(firstQuadTree depth, secondQuadTree depth)), considering the recursion stack space\\n\\n# Code\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n\\n    /** \\n        Time complexity: O( min(firstQuadTree node number, secondQuadTree node number) )\\n        Space complexity: O( min(firstQuadTree depth number, secondQuadTree depth number) ), considering the recursion stack space\\n    */\\n\\n\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        // if the first one is leaf\\n        // that means all values are same (1 or 0)\\n        // if it is 1, then I dont need to consider about others as it is OR operation\\n        // if it is 0, then I need to consider the other one as becuase other one could be 1 or 0\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n\\n        else if(quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n\\n        // if both are not leaf node\\n        // then recurse for each child, topLeft, topRight, bottomLeft, bottomRight\\n        // create a new node, point the topLeft to new node\\'s topLeft and so on\\n        // but before connect check, all 4 child is leaf node and all 4 child values are same\\n        // if yes, then current new node will be leafnode and value will be any one child\\'s value\\n        else {\\n            Node node = new Node();\\n            Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n            if(topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf &&\\n                topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) {\\n                    node.isLeaf = true;\\n                    node.val = topLeft.val;\\n                }\\n\\n            else {\\n                node.topLeft = topLeft;\\n                node.topRight = topRight;\\n                node.bottomLeft = bottomLeft;\\n                node.bottomRight = bottomRight;\\n            }\\n\\n            return node;\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n\\n    /** \\n        Time complexity: O( min(firstQuadTree node number, secondQuadTree node number) )\\n        Space complexity: O( min(firstQuadTree depth number, secondQuadTree depth number) ), considering the recursion stack space\\n    */\\n\\n\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        // if the first one is leaf\\n        // that means all values are same (1 or 0)\\n        // if it is 1, then I dont need to consider about others as it is OR operation\\n        // if it is 0, then I need to consider the other one as becuase other one could be 1 or 0\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val ? quadTree1 : quadTree2;\\n        }\\n\\n        else if(quadTree2.isLeaf) {\\n            return quadTree2.val ? quadTree2 : quadTree1;\\n        }\\n\\n        // if both are not leaf node\\n        // then recurse for each child, topLeft, topRight, bottomLeft, bottomRight\\n        // create a new node, point the topLeft to new node\\'s topLeft and so on\\n        // but before connect check, all 4 child is leaf node and all 4 child values are same\\n        // if yes, then current new node will be leafnode and value will be any one child\\'s value\\n        else {\\n            Node node = new Node();\\n            Node topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n            Node topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n            Node bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n            Node bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n            if(topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf &&\\n                topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) {\\n                    node.isLeaf = true;\\n                    node.val = topLeft.val;\\n                }\\n\\n            else {\\n                node.topLeft = topLeft;\\n                node.topRight = topRight;\\n                node.bottomLeft = bottomLeft;\\n                node.bottomRight = bottomRight;\\n            }\\n\\n            return node;\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562630,
                "title": "c-dfs-simple",
                "content": "```\\nclass Solution{\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf && quadTree2->isLeaf){\\n            Node* newnode1;\\n            if(quadTree1->val==quadTree2->val){\\n                newnode1=quadTree1;\\n                return newnode1;\\n            }\\n            else{\\n                newnode1=new Node(1,true);\\n                return newnode1;\\n            }\\n        }\\n        if(quadTree1->isLeaf){\\n            Node* newnode1;\\n            if(quadTree1->val==1) newnode1=quadTree1;\\n            else{\\n                newnode1=quadTree2;\\n            }\\n            return newnode1;\\n        }\\n        if(quadTree2->isLeaf){\\n            Node* newnode1;\\n            if(quadTree2->val==1) newnode1=quadTree2;\\n            else{\\n                newnode1=quadTree1;\\n            }\\n            return newnode1;\\n        }\\n        Node* newnode=new Node();\\n        newnode->topLeft=intersect(quadTree1->topLeft,quadTree2->topLeft);\\n        newnode->topRight=intersect(quadTree1->topRight,quadTree2->topRight);\\n        newnode->bottomLeft=intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n        newnode->bottomRight=intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        int u=newnode->topLeft->val+newnode->topRight->val+newnode->bottomLeft->val+newnode->bottomRight->val;\\n        Node* newnode2=new Node();\\n        if(newnode->topLeft->isLeaf && newnode->topRight->isLeaf && newnode->bottomLeft->isLeaf && newnode->bottomRight->isLeaf){\\n        if(u==0){\\n            newnode2->isLeaf=true;\\n            newnode2->val=0;\\n            return newnode2;\\n        }\\n        else if(u==4){\\n            newnode2->isLeaf=true;\\n            newnode2->val=1;\\n            return newnode2;\\n        }\\n        }\\n        return newnode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(quadTree1->isLeaf && quadTree2->isLeaf){\\n            Node* newnode1;\\n            if(quadTree1->val==quadTree2->val){\\n                newnode1=quadTree1;\\n                return newnode1;\\n            }\\n            else{\\n                newnode1=new Node(1,true);\\n                return newnode1;\\n            }\\n        }\\n        if(quadTree1->isLeaf){\\n            Node* newnode1;\\n            if(quadTree1->val==1) newnode1=quadTree1;\\n            else{\\n                newnode1=quadTree2;\\n            }\\n            return newnode1;\\n        }\\n        if(quadTree2->isLeaf){\\n            Node* newnode1;\\n            if(quadTree2->val==1) newnode1=quadTree2;\\n            else{\\n                newnode1=quadTree1;\\n            }\\n            return newnode1;\\n        }\\n        Node* newnode=new Node();\\n        newnode->topLeft=intersect(quadTree1->topLeft,quadTree2->topLeft);\\n        newnode->topRight=intersect(quadTree1->topRight,quadTree2->topRight);\\n        newnode->bottomLeft=intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n        newnode->bottomRight=intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        int u=newnode->topLeft->val+newnode->topRight->val+newnode->bottomLeft->val+newnode->bottomRight->val;\\n        Node* newnode2=new Node();\\n        if(newnode->topLeft->isLeaf && newnode->topRight->isLeaf && newnode->bottomLeft->isLeaf && newnode->bottomRight->isLeaf){\\n        if(u==0){\\n            newnode2->isLeaf=true;\\n            newnode2->val=0;\\n            return newnode2;\\n        }\\n        else if(u==4){\\n            newnode2->isLeaf=true;\\n            newnode2->val=1;\\n            return newnode2;\\n        }\\n        }\\n        return newnode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418809,
                "title": "c-easy-post-order-dfs-recursive-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* correctTree(Node* root){\\n        if (!(root->isLeaf)){\\n            if (root->topLeft->val == root->topRight->val && root->topRight->val == root->bottomLeft->val && root->bottomLeft->val == root->bottomRight->val && root->topLeft->isLeaf && root->topRight->isLeaf && root->bottomLeft->isLeaf && root->bottomRight->isLeaf){\\n                root->val = root->topLeft->val;\\n                root->isLeaf = 1;\\n                root->topLeft = NULL;\\n                root->topRight = NULL;\\n                root->bottomLeft = NULL;\\n                root->bottomRight = NULL;\\n                return root;\\n            }  \\n        }\\n        return root;\\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (!(quadTree1 || quadTree2)){\\n            return quadTree1;\\n        }\\n        if (quadTree1->isLeaf && quadTree2->isLeaf){\\n        quadTree1-> val = quadTree1->val || quadTree2->val;\\n        }else if (!quadTree1->isLeaf && quadTree2->isLeaf){\\n            quadTree2->isLeaf = false;\\n            quadTree2->topRight = new Node(quadTree2->val,1);\\n            quadTree2->topLeft = new Node(quadTree2->val,1);\\n            quadTree2->bottomLeft = new Node(quadTree2->val,1);\\n            quadTree2->bottomRight = new Node(quadTree2->val,1);\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }else if (quadTree1->isLeaf && !quadTree2->isLeaf){\\n            quadTree1->isLeaf = false;\\n            quadTree1->topRight = new Node(quadTree1->val,1);\\n            quadTree1->topLeft = new Node(quadTree1->val,1);\\n            quadTree1->bottomLeft = new Node(quadTree1->val,1);\\n            quadTree1->bottomRight = new Node(quadTree1->val,1);\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }else{\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }\\n        return correctTree(quadTree1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* correctTree(Node* root){\\n        if (!(root->isLeaf)){\\n            if (root->topLeft->val == root->topRight->val && root->topRight->val == root->bottomLeft->val && root->bottomLeft->val == root->bottomRight->val && root->topLeft->isLeaf && root->topRight->isLeaf && root->bottomLeft->isLeaf && root->bottomRight->isLeaf){\\n                root->val = root->topLeft->val;\\n                root->isLeaf = 1;\\n                root->topLeft = NULL;\\n                root->topRight = NULL;\\n                root->bottomLeft = NULL;\\n                root->bottomRight = NULL;\\n                return root;\\n            }  \\n        }\\n        return root;\\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (!(quadTree1 || quadTree2)){\\n            return quadTree1;\\n        }\\n        if (quadTree1->isLeaf && quadTree2->isLeaf){\\n        quadTree1-> val = quadTree1->val || quadTree2->val;\\n        }else if (!quadTree1->isLeaf && quadTree2->isLeaf){\\n            quadTree2->isLeaf = false;\\n            quadTree2->topRight = new Node(quadTree2->val,1);\\n            quadTree2->topLeft = new Node(quadTree2->val,1);\\n            quadTree2->bottomLeft = new Node(quadTree2->val,1);\\n            quadTree2->bottomRight = new Node(quadTree2->val,1);\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }else if (quadTree1->isLeaf && !quadTree2->isLeaf){\\n            quadTree1->isLeaf = false;\\n            quadTree1->topRight = new Node(quadTree1->val,1);\\n            quadTree1->topLeft = new Node(quadTree1->val,1);\\n            quadTree1->bottomLeft = new Node(quadTree1->val,1);\\n            quadTree1->bottomRight = new Node(quadTree1->val,1);\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }else{\\n            intersect(quadTree1->topLeft,quadTree2->topLeft);\\n            intersect(quadTree1->topRight,quadTree2->topRight);\\n            intersect(quadTree1->bottomLeft,quadTree2->bottomLeft);\\n            intersect(quadTree1->bottomRight,quadTree2->bottomRight);\\n        }\\n        return correctTree(quadTree1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383967,
                "title": "python-simple-maths",
                "content": "\\n    def intersect(self, quadTree1, quadTree2):\\n        def dfs(q1, q2):\\n            if q1.isLeaf:\\n                if not q1.val:\\n                    return q2\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n                \\n                \\n            if q2.isLeaf:\\n                if not q2.val:\\n                    return q1\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n                \\n                \\n            tl = dfs(q1.topLeft, q2.topLeft) \\n            tr = dfs(q1.topRight, q2.topRight)\\n            bl = dfs(q1.bottomLeft, q2.bottomLeft)\\n            br = dfs(q1.bottomRight, q2.bottomRight)\\n            \\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n                return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(1, False, tl, tr, bl, br)\\n            \\n        return dfs(quadTree1, quadTree2)",
                "solutionTags": [],
                "code": "\\n    def intersect(self, quadTree1, quadTree2):\\n        def dfs(q1, q2):\\n            if q1.isLeaf:\\n                if not q1.val:\\n                    return q2\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n                \\n                \\n            if q2.isLeaf:\\n                if not q2.val:\\n                    return q1\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n                \\n                \\n            tl = dfs(q1.topLeft, q2.topLeft) \\n            tr = dfs(q1.topRight, q2.topRight)\\n            bl = dfs(q1.bottomLeft, q2.bottomLeft)\\n            br = dfs(q1.bottomRight, q2.bottomRight)\\n            \\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n                return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(1, False, tl, tr, bl, br)\\n            \\n        return dfs(quadTree1, quadTree2)",
                "codeTag": "Python3"
            },
            {
                "id": 2251480,
                "title": "c-dfs-simple-recursive-solution",
                "content": "class Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        \\n        if(quadTree1->isLeaf)\\n            return quadTree1->val ? new Node(true, true) : quadTree2;\\n        \\n        if(quadTree2->isLeaf)\\n            return quadTree2->val ? new Node(true, true) : quadTree1;\\n    \\n        auto tmp = new Node(false, false);\\n        \\n        tmp->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        tmp->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        tmp->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        tmp->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if((tmp->topLeft->isLeaf && tmp->topLeft->val) && (tmp->topRight->isLeaf && tmp->topRight->val) && (tmp->bottomLeft->isLeaf && tmp->bottomLeft->val) && (tmp->bottomRight->isLeaf && tmp->bottomRight->val))\\n            return new Node(true, true);\\n        \\n        return tmp;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        \\n        if(quadTree1->isLeaf)\\n            return quadTree1->val ? new Node(true, true) : quadTree2;\\n        \\n        if(quadTree2->isLeaf)\\n            return quadTree2->val ? new Node(true, true) : quadTree1;\\n    \\n        auto tmp = new Node(false, false);\\n        \\n        tmp->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        tmp->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        tmp->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        tmp->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        \\n        if((tmp->topLeft->isLeaf && tmp->topLeft->val) && (tmp->topRight->isLeaf && tmp->topRight->val) && (tmp->bottomLeft->isLeaf && tmp->bottomLeft->val) && (tmp->bottomRight->isLeaf && tmp->bottomRight->val))\\n            return new Node(true, true);\\n        \\n        return tmp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2248379,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  Node* intersect(Node *quadTree1, Node *quadTree2) {\\n    if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n      return new Node(quadTree1->val || quadTree2->val, true);\\n    }\\n    \\n    Node* ret = nullptr;\\n    if (!quadTree1->isLeaf && !quadTree2->isLeaf) {\\n      ret = new Node(true,\\n                     false,\\n                     intersect(quadTree1->topLeft, quadTree2->topLeft),\\n                     intersect(quadTree1->topRight, quadTree2->topRight),\\n                     intersect(quadTree1->bottomLeft, quadTree2->bottomLeft),\\n                     intersect(quadTree1->bottomRight, quadTree2->bottomRight));\\n    } else {\\n      if (quadTree1->isLeaf) {\\n        ret = new Node(true,\\n                       false,\\n                       intersect(quadTree1, quadTree2->topLeft),\\n                       intersect(quadTree1, quadTree2->topRight),\\n                       intersect(quadTree1, quadTree2->bottomLeft),\\n                       intersect(quadTree1, quadTree2->bottomRight));\\n      } else {\\n        ret = new Node(true,\\n                       false,\\n                       intersect(quadTree1->topLeft, quadTree2),\\n                       intersect(quadTree1->topRight, quadTree2),\\n                       intersect(quadTree1->bottomLeft, quadTree2),\\n                       intersect(quadTree1->bottomRight, quadTree2));\\n      }\\n    }\\n    \\n    if (ret->topLeft->isLeaf &&\\n        ret->topRight->isLeaf &&\\n        ret->bottomLeft->isLeaf &&\\n        ret->bottomRight->isLeaf) {\\n      if (ret->topLeft->val &&\\n          ret->topRight->val &&\\n          ret->bottomLeft->val &&\\n          ret->bottomRight->val) {\\n        ret->isLeaf = true;\\n        ret->val = true;\\n        delete ret->topLeft;\\n        delete ret->topRight;\\n        delete ret->bottomLeft;\\n        delete ret->bottomRight;\\n        ret->topLeft = nullptr;\\n        ret->topRight = nullptr;\\n        ret->bottomLeft = nullptr;\\n        ret->bottomRight = nullptr;\\n      } else if (!ret->topLeft->val &&\\n                 !ret->topRight->val &&\\n                 !ret->bottomLeft->val &&\\n                 !ret->bottomRight->val) {\\n        ret->isLeaf = true;\\n        ret->val = false;\\n        delete ret->topLeft;\\n        delete ret->topRight;\\n        delete ret->bottomLeft;\\n        delete ret->bottomRight;\\n        ret->topLeft = nullptr;\\n        ret->topRight = nullptr;\\n        ret->bottomLeft = nullptr;\\n        ret->bottomRight = nullptr;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  Node* intersect(Node *quadTree1, Node *quadTree2) {\\n    if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n      return new Node(quadTree1->val || quadTree2->val, true);\\n    }\\n    \\n    Node* ret = nullptr;\\n    if (!quadTree1->isLeaf && !quadTree2->isLeaf) {\\n      ret = new Node(true,\\n                     false,\\n                     intersect(quadTree1->topLeft, quadTree2->topLeft),\\n                     intersect(quadTree1->topRight, quadTree2->topRight),\\n                     intersect(quadTree1->bottomLeft, quadTree2->bottomLeft),\\n                     intersect(quadTree1->bottomRight, quadTree2->bottomRight));\\n    } else {\\n      if (quadTree1->isLeaf) {\\n        ret = new Node(true,\\n                       false,\\n                       intersect(quadTree1, quadTree2->topLeft),\\n                       intersect(quadTree1, quadTree2->topRight),\\n                       intersect(quadTree1, quadTree2->bottomLeft),\\n                       intersect(quadTree1, quadTree2->bottomRight));\\n      } else {\\n        ret = new Node(true,\\n                       false,\\n                       intersect(quadTree1->topLeft, quadTree2),\\n                       intersect(quadTree1->topRight, quadTree2),\\n                       intersect(quadTree1->bottomLeft, quadTree2),\\n                       intersect(quadTree1->bottomRight, quadTree2));\\n      }\\n    }\\n    \\n    if (ret->topLeft->isLeaf &&\\n        ret->topRight->isLeaf &&\\n        ret->bottomLeft->isLeaf &&\\n        ret->bottomRight->isLeaf) {\\n      if (ret->topLeft->val &&\\n          ret->topRight->val &&\\n          ret->bottomLeft->val &&\\n          ret->bottomRight->val) {\\n        ret->isLeaf = true;\\n        ret->val = true;\\n        delete ret->topLeft;\\n        delete ret->topRight;\\n        delete ret->bottomLeft;\\n        delete ret->bottomRight;\\n        ret->topLeft = nullptr;\\n        ret->topRight = nullptr;\\n        ret->bottomLeft = nullptr;\\n        ret->bottomRight = nullptr;\\n      } else if (!ret->topLeft->val &&\\n                 !ret->topRight->val &&\\n                 !ret->bottomLeft->val &&\\n                 !ret->bottomRight->val) {\\n        ret->isLeaf = true;\\n        ret->val = false;\\n        delete ret->topLeft;\\n        delete ret->topRight;\\n        delete ret->bottomLeft;\\n        delete ret->bottomRight;\\n        ret->topLeft = nullptr;\\n        ret->topRight = nullptr;\\n        ret->bottomLeft = nullptr;\\n        ret->bottomRight = nullptr;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187966,
                "title": "0-ms-100-faster-java-solution",
                "content": "public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if(quadTree1==null)\\n            return quadTree2;\\n        \\n        if(quadTree2==null)\\n            return quadTree1;\\n        \\n        //These 4 conditions are important\\n        if ((quadTree1.isLeaf) && (!quadTree1.val)) return quadTree2;\\n        if ((quadTree2.isLeaf) && (!quadTree2.val)) return quadTree1;\\n        if ((quadTree1.isLeaf) && (quadTree1.val)) return quadTree1;\\n        if ((quadTree2.isLeaf) && (quadTree2.val)) return quadTree2;\\n        \\n        Node root=new Node();\\n        root.val=quadTree1.val || quadTree2.val;\\n        root.isLeaf=quadTree1.isLeaf || quadTree2.isLeaf;\\n        \\n        if(root.isLeaf)\\n            return root;\\n        \\n        root.topLeft=intersect(quadTree1.topLeft,quadTree2.topLeft);\\n        root.topRight=intersect(quadTree1.topRight,quadTree2.topRight);\\n        root.bottomLeft=intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n        root.bottomRight=intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n        boolean grid=checkGrid(root);\\n        if(grid)\\n        {\\n            Node newRoot=new Node();\\n            newRoot.isLeaf=true;\\n            if(root.topLeft!=null)\\n                newRoot.val=root.topLeft.val;\\n           else if(root.topRight!=null)\\n                newRoot.val=root.topRight.val;\\n            else if(root.bottomRight!=null)\\n                newRoot.val=root.bottomRight.val;\\n            else if(root.bottomLeft!=null)\\n                newRoot.val=root.bottomLeft.val;\\n           \\n             return newRoot;\\n        }\\n        return root;\\n    }\\n    public boolean checkGrid(Node root)\\n    {\\n        if(root==null)\\n            return true;\\n        \\n        if((root.topLeft!=null && root.topRight!=null && root.bottomLeft!=null && root.bottomRight!=null) && (root.topLeft.val!=root.topRight.val || root.topLeft.val!=root.bottomRight.val || root.topLeft.val!=root.bottomLeft.val))\\n            return false;\\n        \\n        \\n        boolean case1=checkGrid(root.topLeft);\\n        boolean case2=checkGrid(root.topRight);\\n        boolean case3=checkGrid(root.bottomLeft);\\n        boolean case4=checkGrid(root.bottomRight);\\n        \\n        return case1 && case2 && case3 && case4;\\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if(quadTree1==null)\\n            return quadTree2;\\n        \\n        if(quadTree2==null)\\n            return quadTree1;\\n        \\n        //These 4 conditions are important\\n        if ((quadTree1.isLeaf) && (!quadTree1.val)) return quadTree2;\\n        if ((quadTree2.isLeaf) && (!quadTree2.val)) return quadTree1;\\n        if ((quadTree1.isLeaf) && (quadTree1.val)) return quadTree1;\\n        if ((quadTree2.isLeaf) && (quadTree2.val)) return quadTree2;\\n        \\n        Node root=new Node();\\n        root.val=quadTree1.val || quadTree2.val;\\n        root.isLeaf=quadTree1.isLeaf || quadTree2.isLeaf;\\n        \\n        if(root.isLeaf)\\n            return root;\\n        \\n        root.topLeft=intersect(quadTree1.topLeft,quadTree2.topLeft);\\n        root.topRight=intersect(quadTree1.topRight,quadTree2.topRight);\\n        root.bottomLeft=intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n        root.bottomRight=intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n        boolean grid=checkGrid(root);\\n        if(grid)\\n        {\\n            Node newRoot=new Node();\\n            newRoot.isLeaf=true;\\n            if(root.topLeft!=null)\\n                newRoot.val=root.topLeft.val;\\n           else if(root.topRight!=null)\\n                newRoot.val=root.topRight.val;\\n            else if(root.bottomRight!=null)\\n                newRoot.val=root.bottomRight.val;\\n            else if(root.bottomLeft!=null)\\n                newRoot.val=root.bottomLeft.val;\\n           \\n             return newRoot;\\n        }\\n        return root;\\n    }\\n    public boolean checkGrid(Node root)\\n    {\\n        if(root==null)\\n            return true;\\n        \\n        if((root.topLeft!=null && root.topRight!=null && root.bottomLeft!=null && root.bottomRight!=null) && (root.topLeft.val!=root.topRight.val || root.topLeft.val!=root.bottomRight.val || root.topLeft.val!=root.bottomLeft.val))\\n            return false;\\n        \\n        \\n        boolean case1=checkGrid(root.topLeft);\\n        boolean case2=checkGrid(root.topRight);\\n        boolean case3=checkGrid(root.bottomLeft);\\n        boolean case4=checkGrid(root.bottomRight);\\n        \\n        return case1 && case2 && case3 && case4;\\n        \\n    }\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2169025,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar intersect = function(quadTree1, quadTree2) {\\n\\t\\tif (quadTree1.isLeaf) {\\n\\t\\t\\treturn quadTree1.val ? quadTree1 : quadTree2;\\n\\t\\t}\\n\\n\\t\\tif (quadTree2.isLeaf) {\\n\\t\\t\\treturn quadTree2.val ? quadTree2 : quadTree1;\\n\\t\\t}\\n\\n\\t\\tconst nodes = [\\n\\t\\t\\tintersect(quadTree1.topLeft, quadTree2.topLeft),\\n\\t\\t\\tintersect(quadTree1.topRight, quadTree2.topRight),\\n\\t\\t\\tintersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n\\t\\t\\tintersect(quadTree1.bottomRight, quadTree2.bottomRight),\\n\\t\\t];\\n\\t\\tconst isSame = nodes.every(({ isLeaf, val }) => isLeaf && val);\\n\\t\\tconst [topLeft, topRight, bottomLeft, bottomRight] = nodes;\\n\\n\\t\\tif (isSame) return topLeft;\\n\\t\\treturn new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar intersect = function(quadTree1, quadTree2) {\\n\\t\\tif (quadTree1.isLeaf) {\\n\\t\\t\\treturn quadTree1.val ? quadTree1 : quadTree2;\\n\\t\\t}\\n\\n\\t\\tif (quadTree2.isLeaf) {\\n\\t\\t\\treturn quadTree2.val ? quadTree2 : quadTree1;\\n\\t\\t}\\n\\n\\t\\tconst nodes = [\\n\\t\\t\\tintersect(quadTree1.topLeft, quadTree2.topLeft),\\n\\t\\t\\tintersect(quadTree1.topRight, quadTree2.topRight),\\n\\t\\t\\tintersect(quadTree1.bottomLeft, quadTree2.bottomLeft),\\n\\t\\t\\tintersect(quadTree1.bottomRight, quadTree2.bottomRight),\\n\\t\\t];\\n\\t\\tconst isSame = nodes.every(({ isLeaf, val }) => isLeaf && val);\\n\\t\\tconst [topLeft, topRight, bottomLeft, bottomRight] = nodes;\\n\\n\\t\\tif (isSame) return topLeft;\\n\\t\\treturn new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2108549,
                "title": "python-solution-check-both-isleaf-and-val",
                "content": "I wonder if we would be better off if the values are set to be 0 or 1\\n```\\n\"\"\"\\n# Definition for a QuadTree node.\\nclass Node:\\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\"\"\"\\n\\nclass Solution:\\n    # Recursive\\n    # Different cases:\\n    # 1. Both leaves, OR the values and return\\n    # 2. One is and one is not, put the quad1 to be the one is\\n    # 3. Once taken care of, turn quad1 into not leaf and add the quadrants\\n    # Then call the recursive function quadrant by quadrant. During the process, note if the four quadrants are all leaves (it could be not as Quad2 might have deep layers) and their values are the same. If so, convert quad1 back to a leaf with the value, and return it\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            quadTree1.val = quadTree1.val or quadTree2.val\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf:\\n            return self.intersect(quadTree2, quadTree1)   \\n        elif not quadTree2.isLeaf:\\n            if quadTree1.isLeaf:\\n                quadTree1.isLeaf = False\\n                quadTree1.topLeft = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.topRight = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.bottomLeft = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.bottomRight = Node(quadTree1.val, True, None, None, None, None)\\n            \\n            quadTree1.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            value = quadTree1.topLeft.val\\n            same = quadTree1.topLeft.isLeaf\\n            quadTree1.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            if quadTree1.topRight.val != value or not quadTree1.topRight.isLeaf:\\n                same = False\\n            quadTree1.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            if quadTree1.bottomLeft.val != value or not quadTree1.bottomLeft.isLeaf:\\n                same = False\\n            quadTree1.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            if quadTree1.bottomRight.val != value or not quadTree1.bottomRight.isLeaf:\\n                same = False\\n            if same:\\n                quadTree1.isLeaf = True\\n                quadTree1.val = value\\n                quadTree1.topLeft = None\\n                quadTree1.topRight = None\\n                quadTree1.bottomLeft = None\\n                quadTree1.bottomRight = None\\n        return quadTree1\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a QuadTree node.\\nclass Node:\\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\"\"\"\\n\\nclass Solution:\\n    # Recursive\\n    # Different cases:\\n    # 1. Both leaves, OR the values and return\\n    # 2. One is and one is not, put the quad1 to be the one is\\n    # 3. Once taken care of, turn quad1 into not leaf and add the quadrants\\n    # Then call the recursive function quadrant by quadrant. During the process, note if the four quadrants are all leaves (it could be not as Quad2 might have deep layers) and their values are the same. If so, convert quad1 back to a leaf with the value, and return it\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree2.isLeaf:\\n            quadTree1.val = quadTree1.val or quadTree2.val\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf:\\n            return self.intersect(quadTree2, quadTree1)   \\n        elif not quadTree2.isLeaf:\\n            if quadTree1.isLeaf:\\n                quadTree1.isLeaf = False\\n                quadTree1.topLeft = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.topRight = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.bottomLeft = Node(quadTree1.val, True, None, None, None, None)\\n                quadTree1.bottomRight = Node(quadTree1.val, True, None, None, None, None)\\n            \\n            quadTree1.topLeft = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\\n            value = quadTree1.topLeft.val\\n            same = quadTree1.topLeft.isLeaf\\n            quadTree1.topRight = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n            if quadTree1.topRight.val != value or not quadTree1.topRight.isLeaf:\\n                same = False\\n            quadTree1.bottomLeft = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n            if quadTree1.bottomLeft.val != value or not quadTree1.bottomLeft.isLeaf:\\n                same = False\\n            quadTree1.bottomRight = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n            if quadTree1.bottomRight.val != value or not quadTree1.bottomRight.isLeaf:\\n                same = False\\n            if same:\\n                quadTree1.isLeaf = True\\n                quadTree1.val = value\\n                quadTree1.topLeft = None\\n                quadTree1.topRight = None\\n                quadTree1.bottomLeft = None\\n                quadTree1.bottomRight = None\\n        return quadTree1\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2029341,
                "title": "c-constant-space-tree-traversal-with-recursion-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n            \\n    Node* intersect(Node* store, Node* traverse) {\\n        if(store->isLeaf && traverse->isLeaf){            \\n            store->val |= traverse->val;            \\n            return store;\\n        }\\n                \\n        // could be that store has other leaves, and traverse is just a leaf\\n        // in that case traverse the other tree as it can be divided further\\n        if(traverse->isLeaf && !store->isLeaf){            \\n            return intersect(traverse,store);\\n        }\\n        // could be that traverse has other leaves, and store is just a leaf        \\n        else if(store->isLeaf && !traverse->isLeaf){\\n            if(store->val == 1){\\n                // no matter what traverse has, the OR will be 1 so return this               \\n                return store;\\n            }\\n            else{\\n                // since this is 0, there might be other nodes in 1 which might be 1\\n                // so return traverse\\n                return traverse;                \\n            }\\n        }\\n        else if(!store->isLeaf && !traverse->isLeaf){\\n            store->topLeft = intersect(store->topLeft,traverse->topLeft);\\n            store->topRight = intersect(store->topRight,traverse->topRight);\\n            store->bottomLeft = intersect(store->bottomLeft,traverse->bottomLeft);\\n            store->bottomRight = intersect(store->bottomRight,traverse->bottomRight);\\n            \\n\\t\\t\\t// avoiding unnecesary divisions if all the child nodes are leaves and have same value\\n\\t\\t\\t// it can be reduced a single leaf with the same value as in all children\\t\\t\\t\\n            if(store->topLeft->val == store->topRight->val && \\n               store->topRight->val == store->bottomLeft->val &&\\n               store->bottomLeft->val  == store->bottomRight->val && \\n               store->topLeft->isLeaf && store->topRight->isLeaf && \\n               store->bottomLeft->isLeaf && store->bottomRight->isLeaf)\\n            {                \\n                store->isLeaf = true;\\n                store->val = store->topLeft->val;\\n                store->topLeft = nullptr;\\n                store->topRight = nullptr;\\n                store->bottomLeft = nullptr;\\n                store->bottomRight = nullptr;                \\n            }\\n            \\n            return store;\\n        }\\n        \\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n            \\n    Node* intersect(Node* store, Node* traverse) {\\n        if(store->isLeaf && traverse->isLeaf){            \\n            store->val |= traverse->val;            \\n            return store;\\n        }\\n                \\n        // could be that store has other leaves, and traverse is just a leaf\\n        // in that case traverse the other tree as it can be divided further\\n        if(traverse->isLeaf && !store->isLeaf){            \\n            return intersect(traverse,store);\\n        }\\n        // could be that traverse has other leaves, and store is just a leaf        \\n        else if(store->isLeaf && !traverse->isLeaf){\\n            if(store->val == 1){\\n                // no matter what traverse has, the OR will be 1 so return this               \\n                return store;\\n            }\\n            else{\\n                // since this is 0, there might be other nodes in 1 which might be 1\\n                // so return traverse\\n                return traverse;                \\n            }\\n        }\\n        else if(!store->isLeaf && !traverse->isLeaf){\\n            store->topLeft = intersect(store->topLeft,traverse->topLeft);\\n            store->topRight = intersect(store->topRight,traverse->topRight);\\n            store->bottomLeft = intersect(store->bottomLeft,traverse->bottomLeft);\\n            store->bottomRight = intersect(store->bottomRight,traverse->bottomRight);\\n            \\n\\t\\t\\t// avoiding unnecesary divisions if all the child nodes are leaves and have same value\\n\\t\\t\\t// it can be reduced a single leaf with the same value as in all children\\t\\t\\t\\n            if(store->topLeft->val == store->topRight->val && \\n               store->topRight->val == store->bottomLeft->val &&\\n               store->bottomLeft->val  == store->bottomRight->val && \\n               store->topLeft->isLeaf && store->topRight->isLeaf && \\n               store->bottomLeft->isLeaf && store->bottomRight->isLeaf)\\n            {                \\n                store->isLeaf = true;\\n                store->val = store->topLeft->val;\\n                store->topLeft = nullptr;\\n                store->topRight = nullptr;\\n                store->bottomLeft = nullptr;\\n                store->bottomRight = nullptr;                \\n            }\\n            \\n            return store;\\n        }\\n        \\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811157,
                "title": "java-concise-simple-solution",
                "content": "This question is the kind of question where it takes 15 minutes to understand what the question wants and 3 minutes to type up a solution and the next 10 minutes pondering whether there is a better way to not repeatedly write the same thing over and over... \\n\\nI think the solution is concise enough, but just to save us some characters to type, let\\'s use `a`, `b`, `c`, `d` for 4 children and `x` and `y` for the current root node.\\n\\n```Java\\nclass Solution {\\n    public Node intersect(Node x, Node y) {\\n        if (x.isLeaf) return x.val? x : y;\\n        if (y.isLeaf) return y.val? y : x;\\n        Node a = x.topLeft,\\n             b = x.topRight,\\n             c = x.bottomLeft,\\n             d = x.bottomRight;\\n\\n        x.topLeft     = a = intersect(a, y.topLeft);\\n        x.topRight    = b = intersect(b, y.topRight);\\n        x.bottomLeft  = c = intersect(c, y.bottomLeft);\\n        x.bottomRight = d = intersect(d, y.bottomRight);\\n\\n        if (a.isLeaf && b.isLeaf && c.isLeaf && d.isLeaf &&\\n            a.val == b.val && a.val == c.val && a.val == d.val){\\n\\n            x.val = a.val;\\n            x.topLeft = x.topRight = x.bottomLeft = x.bottomRight = null;\\n            x.isLeaf = true;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public Node intersect(Node x, Node y) {\\n        if (x.isLeaf) return x.val? x : y;\\n        if (y.isLeaf) return y.val? y : x;\\n        Node a = x.topLeft,\\n             b = x.topRight,\\n             c = x.bottomLeft,\\n             d = x.bottomRight;\\n\\n        x.topLeft     = a = intersect(a, y.topLeft);\\n        x.topRight    = b = intersect(b, y.topRight);\\n        x.bottomLeft  = c = intersect(c, y.bottomLeft);\\n        x.bottomRight = d = intersect(d, y.bottomRight);\\n\\n        if (a.isLeaf && b.isLeaf && c.isLeaf && d.isLeaf &&\\n            a.val == b.val && a.val == c.val && a.val == d.val){\\n\\n            x.val = a.val;\\n            x.topLeft = x.topRight = x.bottomLeft = x.bottomRight = null;\\n            x.isLeaf = true;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768191,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1==null) return quadTree2;\\n        if (quadTree2==null) return quadTree1;\\n        if ((quadTree1.isLeaf) && (!quadTree1.val)) return quadTree2;\\n        if ((quadTree2.isLeaf) && (!quadTree2.val)) return quadTree1;\\n        if ((quadTree1.isLeaf) && (quadTree1.val)) return quadTree1;\\n        if ((quadTree2.isLeaf) && (quadTree2.val)) return quadTree2;\\n        Node t = new Node();\\n        t.isLeaf = false;\\n        t.val = true;\\n        Node tl = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr = intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        if ((tl.isLeaf)&&(tr.isLeaf)&&(bl.isLeaf)&&(br.isLeaf)) {\\n            if ((tl.val)&&(tr.val)&&(bl.val)&&(br.val)) {\\n                t.isLeaf = true;\\n                t.val = true;\\n                return t;\\n            } else {\\n                if ((!tl.val)&&(!tr.val)&&(!bl.val)&&(!br.val)) {\\n                    t.isLeaf = true;\\n                    t.val = false;\\n                    return t;\\n                }\\n            }\\n        }\\n        t.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        t.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        t.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        t.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        return t;\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1==null) return quadTree2;\\n        if (quadTree2==null) return quadTree1;\\n        if ((quadTree1.isLeaf) && (!quadTree1.val)) return quadTree2;\\n        if ((quadTree2.isLeaf) && (!quadTree2.val)) return quadTree1;\\n        if ((quadTree1.isLeaf) && (quadTree1.val)) return quadTree1;\\n        if ((quadTree2.isLeaf) && (quadTree2.val)) return quadTree2;\\n        Node t = new Node();\\n        t.isLeaf = false;\\n        t.val = true;\\n        Node tl = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr = intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        if ((tl.isLeaf)&&(tr.isLeaf)&&(bl.isLeaf)&&(br.isLeaf)) {\\n            if ((tl.val)&&(tr.val)&&(bl.val)&&(br.val)) {\\n                t.isLeaf = true;\\n                t.val = true;\\n                return t;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1763323,
                "title": "python-solution-with-thought-process",
                "content": "```python\\nclass Solution:\\n    def intersect(self, tree1: \\'Node\\', tree2: \\'Node\\') -> \\'Node\\':\\n        if tree1.isLeaf:\\n            return tree1 if tree1.val else tree2\\n        elif tree2.isLeaf:\\n            return tree2 if tree2.val else tree1\\n        else:\\n            return_node = Node(1, False, None, None, None, None)\\n            return_node.topLeft = self.intersect(tree1.topLeft, tree2.topLeft)\\n            return_node.topRight = self.intersect(tree1.topRight, tree2.topRight)\\n            return_node.bottomLeft = self.intersect(tree1.bottomLeft, tree2.bottomLeft)\\n            return_node.bottomRight = self.intersect(tree1.bottomRight, tree2.bottomRight)\\n            if return_node.topLeft.isLeaf == return_node.topRight.isLeaf == return_node.bottomLeft.isLeaf == return_node.bottomRight.isLeaf == True \\\\\\n\\t\\t\\tand return_node.topLeft.val == return_node.topRight.val == return_node.bottomLeft.val == return_node.bottomRight.val:\\n                return_node.isLeaf = True\\n                return_node.val = return_node.topLeft.val\\n                return_node.topLeft = None\\n                return_node.topRight = None\\n                return_node.bottomLeft = None\\n                return_node.bottomRight = None\\n            return return_node\\n```\\n* At first, we may be tempted to do something like `intersect(tree1.left, tree2)` when `tree2.isLeaf==True`. However, this is not True as the problem states\\n\\t> If the current grid has the same value (i.e all 1\\'s or all 0\\'s) set isLeaf True and set val to the value of the grid and **set the four children to Null and stop.**\\n* This tells us that whenever we run into a case of either tree\\'s `isLeaf` is True, we should do the logical or check and then return.\\n\\t* The logical or check is intuitive that if one of the tree\\'s value is 1, then the whole sub-tree rooted at that node will be all *1*.\\n* Now that we understand the first two cases(base case), we move on to the more general case. This would just be a simple recursion problem as all the other questions with a catch that\\n   > If the current **grid has the same value (i.e all 1\\'s or all 0\\'s)** set isLeaf True and set val to the value of the grid and **set the four children to Null**...\\n* There goes the solution",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def intersect(self, tree1: \\'Node\\', tree2: \\'Node\\') -> \\'Node\\':\\n        if tree1.isLeaf:\\n            return tree1 if tree1.val else tree2\\n        elif tree2.isLeaf:\\n            return tree2 if tree2.val else tree1\\n        else:\\n            return_node = Node(1, False, None, None, None, None)\\n            return_node.topLeft = self.intersect(tree1.topLeft, tree2.topLeft)\\n            return_node.topRight = self.intersect(tree1.topRight, tree2.topRight)\\n            return_node.bottomLeft = self.intersect(tree1.bottomLeft, tree2.bottomLeft)\\n            return_node.bottomRight = self.intersect(tree1.bottomRight, tree2.bottomRight)\\n            if return_node.topLeft.isLeaf == return_node.topRight.isLeaf == return_node.bottomLeft.isLeaf == return_node.bottomRight.isLeaf == True \\\\\\n\\t\\t\\tand return_node.topLeft.val == return_node.topRight.val == return_node.bottomLeft.val == return_node.bottomRight.val:\\n                return_node.isLeaf = True\\n                return_node.val = return_node.topLeft.val\\n                return_node.topLeft = None\\n                return_node.topRight = None\\n                return_node.bottomLeft = None\\n                return_node.bottomRight = None\\n            return return_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724564,
                "title": "build-tree-then-contract",
                "content": "```python\\nclass Solution:\\n    def intersect(self, t1: \\'Node\\', t2: \\'Node\\') -> \\'Node\\':\\n        def s(t1, t2, t3):\\n            \\'\\'\\'create tree 3\\'\\'\\'\\n            if t1.isLeaf and t2.isLeaf:\\n                t3.val, t3.isLeaf = t1.val or t2.val, 1\\n                return\\n            t3.topLeft = Node(0, 0, None, None, None, None)\\n            t3.topRight = Node(0, 0, None, None, None, None)\\n            t3.bottomLeft = Node(0, 0, None, None, None, None)\\n            t3.bottomRight = Node(0, 0, None, None, None, None)\\n            if t1.isLeaf and not t2.isLeaf:\\n                s(t1, t2.topLeft, t3.topLeft)\\n                s(t1, t2.topRight, t3.topRight)\\n                s(t1, t2.bottomLeft, t3.bottomLeft)\\n                s(t1, t2.bottomRight, t3.bottomRight)\\n            if not t1.isLeaf and t2.isLeaf:\\n                s(t1.topLeft, t2, t3.topLeft)\\n                s(t1.topRight, t2, t3.topRight)\\n                s(t1.bottomLeft, t2, t3.bottomLeft)\\n                s(t1.bottomRight, t2, t3.bottomRight)\\n            if not t1.isLeaf and not t2.isLeaf:\\n                s(t1.topLeft, t2.topLeft, t3.topLeft)\\n                s(t1.topRight, t2.topRight, t3.topRight)\\n                s(t1.bottomLeft, t2.bottomLeft, t3.bottomLeft)\\n                s(t1.bottomRight, t2.bottomRight, t3.bottomRight)\\n                \\n        def s2(t):\\n            \\'\\'\\'contract this level if lower level values are equal\\'\\'\\'\\n            if t.isLeaf:\\n                return t.val\\n            tl = s2(t.topLeft)\\n            tr = s2(t.topRight)\\n            bl = s2(t.bottomLeft)\\n            br = s2(t.bottomRight)\\n            x = list(set([tl, tr, bl, br]))\\n            if len(x) == 1 and x[0] != 2:\\n                t.val, t.isLeaf = x[0], 1\\n                t.topLeft = t.topRight = t.bottomLeft = t.bottomRight = None\\n                return t.val\\n            return 2\\n\\n        t3 = Node(0, 0, None, None, None, None)\\n        s(t1, t2, t3)\\n        s2(t3)\\n        return t3\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def intersect(self, t1: \\'Node\\', t2: \\'Node\\') -> \\'Node\\':\\n        def s(t1, t2, t3):\\n            \\'\\'\\'create tree 3\\'\\'\\'\\n            if t1.isLeaf and t2.isLeaf:\\n                t3.val, t3.isLeaf = t1.val or t2.val, 1\\n                return\\n            t3.topLeft = Node(0, 0, None, None, None, None)\\n            t3.topRight = Node(0, 0, None, None, None, None)\\n            t3.bottomLeft = Node(0, 0, None, None, None, None)\\n            t3.bottomRight = Node(0, 0, None, None, None, None)\\n            if t1.isLeaf and not t2.isLeaf:\\n                s(t1, t2.topLeft, t3.topLeft)\\n                s(t1, t2.topRight, t3.topRight)\\n                s(t1, t2.bottomLeft, t3.bottomLeft)\\n                s(t1, t2.bottomRight, t3.bottomRight)\\n            if not t1.isLeaf and t2.isLeaf:\\n                s(t1.topLeft, t2, t3.topLeft)\\n                s(t1.topRight, t2, t3.topRight)\\n                s(t1.bottomLeft, t2, t3.bottomLeft)\\n                s(t1.bottomRight, t2, t3.bottomRight)\\n            if not t1.isLeaf and not t2.isLeaf:\\n                s(t1.topLeft, t2.topLeft, t3.topLeft)\\n                s(t1.topRight, t2.topRight, t3.topRight)\\n                s(t1.bottomLeft, t2.bottomLeft, t3.bottomLeft)\\n                s(t1.bottomRight, t2.bottomRight, t3.bottomRight)\\n                \\n        def s2(t):\\n            \\'\\'\\'contract this level if lower level values are equal\\'\\'\\'\\n            if t.isLeaf:\\n                return t.val\\n            tl = s2(t.topLeft)\\n            tr = s2(t.topRight)\\n            bl = s2(t.bottomLeft)\\n            br = s2(t.bottomRight)\\n            x = list(set([tl, tr, bl, br]))\\n            if len(x) == 1 and x[0] != 2:\\n                t.val, t.isLeaf = x[0], 1\\n                t.topLeft = t.topRight = t.bottomLeft = t.bottomRight = None\\n                return t.val\\n            return 2\\n\\n        t3 = Node(0, 0, None, None, None, None)\\n        s(t1, t2, t3)\\n        s2(t3)\\n        return t3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646661,
                "title": "python3-in-place-recursion",
                "content": "In this approach I reuse one of input tree as result. If you like it please voteup, thanks\\n```\\nclass Solution:\\n    def intersect(self, t1: \\'Node\\', t2: \\'Node\\') -> \\'Node\\':\\n        if t1.isLeaf:\\n            return t1 if t1.val else t2\\n        elif t2.isLeaf:\\n            return t2 if t2.val else t1\\n        else:\\n            t1.topLeft = self.intersect(t1.topLeft, t2.topLeft)\\n            t1.topRight = self.intersect(t1.topRight, t2.topRight)\\n            t1.bottomLeft = self.intersect(t1.bottomLeft, t2.bottomLeft)\\n            t1.bottomRight = self.intersect(t1.bottomRight, t2.bottomRight)\\n            if t1.topLeft.isLeaf and t1.topRight.isLeaf and t1.bottomLeft.isLeaf and t1.bottomRight.isLeaf and t1.topLeft.val == t1.topRight.val and t1.topLeft.val == t1.bottomLeft.val and t1.bottomLeft.val == t1.bottomRight.val:\\n                t1.isLeaf = 1\\n                t1.val = t1.bottomLeft.val\\n                t1.topLeft = None\\n                t1.topRight = None\\n                t1.bottomLeft = None\\n                t1.bottomRight = None\\n            return t1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersect(self, t1: \\'Node\\', t2: \\'Node\\') -> \\'Node\\':\\n        if t1.isLeaf:\\n            return t1 if t1.val else t2\\n        elif t2.isLeaf:\\n            return t2 if t2.val else t1\\n        else:\\n            t1.topLeft = self.intersect(t1.topLeft, t2.topLeft)\\n            t1.topRight = self.intersect(t1.topRight, t2.topRight)\\n            t1.bottomLeft = self.intersect(t1.bottomLeft, t2.bottomLeft)\\n            t1.bottomRight = self.intersect(t1.bottomRight, t2.bottomRight)\\n            if t1.topLeft.isLeaf and t1.topRight.isLeaf and t1.bottomLeft.isLeaf and t1.bottomRight.isLeaf and t1.topLeft.val == t1.topRight.val and t1.topLeft.val == t1.bottomLeft.val and t1.bottomLeft.val == t1.bottomRight.val:\\n                t1.isLeaf = 1\\n                t1.val = t1.bottomLeft.val\\n                t1.topLeft = None\\n                t1.topRight = None\\n                t1.bottomLeft = None\\n                t1.bottomRight = None\\n            return t1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480748,
                "title": "short-and-simple-recursive-python",
                "content": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        def dfs(node1,node2):\\n            if node1.isLeaf and node2.isLeaf:\\n                return Node(node1.val or node2.val,True,None,None,None,None)\\n            \\n            topLeft=dfs(node1.topLeft if node1.topLeft else node1,node2.topLeft if node2.topLeft else node2)\\n            bottomLeft=dfs(node1.bottomLeft if node1.bottomLeft else node1,node2.bottomLeft if node2.bottomLeft else node2)\\n            topRight=dfs(node1.topRight if node1.topRight else node1,node2.topRight if node2.topRight else node2)\\n            bottomRight=dfs(node1.bottomRight if node1.bottomRight else node1,node2.bottomRight if node2.bottomRight else node2)\\n            \\n            if topLeft.isLeaf and topRight.isLeaf and bottomRight.isLeaf and bottomLeft.isLeaf and topLeft.val==topRight.val==bottomRight.val==bottomLeft.val:\\n                return Node(topLeft.val,True,None,None,None,None)\\n            \\n            return Node(1,False,topLeft,topRight,bottomLeft,bottomRight)\\n        \\n        return dfs(quadTree1,quadTree2)\\n```\\n\\nTIme Complexity O(n^2)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        def dfs(node1,node2):\\n            if node1.isLeaf and node2.isLeaf:\\n                return Node(node1.val or node2.val,True,None,None,None,None)\\n            \\n            topLeft=dfs(node1.topLeft if node1.topLeft else node1,node2.topLeft if node2.topLeft else node2)\\n            bottomLeft=dfs(node1.bottomLeft if node1.bottomLeft else node1,node2.bottomLeft if node2.bottomLeft else node2)\\n            topRight=dfs(node1.topRight if node1.topRight else node1,node2.topRight if node2.topRight else node2)\\n            bottomRight=dfs(node1.bottomRight if node1.bottomRight else node1,node2.bottomRight if node2.bottomRight else node2)\\n            \\n            if topLeft.isLeaf and topRight.isLeaf and bottomRight.isLeaf and bottomLeft.isLeaf and topLeft.val==topRight.val==bottomRight.val==bottomLeft.val:\\n                return Node(topLeft.val,True,None,None,None,None)\\n            \\n            return Node(1,False,topLeft,topRight,bottomLeft,bottomRight)\\n        \\n        return dfs(quadTree1,quadTree2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466156,
                "title": "python-3-dfs-simulation-explanation",
                "content": "### Explanation\\n- Just a different tree-like structure, number of nodes are always `4 ^ n` (e.g. 1, 4, 16, 64 ....)\\n- Here are some more facts if you dive a little deeper on it\\n\\t- The root node will start from the center of the matrix `(n/2, n/2)`, and split to 4 areas\\n\\t- If there are 1 level (i.e. only 1 node as leaf), then matrix has `4^0` node (`1 x 1 matrix`)\\n\\t- If there are 2 levels (i.e. 1 node with 4 leaf nodes), then matrix has `4^1` nodes (`2 by 2 matrix`)\\n\\t- ...\\n\\t- If there are n levels (i.e. some branch has n levels), then matrix has `4^(n-1)` nodes (`2^(n-1) by 2^(n-1) matrix`)\\n- Once you understand above, find `OR` on quad tree is basically a simple `DFS` operation\\n- Basically you need to do `OR` when both nodes are leaf nodes; otherwise `DFS` to corresponding area until reach leaf node\\n- Read below comments for more detail\\n- Below solution is easier to understand, while @ye15 has a [simplified solution](https://leetcode.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/discuss/884082/Python3-9-line-recursive-(64ms-93.33)) based on the same idea, if you are interested.\\n### Implementation\\n```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes\\n            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)\\n            return node\\n        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not\\n            node = Node(0, 0, \\n                        self.intersect(quadTree1, quadTree2.topLeft), \\n                        self.intersect(quadTree1, quadTree2.topRight), \\n                        self.intersect(quadTree1, quadTree2.bottomLeft), \\n                        self.intersect(quadTree1, quadTree2.bottomRight))\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not\\n            node = Node(0, 0, \\n                        self.intersect(quadTree1.topLeft, quadTree2), \\n                        self.intersect(quadTree1.topRight, quadTree2), \\n                        self.intersect(quadTree1.bottomLeft, quadTree2), \\n                        self.intersect(quadTree1.bottomRight, quadTree2))\\n        else:                                                                        # case 4: neither nodes are leaf \\n            node = Node(0, 0, \\n                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), \\n                        self.intersect(quadTree1.topRight, quadTree2.topRight), \\n                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), \\n                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))\\n            \\n        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \\\\\\n            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \\\\\\n            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same\\n            return Node(node.topLeft.val, 1, None, None, None, None)\\n        return node \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes\\n            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)\\n            return node\\n        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not\\n            node = Node(0, 0, \\n                        self.intersect(quadTree1, quadTree2.topLeft), \\n                        self.intersect(quadTree1, quadTree2.topRight), \\n                        self.intersect(quadTree1, quadTree2.bottomLeft), \\n                        self.intersect(quadTree1, quadTree2.bottomRight))\\n        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not\\n            node = Node(0, 0, \\n                        self.intersect(quadTree1.topLeft, quadTree2), \\n                        self.intersect(quadTree1.topRight, quadTree2), \\n                        self.intersect(quadTree1.bottomLeft, quadTree2), \\n                        self.intersect(quadTree1.bottomRight, quadTree2))\\n        else:                                                                        # case 4: neither nodes are leaf \\n            node = Node(0, 0, \\n                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), \\n                        self.intersect(quadTree1.topRight, quadTree2.topRight), \\n                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), \\n                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))\\n            \\n        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \\\\\\n            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \\\\\\n            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same\\n            return Node(node.topLeft.val, 1, None, None, None, None)\\n        return node \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319972,
                "title": "recursive-swift-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    \\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard  let quadTree1 = quadTree1,\\n               let quadTree2 = quadTree2\\n        else{return nil}\\n\\n        return createLeaf(quadTree1, quadTree2)\\n    }\\n\\nfunc createLeaf(_ quadTree1: Node, _ quadTree2: Node)->Node{\\n    let resultNode: Node\\n    resultNode = Node(quadTree1.val || quadTree2.val, quadTree1.isLeaf && quadTree2.isLeaf) //create OR Node\\n    \\n    // if One of Node isn\\'t leaf we create Node with childes.. we dont need to know which one.\\n    // But we know that one is. If its tree1 then childes of tree2 is nill and we take tree2 and same for tree2. if both just take childes\\n    \\n    if !quadTree1.isLeaf || !quadTree2.isLeaf{ \\n        resultNode.bottomLeft = createLeaf(quadTree1.bottomLeft ?? quadTree1, \\n                                           quadTree2.bottomLeft ?? quadTree2)\\n        resultNode.bottomRight = createLeaf(quadTree1.bottomRight ?? quadTree1,\\n                                            quadTree2.bottomRight ?? quadTree2)\\n        resultNode.topLeft = createLeaf(quadTree1.topLeft ?? quadTree1,\\n                                        quadTree2.topLeft ?? quadTree2)\\n        resultNode.topRight = createLeaf(quadTree1.topRight ?? quadTree1,\\n                                         quadTree2.topRight ?? quadTree2)\\n    //check childs. If all of them is leaf with same val just return parent like Node(val, true)    \\n        if resultNode.bottomLeft!.isLeaf && resultNode.bottomRight!.isLeaf &&\\n        resultNode.topLeft!.isLeaf && resultNode.topRight!.isLeaf{\\n            if resultNode.bottomLeft!.val && resultNode.bottomRight!.val &&\\n            resultNode.topLeft!.val && resultNode.topRight!.val{\\n                return Node(true,true)\\n            }\\n            if !resultNode.bottomLeft!.val && !resultNode.bottomRight!.val &&\\n            !resultNode.topLeft!.val && !resultNode.topRight!.val{\\n                return Node(false,true)\\n            }\\n        }\\n    }\\n    \\n    return resultNode\\n}\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard  let quadTree1 = quadTree1,\\n               let quadTree2 = quadTree2\\n        else{return nil}\\n\\n        return createLeaf(quadTree1, quadTree2)\\n    }\\n\\nfunc createLeaf(_ quadTree1: Node, _ quadTree2: Node)->Node{\\n    let resultNode: Node\\n    resultNode = Node(quadTree1.val || quadTree2.val, quadTree1.isLeaf && quadTree2.isLeaf) //create OR Node\\n    \\n    // if One of Node isn\\'t leaf we create Node with childes.. we dont need to know which one.\\n    // But we know that one is. If its tree1 then childes of tree2 is nill and we take tree2 and same for tree2. if both just take childes\\n    \\n    if !quadTree1.isLeaf || !quadTree2.isLeaf{ \\n        resultNode.bottomLeft = createLeaf(quadTree1.bottomLeft ?? quadTree1, \\n                                           quadTree2.bottomLeft ?? quadTree2)\\n        resultNode.bottomRight = createLeaf(quadTree1.bottomRight ?? quadTree1,\\n                                            quadTree2.bottomRight ?? quadTree2)\\n        resultNode.topLeft = createLeaf(quadTree1.topLeft ?? quadTree1,\\n                                        quadTree2.topLeft ?? quadTree2)\\n        resultNode.topRight = createLeaf(quadTree1.topRight ?? quadTree1,\\n                                         quadTree2.topRight ?? quadTree2)\\n    //check childs. If all of them is leaf with same val just return parent like Node(val, true)    \\n        if resultNode.bottomLeft!.isLeaf && resultNode.bottomRight!.isLeaf &&\\n        resultNode.topLeft!.isLeaf && resultNode.topRight!.isLeaf{\\n            if resultNode.bottomLeft!.val && resultNode.bottomRight!.val &&\\n            resultNode.topLeft!.val && resultNode.topRight!.val{\\n                return Node(true,true)\\n            }\\n            if !resultNode.bottomLeft!.val && !resultNode.bottomRight!.val &&\\n            !resultNode.topLeft!.val && !resultNode.topRight!.val{\\n                return Node(false,true)\\n            }\\n        }\\n    }\\n    \\n    return resultNode\\n}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318974,
                "title": "swift-recursion",
                "content": "```swift\\nclass Solution {\\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard let qt1 = quadTree1, let qt2 = quadTree2 else {\\n            return nil\\n        }\\n        \\n        if qt1.isLeaf {\\n            return qt1.val ? qt1 : qt2\\n        }\\n        if qt2.isLeaf {\\n            return qt2.val ? qt2 : qt1\\n        }\\n        let ans = Node(false, false)\\n        ans.topLeft = intersect(qt1.topLeft, qt2.topLeft )\\n        ans.topRight = intersect(qt1.topRight , qt2.topRight)\\n        ans.bottomLeft = intersect(qt1.bottomLeft, qt2.bottomLeft)\\n        ans.bottomRight = intersect(qt1.bottomRight, qt2.bottomRight)\\n        //\\u5408\\u5E76:\\u56DB\\u4E2A\\u5B50\\u6811\\u90FD\\u662F\\u53F6\\u5B50\\u5E76\\u4E14\\u6570\\u503C\\u76F8\\u540C\\uFF0C\\u5408\\u5E76\\u4E3A\\u4E00\\u4E2A\\u5927\\u7684\\u53F6\\u5B50\\u7ED3\\u70B9\\n        guard let tl = ans.topLeft?.val, let tlf = ans.topLeft?.isLeaf,tlf else {\\n            return ans\\n        }\\n        guard let tr = ans.topRight?.val, let trf = ans.topRight?.isLeaf,trf,tr == tl else {\\n            return ans\\n        }\\n        guard let bl = ans.bottomLeft?.val, let blf = ans.bottomLeft?.isLeaf,blf,bl == tr else {\\n            return ans\\n        }\\n        guard let br = ans.bottomRight?.val, let brf = ans.bottomRight?.isLeaf,brf ,br == bl else {\\n            return ans\\n        }\\n        return Node(tl, true)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```swift\\nclass Solution {\\n    func intersect(_ quadTree1: Node?, _ quadTree2: Node?) -> Node? {\\n        guard let qt1 = quadTree1, let qt2 = quadTree2 else {\\n            return nil\\n        }\\n        \\n        if qt1.isLeaf {\\n            return qt1.val ? qt1 : qt2\\n        }\\n        if qt2.isLeaf {\\n            return qt2.val ? qt2 : qt1\\n        }\\n        let ans = Node(false, false)\\n        ans.topLeft = intersect(qt1.topLeft, qt2.topLeft )\\n        ans.topRight = intersect(qt1.topRight , qt2.topRight)\\n        ans.bottomLeft = intersect(qt1.bottomLeft, qt2.bottomLeft)\\n        ans.bottomRight = intersect(qt1.bottomRight, qt2.bottomRight)\\n        //\\u5408\\u5E76:\\u56DB\\u4E2A\\u5B50\\u6811\\u90FD\\u662F\\u53F6\\u5B50\\u5E76\\u4E14\\u6570\\u503C\\u76F8\\u540C\\uFF0C\\u5408\\u5E76\\u4E3A\\u4E00\\u4E2A\\u5927\\u7684\\u53F6\\u5B50\\u7ED3\\u70B9\\n        guard let tl = ans.topLeft?.val, let tlf = ans.topLeft?.isLeaf,tlf else {\\n            return ans\\n        }\\n        guard let tr = ans.topRight?.val, let trf = ans.topRight?.isLeaf,trf,tr == tl else {\\n            return ans\\n        }\\n        guard let bl = ans.bottomLeft?.val, let blf = ans.bottomLeft?.isLeaf,blf,bl == tr else {\\n            return ans\\n        }\\n        guard let br = ans.bottomRight?.val, let brf = ans.bottomRight?.isLeaf,brf ,br == bl else {\\n            return ans\\n        }\\n        return Node(tl, true)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315934,
                "title": "java-0ms-100-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic Node intersect(Node quadTree1, Node quadTree2) {\\n\\t\\t\\tif(quadTree1.isLeaf)    return quadTree1.val?quadTree1:quadTree2;\\n\\t\\t\\telse if(quadTree2.isLeaf)    return quadTree2.val?quadTree2:quadTree1;\\n\\t\\t\\telse{\\n\\t\\t\\t\\tNode root=quadTree1;\\n\\t\\t\\t\\troot.topLeft=intersect(quadTree1.topLeft,quadTree2.topLeft);\\n\\t\\t\\t\\troot.topRight=intersect(quadTree1.topRight,quadTree2.topRight);\\n\\t\\t\\t\\troot.bottomLeft=intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n\\t\\t\\t\\troot.bottomRight=intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n\\t\\t\\t\\tif(root.topLeft.isLeaf && root.topRight.isLeaf \\n\\t\\t\\t\\t   && root.bottomLeft.isLeaf && root.bottomRight.isLeaf\\n\\t\\t\\t\\t   && root.topLeft.val==root.topRight.val \\n\\t\\t\\t\\t   && root.topLeft.val==root.bottomLeft.val\\n\\t\\t\\t\\t   && root.bottomLeft.val==root.bottomRight.val\\n\\t\\t\\t\\t){\\n\\t\\t\\t\\t\\troot.isLeaf = root.val = true;  \\n\\t\\t\\t\\t\\troot.topLeft = root.topRight = root.bottomLeft = root.bottomRight =null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse    root.isLeaf = root.val = false;  \\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic Node intersect(Node quadTree1, Node quadTree2) {\\n\\t\\t\\tif(quadTree1.isLeaf)    return quadTree1.val?quadTree1:quadTree2;\\n\\t\\t\\telse if(quadTree2.isLeaf)    return quadTree2.val?quadTree2:quadTree1;\\n\\t\\t\\telse{\\n\\t\\t\\t\\tNode root=quadTree1;\\n\\t\\t\\t\\troot.topLeft=intersect(quadTree1.topLeft,quadTree2.topLeft);\\n\\t\\t\\t\\troot.topRight=intersect(quadTree1.topRight,quadTree2.topRight);\\n\\t\\t\\t\\troot.bottomLeft=intersect(quadTree1.bottomLeft,quadTree2.bottomLeft);\\n\\t\\t\\t\\troot.bottomRight=intersect(quadTree1.bottomRight,quadTree2.bottomRight);\\n\\t\\t\\t\\tif(root.topLeft.isLeaf && root.topRight.isLeaf \\n\\t\\t\\t\\t   && root.bottomLeft.isLeaf && root.bottomRight.isLeaf\\n\\t\\t\\t\\t   && root.topLeft.val==root.topRight.val \\n\\t\\t\\t\\t   && root.topLeft.val==root.bottomLeft.val\\n\\t\\t\\t\\t   && root.bottomLeft.val==root.bottomRight.val\\n\\t\\t\\t\\t){\\n\\t\\t\\t\\t\\troot.isLeaf = root.val = true;  \\n\\t\\t\\t\\t\\troot.topLeft = root.topRight = root.bottomLeft = root.bottomRight =null;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1282797,
                "title": "javascript-recursive",
                "content": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\n\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    function clone(tree) {\\n        let result = new Node(tree.val, tree.isLeaf)\\n        if (!tree.isLeaf) {\\n            result.topLeft = clone(tree.topLeft)\\n            result.topRight = clone(tree.topRight)\\n            result.bottomLeft = clone(tree.bottomLeft)\\n            result.bottomRight = clone(tree.bottomRight)\\n        }\\n        \\n        return result\\n    }\\n    \\n    function merge(treeA, treeB) {\\n        if (!treeA.isLeaf && treeB.isLeaf) {\\n            [treeA, treeB] = [treeB, treeA]\\n        }\\n        \\n        if (treeA.isLeaf) {\\n            if (treeA.val) {\\n                // when treeA is full of 1\\n                return treeA\\n            } else {\\n                // when treeB is full of 0\\n                return treeB\\n            }\\n        } else {\\n            let result\\n            let topLeftResult = merge(treeA.topLeft, treeB.topLeft)\\n            let topRightResult = merge(treeA.topRight, treeB.topRight)\\n            let bottomLeftResult = merge(treeA.bottomLeft, treeB.bottomLeft)\\n            let bottomRightResult = merge(treeA.bottomRight, treeB.bottomRight)\\n            // here, all four results must be leaves\\n            if ((topLeftResult.isLeaf && topRightResult.isLeaf && bottomLeftResult.isLeaf && bottomRightResult.isLeaf) &&\\n              (topLeftResult.val === topRightResult.val && \\n              topLeftResult.val === bottomLeftResult.val &&\\n              topLeftResult.val === bottomRightResult.val)) {\\n              result = new Node(topLeftResult.val, true)\\n            } else {\\n                result = new Node(topLeftResult.val, false, topLeftResult, topRightResult, bottomLeftResult, bottomRightResult)\\n            }\\n            \\n            \\n            return result\\n        }\\n    }\\n    \\n    \\n    return merge(clone(quadTree1), clone(quadTree2))\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\n\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    function clone(tree) {\\n        let result = new Node(tree.val, tree.isLeaf)\\n        if (!tree.isLeaf) {\\n            result.topLeft = clone(tree.topLeft)\\n            result.topRight = clone(tree.topRight)\\n            result.bottomLeft = clone(tree.bottomLeft)\\n            result.bottomRight = clone(tree.bottomRight)\\n        }\\n        \\n        return result\\n    }\\n    \\n    function merge(treeA, treeB) {\\n        if (!treeA.isLeaf && treeB.isLeaf) {\\n            [treeA, treeB] = [treeB, treeA]\\n        }\\n        \\n        if (treeA.isLeaf) {\\n            if (treeA.val) {\\n                // when treeA is full of 1\\n                return treeA\\n            } else {\\n                // when treeB is full of 0\\n                return treeB\\n            }\\n        } else {\\n            let result\\n            let topLeftResult = merge(treeA.topLeft, treeB.topLeft)\\n            let topRightResult = merge(treeA.topRight, treeB.topRight)\\n            let bottomLeftResult = merge(treeA.bottomLeft, treeB.bottomLeft)\\n            let bottomRightResult = merge(treeA.bottomRight, treeB.bottomRight)\\n            // here, all four results must be leaves\\n            if ((topLeftResult.isLeaf && topRightResult.isLeaf && bottomLeftResult.isLeaf && bottomRightResult.isLeaf) &&\\n              (topLeftResult.val === topRightResult.val && \\n              topLeftResult.val === bottomLeftResult.val &&\\n              topLeftResult.val === bottomRightResult.val)) {\\n              result = new Node(topLeftResult.val, true)\\n            } else {\\n                result = new Node(topLeftResult.val, false, topLeftResult, topRightResult, bottomLeftResult, bottomRightResult)\\n            }\\n            \\n            \\n            return result\\n        }\\n    }\\n    \\n    \\n    return merge(clone(quadTree1), clone(quadTree2))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274104,
                "title": "c-solution",
                "content": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void okk(Node*&qd1,Node*&qd2)\\n    {\\n        \\n        if(qd1->isLeaf&&!qd2->isLeaf)\\n        {\\n          if(qd1->val==0)\\n          {\\n              qd1=qd2;\\n              return ;\\n          }\\n            return ;\\n        }\\n        if(qd2->isLeaf&&!qd1->isLeaf)\\n        {\\n            if(qd2->val==1)\\n            {\\n                qd1=qd2;\\n                \\n            }\\n                return ;\\n        }\\n        if(qd1->isLeaf&&qd2->isLeaf)return ;\\n        if(qd1->topLeft->isLeaf||qd2->topLeft->isLeaf)\\n        {\\n            if(qd1->topLeft->isLeaf)\\n            {\\n                if(qd1->topLeft->val==0)\\n                {\\n                    qd1->topLeft=qd2->topLeft;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->topLeft->val==1)\\n                {\\n                    qd1->topLeft=qd2->topLeft;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->topLeft,qd2->topLeft);\\n        }\\n        \\n        \\n          if(qd1->topRight->isLeaf||qd2->topRight->isLeaf)\\n        {\\n            if(qd1->topRight->isLeaf)\\n            {\\n                if(qd1->topRight->val==0)\\n                {\\n                    qd1->topRight=qd2->topRight;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->topRight->val==1)\\n                {\\n                    qd1->topRight=qd2->topRight;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->topRight,qd2->topRight);\\n        }\\n\\n          if(qd1->bottomLeft->isLeaf||qd2->bottomLeft->isLeaf)\\n        {\\n            if(qd1->bottomLeft->isLeaf)\\n            {\\n                if(qd1->bottomLeft->val==0)\\n                {\\n                    qd1->bottomLeft=qd2->bottomLeft;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->bottomLeft->val==1)\\n                {\\n                    qd1->bottomLeft=qd2->bottomLeft;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->bottomLeft,qd2->bottomLeft);\\n        }\\n        if(qd1->bottomRight->isLeaf||qd2->bottomRight->isLeaf)\\n        {\\n            if(qd1->bottomRight->isLeaf)\\n            {\\n                if(qd1->bottomRight->val==0)\\n                {\\n                    qd1->bottomRight=qd2->bottomRight;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->bottomRight->val==1)\\n                {\\n                    qd1->bottomRight=qd2->bottomRight;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->bottomRight,qd2->bottomRight);\\n        }\\n        if((qd1->topLeft->isLeaf==1&&qd1->topRight->isLeaf&&qd1->bottomLeft->isLeaf&&qd1->bottomRight->isLeaf)&&(qd1->topLeft->val==1&&qd1->topRight->val==1&&qd1->bottomLeft->val==1&&qd1->bottomRight->val==1))\\n        {\\n        qd1->val=1;\\n        qd1->isLeaf=true;\\n        qd1->topLeft=NULL;\\n        qd1->topRight=NULL;\\n        qd1->bottomLeft=NULL;\\n        qd1->bottomRight=NULL;\\n        }\\n    \\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) \\n    {\\n        okk(quadTree1,quadTree2);\\n        return quadTree1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\npublic:\\n    bool val;\\n    bool isLeaf;\\n    Node* topLeft;\\n    Node* topRight;\\n    Node* bottomLeft;\\n    Node* bottomRight;\\n    \\n    Node() {\\n        val = false;\\n        isLeaf = false;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = NULL;\\n        topRight = NULL;\\n        bottomLeft = NULL;\\n        bottomRight = NULL;\\n    }\\n    \\n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void okk(Node*&qd1,Node*&qd2)\\n    {\\n        \\n        if(qd1->isLeaf&&!qd2->isLeaf)\\n        {\\n          if(qd1->val==0)\\n          {\\n              qd1=qd2;\\n              return ;\\n          }\\n            return ;\\n        }\\n        if(qd2->isLeaf&&!qd1->isLeaf)\\n        {\\n            if(qd2->val==1)\\n            {\\n                qd1=qd2;\\n                \\n            }\\n                return ;\\n        }\\n        if(qd1->isLeaf&&qd2->isLeaf)return ;\\n        if(qd1->topLeft->isLeaf||qd2->topLeft->isLeaf)\\n        {\\n            if(qd1->topLeft->isLeaf)\\n            {\\n                if(qd1->topLeft->val==0)\\n                {\\n                    qd1->topLeft=qd2->topLeft;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->topLeft->val==1)\\n                {\\n                    qd1->topLeft=qd2->topLeft;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->topLeft,qd2->topLeft);\\n        }\\n        \\n        \\n          if(qd1->topRight->isLeaf||qd2->topRight->isLeaf)\\n        {\\n            if(qd1->topRight->isLeaf)\\n            {\\n                if(qd1->topRight->val==0)\\n                {\\n                    qd1->topRight=qd2->topRight;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->topRight->val==1)\\n                {\\n                    qd1->topRight=qd2->topRight;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->topRight,qd2->topRight);\\n        }\\n\\n          if(qd1->bottomLeft->isLeaf||qd2->bottomLeft->isLeaf)\\n        {\\n            if(qd1->bottomLeft->isLeaf)\\n            {\\n                if(qd1->bottomLeft->val==0)\\n                {\\n                    qd1->bottomLeft=qd2->bottomLeft;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->bottomLeft->val==1)\\n                {\\n                    qd1->bottomLeft=qd2->bottomLeft;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->bottomLeft,qd2->bottomLeft);\\n        }\\n        if(qd1->bottomRight->isLeaf||qd2->bottomRight->isLeaf)\\n        {\\n            if(qd1->bottomRight->isLeaf)\\n            {\\n                if(qd1->bottomRight->val==0)\\n                {\\n                    qd1->bottomRight=qd2->bottomRight;\\n                }\\n            }\\n            else\\n            {\\n                if(qd2->bottomRight->val==1)\\n                {\\n                    qd1->bottomRight=qd2->bottomRight;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            okk(qd1->bottomRight,qd2->bottomRight);\\n        }\\n        if((qd1->topLeft->isLeaf==1&&qd1->topRight->isLeaf&&qd1->bottomLeft->isLeaf&&qd1->bottomRight->isLeaf)&&(qd1->topLeft->val==1&&qd1->topRight->val==1&&qd1->bottomLeft->val==1&&qd1->bottomRight->val==1))\\n        {\\n        qd1->val=1;\\n        qd1->isLeaf=true;\\n        qd1->topLeft=NULL;\\n        qd1->topRight=NULL;\\n        qd1->bottomLeft=NULL;\\n        qd1->bottomRight=NULL;\\n        }\\n    \\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) \\n    {\\n        okk(quadTree1,quadTree2);\\n        return quadTree1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230753,
                "title": "python3-dfs",
                "content": "```python\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        def dfs(q1, q2):\\n            if q1.isLeaf:\\n                if not q1.val:\\n                    return q2\\n                else:\\n                    return Node(1, True, None, None, None, None) \\n            if q2.isLeaf:\\n                if not q2.val:\\n                    return q1\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n            \\n            tl = dfs(q1.topLeft, q2.topLeft) \\n            tr = dfs(q1.topRight, q2.topRight)\\n            bl = dfs(q1.bottomLeft, q2.bottomLeft)\\n            br = dfs(q1.bottomRight, q2.bottomRight)\\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and \\\\\\n                tl.val == tr.val == bl.val == br.val:\\n                return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(1, False, tl, tr, bl, br)\\n            \\n        return dfs(quadTree1, quadTree2)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        \\n        def dfs(q1, q2):\\n            if q1.isLeaf:\\n                if not q1.val:\\n                    return q2\\n                else:\\n                    return Node(1, True, None, None, None, None) \\n            if q2.isLeaf:\\n                if not q2.val:\\n                    return q1\\n                else:\\n                    return Node(1, True, None, None, None, None)\\n            \\n            tl = dfs(q1.topLeft, q2.topLeft) \\n            tr = dfs(q1.topRight, q2.topRight)\\n            bl = dfs(q1.bottomLeft, q2.bottomLeft)\\n            br = dfs(q1.bottomRight, q2.bottomRight)\\n            if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and \\\\\\n                tl.val == tr.val == bl.val == br.val:\\n                return Node(tl.val, True, None, None, None, None)\\n            else:\\n                return Node(1, False, tl, tr, bl, br)\\n            \\n        return dfs(quadTree1, quadTree2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113168,
                "title": "c-short-solution",
                "content": "Run-time is `O(N*N)`, space is `O(log4(N*N))`. Most of the code is copy pasting... \\n\\n```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(!quadTree1 || !quadTree2) {}\\n        else if(quadTree1->isLeaf && quadTree2->isLeaf) {\\n            quadTree1->val |= quadTree2->val;\\n        } else if(quadTree1->isLeaf) {\\n            if(!quadTree1->val) {\\n                std::swap(quadTree1, quadTree2);\\n                quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2);\\n                quadTree1->topRight = intersect(quadTree1->topRight, quadTree2);\\n                quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2);\\n                quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2);\\n            }\\n        } else if(quadTree2->isLeaf) {\\n            quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2);\\n            quadTree1->topRight = intersect(quadTree1->topRight, quadTree2);\\n            quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2);\\n            quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2);\\n        } else {\\n            quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            quadTree1->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        }\\n        \\n        if(!quadTree1->isLeaf && \\n           quadTree1->topLeft->isLeaf &&\\n           quadTree1->topRight->isLeaf &&\\n           quadTree1->bottomLeft->isLeaf &&\\n           quadTree1->bottomRight->isLeaf &&\\n           quadTree1->topLeft->val == quadTree1->topRight->val &&\\n           quadTree1->topLeft->val == quadTree1->bottomLeft->val &&\\n           quadTree1->topLeft->val == quadTree1->bottomRight->val) {\\n            quadTree1->val = quadTree1->topLeft->val, quadTree1->isLeaf = true;\\n            quadTree1->topLeft = quadTree1->topRight = quadTree1->bottomLeft = quadTree1->bottomRight = nullptr;\\n        }\\n        \\n        return quadTree1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if(!quadTree1 || !quadTree2) {}\\n        else if(quadTree1->isLeaf && quadTree2->isLeaf) {\\n            quadTree1->val |= quadTree2->val;\\n        } else if(quadTree1->isLeaf) {\\n            if(!quadTree1->val) {\\n                std::swap(quadTree1, quadTree2);\\n                quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2);\\n                quadTree1->topRight = intersect(quadTree1->topRight, quadTree2);\\n                quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2);\\n                quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2);\\n            }\\n        } else if(quadTree2->isLeaf) {\\n            quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2);\\n            quadTree1->topRight = intersect(quadTree1->topRight, quadTree2);\\n            quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2);\\n            quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2);\\n        } else {\\n            quadTree1->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            quadTree1->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            quadTree1->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            quadTree1->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        }\\n        \\n        if(!quadTree1->isLeaf && \\n           quadTree1->topLeft->isLeaf &&\\n           quadTree1->topRight->isLeaf &&\\n           quadTree1->bottomLeft->isLeaf &&\\n           quadTree1->bottomRight->isLeaf &&\\n           quadTree1->topLeft->val == quadTree1->topRight->val &&\\n           quadTree1->topLeft->val == quadTree1->bottomLeft->val &&\\n           quadTree1->topLeft->val == quadTree1->bottomRight->val) {\\n            quadTree1->val = quadTree1->topLeft->val, quadTree1->isLeaf = true;\\n            quadTree1->topLeft = quadTree1->topRight = quadTree1->bottomLeft = quadTree1->bottomRight = nullptr;\\n        }\\n        \\n        return quadTree1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090957,
                "title": "java-0ms-recursive-solution",
                "content": "\\n```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if (q1.isLeaf && q2.isLeaf) {\\n            return new Node(q1.val | q2.val, true, null, null, null, null);\\n        }\\n        \\n        Node topLeft = intersect(q1.isLeaf ? q1 : q1.topLeft, q2.isLeaf ? q2 : q2.topLeft);\\n        Node topRight = intersect(q1.isLeaf ? q1 : q1.topRight, q2.isLeaf ? q2 : q2.topRight);\\n        Node bottomLeft = intersect(q1.isLeaf ? q1 : q1.bottomLeft, q2.isLeaf ? q2 : q2.bottomLeft);\\n        Node bottomRight = intersect(q1.isLeaf ? q1 : q1.bottomRight, q2.isLeaf ? q2 : q2.bottomRight);\\n        \\n        if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf\\n           && topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) {\\n            return new Node(topLeft.val, true, null, null, null, null);\\n        }\\n        return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a QuadTree node.\\nclass Node {\\n    public boolean val;\\n    public boolean isLeaf;\\n    public Node topLeft;\\n    public Node topRight;\\n    public Node bottomLeft;\\n    public Node bottomRight;\\n\\n    public Node() {}\\n\\n    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {\\n        val = _val;\\n        isLeaf = _isLeaf;\\n        topLeft = _topLeft;\\n        topRight = _topRight;\\n        bottomLeft = _bottomLeft;\\n        bottomRight = _bottomRight;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node intersect(Node q1, Node q2) {\\n        if (q1.isLeaf && q2.isLeaf) {\\n            return new Node(q1.val | q2.val, true, null, null, null, null);\\n        }\\n        \\n        Node topLeft = intersect(q1.isLeaf ? q1 : q1.topLeft, q2.isLeaf ? q2 : q2.topLeft);\\n        Node topRight = intersect(q1.isLeaf ? q1 : q1.topRight, q2.isLeaf ? q2 : q2.topRight);\\n        Node bottomLeft = intersect(q1.isLeaf ? q1 : q1.bottomLeft, q2.isLeaf ? q2 : q2.bottomLeft);\\n        Node bottomRight = intersect(q1.isLeaf ? q1 : q1.bottomRight, q2.isLeaf ? q2 : q2.bottomRight);\\n        \\n        if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf\\n           && topLeft.val == topRight.val && topRight.val == bottomLeft.val && bottomLeft.val == bottomRight.val) {\\n            return new Node(topLeft.val, true, null, null, null, null);\\n        }\\n        return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985070,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1==null || quadTree2.isLeaf && quadTree2.val || quadTree1.isLeaf && !quadTree1.val) \\n            return quadTree2;\\n        if(quadTree2==null || quadTree1.isLeaf && quadTree1.val || quadTree2.isLeaf && !quadTree2.val) \\n            return quadTree1;\\n        Node res = new Node();\\n        res.topLeft=intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        res.topRight=intersect(quadTree1.topRight, quadTree2.topRight);\\n        res.bottomLeft=intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        res.bottomRight=intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        if(res.topLeft.isLeaf && res.topRight.isLeaf && res.bottomLeft.isLeaf && res.bottomRight.isLeaf){\\n            if(res.topLeft.val && res.topRight.val && res.bottomLeft.val && res.bottomRight.val)\\n                return new Node(true, true);\\n            else if(!res.topLeft.val && !res.topRight.val && !res.bottomLeft.val && !res.bottomRight.val)\\n                return new Node(true, false);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1==null || quadTree2.isLeaf && quadTree2.val || quadTree1.isLeaf && !quadTree1.val) \\n            return quadTree2;\\n        if(quadTree2==null || quadTree1.isLeaf && quadTree1.val || quadTree2.isLeaf && !quadTree2.val) \\n            return quadTree1;\\n        Node res = new Node();\\n        res.topLeft=intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        res.topRight=intersect(quadTree1.topRight, quadTree2.topRight);\\n        res.bottomLeft=intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        res.bottomRight=intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        if(res.topLeft.isLeaf && res.topRight.isLeaf && res.bottomLeft.isLeaf && res.bottomRight.isLeaf){\\n            if(res.topLeft.val && res.topRight.val && res.bottomLeft.val && res.bottomRight.val)\\n                return new Node(true, true);\\n            else if(!res.topLeft.val && !res.topRight.val && !res.bottomLeft.val && !res.bottomRight.val)\\n                return new Node(true, false);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 879999,
                "title": "go",
                "content": "```\\nfunc intersect(quadTree1 *Node, quadTree2 *Node) *Node {\\n    a, b := quadTree1, quadTree2\\n    if a.IsLeaf == true && b.IsLeaf == true {\\n        return &Node{a.Val || b.Val, true, nil, nil, nil, nil}\\n    }\\n    \\n    if a.IsLeaf == true {\\n        if a.Val == true {\\n            return a\\n        } else {\\n            return b\\n        }\\n    }\\n    \\n    if b.IsLeaf == true {\\n        if b.Val == true {\\n            return b\\n        } else {\\n            return a\\n        }\\n    }\\n    \\n    p1 := intersect(a.TopLeft, b.TopLeft)\\n    p2 := intersect(a.TopRight, b.TopRight)\\n    p3 := intersect(a.BottomLeft, b.BottomLeft)\\n    p4 := intersect(a.BottomRight, b.BottomRight)\\n    \\n    if p1.IsLeaf && p2.IsLeaf && p3.IsLeaf && p4.IsLeaf && p1.Val && p2.Val && p3.Val && p4.Val {\\n        return &Node{true, true, nil, nil, nil, nil}\\n    }\\n    \\n    return &Node{false, false, p1, p2, p3, p4}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc intersect(quadTree1 *Node, quadTree2 *Node) *Node {\\n    a, b := quadTree1, quadTree2\\n    if a.IsLeaf == true && b.IsLeaf == true {\\n        return &Node{a.Val || b.Val, true, nil, nil, nil, nil}\\n    }\\n    \\n    if a.IsLeaf == true {\\n        if a.Val == true {\\n            return a\\n        } else {\\n            return b\\n        }\\n    }\\n    \\n    if b.IsLeaf == true {\\n        if b.Val == true {\\n            return b\\n        } else {\\n            return a\\n        }\\n    }\\n    \\n    p1 := intersect(a.TopLeft, b.TopLeft)\\n    p2 := intersect(a.TopRight, b.TopRight)\\n    p3 := intersect(a.BottomLeft, b.BottomLeft)\\n    p4 := intersect(a.BottomRight, b.BottomRight)\\n    \\n    if p1.IsLeaf && p2.IsLeaf && p3.IsLeaf && p4.IsLeaf && p1.Val && p2.Val && p3.Val && p4.Val {\\n        return &Node{true, true, nil, nil, nil, nil}\\n    }\\n    \\n    return &Node{false, false, p1, p2, p3, p4}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869701,
                "title": "effing-lengthy-question",
                "content": "Interviewers will spend 20 minutes explaining the question to the candidate and the candidate hopefully understands it.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 839299,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf && quadTree2.isLeaf) {\\n            Node n = new Node();\\n            n.val = quadTree1.val || quadTree2.val;\\n            n.isLeaf = true;\\n            return n;\\n        }\\n        if (quadTree1.isLeaf) {\\n            if (quadTree1.val) {\\n                return cloneNode(quadTree1);\\n            }\\n            else {\\n                return cloneNode(quadTree2);\\n            }\\n        }\\n        if (quadTree2.isLeaf) {\\n            if (quadTree2.val) {\\n                return cloneNode(quadTree2);\\n            }\\n            else {\\n                return cloneNode(quadTree1);\\n            }\\n        }\\n        \\n        Node n = new Node();\\n        n.isLeaf = false;\\n        \\n        n.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        n.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        n.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        n.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        \\n        if (n.topLeft.isLeaf && n.topRight.isLeaf && n.bottomLeft.isLeaf && n.bottomRight.isLeaf &&\\n            (n.topLeft.val == n.topRight.val) && (n.topLeft.val == n.bottomLeft.val) && (n.topLeft.val == n.bottomRight.val)) {\\n            n.val = n.topLeft.val;\\n            n.isLeaf = true;\\n            n.topLeft = null;\\n            n.topRight = null;\\n            n.bottomLeft = null;\\n            n.bottomRight = null;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    protected Node cloneNode(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        Node n = new Node();\\n        n.isLeaf = node.isLeaf;\\n        n.val = node.val;\\n        \\n        n.topLeft = cloneNode(node.topLeft);\\n        n.topRight = cloneNode(node.topRight);\\n        n.bottomLeft = cloneNode(node.bottomLeft);\\n        n.bottomRight = cloneNode(node.bottomRight);\\n        \\n        return n;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if (quadTree1.isLeaf && quadTree2.isLeaf) {\\n            Node n = new Node();\\n            n.val = quadTree1.val || quadTree2.val;\\n            n.isLeaf = true;\\n            return n;\\n        }\\n        if (quadTree1.isLeaf) {\\n            if (quadTree1.val) {\\n                return cloneNode(quadTree1);\\n            }\\n            else {\\n                return cloneNode(quadTree2);\\n            }\\n        }\\n        if (quadTree2.isLeaf) {\\n            if (quadTree2.val) {\\n                return cloneNode(quadTree2);\\n            }\\n            else {\\n                return cloneNode(quadTree1);\\n            }\\n        }\\n        \\n        Node n = new Node();\\n        n.isLeaf = false;\\n        \\n        n.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        n.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        n.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        n.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        \\n        if (n.topLeft.isLeaf && n.topRight.isLeaf && n.bottomLeft.isLeaf && n.bottomRight.isLeaf &&\\n            (n.topLeft.val == n.topRight.val) && (n.topLeft.val == n.bottomLeft.val) && (n.topLeft.val == n.bottomRight.val)) {\\n            n.val = n.topLeft.val;\\n            n.isLeaf = true;\\n            n.topLeft = null;\\n            n.topRight = null;\\n            n.bottomLeft = null;\\n            n.bottomRight = null;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    protected Node cloneNode(Node node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        Node n = new Node();\\n        n.isLeaf = node.isLeaf;\\n        n.val = node.val;\\n        \\n        n.topLeft = cloneNode(node.topLeft);\\n        n.topRight = cloneNode(node.topRight);\\n        n.bottomLeft = cloneNode(node.bottomLeft);\\n        n.bottomRight = cloneNode(node.bottomRight);\\n        \\n        return n;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719275,
                "title": "easy-to-understand-recursive-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        /*\\n        Base Case:\\n        If one of the leaf values is true then return the node if its value is true else the other one.\\n        \\n        Recurrence Relation:\\n         - If both are not Leaf then call recursively by retrieving the corresponding node values and passing it.\\n         - On return, check the values. If all the nodes values are same:\\n                - then set leaf as true and set it as node\\'s value\\n                - else set leaf as false and set one of the values (chose false).\\n        */\\n        \\n        /* Base Case*/\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val?quadTree1:quadTree2;\\n        }\\n        \\n        if(quadTree2.isLeaf) {\\n            return quadTree2.val?quadTree2:quadTree1;\\n        }\\n        \\n        Node node, tl, tr, bl, br;\\n        \\n        /* Recurrence Relation */\\n        tl = intersect (quadTree1.topLeft, quadTree2.topLeft);\\n        tr = intersect (quadTree1.topRight, quadTree2.topRight);\\n        bl = intersect (quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        br = intersect (quadTree1.bottomRight, quadTree2.bottomRight);\\n        \\n        if(tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf \\n           && tl.val == tr.val && tr.val == bl.val && bl.val == br.val) {\\n            node = new Node(true, true);\\n        } else {\\n            node = new Node(false, false, tl, tr, bl, br);\\n        }\\n        \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        /*\\n        Base Case:\\n        If one of the leaf values is true then return the node if its value is true else the other one.\\n        \\n        Recurrence Relation:\\n         - If both are not Leaf then call recursively by retrieving the corresponding node values and passing it.\\n         - On return, check the values. If all the nodes values are same:\\n                - then set leaf as true and set it as node\\'s value\\n                - else set leaf as false and set one of the values (chose false).\\n        */\\n        \\n        /* Base Case*/\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val?quadTree1:quadTree2;\\n        }\\n        \\n        if(quadTree2.isLeaf) {\\n            return quadTree2.val?quadTree2:quadTree1;\\n        }\\n        \\n        Node node, tl, tr, bl, br;\\n        \\n        /* Recurrence Relation */\\n        tl = intersect (quadTree1.topLeft, quadTree2.topLeft);\\n        tr = intersect (quadTree1.topRight, quadTree2.topRight);\\n        bl = intersect (quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        br = intersect (quadTree1.bottomRight, quadTree2.bottomRight);\\n        \\n        if(tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf \\n           && tl.val == tr.val && tr.val == bl.val && bl.val == br.val) {\\n            node = new Node(true, true);\\n        } else {\\n            node = new Node(false, false, tl, tr, bl, br);\\n        }\\n        \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711674,
                "title": "python-in-7-lines-beats-100",
                "content": "In an effort to avoid repetitive code, we may do:\\n```\\ndef intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n    if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2\\n    if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1\\n    args = [[t.topLeft, t.topRight, t.bottomLeft, t.bottomRight] for t in [quadTree1, quadTree2]]\\n    kids = list(map(self.intersect, *args))\\n    if all(n.isLeaf and n.val for n in kids): return Node(True, True)\\n    if all(n.isLeaf and not n.val for n in kids): return Node(False, True)\\n    return Node(False, False, *kids)\\n```",
                "solutionTags": [],
                "code": "```\\ndef intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n    if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2\\n    if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1\\n    args = [[t.topLeft, t.topRight, t.bottomLeft, t.bottomRight] for t in [quadTree1, quadTree2]]\\n    kids = list(map(self.intersect, *args))\\n    if all(n.isLeaf and n.val for n in kids): return Node(True, True)\\n    if all(n.isLeaf and not n.val for n in kids): return Node(False, True)\\n    return Node(False, False, *kids)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 653001,
                "title": "java-deep-copy",
                "content": "```\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val?deepCopy(quadTree1):deepCopy(quadTree2);\\n        }\\n        if(quadTree2.isLeaf) {\\n            return quadTree2.val?deepCopy(quadTree2):deepCopy(quadTree1);\\n        }\\n        Node tl=intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr=intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl=intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br=intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        boolean isLeaf= tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && ((tl.val&&tr.val&&bl.val&&br.val) ||!(tl.val || tr.val ||bl.val ||br.val));\\n        return isLeaf? new Node(tl.val,true,null,null,null,null) : new Node(tl.val,false,tl,tr,bl,br);\\n    }\\n    private Node deepCopy(Node node) {\\n        if(node == null) return null;\\n        return new Node(node.val, node.isLeaf, deepCopy(node.topLeft), deepCopy(node.topRight), deepCopy(node.bottomLeft), deepCopy(node.bottomRight));      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        if(quadTree1.isLeaf) {\\n            return quadTree1.val?deepCopy(quadTree1):deepCopy(quadTree2);\\n        }\\n        if(quadTree2.isLeaf) {\\n            return quadTree2.val?deepCopy(quadTree2):deepCopy(quadTree1);\\n        }\\n        Node tl=intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        Node tr=intersect(quadTree1.topRight, quadTree2.topRight);\\n        Node bl=intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        Node br=intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n        boolean isLeaf= tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && ((tl.val&&tr.val&&bl.val&&br.val) ||!(tl.val || tr.val ||bl.val ||br.val));\\n        return isLeaf? new Node(tl.val,true,null,null,null,null) : new Node(tl.val,false,tl,tr,bl,br);\\n    }\\n    private Node deepCopy(Node node) {\\n        if(node == null) return null;\\n        return new Node(node.val, node.isLeaf, deepCopy(node.topLeft), deepCopy(node.topRight), deepCopy(node.bottomLeft), deepCopy(node.bottomRight));      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616686,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree2->isLeaf && !(quadTree1->isLeaf)){\\n            return intersect(quadTree2, quadTree1);\\n        }else if (quadTree1->isLeaf){\\n            if (quadTree1->val){\\n                return quadTree1;\\n            }else{\\n                return quadTree2;\\n            }\\n        }else{\\n            Node* newnode = new Node;\\n            newnode->isLeaf = false;\\n            newnode->topLeft = \\n                intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            newnode->topRight = \\n                intersect(quadTree1->topRight, quadTree2->topRight);\\n            newnode->bottomLeft = \\n                intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            newnode->bottomRight = \\n                intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            newnode->val = false;\\n            bool oneval = newnode->topLeft->val;\\n            if (newnode->topRight->isLeaf &&\\n                newnode->topRight->val == oneval && \\n                newnode->bottomLeft->isLeaf  &&\\n               newnode->bottomLeft->val == oneval &&\\n                 newnode->bottomRight->isLeaf  &&\\n               newnode->bottomRight->val == oneval){\\n                newnode = new Node(oneval, true, NULL, NULL, NULL, NULL);\\n            }\\n            return newnode;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree2->isLeaf && !(quadTree1->isLeaf)){\\n            return intersect(quadTree2, quadTree1);\\n        }else if (quadTree1->isLeaf){\\n            if (quadTree1->val){\\n                return quadTree1;\\n            }else{\\n                return quadTree2;\\n            }\\n        }else{\\n            Node* newnode = new Node;\\n            newnode->isLeaf = false;\\n            newnode->topLeft = \\n                intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            newnode->topRight = \\n                intersect(quadTree1->topRight, quadTree2->topRight);\\n            newnode->bottomLeft = \\n                intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            newnode->bottomRight = \\n                intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            newnode->val = false;\\n            bool oneval = newnode->topLeft->val;\\n            if (newnode->topRight->isLeaf &&\\n                newnode->topRight->val == oneval && \\n                newnode->bottomLeft->isLeaf  &&\\n               newnode->bottomLeft->val == oneval &&\\n                 newnode->bottomRight->isLeaf  &&\\n               newnode->bottomRight->val == oneval){\\n                newnode = new Node(oneval, true, NULL, NULL, NULL, NULL);\\n            }\\n            return newnode;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544837,
                "title": "python-dfs-easy-code",
                "content": "\\t\\tdef combine(r1,r2,r3,r4): return r1.val if r1.val == r2.val == r3.val == r4.val and r1.isLeaf == r2.isLeaf == r3.isLeaf == r4.isLeaf == 1 else -1\\n        def DFS(root1, root2):\\n            if root1 == root2 == None: return None\\n            if root1.isLeaf == root2.isLeaf == 1: \\n                root1.val |= root2.val\\n                return root1\\n            elif root1.isLeaf == 1 and root2.isLeaf == 0: return root1 if root1.val == 1 else root2\\n            elif root1.isLeaf == 0 and root2.isLeaf == 1: return root2 if root2.val == 1 else root1\\n            else:\\n                root = Node(0, 0, None, None, None, None)\\n                root.topLeft = DFS(root1.topLeft, root2.topLeft)\\n                root.topRight = DFS(root1.topRight, root2.topRight)\\n                root.bottomLeft = DFS(root1.bottomLeft, root2.bottomLeft)\\n                root.bottomRight = DFS(root1.bottomRight, root2.bottomRight)\\n                v = combine(root.topLeft, root.topRight, root.bottomLeft, root.bottomRight)\\n                if v != -1: root = Node(v, 1, None, None, None, None)\\n                return root\\n        return DFS(quadTree1, quadTree2)",
                "solutionTags": [],
                "code": "\\t\\tdef combine(r1,r2,r3,r4): return r1.val if r1.val == r2.val == r3.val == r4.val and r1.isLeaf == r2.isLeaf == r3.isLeaf == r4.isLeaf == 1 else -1\\n        def DFS(root1, root2):\\n            if root1 == root2 == None: return None\\n            if root1.isLeaf == root2.isLeaf == 1: \\n                root1.val |= root2.val\\n                return root1\\n            elif root1.isLeaf == 1 and root2.isLeaf == 0: return root1 if root1.val == 1 else root2\\n            elif root1.isLeaf == 0 and root2.isLeaf == 1: return root2 if root2.val == 1 else root1\\n            else:\\n                root = Node(0, 0, None, None, None, None)\\n                root.topLeft = DFS(root1.topLeft, root2.topLeft)\\n                root.topRight = DFS(root1.topRight, root2.topRight)\\n                root.bottomLeft = DFS(root1.bottomLeft, root2.bottomLeft)\\n                root.bottomRight = DFS(root1.bottomRight, root2.bottomRight)\\n                v = combine(root.topLeft, root.topRight, root.bottomLeft, root.bottomRight)\\n                if v != -1: root = Node(v, 1, None, None, None, None)\\n                return root\\n        return DFS(quadTree1, quadTree2)",
                "codeTag": "Python3"
            },
            {
                "id": 517525,
                "title": "easy-c-recursive-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public Node Intersect(Node quadTree1, Node quadTree2)\\n        {\\n            if (quadTree1 == null || quadTree2 == null)\\n            {\\n                return null;\\n            }\\n\\n            if (quadTree1.isLeaf && quadTree2.isLeaf)\\n            {\\n                return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n            }\\n\\n            Node tl, tr, bl, br;\\n            if (quadTree1.isLeaf)\\n            {\\n                tl = Intersect(quadTree1, quadTree2.topLeft);\\n                tr = Intersect(quadTree1, quadTree2.topRight);\\n                bl = Intersect(quadTree1, quadTree2.bottomLeft);\\n                br = Intersect(quadTree1, quadTree2.bottomRight);\\n            }\\n            else\\n            {\\n                if (quadTree2.isLeaf)\\n                {\\n                    tl = Intersect(quadTree1.topLeft, quadTree2);\\n                    tr = Intersect(quadTree1.topRight, quadTree2);\\n                    bl = Intersect(quadTree1.bottomLeft, quadTree2);\\n                    br = Intersect(quadTree1.bottomRight, quadTree2);\\n                }\\n                else\\n                {\\n                    tl = Intersect(quadTree1.topLeft, quadTree2.topLeft);\\n                    tr = Intersect(quadTree1.topRight, quadTree2.topRight);\\n                    bl = Intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n                    br = Intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n                }\\n            }\\n\\n            if (tl.val == tr.val && tl.val == bl.val && tl.val == br.val)\\n            {\\n                if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf)\\n                {\\n                    return new Node(tl.val, true, null, null, null, null);\\n                }\\n            }\\n\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public Node Intersect(Node quadTree1, Node quadTree2)\\n        {\\n            if (quadTree1 == null || quadTree2 == null)\\n            {\\n                return null;\\n            }\\n\\n            if (quadTree1.isLeaf && quadTree2.isLeaf)\\n            {\\n                return new Node(quadTree1.val || quadTree2.val, true, null, null, null, null);\\n            }\\n\\n            Node tl, tr, bl, br;\\n            if (quadTree1.isLeaf)\\n            {\\n                tl = Intersect(quadTree1, quadTree2.topLeft);\\n                tr = Intersect(quadTree1, quadTree2.topRight);\\n                bl = Intersect(quadTree1, quadTree2.bottomLeft);\\n                br = Intersect(quadTree1, quadTree2.bottomRight);\\n            }\\n            else\\n            {\\n                if (quadTree2.isLeaf)\\n                {\\n                    tl = Intersect(quadTree1.topLeft, quadTree2);\\n                    tr = Intersect(quadTree1.topRight, quadTree2);\\n                    bl = Intersect(quadTree1.bottomLeft, quadTree2);\\n                    br = Intersect(quadTree1.bottomRight, quadTree2);\\n                }\\n                else\\n                {\\n                    tl = Intersect(quadTree1.topLeft, quadTree2.topLeft);\\n                    tr = Intersect(quadTree1.topRight, quadTree2.topRight);\\n                    bl = Intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n                    br = Intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n                }\\n            }\\n\\n            if (tl.val == tr.val && tl.val == bl.val && tl.val == br.val)\\n            {\\n                if (tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf)\\n                {\\n                    return new Node(tl.val, true, null, null, null, null);\\n                }\\n            }\\n\\n            return new Node(false, false, tl, tr, bl, br);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510377,
                "title": "javascript-recursion",
                "content": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function (quadTree1, quadTree2) {\\n  let rtn = or(quadTree1, quadTree2)\\n  return rtn\\n\\n  /**\\n   * @param {Node} n1\\n   * @param {Node} q2\\n   * @return {Node} \\n   */\\n  function or(n1, n2) {\\n    if (n1.isLeaf) {\\n      if (n1.val) {\\n        return n1\\n      }\\n      return n2\\n    }\\n    if (n2.isLeaf) {\\n      if (n2.val) {\\n        return n2\\n      }\\n      return n1\\n    }\\n    let nodes = [\\n      or(n1.topLeft, n2.topLeft),\\n      or(n1.topRight, n2.topRight),\\n      or(n1.bottomLeft, n2.bottomLeft),\\n      or(n1.bottomRight, n2.bottomRight)\\n    ]\\n    if (nodes.every(n => n.isLeaf && n.val)) {\\n      return new Node(true, true)\\n    }\\n    return new Node(false, false,\\n      nodes[0],\\n      nodes[1],\\n      nodes[2],\\n      nodes[3])\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function (quadTree1, quadTree2) {\\n  let rtn = or(quadTree1, quadTree2)\\n  return rtn\\n\\n  /**\\n   * @param {Node} n1\\n   * @param {Node} q2\\n   * @return {Node} \\n   */\\n  function or(n1, n2) {\\n    if (n1.isLeaf) {\\n      if (n1.val) {\\n        return n1\\n      }\\n      return n2\\n    }\\n    if (n2.isLeaf) {\\n      if (n2.val) {\\n        return n2\\n      }\\n      return n1\\n    }\\n    let nodes = [\\n      or(n1.topLeft, n2.topLeft),\\n      or(n1.topRight, n2.topRight),\\n      or(n1.bottomLeft, n2.bottomLeft),\\n      or(n1.bottomRight, n2.bottomRight)\\n    ]\\n    if (nodes.every(n => n.isLeaf && n.val)) {\\n      return new Node(true, true)\\n    }\\n    return new Node(false, false,\\n      nodes[0],\\n      nodes[1],\\n      nodes[2],\\n      nodes[3])\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 505597,
                "title": "c-340ms-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr) {\\n            return quadTree2;\\n        }\\n        if (quadTree2 == nullptr) {\\n            return quadTree1;\\n        }\\n        auto unionNode = new Node(false, false, nullptr, nullptr, nullptr, nullptr);\\n        if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n            unionNode->val = quadTree1->val||quadTree2->val;\\n            unionNode->isLeaf = true;\\n            return unionNode;\\n        }\\n        if (quadTree1->isLeaf) {\\n            if (quadTree1->val == true) {\\n                unionNode->val = true;\\n                unionNode->isLeaf = true;\\n            } else {\\n                unionNode->topLeft = quadTree2->topLeft;\\n                unionNode->topRight = quadTree2->topRight;\\n                unionNode->bottomLeft = quadTree2->bottomLeft;\\n                unionNode->bottomRight = quadTree2->bottomRight;\\n                unionNode->isLeaf = false;\\n            }\\n            return unionNode;\\n        }\\n        if (quadTree2->isLeaf) {\\n            if (quadTree2->val == true) {\\n                unionNode->val = true;\\n                unionNode->isLeaf = true;\\n            } else {\\n                unionNode->topLeft = quadTree1->topLeft;\\n                unionNode->topRight = quadTree1->topRight;\\n                unionNode->bottomLeft = quadTree1->bottomLeft;\\n                unionNode->bottomRight = quadTree1->bottomRight;\\n                unionNode->isLeaf = false;\\n            }\\n            return unionNode;\\n        }\\n        unionNode->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        unionNode->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        unionNode->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        unionNode->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        if (unionNode->topLeft->isLeaf && unionNode->topRight->isLeaf && unionNode->bottomLeft->isLeaf && unionNode->bottomRight->isLeaf) {\\n            if ((unionNode->topLeft->val && unionNode->topRight->val && unionNode->bottomLeft->val && unionNode->bottomRight->val) || (!unionNode->topLeft->val && !unionNode->topRight->val && !unionNode->bottomLeft->val && !unionNode->bottomRight->val)) {\\n                unionNode->isLeaf = true;\\n                unionNode->val = unionNode->topLeft->val;\\n                unionNode->topLeft = nullptr;\\n                unionNode->topRight = nullptr;\\n                unionNode->bottomLeft = nullptr;\\n                unionNode->bottomRight = nullptr;\\n            }\\n        }\\n        return unionNode;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        if (quadTree1 == nullptr) {\\n            return quadTree2;\\n        }\\n        if (quadTree2 == nullptr) {\\n            return quadTree1;\\n        }\\n        auto unionNode = new Node(false, false, nullptr, nullptr, nullptr, nullptr);\\n        if (quadTree1->isLeaf && quadTree2->isLeaf) {\\n            unionNode->val = quadTree1->val||quadTree2->val;\\n            unionNode->isLeaf = true;\\n            return unionNode;\\n        }\\n        if (quadTree1->isLeaf) {\\n            if (quadTree1->val == true) {\\n                unionNode->val = true;\\n                unionNode->isLeaf = true;\\n            } else {\\n                unionNode->topLeft = quadTree2->topLeft;\\n                unionNode->topRight = quadTree2->topRight;\\n                unionNode->bottomLeft = quadTree2->bottomLeft;\\n                unionNode->bottomRight = quadTree2->bottomRight;\\n                unionNode->isLeaf = false;\\n            }\\n            return unionNode;\\n        }\\n        if (quadTree2->isLeaf) {\\n            if (quadTree2->val == true) {\\n                unionNode->val = true;\\n                unionNode->isLeaf = true;\\n            } else {\\n                unionNode->topLeft = quadTree1->topLeft;\\n                unionNode->topRight = quadTree1->topRight;\\n                unionNode->bottomLeft = quadTree1->bottomLeft;\\n                unionNode->bottomRight = quadTree1->bottomRight;\\n                unionNode->isLeaf = false;\\n            }\\n            return unionNode;\\n        }\\n        unionNode->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n        unionNode->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n        unionNode->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n        unionNode->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n        if (unionNode->topLeft->isLeaf && unionNode->topRight->isLeaf && unionNode->bottomLeft->isLeaf && unionNode->bottomRight->isLeaf) {\\n            if ((unionNode->topLeft->val && unionNode->topRight->val && unionNode->bottomLeft->val && unionNode->bottomRight->val) || (!unionNode->topLeft->val && !unionNode->topRight->val && !unionNode->bottomLeft->val && !unionNode->bottomRight->val)) {\\n                unionNode->isLeaf = true;\\n                unionNode->val = unionNode->topLeft->val;\\n                unionNode->topLeft = nullptr;\\n                unionNode->topRight = nullptr;\\n                unionNode->bottomLeft = nullptr;\\n                unionNode->bottomRight = nullptr;\\n            }\\n        }\\n        return unionNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484673,
                "title": "faster-than-90-00-of-javascript",
                "content": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\nvar hasChildren = (tree) => {\\n    return tree.topLeft !== null || tree.topRight !== null || tree.bottomLeft !== null || tree.bottomRight !== null;\\n}\\n\\nvar mergeTwoTree = (tree1, tree2) => {\\n    const topLeft = mergeAny(tree1.topLeft, tree2.topLeft);\\n    const topRight = mergeAny(tree1.topRight, tree2.topRight);\\n    const bottomLeft = mergeAny(tree1.bottomLeft, tree2.bottomLeft);\\n    const bottomRight = mergeAny(tree1.bottomRight, tree2.bottomRight);\\n\\n    const r = new Node();\\n    r.topLeft = topLeft;\\n    r.topRight = topRight;\\n    r.bottomLeft = bottomLeft;\\n    r.bottomRight = bottomRight;\\n    r.isLeaf = tree1.isLeaf && tree2.isLeaf;\\n    return r;\\n}\\n\\nvar mergeNode = (node1, node2) => {\\n    return new Node(node1.val || node2.val, node1.isLeaf && node2.isLeaf);\\n}\\n\\nvar mergeAny = (quadTree1, quadTree2) => {\\n    if (!quadTree1 || !quadTree2) return quadTree1 || quadTree2;\\n    \\n    const h1 = hasChildren(quadTree1);\\n    const h2 = hasChildren(quadTree2);\\n    \\n    if (h1 && h2) {\\n        return mergeTwoTree(quadTree1, quadTree2);\\n    } else if ((h1 === false) && (h2 == false)) {\\n        return mergeNode(quadTree1, quadTree2);\\n    } else if (h1 && !h2) {\\n        return mergeTreeNode(quadTree1, quadTree2);\\n    } else {\\n        return mergeTreeNode(quadTree2, quadTree1);\\n    }\\n};\\n\\nvar mergeTreeNode = (tree, node) => {\\n    if (node.val === true) { // \\u903B\\u8F91\\u77ED\\u8DEF\\n        return new Node(true, node.isLeaf);\\n    }\\n    if (hasChildren(tree)) {\\n        const topLeft = mergeTreeNode(tree.topLeft, node);\\n        const topRight = mergeTreeNode(tree.topRight, node);\\n        const bottomLeft = mergeTreeNode(tree.bottomLeft, node);\\n        const bottomRight = mergeTreeNode(tree.bottomRight, node);\\n        const r = new Node();\\n        r.topLeft = topLeft;\\n        r.topRight = topRight;\\n        r.bottomLeft = bottomLeft;\\n        r.bottomRight = bottomRight;\\n        r.isLeaf = false;\\n        return r;\\n    }\\n    return mergeNode(tree, node);\\n}\\n\\n\\nvar unionTreeNodes = (tree) => {\\n    if (hasChildren(tree)) {\\n        let { topLeft, topRight, bottomLeft, bottomRight} = tree\\n        topLeft = unionTreeNodes(topLeft);\\n        topRight = unionTreeNodes(topRight);\\n        bottomLeft = unionTreeNodes(bottomLeft);\\n        bottomRight = unionTreeNodes(bottomRight);\\n\\n        if (  \\n            (\\n                (hasChildren(topLeft)\\n                || hasChildren(topRight)\\n                || hasChildren(bottomLeft)\\n                || hasChildren(bottomRight)) === false\\n            )\\n        && (\\n            (topLeft.val === topRight.val) \\n            && (topRight.val == bottomLeft.val)\\n            && (bottomLeft.val === bottomRight.val)\\n            ) \\n        ) {\\n            tree.val = topLeft.val;\\n            tree.topLeft = null;\\n            tree.topRight = null;\\n            tree.bottomLeft = null;\\n            tree.bottomRight = null;\\n            tree.isLeaf = topLeft.isLeaf || topRight.isLeaf || bottomLeft.isLeaf || bottomRight.isLeaf;\\n        }\\n        \\n    } \\n    return tree;\\n}\\n\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    const r = mergeAny(quadTree1, quadTree2);\\n    return unionTreeNodes(r);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // Definition for a QuadTree node.\\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\\n *    this.val = val;\\n *    this.isLeaf = isLeaf;\\n *    this.topLeft = topLeft;\\n *    this.topRight = topRight;\\n *    this.bottomLeft = bottomLeft;\\n *    this.bottomRight = bottomRight;\\n * };\\n */\\nvar hasChildren = (tree) => {\\n    return tree.topLeft !== null || tree.topRight !== null || tree.bottomLeft !== null || tree.bottomRight !== null;\\n}\\n\\nvar mergeTwoTree = (tree1, tree2) => {\\n    const topLeft = mergeAny(tree1.topLeft, tree2.topLeft);\\n    const topRight = mergeAny(tree1.topRight, tree2.topRight);\\n    const bottomLeft = mergeAny(tree1.bottomLeft, tree2.bottomLeft);\\n    const bottomRight = mergeAny(tree1.bottomRight, tree2.bottomRight);\\n\\n    const r = new Node();\\n    r.topLeft = topLeft;\\n    r.topRight = topRight;\\n    r.bottomLeft = bottomLeft;\\n    r.bottomRight = bottomRight;\\n    r.isLeaf = tree1.isLeaf && tree2.isLeaf;\\n    return r;\\n}\\n\\nvar mergeNode = (node1, node2) => {\\n    return new Node(node1.val || node2.val, node1.isLeaf && node2.isLeaf);\\n}\\n\\nvar mergeAny = (quadTree1, quadTree2) => {\\n    if (!quadTree1 || !quadTree2) return quadTree1 || quadTree2;\\n    \\n    const h1 = hasChildren(quadTree1);\\n    const h2 = hasChildren(quadTree2);\\n    \\n    if (h1 && h2) {\\n        return mergeTwoTree(quadTree1, quadTree2);\\n    } else if ((h1 === false) && (h2 == false)) {\\n        return mergeNode(quadTree1, quadTree2);\\n    } else if (h1 && !h2) {\\n        return mergeTreeNode(quadTree1, quadTree2);\\n    } else {\\n        return mergeTreeNode(quadTree2, quadTree1);\\n    }\\n};\\n\\nvar mergeTreeNode = (tree, node) => {\\n    if (node.val === true) { // \\u903B\\u8F91\\u77ED\\u8DEF\\n        return new Node(true, node.isLeaf);\\n    }\\n    if (hasChildren(tree)) {\\n        const topLeft = mergeTreeNode(tree.topLeft, node);\\n        const topRight = mergeTreeNode(tree.topRight, node);\\n        const bottomLeft = mergeTreeNode(tree.bottomLeft, node);\\n        const bottomRight = mergeTreeNode(tree.bottomRight, node);\\n        const r = new Node();\\n        r.topLeft = topLeft;\\n        r.topRight = topRight;\\n        r.bottomLeft = bottomLeft;\\n        r.bottomRight = bottomRight;\\n        r.isLeaf = false;\\n        return r;\\n    }\\n    return mergeNode(tree, node);\\n}\\n\\n\\nvar unionTreeNodes = (tree) => {\\n    if (hasChildren(tree)) {\\n        let { topLeft, topRight, bottomLeft, bottomRight} = tree\\n        topLeft = unionTreeNodes(topLeft);\\n        topRight = unionTreeNodes(topRight);\\n        bottomLeft = unionTreeNodes(bottomLeft);\\n        bottomRight = unionTreeNodes(bottomRight);\\n\\n        if (  \\n            (\\n                (hasChildren(topLeft)\\n                || hasChildren(topRight)\\n                || hasChildren(bottomLeft)\\n                || hasChildren(bottomRight)) === false\\n            )\\n        && (\\n            (topLeft.val === topRight.val) \\n            && (topRight.val == bottomLeft.val)\\n            && (bottomLeft.val === bottomRight.val)\\n            ) \\n        ) {\\n            tree.val = topLeft.val;\\n            tree.topLeft = null;\\n            tree.topRight = null;\\n            tree.bottomLeft = null;\\n            tree.bottomRight = null;\\n            tree.isLeaf = topLeft.isLeaf || topRight.isLeaf || bottomLeft.isLeaf || bottomRight.isLeaf;\\n        }\\n        \\n    } \\n    return tree;\\n}\\n\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    const r = mergeAny(quadTree1, quadTree2);\\n    return unionTreeNodes(r);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470291,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) \\n    {\\n        // if a is leaf+true, choose a.\\n        // if b is leaf+false, choose a.\\n        if (quadTree1->isLeaf && quadTree1->val == true ||\\n            quadTree2->isLeaf && quadTree2->val == false)\\n            return quadTree1;\\n        // if b is leaf+true, choose b.\\n        // if a is leaf+false, choose b;\\n        if (quadTree2->isLeaf && quadTree2->val == true ||\\n            quadTree1->isLeaf && quadTree1->val == false)\\n            return quadTree2;\\n        \\n        // intersect.\\n        Node* ret = new Node (false, false, \\n                                intersect (quadTree1->topLeft, quadTree2->topLeft),\\n                                intersect (quadTree1->topRight, quadTree2->topRight),\\n                                intersect (quadTree1->bottomLeft, quadTree2->bottomLeft),\\n                                intersect (quadTree1->bottomRight, quadTree2->bottomRight));\\n        \\n        // merge if all children are leaves and have the same value.\\n        if (ret->topLeft->val == ret->topRight->val && ret->topLeft->val == ret->bottomLeft->val && \\n            ret->topLeft->val == ret->bottomRight->val &&\\n            ret->topLeft->isLeaf && ret->topRight->isLeaf && ret->bottomLeft->isLeaf && ret->bottomRight->isLeaf)\\n        {\\n            ret->val = ret->topLeft->val;\\n            ret->isLeaf = true;\\n            ret->topLeft = ret->topRight = ret->bottomLeft = ret->bottomRight = NULL;\\n        }\\n        \\n        // done.\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) \\n    {\\n        // if a is leaf+true, choose a.\\n        // if b is leaf+false, choose a.\\n        if (quadTree1->isLeaf && quadTree1->val == true ||\\n            quadTree2->isLeaf && quadTree2->val == false)\\n            return quadTree1;\\n        // if b is leaf+true, choose b.\\n        // if a is leaf+false, choose b;\\n        if (quadTree2->isLeaf && quadTree2->val == true ||\\n            quadTree1->isLeaf && quadTree1->val == false)\\n            return quadTree2;\\n        \\n        // intersect.\\n        Node* ret = new Node (false, false, \\n                                intersect (quadTree1->topLeft, quadTree2->topLeft),\\n                                intersect (quadTree1->topRight, quadTree2->topRight),\\n                                intersect (quadTree1->bottomLeft, quadTree2->bottomLeft),\\n                                intersect (quadTree1->bottomRight, quadTree2->bottomRight));\\n        \\n        // merge if all children are leaves and have the same value.\\n        if (ret->topLeft->val == ret->topRight->val && ret->topLeft->val == ret->bottomLeft->val && \\n            ret->topLeft->val == ret->bottomRight->val &&\\n            ret->topLeft->isLeaf && ret->topRight->isLeaf && ret->bottomLeft->isLeaf && ret->bottomRight->isLeaf)\\n        {\\n            ret->val = ret->topLeft->val;\\n            ret->isLeaf = true;\\n            ret->topLeft = ret->topRight = ret->bottomLeft = ret->bottomRight = NULL;\\n        }\\n        \\n        // done.\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455765,
                "title": "best-java-dfs-solution-beats-100-with-explanation",
                "content": "```\\n\\tpublic Node intersect(Node quadTree1, Node quadTree2) {\\n\\t\\tNode result = new Node();\\n\\t\\tif(quadTree1 == null || quadTree2 == null) { // based on given assumption, this should not happen\\n\\t\\t\\treturn null;\\n\\t\\t} else if(quadTree1.isLeaf && quadTree2.isLeaf) { // both nodes are leaf nodes\\n\\t\\t\\tresult.isLeaf = true;\\n\\t\\t\\tresult.val = quadTree1.val || quadTree2.val;\\n\\t\\t} else if(quadTree1.isLeaf) { // true || statement == true; false || statement == statement\\n\\t\\t\\tresult = quadTree1.val ? quadTree1 : quadTree2;\\n\\t\\t} else if(quadTree2.isLeaf) {\\n\\t\\t\\tresult = quadTree2.val ? quadTree2 : quadTree1;\\n\\t\\t} else {\\n\\t\\t\\tresult.isLeaf = false;\\n\\t\\t\\tresult.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n\\t\\t\\tresult.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n\\t\\t\\tresult.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n\\t\\t\\tresult.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\t\\t}\\n\\t\\t// the last step - merge nodes if possible:\\n\\t\\tif(!result.isLeaf && result.topLeft.isLeaf && result.topRight.isLeaf &&\\n\\t\\t\\tresult.bottomLeft.isLeaf && result.bottomRight.isLeaf && \\n\\t\\t\\tresult.topLeft.val == result.topRight.val &&\\n\\t\\t\\tresult.topRight.val == result.bottomLeft.val &&\\n\\t\\t\\tresult.bottomLeft.val == result.bottomRight.val) {\\n\\t\\t\\tresult.isLeaf = true;\\n            result.val = result.topLeft.val;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic Node intersect(Node quadTree1, Node quadTree2) {\\n\\t\\tNode result = new Node();\\n\\t\\tif(quadTree1 == null || quadTree2 == null) { // based on given assumption, this should not happen\\n\\t\\t\\treturn null;\\n\\t\\t} else if(quadTree1.isLeaf && quadTree2.isLeaf) { // both nodes are leaf nodes\\n\\t\\t\\tresult.isLeaf = true;\\n\\t\\t\\tresult.val = quadTree1.val || quadTree2.val;\\n\\t\\t} else if(quadTree1.isLeaf) { // true || statement == true; false || statement == statement\\n\\t\\t\\tresult = quadTree1.val ? quadTree1 : quadTree2;\\n\\t\\t} else if(quadTree2.isLeaf) {\\n\\t\\t\\tresult = quadTree2.val ? quadTree2 : quadTree1;\\n\\t\\t} else {\\n\\t\\t\\tresult.isLeaf = false;\\n\\t\\t\\tresult.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n\\t\\t\\tresult.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n\\t\\t\\tresult.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n\\t\\t\\tresult.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\t\\t}\\n\\t\\t// the last step - merge nodes if possible:\\n\\t\\tif(!result.isLeaf && result.topLeft.isLeaf && result.topRight.isLeaf &&\\n\\t\\t\\tresult.bottomLeft.isLeaf && result.bottomRight.isLeaf && \\n\\t\\t\\tresult.topLeft.val == result.topRight.val &&\\n\\t\\t\\tresult.topRight.val == result.bottomLeft.val &&\\n\\t\\t\\tresult.bottomLeft.val == result.bottomRight.val) {\\n\\t\\t\\tresult.isLeaf = true;\\n            result.val = result.topLeft.val;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447563,
                "title": "python-different-way-to-treat-the-leaf",
                "content": "\\n```\\nclass Solution:\\n    def intersect(self, tree1: \\'Node\\', tree2: \\'Node\\') -> \\'Node\\':\\n\\t\\n        if tree1.isLeaf or tree2.isLeaf:\\n            tree,leaf=[tree1,tree2][::(None if tree2.isLeaf else -1)]\\n            return leaf if leaf.val else tree\\n\\t\\t\\t\\n        else:\\n            tl=self.intersect(tree1.topLeft,tree2.topLeft)\\n            tr=self.intersect(tree1.topRight,tree2.topRight)\\n            bl=self.intersect(tree1.bottomLeft,tree2.bottomLeft)\\n            br=self.intersect(tree1.bottomRight,tree2.bottomRight)\\n\\t\\t\\t\\n            if (\\n                tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf\\n                and tl.val==tr.val==bl.val==br.val\\n            ):\\n                return Node(tl.val,True,None,None,None,None)\\n\\t\\t\\t\\t\\n            return Node(False,False,tl,tr,bl,br)\\n```\\n\\nExplanation:\\n```\\ntree,leaf=[tree1,tree2][::(None if tree2.isLeaf else -1)]\\n```\\nIt will reverse into [tree2,tree1] when the tree2 not leaf.\\nAnd not reverse when tree2 is leaf.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersect(self, tree1: \\'Node\\', tree2: \\'Node\\') -> \\'Node\\':\\n\\t\\n        if tree1.isLeaf or tree2.isLeaf:\\n            tree,leaf=[tree1,tree2][::(None if tree2.isLeaf else -1)]\\n            return leaf if leaf.val else tree\\n\\t\\t\\t\\n        else:\\n            tl=self.intersect(tree1.topLeft,tree2.topLeft)\\n            tr=self.intersect(tree1.topRight,tree2.topRight)\\n            bl=self.intersect(tree1.bottomLeft,tree2.bottomLeft)\\n            br=self.intersect(tree1.bottomRight,tree2.bottomRight)\\n\\t\\t\\t\\n            if (\\n                tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf\\n                and tl.val==tr.val==bl.val==br.val\\n            ):\\n                return Node(tl.val,True,None,None,None,None)\\n\\t\\t\\t\\t\\n            return Node(False,False,tl,tr,bl,br)\\n```\n```\\ntree,leaf=[tree1,tree2][::(None if tree2.isLeaf else -1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445686,
                "title": "easy-java-solution",
                "content": "The only key ideal is to remember mergeing the Node after or operation when all of its\\' children are leaves and have the same value. \\n```\\nclass Solution {\\n    void combine(Node a){\\n        if(a.topLeft.isLeaf && a.topRight.isLeaf && a.bottomLeft.isLeaf && a.bottomRight.isLeaf){\\n            if(a.topLeft.val == a.topRight.val && a.topRight.val == a.bottomLeft.val && a.bottomLeft.val == a.bottomRight.val){\\n                a.isLeaf = true;\\n                a.val = a.topLeft.val;\\n            }\\n        }\\n    }\\n    public Node f(Node a, Node b){\\n        if(a.isLeaf){\\n            if(a.val){\\n                return a;\\n            }\\n            return b;\\n        }\\n        if(b.isLeaf){\\n            if(b.val){\\n                return b;\\n            }\\n            return a;\\n        }\\n        a.topLeft = f(a.topLeft,b.topLeft);\\n        a.topRight = f(a.topRight,b.topRight);\\n        a.bottomLeft = f(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = f(a.bottomRight,b.bottomRight);\\n        combine(a);\\n        return a;\\n    }\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        return f(quadTree1,quadTree2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void combine(Node a){\\n        if(a.topLeft.isLeaf && a.topRight.isLeaf && a.bottomLeft.isLeaf && a.bottomRight.isLeaf){\\n            if(a.topLeft.val == a.topRight.val && a.topRight.val == a.bottomLeft.val && a.bottomLeft.val == a.bottomRight.val){\\n                a.isLeaf = true;\\n                a.val = a.topLeft.val;\\n            }\\n        }\\n    }\\n    public Node f(Node a, Node b){\\n        if(a.isLeaf){\\n            if(a.val){\\n                return a;\\n            }\\n            return b;\\n        }\\n        if(b.isLeaf){\\n            if(b.val){\\n                return b;\\n            }\\n            return a;\\n        }\\n        a.topLeft = f(a.topLeft,b.topLeft);\\n        a.topRight = f(a.topRight,b.topRight);\\n        a.bottomLeft = f(a.bottomLeft,b.bottomLeft);\\n        a.bottomRight = f(a.bottomRight,b.bottomRight);\\n        combine(a);\\n        return a;\\n    }\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        return f(quadTree1,quadTree2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439730,
                "title": "558-quad-tree-intersection-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Naive**\\n| O(T): O(n) | O(S): O(n) | Rt: 220ms | \\n```python\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree1.val: return quadTree1\\n        elif quadTree1.isLeaf and not quadTree1.val: return quadTree2\\n        elif quadTree2.isLeaf and quadTree2.val: return quadTree2\\n        elif quadTree2.isLeaf and not quadTree2.val: return quadTree1\\n        \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)        \\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(False, False, tl, tr, bl, br)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def intersect(self, quadTree1: \\'Node\\', quadTree2: \\'Node\\') -> \\'Node\\':\\n        if quadTree1.isLeaf and quadTree1.val: return quadTree1\\n        elif quadTree1.isLeaf and not quadTree1.val: return quadTree2\\n        elif quadTree2.isLeaf and quadTree2.val: return quadTree2\\n        elif quadTree2.isLeaf and not quadTree2.val: return quadTree1\\n        \\n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)        \\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\\n            return Node(tl.val, True, None, None, None, None)\\n        return Node(False, False, tl, tr, bl, br)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434466,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        Node* node;\\n        if(quadTree1->isLeaf && quadTree2->isLeaf){\\n            node = new Node(quadTree1->val || quadTree2->val, true, NULL, NULL, NULL, NULL);\\n        }else if(quadTree1->isLeaf){\\n            if(quadTree1->val) node = quadTree1;\\n            else node = quadTree2;\\n        }else if(quadTree2->isLeaf){\\n            if(quadTree2->val) node = quadTree2;\\n            else node = quadTree1;\\n        }else{\\n            node = new Node(quadTree1->val || quadTree2->val, false, NULL, NULL, NULL, NULL);\\n            \\n            node->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            node->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            node->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            node->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            \\n            if(node->topLeft->isLeaf && node->topRight->isLeaf && node->bottomLeft->isLeaf && node->bottomRight->isLeaf  // all leaves\\n               && ((node->topLeft->val && node->topRight->val && node->bottomLeft->val && node->bottomRight->val)        // all true\\n               || (!node->topLeft->val && !node->topRight->val && !node->bottomLeft->val && !node->bottomRight->val))){  // all false\\n                node->val = node->topLeft->val;\\n                node->topLeft = NULL;\\n                node->topRight = NULL;\\n                node->bottomLeft = NULL;\\n                node->bottomRight = NULL;\\n                node->isLeaf = true;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        Node* node;\\n        if(quadTree1->isLeaf && quadTree2->isLeaf){\\n            node = new Node(quadTree1->val || quadTree2->val, true, NULL, NULL, NULL, NULL);\\n        }else if(quadTree1->isLeaf){\\n            if(quadTree1->val) node = quadTree1;\\n            else node = quadTree2;\\n        }else if(quadTree2->isLeaf){\\n            if(quadTree2->val) node = quadTree2;\\n            else node = quadTree1;\\n        }else{\\n            node = new Node(quadTree1->val || quadTree2->val, false, NULL, NULL, NULL, NULL);\\n            \\n            node->topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n            node->topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n            node->bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n            node->bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n            \\n            if(node->topLeft->isLeaf && node->topRight->isLeaf && node->bottomLeft->isLeaf && node->bottomRight->isLeaf  // all leaves\\n               && ((node->topLeft->val && node->topRight->val && node->bottomLeft->val && node->bottomRight->val)        // all true\\n               || (!node->topLeft->val && !node->topRight->val && !node->bottomLeft->val && !node->bottomRight->val))){  // all false\\n                node->val = node->topLeft->val;\\n                node->topLeft = NULL;\\n                node->topRight = NULL;\\n                node->bottomLeft = NULL;\\n                node->bottomRight = NULL;\\n                node->isLeaf = true;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399024,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool quadvalue(Node* node){\\n        bool temp = 0;\\n        if(node->isLeaf){\\n            return node->val;\\n        }\\n        else{\\n            return quadvalue(node->topLeft)||quadvalue(node->topRight)||quadvalue(node->bottomLeft)||quadvalue(node->bottomRight);\\n        }\\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        bool tl =  quadvalue(quadTree1->topLeft) || quadvalue(quadTree2->topLeft);\\n        bool tr = quadvalue(quadTree1->topRight) || quadvalue(quadTree2->topRight);\\n        bool bl = quadvalue(quadTree1->bottomLeft) || quadvalue(quadTree2->bottomLeft);\\n        bool br = quadvalue(quadTree1->bottomRight) || quadvalue(quadTree2->bottomRight);\\n        Node* topLeft = new Node(tl,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* topRight = new Node(tr,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* bottomLeft = new Node(bl,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* bottomRight = new Node(br,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* newTree = new Node((tl||tr||bl||br),false,topLeft,topRight,bottomLeft,bottomRight);\\n        return newTree;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool quadvalue(Node* node){\\n        bool temp = 0;\\n        if(node->isLeaf){\\n            return node->val;\\n        }\\n        else{\\n            return quadvalue(node->topLeft)||quadvalue(node->topRight)||quadvalue(node->bottomLeft)||quadvalue(node->bottomRight);\\n        }\\n    }\\n    Node* intersect(Node* quadTree1, Node* quadTree2) {\\n        bool tl =  quadvalue(quadTree1->topLeft) || quadvalue(quadTree2->topLeft);\\n        bool tr = quadvalue(quadTree1->topRight) || quadvalue(quadTree2->topRight);\\n        bool bl = quadvalue(quadTree1->bottomLeft) || quadvalue(quadTree2->bottomLeft);\\n        bool br = quadvalue(quadTree1->bottomRight) || quadvalue(quadTree2->bottomRight);\\n        Node* topLeft = new Node(tl,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* topRight = new Node(tr,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* bottomLeft = new Node(bl,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* bottomRight = new Node(br,true,nullptr,nullptr,nullptr,nullptr);\\n        Node* newTree = new Node((tl||tr||bl||br),false,topLeft,topRight,bottomLeft,bottomRight);\\n        return newTree;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341332,
                "title": "please-add-tags",
                "content": "This problem is very good problem but tags are not added for this.\\n\\nI suggest following tags : \\n1. Tree\\n2. QuadTree\\n3. Recursion\\n\\n@1337c0d3r please add the tags.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 333354,
                "title": "easy-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* q1, Node* q2) {\\n        Node* res = new Node();\\n        res->isLeaf = false;\\n        res->val = NULL;\\n        \\n        if (q1->isLeaf && q2->isLeaf) {\\n            res->isLeaf = true;\\n            res->val = q1->val || q2->val;\\n            res->topLeft = NULL;\\n            res->topRight = NULL;\\n            res->bottomLeft = NULL;\\n            res->bottomRight = NULL;\\n            return res;\\t\\n        } \\n\\t\\telse if (q1->isLeaf)\\n\\t\\t{\\n\\t\\t\\t// Return true immediately if one leaf node has true value \\n            if (q1->val)    return new Node(true, true, NULL, NULL, NULL, NULL);\\n\\t\\t\\t\\n            res->topLeft = intersect(q1, q2->topLeft);\\n            res->topRight = intersect(q1, q2->topRight);\\n            res->bottomLeft = intersect(q1, q2->bottomLeft);\\n            res->bottomRight = intersect(q1, q2->bottomRight);\\t\\n        } \\n\\t\\telse if (q2->isLeaf) \\n\\t\\t{\\n\\t\\t\\t// Return true immediately if one leaf node has true value \\n            if (q2->val)    return new Node(true, true, NULL, NULL, NULL, NULL);\\n\\t\\t\\t\\n            res->topLeft = intersect(q1->topLeft, q2);\\n            res->topRight = intersect(q1->topRight, q2);\\n            res->bottomLeft = intersect(q1->bottomLeft, q2);\\n            res->bottomRight = intersect(q1->bottomRight, q2);\\n        } \\n\\t\\telse \\n\\t\\t{\\n            res->topLeft = intersect(q1->topLeft, q2->topLeft);\\n            res->topRight = intersect(q1->topRight, q2->topRight);\\n            res->bottomLeft = intersect(q1->bottomLeft, q2->bottomLeft);\\n            res->bottomRight = intersect(q1->bottomRight, q2->bottomRight);\\n        }\\n        \\n        // If all four children have the same val and are leaves, combine them into one grid\\n        if (res->topLeft->isLeaf && res->topRight->isLeaf && res->bottomLeft->isLeaf && res->bottomRight->isLeaf && res->topLeft->val == res->topRight->val && res->topRight->val == res->bottomLeft->val && res->bottomLeft->val == res->bottomRight->val && res->bottomRight->val == res->topLeft->val)\\n            return new Node(res->topLeft, true, NULL, NULL, NULL, NULL);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* intersect(Node* q1, Node* q2) {\\n        Node* res = new Node();\\n        res->isLeaf = false;\\n        res->val = NULL;\\n        \\n        if (q1->isLeaf && q2->isLeaf) {\\n            res->isLeaf = true;\\n            res->val = q1->val || q2->val;\\n            res->topLeft = NULL;\\n            res->topRight = NULL;\\n            res->bottomLeft = NULL;\\n            res->bottomRight = NULL;\\n            return res;\\t\\n        } \\n\\t\\telse if (q1->isLeaf)\\n\\t\\t{\\n\\t\\t\\t// Return true immediately if one leaf node has true value \\n            if (q1->val)    return new Node(true, true, NULL, NULL, NULL, NULL);\\n\\t\\t\\t\\n            res->topLeft = intersect(q1, q2->topLeft);\\n            res->topRight = intersect(q1, q2->topRight);\\n            res->bottomLeft = intersect(q1, q2->bottomLeft);\\n            res->bottomRight = intersect(q1, q2->bottomRight);\\t\\n        } \\n\\t\\telse if (q2->isLeaf) \\n\\t\\t{\\n\\t\\t\\t// Return true immediately if one leaf node has true value \\n            if (q2->val)    return new Node(true, true, NULL, NULL, NULL, NULL);\\n\\t\\t\\t\\n            res->topLeft = intersect(q1->topLeft, q2);\\n            res->topRight = intersect(q1->topRight, q2);\\n            res->bottomLeft = intersect(q1->bottomLeft, q2);\\n            res->bottomRight = intersect(q1->bottomRight, q2);\\n        } \\n\\t\\telse \\n\\t\\t{\\n            res->topLeft = intersect(q1->topLeft, q2->topLeft);\\n            res->topRight = intersect(q1->topRight, q2->topRight);\\n            res->bottomLeft = intersect(q1->bottomLeft, q2->bottomLeft);\\n            res->bottomRight = intersect(q1->bottomRight, q2->bottomRight);\\n        }\\n        \\n        // If all four children have the same val and are leaves, combine them into one grid\\n        if (res->topLeft->isLeaf && res->topRight->isLeaf && res->bottomLeft->isLeaf && res->bottomRight->isLeaf && res->topLeft->val == res->topRight->val && res->topRight->val == res->bottomLeft->val && res->bottomLeft->val == res->bottomRight->val && res->bottomRight->val == res->topLeft->val)\\n            return new Node(res->topLeft, true, NULL, NULL, NULL, NULL);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324443,
                "title": "python-solution",
                "content": "This Question is so hard to visualize and debug.\\n```\\nclass Solution(object):\\n    def intersect(self, quadTree1, quadTree2):\\n        \"\"\"\\n        :type quadTree1: Node\\n        :type quadTree2: Node\\n        :rtype: Node\\n        \"\"\"\\n        def merge(t1,t2):\\n            if t1.isLeaf or t2.isLeaf:\\n                if t1.isLeaf and t2.isLeaf:\\n                    # print(t1.val|t2.val)\\n                    node = Node(t1.val|t2.val,True)\\n                    return node\\n                elif t1.val==True or t2.val==True:\\n                    node = Node(True,True)\\n                    return node\\n                elif t1.isLeaf:\\n                    return t2\\n                elif t2.isLeaf:\\n                    return t1\\n            else:\\n                tl = merge(t1.topLeft,t2.topLeft)\\n                tr = merge(t1.topRight,t2.topRight)\\n                bl = merge(t1.bottomLeft,t2.bottomLeft)\\n                br = merge(t1.bottomRight,t2.bottomRight) \\n                if tl.val==tr.val==bl.val==br.val and (tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf):\\n                    return Node(tl.val,True)\\n                return Node(None,False,tl,tr,bl,br)\\n            \\n        return merge(quadTree1, quadTree2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersect(self, quadTree1, quadTree2):\\n        \"\"\"\\n        :type quadTree1: Node\\n        :type quadTree2: Node\\n        :rtype: Node\\n        \"\"\"\\n        def merge(t1,t2):\\n            if t1.isLeaf or t2.isLeaf:\\n                if t1.isLeaf and t2.isLeaf:\\n                    # print(t1.val|t2.val)\\n                    node = Node(t1.val|t2.val,True)\\n                    return node\\n                elif t1.val==True or t2.val==True:\\n                    node = Node(True,True)\\n                    return node\\n                elif t1.isLeaf:\\n                    return t2\\n                elif t2.isLeaf:\\n                    return t1\\n            else:\\n                tl = merge(t1.topLeft,t2.topLeft)\\n                tr = merge(t1.topRight,t2.topRight)\\n                bl = merge(t1.bottomLeft,t2.bottomLeft)\\n                br = merge(t1.bottomRight,t2.bottomRight) \\n                if tl.val==tr.val==bl.val==br.val and (tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf):\\n                    return Node(tl.val,True)\\n                return Node(None,False,tl,tr,bl,br)\\n            \\n        return merge(quadTree1, quadTree2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317125,
                "title": "test-1-root-value",
                "content": "In the test 1, both input trees root val == true. The output tree root val is expected to be false. Why?",
                "solutionTags": [],
                "code": "In the test 1, both input trees root val == true. The output tree root val is expected to be false. Why?",
                "codeTag": "Unknown"
            },
            {
                "id": 301323,
                "title": "c-324-ms-easy-recursion",
                "content": "\\'or\\' has a short-cut which returns true (think about it!)\\nyou can get a 100% beat if you use a line which I commented.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tNode* intersect(Node* quadTree1, Node* quadTree2) {\\n\\t\\t\\t//std::ios::sync_with_stdio(false); // beat 100%\\n\\n\\t\\t\\tif (quadTree1==nullptr) return quadTree2;\\n\\t\\t\\tif (quadTree2==nullptr) return quadTree1;\\n\\n\\t\\t\\tif (quadTree1->isLeaf) {\\n\\t\\t\\t\\tif (quadTree1->val)\\n\\t\\t\\t\\t\\treturn quadTree1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn quadTree2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (quadTree2->isLeaf) {\\n\\t\\t\\t\\tif (quadTree2->val)\\n\\t\\t\\t\\t\\treturn quadTree2;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn quadTree1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tNode* _topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);\\n\\t\\t\\tNode* _topRight = intersect(quadTree1->topRight, quadTree2->topRight);\\n\\t\\t\\tNode* _bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);\\n\\t\\t\\tNode* _bottomRight = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\\n\\n\\t\\t\\tbool test = _topLeft->isLeaf &&\\n\\t\\t\\t\\t\\t\\t_topRight->isLeaf &&\\n\\t\\t\\t\\t\\t\\t_bottomLeft->isLeaf &&\\n\\t\\t\\t\\t\\t\\t_bottomRight->isLeaf;\\n\\n\\t\\t\\tbool _isLeaf = test? (_topLeft->val == _topRight->val) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t (_topLeft->val == _bottomLeft->val) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t (_topLeft->val == _bottomRight->val) :\\n\\t\\t\\t\\t\\t\\t\\t\\t false;\\n\\n\\t\\t\\treturn new Node(_isLeaf? _topLeft->val : false,\\n\\t\\t\\t\\t\\t\\t\\t_isLeaf,\\n\\t\\t\\t\\t\\t\\t\\t_isLeaf? nullptr : _topLeft,\\n\\t\\t\\t\\t\\t\\t\\t_isLeaf? nullptr : _topRight,\\n\\t\\t\\t\\t\\t\\t\\t_isLeaf? nullptr : _bottomLeft,\\n\\t\\t\\t\\t\\t\\t\\t_isLeaf? nullptr : _bottomRight);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tNode* intersect(Node* quadTree1, Node* quadTree2) {\\n\\t\\t\\t//std::ios::sync_with_stdio(false); // beat 100%\\n\\n\\t\\t\\tif (quadTree1==nullptr) return quadTree2;\\n\\t\\t\\tif (quadTree2==nullptr) return quadTree1;\\n\\n\\t\\t\\tif (quadTree1->isLeaf) {\\n\\t\\t\\t\\tif (quadTree1->val)\\n\\t\\t\\t\\t\\treturn quadTree1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn quadTree2;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 300298,
                "title": "javascript-solution",
                "content": "``` javascript\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    if(quadTree1.isLeaf) {\\n        return quadTree1.val ? quadTree1 : quadTree2;\\n    }\\n\\n    if(quadTree2.isLeaf) {\\n        return quadTree2.val ? quadTree2 : quadTree1;\\n    }\\n\\n    let topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n    let topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n    let bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n    let bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n    // Detect a merger state when all 4 leaves have same value.\\n    if(topLeft.isLeaf&&topRight.isLeaf&&bottomLeft.isLeaf&&bottomRight.isLeaf && topLeft.val==topRight.val && topRight.val==bottomLeft.val && bottomLeft.val==bottomRight.val) {\\n        return new Node(topLeft.val, true, null, null, null, null);\\n    }else {\\n        return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight)\\n    }\\n};\\n```\\n\\nreference : [Readable Java beats 100%](https://leetcode.com/problems/quad-tree-intersection/discuss/249072/Readable-Java-beats-100)",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {Node} quadTree1\\n * @param {Node} quadTree2\\n * @return {Node}\\n */\\nvar intersect = function(quadTree1, quadTree2) {\\n    if(quadTree1.isLeaf) {\\n        return quadTree1.val ? quadTree1 : quadTree2;\\n    }\\n\\n    if(quadTree2.isLeaf) {\\n        return quadTree2.val ? quadTree2 : quadTree1;\\n    }\\n\\n    let topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n    let topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n    let bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n    let bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n\\n    // Detect a merger state when all 4 leaves have same value.\\n    if(topLeft.isLeaf&&topRight.isLeaf&&bottomLeft.isLeaf&&bottomRight.isLeaf && topLeft.val==topRight.val && topRight.val==bottomLeft.val && bottomLeft.val==bottomRight.val) {\\n        return new Node(topLeft.val, true, null, null, null, null);\\n    }else {\\n        return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201464,
                "title": "what-a-labor-intensive-problem",
                "content": "Is there any short solution?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 201236,
                "title": "java-working-solution",
                "content": "```\\n/**\\nThe val of a node that has children (T or F) is irrelevant \\n**/\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if (quadTree1.isLeaf)\\n           return quadTree1.val? quadTree1 : quadTree2;\\n         \\n        if (quadTree2.isLeaf)\\n            return quadTree2.val? quadTree2 : quadTree1;\\n       \\n        quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n      \\n        if (quadTree1.topLeft.isLeaf && quadTree1.topRight.isLeaf \\n            && quadTree1.bottomLeft.isLeaf && quadTree1.bottomRight.isLeaf\\n            && quadTree1.topLeft.val == quadTree1.topRight.val \\n            && quadTree1.topLeft.val == quadTree1.bottomLeft.val \\n            && quadTree1.topLeft.val == quadTree1.bottomRight.val){\\n           \\n           quadTree1.val = quadTree1.topLeft.val;\\n           quadTree1.isLeaf = true;\\n           quadTree1.topLeft = null;\\n           quadTree1.topRight = null;\\n           quadTree1.bottomLeft = null;\\n           quadTree1.bottomRight = null;\\n        }\\n        \\n        quadTree1.val = quadTree1.val || quadTree2.val;\\n        quadTree1.isLeaf = quadTree1.isLeaf || quadTree2.isLeaf;\\n        return quadTree1;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThe val of a node that has children (T or F) is irrelevant \\n**/\\nclass Solution {\\n    public Node intersect(Node quadTree1, Node quadTree2) {\\n        \\n        if (quadTree1.isLeaf)\\n           return quadTree1.val? quadTree1 : quadTree2;\\n         \\n        if (quadTree2.isLeaf)\\n            return quadTree2.val? quadTree2 : quadTree1;\\n       \\n        quadTree1.topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\\n        quadTree1.topRight = intersect(quadTree1.topRight, quadTree2.topRight);\\n        quadTree1.bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\\n        quadTree1.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\\n      \\n        if (quadTree1.topLeft.isLeaf && quadTree1.topRight.isLeaf \\n            && quadTree1.bottomLeft.isLeaf && quadTree1.bottomRight.isLeaf\\n            && quadTree1.topLeft.val == quadTree1.topRight.val \\n            && quadTree1.topLeft.val == quadTree1.bottomLeft.val \\n            && quadTree1.topLeft.val == quadTree1.bottomRight.val){\\n           \\n           quadTree1.val = quadTree1.topLeft.val;\\n           quadTree1.isLeaf = true;\\n           quadTree1.topLeft = null;\\n           quadTree1.topRight = null;\\n           quadTree1.bottomLeft = null;\\n           quadTree1.bottomRight = null;\\n        }\\n        \\n        quadTree1.val = quadTree1.val || quadTree2.val;\\n        quadTree1.isLeaf = quadTree1.isLeaf || quadTree2.isLeaf;\\n        return quadTree1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188975,
                "title": "super-short-java-solution",
                "content": "```\\n    public Node intersect(Node q1, Node q2) {\\n        if(q1.isLeaf) return q1.val ? q1 : q2;\\n        if(q2.isLeaf) return q2.val ? q2 : q1;\\n        \\n        Node tl = intersect(q1.topLeft, q2.topLeft);\\n        Node tr = intersect(q1.topRight, q2.topRight);\\n        Node bl = intersect(q1.bottomLeft, q2.bottomLeft);\\n        Node br = intersect(q1.bottomRight, q2.bottomRight);\\n        \\n        if(tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && \\n           (tl.val && tr.val && bl.val && br.val \\n            || !tl.val && !tr.val && !bl.val && !br.val)) \\n            return new Node(tl.val, true, null, null, null, null);\\n        else return new Node(false, false, tl, tr, bl, br);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public Node intersect(Node q1, Node q2) {\\n        if(q1.isLeaf) return q1.val ? q1 : q2;\\n        if(q2.isLeaf) return q2.val ? q2 : q1;\\n        \\n        Node tl = intersect(q1.topLeft, q2.topLeft);\\n        Node tr = intersect(q1.topRight, q2.topRight);\\n        Node bl = intersect(q1.bottomLeft, q2.bottomLeft);\\n        Node br = intersect(q1.bottomRight, q2.bottomRight);\\n        \\n        if(tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf && \\n           (tl.val && tr.val && bl.val && br.val \\n            || !tl.val && !tr.val && !bl.val && !br.val)) \\n            return new Node(tl.val, true, null, null, null, null);\\n        else return new Node(false, false, tl, tr, bl, br);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565684,
                "content": [
                    {
                        "username": "JPV",
                        "content": "Why is this problem called \"Quad Tree **Intersection**\", when the description specifically asks us to find the quad tree **union**?  LeetCode should rename the problem (and also the function name in the code) to match what they actually are asking for.\\n\\nSee https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations if you need more details about the Union and Intersection operations."
                    },
                    {
                        "username": "wdanxna",
                        "content": "even if the node is correct."
                    },
                    {
                        "username": "dpwang",
                        "content": "one most  import thing is that,  after OR operation if the four child\\'s value is the same , you shoud merge them to one leaf"
                    },
                    {
                        "username": "khamidjon",
                        "content": "reading for hours but didn\\'t understand anything"
                    }
                ]
            },
            {
                "id": 1566287,
                "content": [
                    {
                        "username": "JPV",
                        "content": "Why is this problem called \"Quad Tree **Intersection**\", when the description specifically asks us to find the quad tree **union**?  LeetCode should rename the problem (and also the function name in the code) to match what they actually are asking for.\\n\\nSee https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations if you need more details about the Union and Intersection operations."
                    },
                    {
                        "username": "wdanxna",
                        "content": "even if the node is correct."
                    },
                    {
                        "username": "dpwang",
                        "content": "one most  import thing is that,  after OR operation if the four child\\'s value is the same , you shoud merge them to one leaf"
                    },
                    {
                        "username": "khamidjon",
                        "content": "reading for hours but didn\\'t understand anything"
                    }
                ]
            },
            {
                "id": 1568077,
                "content": [
                    {
                        "username": "JPV",
                        "content": "Why is this problem called \"Quad Tree **Intersection**\", when the description specifically asks us to find the quad tree **union**?  LeetCode should rename the problem (and also the function name in the code) to match what they actually are asking for.\\n\\nSee https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations if you need more details about the Union and Intersection operations."
                    },
                    {
                        "username": "wdanxna",
                        "content": "even if the node is correct."
                    },
                    {
                        "username": "dpwang",
                        "content": "one most  import thing is that,  after OR operation if the four child\\'s value is the same , you shoud merge them to one leaf"
                    },
                    {
                        "username": "khamidjon",
                        "content": "reading for hours but didn\\'t understand anything"
                    }
                ]
            },
            {
                "id": 1984652,
                "content": [
                    {
                        "username": "JPV",
                        "content": "Why is this problem called \"Quad Tree **Intersection**\", when the description specifically asks us to find the quad tree **union**?  LeetCode should rename the problem (and also the function name in the code) to match what they actually are asking for.\\n\\nSee https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations if you need more details about the Union and Intersection operations."
                    },
                    {
                        "username": "wdanxna",
                        "content": "even if the node is correct."
                    },
                    {
                        "username": "dpwang",
                        "content": "one most  import thing is that,  after OR operation if the four child\\'s value is the same , you shoud merge them to one leaf"
                    },
                    {
                        "username": "khamidjon",
                        "content": "reading for hours but didn\\'t understand anything"
                    }
                ]
            }
        ]
    }
]